(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "+3YS":
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "+5Nw":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// This will need to keep in sync with the `ReactCSSTransitionGroupChild` `TICK` const.
// https://github.com/facebook/react/blob/master/src/addons/transitions/ReactCSSTransitionGroupChild.js#L22

exports.default = 17;

/***/ }),

/***/ "+G64":
/***/ (function(module, exports, __webpack_require__) {

/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */

(function (global, factory) {
     true ? module.exports = factory() :
    undefined;
}(this, (function () { 'use strict';

    var limit = function (x, min, max) {
        if ( min === void 0 ) min=0;
        if ( max === void 0 ) max=1;

        return x < min ? min : x > max ? max : x;
    };

    var clip_rgb = function (rgb) {
        rgb._clipped = false;
        rgb._unclipped = rgb.slice(0);
        for (var i=0; i<=3; i++) {
            if (i < 3) {
                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }
                rgb[i] = limit(rgb[i], 0, 255);
            } else if (i === 3) {
                rgb[i] = limit(rgb[i], 0, 1);
            }
        }
        return rgb;
    };

    // ported from jQuery's $.type
    var classToType = {};
    for (var i = 0, list = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i < list.length; i += 1) {
        var name = list[i];

        classToType[("[object " + name + "]")] = name.toLowerCase();
    }
    var type = function(obj) {
        return classToType[Object.prototype.toString.call(obj)] || "object";
    };

    var unpack = function (args, keyOrder) {
        if ( keyOrder === void 0 ) keyOrder=null;

    	// if called with more than 3 arguments, we return the arguments
        if (args.length >= 3) { return Array.prototype.slice.call(args); }
        // with less than 3 args we check if first arg is object
        // and use the keyOrder string to extract and sort properties
    	if (type(args[0]) == 'object' && keyOrder) {
    		return keyOrder.split('')
    			.filter(function (k) { return args[0][k] !== undefined; })
    			.map(function (k) { return args[0][k]; });
    	}
    	// otherwise we just return the first argument
    	// (which we suppose is an array of args)
        return args[0];
    };

    var last = function (args) {
        if (args.length < 2) { return null; }
        var l = args.length-1;
        if (type(args[l]) == 'string') { return args[l].toLowerCase(); }
        return null;
    };

    var PI = Math.PI;

    var utils = {
    	clip_rgb: clip_rgb,
    	limit: limit,
    	type: type,
    	unpack: unpack,
    	last: last,
    	PI: PI,
    	TWOPI: PI*2,
    	PITHIRD: PI/3,
    	DEG2RAD: PI / 180,
    	RAD2DEG: 180 / PI
    };

    var input = {
    	format: {},
    	autodetect: []
    };

    var last$1 = utils.last;
    var clip_rgb$1 = utils.clip_rgb;
    var type$1 = utils.type;


    var Color = function Color() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var me = this;
        if (type$1(args[0]) === 'object' &&
            args[0].constructor &&
            args[0].constructor === this.constructor) {
            // the argument is already a Color instance
            return args[0];
        }

        // last argument could be the mode
        var mode = last$1(args);
        var autodetect = false;

        if (!mode) {
            autodetect = true;
            if (!input.sorted) {
                input.autodetect = input.autodetect.sort(function (a,b) { return b.p - a.p; });
                input.sorted = true;
            }
            // auto-detect format
            for (var i = 0, list = input.autodetect; i < list.length; i += 1) {
                var chk = list[i];

                mode = chk.test.apply(chk, args);
                if (mode) { break; }
            }
        }

        if (input.format[mode]) {
            var rgb = input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));
            me._rgb = clip_rgb$1(rgb);
        } else {
            throw new Error('unknown format: '+args);
        }

        // add alpha channel
        if (me._rgb.length === 3) { me._rgb.push(1); }
    };

    Color.prototype.toString = function toString () {
        if (type$1(this.hex) == 'function') { return this.hex(); }
        return ("[" + (this._rgb.join(',')) + "]");
    };

    var Color_1 = Color;

    var chroma = function () {
    	var args = [], len = arguments.length;
    	while ( len-- ) args[ len ] = arguments[ len ];

    	return new (Function.prototype.bind.apply( chroma.Color, [ null ].concat( args) ));
    };

    chroma.Color = Color_1;
    chroma.version = '2.0.4';

    var chroma_1 = chroma;

    var unpack$1 = utils.unpack;
    var max = Math.max;

    var rgb2cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$1(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var k = 1 - max(r,max(g,b));
        var f = k < 1 ? 1 / (1-k) : 0;
        var c = (1-r-k) * f;
        var m = (1-g-k) * f;
        var y = (1-b-k) * f;
        return [c,m,y,k];
    };

    var rgb2cmyk_1 = rgb2cmyk;

    var unpack$2 = utils.unpack;

    var cmyk2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$2(args, 'cmyk');
        var c = args[0];
        var m = args[1];
        var y = args[2];
        var k = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) { return [0,0,0,alpha]; }
        return [
            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r
            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g
            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b
            alpha
        ];
    };

    var cmyk2rgb_1 = cmyk2rgb;

    var unpack$3 = utils.unpack;
    var type$2 = utils.type;



    Color_1.prototype.cmyk = function() {
        return rgb2cmyk_1(this._rgb);
    };

    chroma_1.cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['cmyk']) ));
    };

    input.format.cmyk = cmyk2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$3(args, 'cmyk');
            if (type$2(args) === 'array' && args.length === 4) {
                return 'cmyk';
            }
        }
    });

    var unpack$4 = utils.unpack;
    var last$2 = utils.last;
    var rnd = function (a) { return Math.round(a*100)/100; };

    /*
     * supported arguments:
     * - hsl2css(h,s,l)
     * - hsl2css(h,s,l,a)
     * - hsl2css([h,s,l], mode)
     * - hsl2css([h,s,l,a], mode)
     * - hsl2css({h,s,l,a}, mode)
     */
    var hsl2css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hsla = unpack$4(args, 'hsla');
        var mode = last$2(args) || 'lsa';
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1]*100) + '%';
        hsla[2] = rnd(hsla[2]*100) + '%';
        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = 'hsla';
        } else {
            hsla.length = 3;
        }
        return (mode + "(" + (hsla.join(',')) + ")");
    };

    var hsl2css_1 = hsl2css;

    var unpack$5 = utils.unpack;

    /*
     * supported arguments:
     * - rgb2hsl(r,g,b)
     * - rgb2hsl(r,g,b,a)
     * - rgb2hsl([r,g,b])
     * - rgb2hsl([r,g,b,a])
     * - rgb2hsl({r,g,b,a})
     */
    var rgb2hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$5(args, 'rgba');
        var r = args[0];
        var g = args[1];
        var b = args[2];

        r /= 255;
        g /= 255;
        b /= 255;

        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);

        var l = (max + min) / 2;
        var s, h;

        if (max === min){
            s = 0;
            h = Number.NaN;
        } else {
            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
        }

        if (r == max) { h = (g - b) / (max - min); }
        else if (g == max) { h = 2 + (b - r) / (max - min); }
        else if (b == max) { h = 4 + (r - g) / (max - min); }

        h *= 60;
        if (h < 0) { h += 360; }
        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }
        return [h,s,l];
    };

    var rgb2hsl_1 = rgb2hsl;

    var unpack$6 = utils.unpack;
    var last$3 = utils.last;


    var round = Math.round;

    /*
     * supported arguments:
     * - rgb2css(r,g,b)
     * - rgb2css(r,g,b,a)
     * - rgb2css([r,g,b], mode)
     * - rgb2css([r,g,b,a], mode)
     * - rgb2css({r,g,b,a}, mode)
     */
    var rgb2css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$6(args, 'rgba');
        var mode = last$3(args) || 'rgb';
        if (mode.substr(0,3) == 'hsl') {
            return hsl2css_1(rgb2hsl_1(rgba), mode);
        }
        rgba[0] = round(rgba[0]);
        rgba[1] = round(rgba[1]);
        rgba[2] = round(rgba[2]);
        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = 'rgba';
        }
        return (mode + "(" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + ")");
    };

    var rgb2css_1 = rgb2css;

    var unpack$7 = utils.unpack;
    var round$1 = Math.round;

    var hsl2rgb = function () {
        var assign;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$7(args, 'hsl');
        var h = args[0];
        var s = args[1];
        var l = args[2];
        var r,g,b;
        if (s === 0) {
            r = g = b = l*255;
        } else {
            var t3 = [0,0,0];
            var c = [0,0,0];
            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1/3;
            t3[1] = h_;
            t3[2] = h_ - 1/3;
            for (var i=0; i<3; i++) {
                if (t3[i] < 0) { t3[i] += 1; }
                if (t3[i] > 1) { t3[i] -= 1; }
                if (6 * t3[i] < 1)
                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }
                else if (2 * t3[i] < 1)
                    { c[i] = t2; }
                else if (3 * t3[i] < 2)
                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }
                else
                    { c[i] = t1; }
            }
            (assign = [round$1(c[0]*255),round$1(c[1]*255),round$1(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);
        }
        if (args.length > 3) {
            // keep alpha channel
            return [r,g,b,args[3]];
        }
        return [r,g,b,1];
    };

    var hsl2rgb_1 = hsl2rgb;

    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
    var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;

    var round$2 = Math.round;

    var css2rgb = function (css) {
        css = css.toLowerCase().trim();
        var m;

        if (input.format.named) {
            try {
                return input.format.named(css);
            } catch (e) {
                // eslint-disable-next-line
            }
        }

        // rgb(250,20,0)
        if ((m = css.match(RE_RGB))) {
            var rgb = m.slice(1,4);
            for (var i=0; i<3; i++) {
                rgb[i] = +rgb[i];
            }
            rgb[3] = 1;  // default alpha
            return rgb;
        }

        // rgba(250,20,0,0.4)
        if ((m = css.match(RE_RGBA))) {
            var rgb$1 = m.slice(1,5);
            for (var i$1=0; i$1<4; i$1++) {
                rgb$1[i$1] = +rgb$1[i$1];
            }
            return rgb$1;
        }

        // rgb(100%,0%,0%)
        if ((m = css.match(RE_RGB_PCT))) {
            var rgb$2 = m.slice(1,4);
            for (var i$2=0; i$2<3; i$2++) {
                rgb$2[i$2] = round$2(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1;  // default alpha
            return rgb$2;
        }

        // rgba(100%,0%,0%,0.4)
        if ((m = css.match(RE_RGBA_PCT))) {
            var rgb$3 = m.slice(1,5);
            for (var i$3=0; i$3<3; i$3++) {
                rgb$3[i$3] = round$2(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
        }

        // hsl(0,100%,50%)
        if ((m = css.match(RE_HSL))) {
            var hsl = m.slice(1,4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            var rgb$4 = hsl2rgb_1(hsl);
            rgb$4[3] = 1;
            return rgb$4;
        }

        // hsla(0,100%,50%,0.5)
        if ((m = css.match(RE_HSLA))) {
            var hsl$1 = m.slice(1,4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb_1(hsl$1);
            rgb$5[3] = +m[4];  // default alpha = 1
            return rgb$5;
        }
    };

    css2rgb.test = function (s) {
        return RE_RGB.test(s) ||
            RE_RGBA.test(s) ||
            RE_RGB_PCT.test(s) ||
            RE_RGBA_PCT.test(s) ||
            RE_HSL.test(s) ||
            RE_HSLA.test(s);
    };

    var css2rgb_1 = css2rgb;

    var type$3 = utils.type;




    Color_1.prototype.css = function(mode) {
        return rgb2css_1(this._rgb, mode);
    };

    chroma_1.css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['css']) ));
    };

    input.format.css = css2rgb_1;

    input.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$3(h) === 'string' && css2rgb_1.test(h)) {
                return 'css';
            }
        }
    });

    var unpack$8 = utils.unpack;

    input.format.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$8(args, 'rgba');
        rgb[0] *= 255;
        rgb[1] *= 255;
        rgb[2] *= 255;
        return rgb;
    };

    chroma_1.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['gl']) ));
    };

    Color_1.prototype.gl = function() {
        var rgb = this._rgb;
        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];
    };

    var unpack$9 = utils.unpack;

    var rgb2hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$9(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var c = delta * 100 / 255;
        var _g = min / (255 - delta) * 100;
        var h;
        if (delta === 0) {
            h = Number.NaN;
        } else {
            if (r === max) { h = (g - b) / delta; }
            if (g === max) { h = 2+(b - r) / delta; }
            if (b === max) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, c, _g];
    };

    var rgb2hcg_1 = rgb2hcg;

    var unpack$a = utils.unpack;
    var floor = Math.floor;

    /*
     * this is basically just HSV with some minor tweaks
     *
     * hue.. [0..360]
     * chroma .. [0..1]
     * grayness .. [0..1]
     */

    var hcg2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$a(args, 'hcg');
        var h = args[0];
        var c = args[1];
        var _g = args[2];
        var r,g,b;
        _g = _g * 255;
        var _c = c * 255;
        if (c === 0) {
            r = g = b = _g;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;
            var i = floor(h);
            var f = h - i;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var hcg2rgb_1 = hcg2rgb;

    var unpack$b = utils.unpack;
    var type$4 = utils.type;






    Color_1.prototype.hcg = function() {
        return rgb2hcg_1(this._rgb);
    };

    chroma_1.hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcg']) ));
    };

    input.format.hcg = hcg2rgb_1;

    input.autodetect.push({
        p: 1,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$b(args, 'hcg');
            if (type$4(args) === 'array' && args.length === 3) {
                return 'hcg';
            }
        }
    });

    var unpack$c = utils.unpack;
    var last$4 = utils.last;
    var round$3 = Math.round;

    var rgb2hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$c(args, 'rgba');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        var mode = last$4(args) || 'auto';
        if (a === undefined) { a = 1; }
        if (mode === 'auto') {
            mode = a < 1 ? 'rgba' : 'rgb';
        }
        r = round$3(r);
        g = round$3(g);
        b = round$3(b);
        var u = r << 16 | g << 8 | b;
        var str = "000000" + u.toString(16); //#.toUpperCase();
        str = str.substr(str.length - 6);
        var hxa = '0' + round$3(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
            case 'rgba': return ("#" + str + hxa);
            case 'argb': return ("#" + hxa + str);
            default: return ("#" + str);
        }
    };

    var rgb2hex_1 = rgb2hex;

    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    var RE_HEXA = /^#?([A-Fa-f0-9]{8})$/;

    var hex2rgb = function (hex) {
        if (hex.match(RE_HEX)) {
            // remove optional leading #
            if (hex.length === 4 || hex.length === 7) {
                hex = hex.substr(1);
            }
            // expand short-notation to full six-digit
            if (hex.length === 3) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = u >> 8 & 0xFF;
            var b = u & 0xFF;
            return [r,g,b,1];
        }

        // match rgba hex format, eg #FF000077
        if (hex.match(RE_HEXA)) {
            if (hex.length === 9) {
                // remove optional leading #
                hex = hex.substr(1);
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = u$1 >> 24 & 0xFF;
            var g$1 = u$1 >> 16 & 0xFF;
            var b$1 = u$1 >> 8 & 0xFF;
            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;
            return [r$1,g$1,b$1,a];
        }

        // we used to check for css colors here
        // if _input.css? and rgb = _input.css hex
        //     return rgb

        throw new Error(("unknown hex color: " + hex));
    };

    var hex2rgb_1 = hex2rgb;

    var type$5 = utils.type;




    Color_1.prototype.hex = function(mode) {
        return rgb2hex_1(this._rgb, mode);
    };

    chroma_1.hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hex']) ));
    };

    input.format.hex = hex2rgb_1;
    input.autodetect.push({
        p: 4,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$5(h) === 'string' && [3,4,6,7,8,9].includes(h.length)) {
                return 'hex';
            }
        }
    });

    var unpack$d = utils.unpack;
    var TWOPI = utils.TWOPI;
    var min = Math.min;
    var sqrt = Math.sqrt;
    var acos = Math.acos;

    var rgb2hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
        */
        var ref = unpack$d(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var h;
        var min_ = min(r,g,b);
        var i = (r+g+b) / 3;
        var s = i > 0 ? 1 - min_/i : 0;
        if (s === 0) {
            h = NaN;
        } else {
            h = ((r-g)+(r-b)) / 2;
            h /= sqrt((r-g)*(r-g) + (r-b)*(g-b));
            h = acos(h);
            if (b > g) {
                h = TWOPI - h;
            }
            h /= TWOPI;
        }
        return [h*360,s,i];
    };

    var rgb2hsi_1 = rgb2hsi;

    var unpack$e = utils.unpack;
    var limit$1 = utils.limit;
    var TWOPI$1 = utils.TWOPI;
    var PITHIRD = utils.PITHIRD;
    var cos = Math.cos;

    /*
     * hue [0..360]
     * saturation [0..1]
     * intensity [0..1]
     */
    var hsi2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
        */
        args = unpack$e(args, 'hsi');
        var h = args[0];
        var s = args[1];
        var i = args[2];
        var r,g,b;

        if (isNaN(h)) { h = 0; }
        if (isNaN(s)) { s = 0; }
        // normalize hue
        if (h > 360) { h -= 360; }
        if (h < 0) { h += 360; }
        h /= 360;
        if (h < 1/3) {
            b = (1-s)/3;
            r = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;
            g = 1 - (b+r);
        } else if (h < 2/3) {
            h -= 1/3;
            r = (1-s)/3;
            g = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;
            b = 1 - (r+g);
        } else {
            h -= 2/3;
            g = (1-s)/3;
            b = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;
            r = 1 - (g+b);
        }
        r = limit$1(i*r*3);
        g = limit$1(i*g*3);
        b = limit$1(i*b*3);
        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];
    };

    var hsi2rgb_1 = hsi2rgb;

    var unpack$f = utils.unpack;
    var type$6 = utils.type;






    Color_1.prototype.hsi = function() {
        return rgb2hsi_1(this._rgb);
    };

    chroma_1.hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsi']) ));
    };

    input.format.hsi = hsi2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$f(args, 'hsi');
            if (type$6(args) === 'array' && args.length === 3) {
                return 'hsi';
            }
        }
    });

    var unpack$g = utils.unpack;
    var type$7 = utils.type;






    Color_1.prototype.hsl = function() {
        return rgb2hsl_1(this._rgb);
    };

    chroma_1.hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsl']) ));
    };

    input.format.hsl = hsl2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$g(args, 'hsl');
            if (type$7(args) === 'array' && args.length === 3) {
                return 'hsl';
            }
        }
    });

    var unpack$h = utils.unpack;
    var min$1 = Math.min;
    var max$1 = Math.max;

    /*
     * supported arguments:
     * - rgb2hsv(r,g,b)
     * - rgb2hsv([r,g,b])
     * - rgb2hsv({r,g,b})
     */
    var rgb2hsl$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$h(args, 'rgb');
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var min_ = min$1(r, g, b);
        var max_ = max$1(r, g, b);
        var delta = max_ - min_;
        var h,s,v;
        v = max_ / 255.0;
        if (max_ === 0) {
            h = Number.NaN;
            s = 0;
        } else {
            s = delta / max_;
            if (r === max_) { h = (g - b) / delta; }
            if (g === max_) { h = 2+(b - r) / delta; }
            if (b === max_) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, s, v]
    };

    var rgb2hsv = rgb2hsl$1;

    var unpack$i = utils.unpack;
    var floor$1 = Math.floor;

    var hsv2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$i(args, 'hsv');
        var h = args[0];
        var s = args[1];
        var v = args[2];
        var r,g,b;
        v *= 255;
        if (s === 0) {
            r = g = b = v;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;

            var i = floor$1(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r,g,b,args.length > 3?args[3]:1];
    };

    var hsv2rgb_1 = hsv2rgb;

    var unpack$j = utils.unpack;
    var type$8 = utils.type;






    Color_1.prototype.hsv = function() {
        return rgb2hsv(this._rgb);
    };

    chroma_1.hsv = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsv']) ));
    };

    input.format.hsv = hsv2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$j(args, 'hsv');
            if (type$8(args) === 'array' && args.length === 3) {
                return 'hsv';
            }
        }
    });

    var labConstants = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,

        // D65 standard referent
        Xn: 0.950470,
        Yn: 1,
        Zn: 1.088830,

        t0: 0.137931034,  // 4 / 29
        t1: 0.206896552,  // 6 / 29
        t2: 0.12841855,   // 3 * t1 * t1
        t3: 0.008856452,  // t1 * t1 * t1
    };

    var unpack$k = utils.unpack;
    var pow = Math.pow;

    var rgb2lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$k(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2xyz(r,g,b);
        var x = ref$1[0];
        var y = ref$1[1];
        var z = ref$1[2];
        var l = 116 * y - 16;
        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
    };

    var rgb_xyz = function (r) {
        if ((r /= 255) <= 0.04045) { return r / 12.92; }
        return pow((r + 0.055) / 1.055, 2.4);
    };

    var xyz_lab = function (t) {
        if (t > labConstants.t3) { return pow(t, 1 / 3); }
        return t / labConstants.t2 + labConstants.t0;
    };

    var rgb2xyz = function (r,g,b) {
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);
        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);
        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);
        return [x,y,z];
    };

    var rgb2lab_1 = rgb2lab;

    var unpack$l = utils.unpack;
    var pow$1 = Math.pow;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var lab2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$l(args, 'lab');
        var l = args[0];
        var a = args[1];
        var b = args[2];
        var x,y,z, r,g,b_;

        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;

        y = labConstants.Yn * lab_xyz(y);
        x = labConstants.Xn * lab_xyz(x);
        z = labConstants.Zn * lab_xyz(z);

        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB
        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);

        return [r,g,b_,args.length > 3 ? args[3] : 1];
    };

    var xyz_rgb = function (r) {
        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$1(r, 1 / 2.4) - 0.055)
    };

    var lab_xyz = function (t) {
        return t > labConstants.t1 ? t * t * t : labConstants.t2 * (t - labConstants.t0)
    };

    var lab2rgb_1 = lab2rgb;

    var unpack$m = utils.unpack;
    var type$9 = utils.type;






    Color_1.prototype.lab = function() {
        return rgb2lab_1(this._rgb);
    };

    chroma_1.lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lab']) ));
    };

    input.format.lab = lab2rgb_1;

    input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$m(args, 'lab');
            if (type$9(args) === 'array' && args.length === 3) {
                return 'lab';
            }
        }
    });

    var unpack$n = utils.unpack;
    var RAD2DEG = utils.RAD2DEG;
    var sqrt$1 = Math.sqrt;
    var atan2 = Math.atan2;
    var round$4 = Math.round;

    var lab2lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$n(args, 'lab');
        var l = ref[0];
        var a = ref[1];
        var b = ref[2];
        var c = sqrt$1(a * a + b * b);
        var h = (atan2(b, a) * RAD2DEG + 360) % 360;
        if (round$4(c*10000) === 0) { h = Number.NaN; }
        return [l, c, h];
    };

    var lab2lch_1 = lab2lch;

    var unpack$o = utils.unpack;



    var rgb2lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$o(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2lab_1(r,g,b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch_1(l,a,b_);
    };

    var rgb2lch_1 = rgb2lch;

    var unpack$p = utils.unpack;
    var DEG2RAD = utils.DEG2RAD;
    var sin = Math.sin;
    var cos$1 = Math.cos;

    var lch2lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
        These formulas were invented by David Dalrymple to obtain maximum contrast without going
        out of gamut if the parameters are in the range 0-1.

        A saturation multiplier was added by Gregor Aisch
        */
        var ref = unpack$p(args, 'lch');
        var l = ref[0];
        var c = ref[1];
        var h = ref[2];
        if (isNaN(h)) { h = 0; }
        h = h * DEG2RAD;
        return [l, cos$1(h) * c, sin(h) * c]
    };

    var lch2lab_1 = lch2lab;

    var unpack$q = utils.unpack;



    var lch2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$q(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab_1 (l,c,h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb_1 (L,a,b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var lch2rgb_1 = lch2rgb;

    var unpack$r = utils.unpack;


    var hcl2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hcl = unpack$r(args, 'hcl').reverse();
        return lch2rgb_1.apply(void 0, hcl);
    };

    var hcl2rgb_1 = hcl2rgb;

    var unpack$s = utils.unpack;
    var type$a = utils.type;






    Color_1.prototype.lch = function() { return rgb2lch_1(this._rgb); };
    Color_1.prototype.hcl = function() { return rgb2lch_1(this._rgb).reverse(); };

    chroma_1.lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lch']) ));
    };
    chroma_1.hcl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcl']) ));
    };

    input.format.lch = lch2rgb_1;
    input.format.hcl = hcl2rgb_1;

    ['lch','hcl'].forEach(function (m) { return input.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$s(args, m);
            if (type$a(args) === 'array' && args.length === 3) {
                return m;
            }
        }
    }); });

    /**
    	X11 color names

    	http://www.w3.org/TR/css3-color/#svg-color
    */

    var w3cx11 = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflower: '#6495ed',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        laserlemon: '#ffff54',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrod: '#fafad2',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        maroon2: '#7f0000',
        maroon3: '#b03060',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        purple2: '#7f007f',
        purple3: '#a020f0',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32'
    };

    var w3cx11_1 = w3cx11;

    var type$b = utils.type;





    Color_1.prototype.name = function() {
        var hex = rgb2hex_1(this._rgb, 'rgb');
        for (var i = 0, list = Object.keys(w3cx11_1); i < list.length; i += 1) {
            var n = list[i];

            if (w3cx11_1[n] === hex) { return n.toLowerCase(); }
        }
        return hex;
    };

    input.format.named = function (name) {
        name = name.toLowerCase();
        if (w3cx11_1[name]) { return hex2rgb_1(w3cx11_1[name]); }
        throw new Error('unknown color name: '+name);
    };

    input.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$b(h) === 'string' && w3cx11_1[h.toLowerCase()]) {
                return 'named';
            }
        }
    });

    var unpack$t = utils.unpack;

    var rgb2num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$t(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        return (r << 16) + (g << 8) + b;
    };

    var rgb2num_1 = rgb2num;

    var type$c = utils.type;

    var num2rgb = function (num) {
        if (type$c(num) == "number" && num >= 0 && num <= 0xFFFFFF) {
            var r = num >> 16;
            var g = (num >> 8) & 0xFF;
            var b = num & 0xFF;
            return [r,g,b,1];
        }
        throw new Error("unknown num color: "+num);
    };

    var num2rgb_1 = num2rgb;

    var type$d = utils.type;



    Color_1.prototype.num = function() {
        return rgb2num_1(this._rgb);
    };

    chroma_1.num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['num']) ));
    };

    input.format.num = num2rgb_1;

    input.autodetect.push({
        p: 5,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            if (args.length === 1 && type$d(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {
                return 'num';
            }
        }
    });

    var unpack$u = utils.unpack;
    var type$e = utils.type;
    var round$5 = Math.round;

    Color_1.prototype.rgb = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        if (rnd === false) { return this._rgb.slice(0,3); }
        return this._rgb.slice(0,3).map(round$5);
    };

    Color_1.prototype.rgba = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        return this._rgb.slice(0,4).map(function (v,i) {
            return i<3 ? (rnd === false ? v : round$5(v)) : v;
        });
    };

    chroma_1.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['rgb']) ));
    };

    input.format.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$u(args, 'rgba');
        if (rgba[3] === undefined) { rgba[3] = 1; }
        return rgba;
    };

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$u(args, 'rgba');
            if (type$e(args) === 'array' && (args.length === 3 ||
                args.length === 4 && type$e(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {
                return 'rgb';
            }
        }
    });

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     */

    var log = Math.log;

    var temperature2rgb = function (kelvin) {
        var temp = kelvin / 100;
        var r,g,b;
        if (temp < 66) {
            r = 255;
            g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g);
            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b);
        } else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g);
            b = 255;
        }
        return [r,g,b,1];
    };

    var temperature2rgb_1 = temperature2rgb;

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     **/


    var unpack$v = utils.unpack;
    var round$6 = Math.round;

    var rgb2temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$v(args, 'rgb');
        var r = rgb[0], b = rgb[2];
        var minTemp = 1000;
        var maxTemp = 40000;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb_1(temp);
            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {
                maxTemp = temp;
            } else {
                minTemp = temp;
            }
        }
        return round$6(temp);
    };

    var rgb2temperature_1 = rgb2temperature;

    Color_1.prototype.temp =
    Color_1.prototype.kelvin =
    Color_1.prototype.temperature = function() {
        return rgb2temperature_1(this._rgb);
    };

    chroma_1.temp =
    chroma_1.kelvin =
    chroma_1.temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['temp']) ));
    };

    input.format.temp =
    input.format.kelvin =
    input.format.temperature = temperature2rgb_1;

    var type$f = utils.type;

    Color_1.prototype.alpha = function(a, mutate) {
        if ( mutate === void 0 ) mutate=false;

        if (a !== undefined && type$f(a) === 'number') {
            if (mutate) {
                this._rgb[3] = a;
                return this;
            }
            return new Color_1([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');
        }
        return this._rgb[3];
    };

    Color_1.prototype.clipped = function() {
        return this._rgb._clipped || false;
    };

    Color_1.prototype.darken = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lab = me.lab();
    	lab[0] -= labConstants.Kn * amount;
    	return new Color_1(lab, 'lab').alpha(me.alpha(), true);
    };

    Color_1.prototype.brighten = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.darken(-amount);
    };

    Color_1.prototype.darker = Color_1.prototype.darken;
    Color_1.prototype.brighter = Color_1.prototype.brighten;

    Color_1.prototype.get = function(mc) {
        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel);
            if (i > -1) { return src[i]; }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var type$g = utils.type;
    var pow$2 = Math.pow;

    var EPS = 1e-7;
    var MAX_ITER = 20;

    Color_1.prototype.luminance = function(lum) {
        if (lum !== undefined && type$g(lum) === 'number') {
            if (lum === 0) {
                // return pure black
                return new Color_1([0,0,0,this._rgb[3]], 'rgb');
            }
            if (lum === 1) {
                // return pure white
                return new Color_1([255,255,255,this._rgb[3]], 'rgb');
            }
            // compute new color using...
            var cur_lum = this.luminance();
            var mode = 'rgb';
            var max_iter = MAX_ITER;

            var test = function (low, high) {
                var mid = low.interpolate(high, 0.5, mode);
                var lm = mid.luminance();
                if (Math.abs(lum - lm) < EPS || !max_iter--) {
                    // close enough
                    return mid;
                }
                return lm > lum ? test(low, mid) : test(mid, high);
            };

            var rgb = (cur_lum > lum ? test(new Color_1([0,0,0]), this) : test(this, new Color_1([255,255,255]))).rgb();
            return new Color_1(rgb.concat( [this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));
    };


    var rgb2luminance = function (r,g,b) {
        // relative luminance
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    var luminance_x = function (x) {
        x /= 255;
        return x <= 0.03928 ? x/12.92 : pow$2((x+0.055)/1.055, 2.4);
    };

    var interpolator = {};

    var type$h = utils.type;


    var mix = function (col1, col2, f) {
        if ( f === void 0 ) f=0.5;
        var rest = [], len = arguments.length - 3;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];

        var mode = rest[0] || 'lrgb';
        if (!interpolator[mode] && !rest.length) {
            // fall back to the first supported mode
            mode = Object.keys(interpolator)[0];
        }
        if (!interpolator[mode]) {
            throw new Error(("interpolation mode " + mode + " is not defined"));
        }
        if (type$h(col1) !== 'object') { col1 = new Color_1(col1); }
        if (type$h(col2) !== 'object') { col2 = new Color_1(col2); }
        return interpolator[mode](col1, col2, f)
            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
    };

    Color_1.prototype.mix =
    Color_1.prototype.interpolate = function(col2, f) {
    	if ( f === void 0 ) f=0.5;
    	var rest = [], len = arguments.length - 2;
    	while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];

    	return mix.apply(void 0, [ this, col2, f ].concat( rest ));
    };

    Color_1.prototype.premultiply = function(mutate) {
    	if ( mutate === void 0 ) mutate=false;

    	var rgb = this._rgb;
    	var a = rgb[3];
    	if (mutate) {
    		this._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];
    		return this;
    	} else {
    		return new Color_1([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');
    	}
    };

    Color_1.prototype.saturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lch = me.lch();
    	lch[1] += labConstants.Kn * amount;
    	if (lch[1] < 0) { lch[1] = 0; }
    	return new Color_1(lch, 'lch').alpha(me.alpha(), true);
    };

    Color_1.prototype.desaturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.saturate(-amount);
    };

    var type$i = utils.type;

    Color_1.prototype.set = function(mc, value, mutate) {
        if ( mutate === void 0 ) mutate=false;

        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel);
            if (i > -1) {
                if (type$i(value) == 'string') {
                    switch(value.charAt(0)) {
                        case '+': src[i] += +value; break;
                        case '-': src[i] += +value; break;
                        case '*': src[i] *= +(value.substr(1)); break;
                        case '/': src[i] /= +(value.substr(1)); break;
                        default: src[i] = +value;
                    }
                } else if (type$i(value) === 'number') {
                    src[i] = value;
                } else {
                    throw new Error("unsupported value for Color.set");
                }
                var out = new Color_1(src, mode);
                if (mutate) {
                    this._rgb = out._rgb;
                    return this;
                }
                return out;
            }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var rgb$1 = function (col1, col2, f) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color_1(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'rgb'
        )
    };

    // register interpolator
    interpolator.rgb = rgb$1;

    var sqrt$2 = Math.sqrt;
    var pow$3 = Math.pow;

    var lrgb = function (col1, col2, f) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y2 = ref$1[1];
        var z2 = ref$1[2];
        return new Color_1(
            sqrt$2(pow$3(x1,2) * (1-f) + pow$3(x2,2) * f),
            sqrt$2(pow$3(y1,2) * (1-f) + pow$3(y2,2) * f),
            sqrt$2(pow$3(z1,2) * (1-f) + pow$3(z2,2) * f),
            'rgb'
        )
    };

    // register interpolator
    interpolator.lrgb = lrgb;

    var lab$1 = function (col1, col2, f) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color_1(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'lab'
        )
    };

    // register interpolator
    interpolator.lab = lab$1;

    var _hsx = function (col1, col2, f, m) {
        var assign, assign$1;

        var xyz0, xyz1;
        if (m === 'hsl') {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
        } else if (m === 'hsv') {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
        } else if (m === 'hcg') {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
        } else if (m === 'hsi') {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
        } else if (m === 'lch' || m === 'hcl') {
            m = 'hcl';
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
        }

        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m.substr(0, 1) === 'h') {
            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);
            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);
        }

        var sat, hue, lbv, dh;

        if (!isNaN(hue0) && !isNaN(hue1)) {
            // both colors have hue
            if (hue1 > hue0 && hue1 - hue0 > 180) {
                dh = hue1-(hue0+360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
                dh = hue1+360-hue0;
            } else{
                dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }
        } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }
        } else {
            hue = Number.NaN;
        }

        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }
        lbv = lbv0 + f * (lbv1-lbv0);
        return new Color_1([hue, sat, lbv], m);
    };

    var lch$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'lch');
    };

    // register interpolator
    interpolator.lch = lch$1;
    interpolator.hcl = lch$1;

    var num$1 = function (col1, col2, f) {
        var c1 = col1.num();
        var c2 = col2.num();
        return new Color_1(c1 + f * (c2-c1), 'num')
    };

    // register interpolator
    interpolator.num = num$1;

    var hcg$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'hcg');
    };

    // register interpolator
    interpolator.hcg = hcg$1;

    var hsi$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'hsi');
    };

    // register interpolator
    interpolator.hsi = hsi$1;

    var hsl$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'hsl');
    };

    // register interpolator
    interpolator.hsl = hsl$1;

    var hsv$1 = function (col1, col2, f) {
    	return _hsx(col1, col2, f, 'hsv');
    };

    // register interpolator
    interpolator.hsv = hsv$1;

    var clip_rgb$2 = utils.clip_rgb;
    var pow$4 = Math.pow;
    var sqrt$3 = Math.sqrt;
    var PI$1 = Math.PI;
    var cos$2 = Math.cos;
    var sin$1 = Math.sin;
    var atan2$1 = Math.atan2;

    var average = function (colors, mode) {
        if ( mode === void 0 ) mode='lrgb';

        var l = colors.length;
        // convert colors to Color objects
        colors = colors.map(function (c) { return new Color_1(c); });
        if (mode === 'lrgb') {
            return _average_lrgb(colors)
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        // initial color
        for (var i=0; i<xyz.length; i++) {
            xyz[i] = xyz[i] || 0;
            cnt.push(isNaN(xyz[i]) ? 0 : 1);
            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {
                var A = xyz[i] / 180 * PI$1;
                dx += cos$2(A);
                dy += sin$1(A);
            }
        }

        var alpha = first.alpha();
        colors.forEach(function (c) {
            var xyz2 = c.get(mode);
            alpha += c.alpha();
            for (var i=0; i<xyz.length; i++) {
                if (!isNaN(xyz2[i])) {
                    cnt[i]++;
                    if (mode.charAt(i) === 'h') {
                        var A = xyz2[i] / 180 * PI$1;
                        dx += cos$2(A);
                        dy += sin$1(A);
                    } else {
                        xyz[i] += xyz2[i];
                    }
                }
            }
        });

        for (var i$1=0; i$1<xyz.length; i$1++) {
            if (mode.charAt(i$1) === 'h') {
                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;
                while (A$1 < 0) { A$1 += 360; }
                while (A$1 >= 360) { A$1 -= 360; }
                xyz[i$1] = A$1;
            } else {
                xyz[i$1] = xyz[i$1]/cnt[i$1];
            }
        }
        alpha /= l;
        return (new Color_1(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);
    };


    var _average_lrgb = function (colors) {
        var l = colors.length;
        var f = 1/l;
        var xyz = [0,0,0,0];
        for (var i = 0, list = colors; i < list.length; i += 1) {
            var col = list[i];

            var rgb = col._rgb;
            xyz[0] += pow$4(rgb[0],2) * f;
            xyz[1] += pow$4(rgb[1],2) * f;
            xyz[2] += pow$4(rgb[2],2) * f;
            xyz[3] += rgb[3] * f;
        }
        xyz[0] = sqrt$3(xyz[0]);
        xyz[1] = sqrt$3(xyz[1]);
        xyz[2] = sqrt$3(xyz[2]);
        if (xyz[3] > 0.9999999) { xyz[3] = 1; }
        return new Color_1(clip_rgb$2(xyz));
    };

    // minimal multi-purpose interface

    // @requires utils color analyze


    var type$j = utils.type;

    var pow$5 = Math.pow;

    var scale = function(colors) {

        // constructor
        var _mode = 'rgb';
        var _nacol = chroma_1('#ccc');
        var _spread = 0;
        // const _fixed = false;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0,0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;

        // private methods

        var setColors = function(colors) {
            colors = colors || ['#fff', '#000'];
            if (colors && type$j(colors) === 'string' && chroma_1.brewer &&
                chroma_1.brewer[colors.toLowerCase()]) {
                colors = chroma_1.brewer[colors.toLowerCase()];
            }
            if (type$j(colors) === 'array') {
                // handle single color
                if (colors.length === 1) {
                    colors = [colors[0], colors[0]];
                }
                // make a copy of the colors
                colors = colors.slice(0);
                // convert to chroma classes
                for (var c=0; c<colors.length; c++) {
                    colors[c] = chroma_1(colors[c]);
                }
                // auto-fill color position
                _pos.length = 0;
                for (var c$1=0; c$1<colors.length; c$1++) {
                    _pos.push(c$1/(colors.length-1));
                }
            }
            resetCache();
            return _colors = colors;
        };

        var getClass = function(value) {
            if (_classes != null) {
                var n = _classes.length-1;
                var i = 0;
                while (i < n && value >= _classes[i]) {
                    i++;
                }
                return i-1;
            }
            return 0;
        };

        var tmap = function (t) { return t; };

        // const classifyValue = function(value) {
        //     let val = value;
        //     if (_classes.length > 2) {
        //         const n = _classes.length-1;
        //         const i = getClass(value);
        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class
        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class
        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));
        //     }
        //     return val;
        // };

        var getColor = function(val, bypassMap) {
            var col, t;
            if (bypassMap == null) { bypassMap = false; }
            if (isNaN(val) || (val === null)) { return _nacol; }
            if (!bypassMap) {
                if (_classes && (_classes.length > 2)) {
                    // find the class
                    var c = getClass(val);
                    t = c / (_classes.length-2);
                } else if (_max !== _min) {
                    // just interpolate between min/max
                    t = (val - _min) / (_max - _min);
                } else {
                    t = 1;
                }
            } else {
                t = val;
            }

            if (!bypassMap) {
                t = tmap(t);  // lightness correction
            }

            if (_gamma !== 1) { t = pow$5(t, _gamma); }

            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));

            t = Math.min(1, Math.max(0, t));

            var k = Math.floor(t * 10000);

            if (_useCache && _colorCache[k]) {
                col = _colorCache[k];
            } else {
                if (type$j(_colors) === 'array') {
                    //for i in [0.._pos.length-1]
                    for (var i=0; i<_pos.length; i++) {
                        var p = _pos[i];
                        if (t <= p) {
                            col = _colors[i];
                            break;
                        }
                        if ((t >= p) && (i === (_pos.length-1))) {
                            col = _colors[i];
                            break;
                        }
                        if (t > p && t < _pos[i+1]) {
                            t = (t-p)/(_pos[i+1]-p);
                            col = chroma_1.interpolate(_colors[i], _colors[i+1], t, _mode);
                            break;
                        }
                    }
                } else if (type$j(_colors) === 'function') {
                    col = _colors(t);
                }
                if (_useCache) { _colorCache[k] = col; }
            }
            return col;
        };

        var resetCache = function () { return _colorCache = {}; };

        setColors(colors);

        // public interface

        var f = function(v) {
            var c = chroma_1(getColor(v));
            if (_out && c[_out]) { return c[_out](); } else { return c; }
        };

        f.classes = function(classes) {
            if (classes != null) {
                if (type$j(classes) === 'array') {
                    _classes = classes;
                    _domain = [classes[0], classes[classes.length-1]];
                } else {
                    var d = chroma_1.analyze(_domain);
                    if (classes === 0) {
                        _classes = [d.min, d.max];
                    } else {
                        _classes = chroma_1.limits(d, 'e', classes);
                    }
                }
                return f;
            }
            return _classes;
        };


        f.domain = function(domain) {
            if (!arguments.length) {
                return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length-1];
            _pos = [];
            var k = _colors.length;
            if ((domain.length === k) && (_min !== _max)) {
                // update positions
                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {
                    var d = list[i];

                  _pos.push((d-_min) / (_max-_min));
                }
            } else {
                for (var c=0; c<k; c++) {
                    _pos.push(c/(k-1));
                }
            }
            _domain = [_min, _max];
            return f;
        };

        f.mode = function(_m) {
            if (!arguments.length) {
                return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
        };

        f.range = function(colors, _pos) {
            setColors(colors, _pos);
            return f;
        };

        f.out = function(_o) {
            _out = _o;
            return f;
        };

        f.spread = function(val) {
            if (!arguments.length) {
                return _spread;
            }
            _spread = val;
            return f;
        };

        f.correctLightness = function(v) {
            if (v == null) { v = true; }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
                tmap = function(t) {
                    var L0 = getColor(0, true).lab()[0];
                    var L1 = getColor(1, true).lab()[0];
                    var pol = L0 > L1;
                    var L_actual = getColor(t, true).lab()[0];
                    var L_ideal = L0 + ((L1 - L0) * t);
                    var L_diff = L_actual - L_ideal;
                    var t0 = 0;
                    var t1 = 1;
                    var max_iter = 20;
                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {
                        (function() {
                            if (pol) { L_diff *= -1; }
                            if (L_diff < 0) {
                                t0 = t;
                                t += (t1 - t) * 0.5;
                            } else {
                                t1 = t;
                                t += (t0 - t) * 0.5;
                            }
                            L_actual = getColor(t, true).lab()[0];
                            return L_diff = L_actual - L_ideal;
                        })();
                    }
                    return t;
                };
            } else {
                tmap = function (t) { return t; };
            }
            return f;
        };

        f.padding = function(p) {
            if (p != null) {
                if (type$j(p) === 'number') {
                    p = [p,p];
                }
                _padding = p;
                return f;
            } else {
                return _padding;
            }
        };

        f.colors = function(numColors, out) {
            // If no arguments are given, return the original colors that were provided
            if (arguments.length < 2) { out = 'hex'; }
            var result = [];

            if (arguments.length === 0) {
                result = _colors.slice(0);

            } else if (numColors === 1) {
                result = [f(0.5)];

            } else if (numColors > 1) {
                var dm = _domain[0];
                var dd = _domain[1] - dm;
                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });

            } else { // returns all colors based on the defined classes
                colors = [];
                var samples = [];
                if (_classes && (_classes.length > 2)) {
                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
                        samples.push((_classes[i-1]+_classes[i])*0.5);
                    }
                } else {
                    samples = _domain;
                }
                result = samples.map(function (v) { return f(v); });
            }

            if (chroma_1[out]) {
                result = result.map(function (c) { return c[out](); });
            }
            return result;
        };

        f.cache = function(c) {
            if (c != null) {
                _useCache = c;
                return f;
            } else {
                return _useCache;
            }
        };

        f.gamma = function(g) {
            if (g != null) {
                _gamma = g;
                return f;
            } else {
                return _gamma;
            }
        };

        f.nodata = function(d) {
            if (d != null) {
                _nacol = chroma_1(d);
                return f;
            } else {
                return _nacol;
            }
        };

        return f;
    };

    function __range__(left, right, inclusive) {
      var range = [];
      var ascending = left < right;
      var end = !inclusive ? right : ascending ? right + 1 : right - 1;
      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
        range.push(i);
      }
      return range;
    }

    //
    // interpolates between a set of colors uzing a bezier spline
    //

    // @requires utils lab




    var bezier = function(colors) {
        var assign, assign$1, assign$2;

        var I, lab0, lab1, lab2;
        colors = colors.map(function (c) { return new Color_1(c); });
        if (colors.length === 2) {
            // linear interpolation
            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));
                return new Color_1(lab, 'lab');
            };
        } else if (colors.length === 3) {
            // quadratic bezier interpolation
            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));
                return new Color_1(lab, 'lab');
            };
        } else if (colors.length === 4) {
            // cubic bezier interpolation
            var lab3;
            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));
                return new Color_1(lab, 'lab');
            };
        } else if (colors.length === 5) {
            var I0 = bezier(colors.slice(0, 3));
            var I1 = bezier(colors.slice(2, 5));
            I = function(t) {
                if (t < 0.5) {
                    return I0(t*2);
                } else {
                    return I1((t-0.5)*2);
                }
            };
        }
        return I;
    };

    var bezier_1 = function (colors) {
        var f = bezier(colors);
        f.scale = function () { return scale(f); };
        return f;
    };

    /*
     * interpolates between a set of colors uzing a bezier spline
     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
     */




    var blend = function (bottom, top, mode) {
        if (!blend[mode]) {
            throw new Error('unknown blend mode ' + mode);
        }
        return blend[mode](bottom, top);
    };

    var blend_f = function (f) { return function (bottom,top) {
            var c0 = chroma_1(top).rgb();
            var c1 = chroma_1(bottom).rgb();
            return chroma_1.rgb(f(c0, c1));
        }; };

    var each = function (f) { return function (c0, c1) {
            var out = [];
            out[0] = f(c0[0], c1[0]);
            out[1] = f(c0[1], c1[1]);
            out[2] = f(c0[2], c1[2]);
            return out;
        }; };

    var normal = function (a) { return a; };
    var multiply = function (a,b) { return a * b / 255; };
    var darken$1 = function (a,b) { return a > b ? b : a; };
    var lighten = function (a,b) { return a > b ? a : b; };
    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };
    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };
    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };
    var dodge = function (a,b) {
        if (a === 255) { return 255; }
        a = 255 * (b / 255) / (1 - a / 255);
        return a > 255 ? 255 : a
    };

    // # add = (a,b) ->
    // #     if (a + b > 255) then 255 else a + b

    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken$1));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));
    // blend.add = blend_f(each(add));

    var blend_1 = blend;

    // cubehelix interpolation
    // based on D.A. Green "A colour scheme for the display of astronomical intensity images"
    // http://astron-soc.in/bulletin/11June/289392011.pdf

    var type$k = utils.type;
    var clip_rgb$3 = utils.clip_rgb;
    var TWOPI$2 = utils.TWOPI;
    var pow$6 = Math.pow;
    var sin$2 = Math.sin;
    var cos$3 = Math.cos;


    var cubehelix = function(start, rotations, hue, gamma, lightness) {
        if ( start === void 0 ) start=300;
        if ( rotations === void 0 ) rotations=-1.5;
        if ( hue === void 0 ) hue=1;
        if ( gamma === void 0 ) gamma=1;
        if ( lightness === void 0 ) lightness=[0,1];

        var dh = 0, dl;
        if (type$k(lightness) === 'array') {
            dl = lightness[1] - lightness[0];
        } else {
            dl = 0;
            lightness = [lightness, lightness];
        }

        var f = function(fract) {
            var a = TWOPI$2 * (((start+120)/360) + (rotations * fract));
            var l = pow$6(lightness[0] + (dl * fract), gamma);
            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;
            var amp = (h * l * (1-l)) / 2;
            var cos_a = cos$3(a);
            var sin_a = sin$2(a);
            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));
            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));
            var b = l + (amp * (+1.97294 * cos_a));
            return chroma_1(clip_rgb$3([r*255,g*255,b*255,1]));
        };

        f.start = function(s) {
            if ((s == null)) { return start; }
            start = s;
            return f;
        };

        f.rotations = function(r) {
            if ((r == null)) { return rotations; }
            rotations = r;
            return f;
        };

        f.gamma = function(g) {
            if ((g == null)) { return gamma; }
            gamma = g;
            return f;
        };

        f.hue = function(h) {
            if ((h == null)) { return hue; }
            hue = h;
            if (type$k(hue) === 'array') {
                dh = hue[1] - hue[0];
                if (dh === 0) { hue = hue[1]; }
            } else {
                dh = 0;
            }
            return f;
        };

        f.lightness = function(h) {
            if ((h == null)) { return lightness; }
            if (type$k(h) === 'array') {
                lightness = h;
                dl = h[1] - h[0];
            } else {
                lightness = [h,h];
                dl = 0;
            }
            return f;
        };

        f.scale = function () { return chroma_1.scale(f); };

        f.hue(hue);

        return f;
    };

    var digits = '0123456789abcdef';

    var floor$2 = Math.floor;
    var random = Math.random;

    var random_1 = function () {
        var code = '#';
        for (var i=0; i<6; i++) {
            code += digits.charAt(floor$2(random() * 16));
        }
        return new Color_1(code, 'hex');
    };

    var log$1 = Math.log;
    var pow$7 = Math.pow;
    var floor$3 = Math.floor;
    var abs = Math.abs;


    var analyze = function (data, key) {
        if ( key === void 0 ) key=null;

        var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE*-1,
            sum: 0,
            values: [],
            count: 0
        };
        if (type(data) === 'object') {
            data = Object.values(data);
        }
        data.forEach(function (val) {
            if (key && type(val) === 'object') { val = val[key]; }
            if (val !== undefined && val !== null && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) { r.min = val; }
                if (val > r.max) { r.max = val; }
                r.count += 1;
            }
        });

        r.domain = [r.min, r.max];

        r.limits = function (mode, num) { return limits(r, mode, num); };

        return r;
    };


    var limits = function (data, mode, num) {
        if ( mode === void 0 ) mode='equal';
        if ( num === void 0 ) num=7;

        if (type(data) == 'array') {
            data = analyze(data);
        }
        var min = data.min;
        var max = data.max;
        var values = data.values.sort(function (a,b) { return a-b; });

        if (num === 1) { return [min,max]; }

        var limits = [];

        if (mode.substr(0,1) === 'c') { // continuous
            limits.push(min);
            limits.push(max);
        }

        if (mode.substr(0,1) === 'e') { // equal interval
            limits.push(min);
            for (var i=1; i<num; i++) {
                limits.push(min+((i/num)*(max-min)));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'l') { // log scale
            if (min <= 0) {
                throw new Error('Logarithmic scales are only possible for values > 0');
            }
            var min_log = Math.LOG10E * log$1(min);
            var max_log = Math.LOG10E * log$1(max);
            limits.push(min);
            for (var i$1=1; i$1<num; i$1++) {
                limits.push(pow$7(10, min_log + ((i$1/num) * (max_log - min_log))));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'q') { // quantile scale
            limits.push(min);
            for (var i$2=1; i$2<num; i$2++) {
                var p = ((values.length-1) * i$2)/num;
                var pb = floor$3(p);
                if (pb === p) {
                    limits.push(values[pb]);
                } else { // p > pb
                    var pr = p - pb;
                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));
                }
            }
            limits.push(max);

        }

        else if (mode.substr(0,1) === 'k') { // k-means clustering
            /*
            implementation based on
            http://code.google.com/p/figue/source/browse/trunk/figue.js#336
            simplified for 1-d input values
            */
            var cluster;
            var n = values.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;

            // get seed values
            centroids = [];
            centroids.push(min);
            for (var i$3=1; i$3<num; i$3++) {
                centroids.push(min + ((i$3/num) * (max-min)));
            }
            centroids.push(max);

            while (repeat) {
                // assignment step
                for (var j=0; j<num; j++) {
                    clusterSizes[j] = 0;
                }
                for (var i$4=0; i$4<n; i$4++) {
                    var value = values[i$4];
                    var mindist = Number.MAX_VALUE;
                    var best = (void 0);
                    for (var j$1=0; j$1<num; j$1++) {
                        var dist = abs(centroids[j$1]-value);
                        if (dist < mindist) {
                            mindist = dist;
                            best = j$1;
                        }
                        clusterSizes[best]++;
                        assignments[i$4] = best;
                    }
                }

                // update centroids step
                var newCentroids = new Array(num);
                for (var j$2=0; j$2<num; j$2++) {
                    newCentroids[j$2] = null;
                }
                for (var i$5=0; i$5<n; i$5++) {
                    cluster = assignments[i$5];
                    if (newCentroids[cluster] === null) {
                        newCentroids[cluster] = values[i$5];
                    } else {
                        newCentroids[cluster] += values[i$5];
                    }
                }
                for (var j$3=0; j$3<num; j$3++) {
                    newCentroids[j$3] *= 1/clusterSizes[j$3];
                }

                // check convergence
                repeat = false;
                for (var j$4=0; j$4<num; j$4++) {
                    if (newCentroids[j$4] !== centroids[j$4]) {
                        repeat = true;
                        break;
                    }
                }

                centroids = newCentroids;
                nb_iters++;

                if (nb_iters > 200) {
                    repeat = false;
                }
            }

            // finished k-means clustering
            // the next part is borrowed from gabrielflor.it
            var kClusters = {};
            for (var j$5=0; j$5<num; j$5++) {
                kClusters[j$5] = [];
            }
            for (var i$6=0; i$6<n; i$6++) {
                cluster = assignments[i$6];
                kClusters[cluster].push(values[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6=0; j$6<num; j$6++) {
                tmpKMeansBreaks.push(kClusters[j$6][0]);
                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });
            limits.push(tmpKMeansBreaks[0]);
            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {
                var v = tmpKMeansBreaks[i$7];
                if (!isNaN(v) && (limits.indexOf(v) === -1)) {
                    limits.push(v);
                }
            }
        }
        return limits;
    };

    var analyze_1 = {analyze: analyze, limits: limits};

    var contrast = function (a, b) {
        // WCAG contrast ratio
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
        a = new Color_1(a);
        b = new Color_1(b);
        var l1 = a.luminance();
        var l2 = b.luminance();
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    };

    var sqrt$4 = Math.sqrt;
    var atan2$2 = Math.atan2;
    var abs$1 = Math.abs;
    var cos$4 = Math.cos;
    var PI$2 = Math.PI;

    var deltaE = function(a, b, L, C) {
        if ( L === void 0 ) L=1;
        if ( C === void 0 ) C=1;

        // Delta E (CMC)
        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CMC.html
        a = new Color_1(a);
        b = new Color_1(b);
        var ref = Array.from(a.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b.lab());
        var L2 = ref$1[0];
        var a2 = ref$1[1];
        var b2 = ref$1[2];
        var c1 = sqrt$4((a1 * a1) + (b1 * b1));
        var c2 = sqrt$4((a2 * a2) + (b2 * b2));
        var sl = L1 < 16.0 ? 0.511 : (0.040975 * L1) / (1.0 + (0.01765 * L1));
        var sc = ((0.0638 * c1) / (1.0 + (0.0131 * c1))) + 0.638;
        var h1 = c1 < 0.000001 ? 0.0 : (atan2$2(b1, a1) * 180.0) / PI$2;
        while (h1 < 0) { h1 += 360; }
        while (h1 >= 360) { h1 -= 360; }
        var t = (h1 >= 164.0) && (h1 <= 345.0) ? (0.56 + abs$1(0.2 * cos$4((PI$2 * (h1 + 168.0)) / 180.0))) : (0.36 + abs$1(0.4 * cos$4((PI$2 * (h1 + 35.0)) / 180.0)));
        var c4 = c1 * c1 * c1 * c1;
        var f = sqrt$4(c4 / (c4 + 1900.0));
        var sh = sc * (((f * t) + 1.0) - f);
        var delL = L1 - L2;
        var delC = c1 - c2;
        var delA = a1 - a2;
        var delB = b1 - b2;
        var dH2 = ((delA * delA) + (delB * delB)) - (delC * delC);
        var v1 = delL / (L * sl);
        var v2 = delC / (C * sc);
        var v3 = sh;
        return sqrt$4((v1 * v1) + (v2 * v2) + (dH2 / (v3 * v3)));
    };

    // simple Euclidean distance
    var distance = function(a, b, mode) {
        if ( mode === void 0 ) mode='lab';

        // Delta E (CIE 1976)
        // see http://www.brucelindbloom.com/index.html?Equations.html
        a = new Color_1(a);
        b = new Color_1(b);
        var l1 = a.get(mode);
        var l2 = b.get(mode);
        var sum_sq = 0;
        for (var i in l1) {
            var d = (l1[i] || 0) - (l2[i] || 0);
            sum_sq += d*d;
        }
        return Math.sqrt(sum_sq);
    };

    var valid = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        try {
            new (Function.prototype.bind.apply( Color_1, [ null ].concat( args) ));
            return true;
        } catch (e) {
            return false;
        }
    };

    // some pre-defined color scales:




    var scales = {
    	cool: function cool() { return scale([chroma_1.hsl(180,1,.9), chroma_1.hsl(250,.7,.4)]) },
    	hot: function hot() { return scale(['#000','#f00','#ff0','#fff'], [0,.25,.75,1]).mode('rgb') }
    };

    /**
        ColorBrewer colors for chroma.js

        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
        Pennsylvania State University.

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing, software distributed
        under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
        CONDITIONS OF ANY KIND, either express or implied. See the License for the
        specific language governing permissions and limitations under the License.
    */

    var colorbrewer = {
        // sequential
        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],

        // diverging

        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],

        // qualitative

        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
    };

    // add lowercase aliases for case-insensitive matches
    for (var i$1 = 0, list$1 = Object.keys(colorbrewer); i$1 < list$1.length; i$1 += 1) {
        var key = list$1[i$1];

        colorbrewer[key.toLowerCase()] = colorbrewer[key];
    }

    var colorbrewer_1 = colorbrewer;

    // feel free to comment out anything to rollup
    // a smaller chroma.js built

    // io --> convert colors















    // operators --> modify existing Colors










    // interpolators










    // generators -- > create new colors
    chroma_1.average = average;
    chroma_1.bezier = bezier_1;
    chroma_1.blend = blend_1;
    chroma_1.cubehelix = cubehelix;
    chroma_1.mix = chroma_1.interpolate = mix;
    chroma_1.random = random_1;
    chroma_1.scale = scale;

    // other utility methods
    chroma_1.analyze = analyze_1.analyze;
    chroma_1.contrast = contrast;
    chroma_1.deltaE = deltaE;
    chroma_1.distance = distance;
    chroma_1.limits = analyze_1.limits;
    chroma_1.valid = valid;

    // scale
    chroma_1.scales = scales;

    // colors
    chroma_1.colors = w3cx11_1;
    chroma_1.brewer = colorbrewer_1;

    var chroma_js = chroma_1;

    return chroma_js;

})));


/***/ }),

/***/ "+I+c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "+IV6":
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "+YGm":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.classNamesShape = exports.timeoutsShape = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var timeoutsShape =  false ? undefined : null;
exports.timeoutsShape = timeoutsShape;
var classNamesShape =  false ? undefined : null;
exports.classNamesShape = classNamesShape;

/***/ }),

/***/ "+bRE":
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "+l6y":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getScreenSize;
/** @module utils/Positioning/getScreenSize */

/**
 * A utility function to get the height or width of the of the browser with
 * a fallback for older browsers.
 *
 * @param {String} position - the position to get the screen size for
 * @return {number} the screen size for the provided position.
 */
function getScreenSize(position) {
  if (position !== 'Height' && position !== 'Width' && "production" !== 'production') {
    throw new Error('The \'getScreenSize\' function requires either a position of \'Height\' or \'Width\' ' + ('but received `' + position + '`'));
  }

  return window['inner' + position] || document.documentElement['client' + position];
}

/***/ }),

/***/ "+vVB":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _themeColors = __webpack_require__("VZNk");

var _themeColors2 = _interopRequireDefault(_themeColors);

var _AccessibleFakeInkedButton = __webpack_require__("MrGi");

var _AccessibleFakeInkedButton2 = _interopRequireDefault(_AccessibleFakeInkedButton);

var _Collapse = __webpack_require__("cp8/");

var _Collapse2 = _interopRequireDefault(_Collapse);

var _FontIcons = __webpack_require__("B7Yq");

var _FontIcons2 = _interopRequireDefault(_FontIcons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `BottomNav` component is used for rendering the navigation tab/link in the `BottomNavigation`
 * component.
 */
var BottomNav = function (_PureComponent) {
  _inherits(BottomNav, _PureComponent);

  function BottomNav() {
    var _temp, _this, _ret;

    _classCallCheck(this, BottomNav);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._handleClick = function (e) {
      var _this$props = _this.props,
          onClick = _this$props.onClick,
          onNavChange = _this$props.onNavChange,
          index = _this$props.index;

      if (onClick) {
        onClick(index, e);
      }

      if (onNavChange) {
        onNavChange(index, e);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  BottomNav.prototype.render = function render() {
    var _props = this.props,
        active = _props.active,
        fixed = _props.fixed,
        className = _props.className,
        colored = _props.colored,
        animate = _props.animate,
        iconClassName = _props.iconClassName,
        iconChildren = _props.iconChildren,
        index = _props.index,
        propIcon = _props.icon,
        propLabel = _props.label,
        onClick = _props.onClick,
        onNavChange = _props.onNavChange,
        props = _objectWithoutProperties(_props, ['active', 'fixed', 'className', 'colored', 'animate', 'iconClassName', 'iconChildren', 'index', 'icon', 'label', 'onClick', 'onNavChange']);

    var _props2 = this.props,
        label = _props2.label,
        icon = _props2.icon;

    var labelClassName = (0, _classnames2.default)('md-bottom-nav-label', { 'md-bottom-nav-label--shifting-inactive': !active && !fixed });
    if (_react.Children.count(label) === 1 && (0, _react.isValidElement)(label)) {
      var labelEl = _react.Children.only(label);
      label = (0, _react.cloneElement)(label, {
        className: (0, _classnames2.default)(labelClassName, labelEl.props.className)
      });
    } else {
      label = _react2.default.createElement(
        'div',
        { className: labelClassName },
        label
      );
    }

    if (!icon && (iconClassName || iconChildren)) {
      // Deprecated
      icon = _react2.default.createElement(
        _FontIcons2.default,
        { iconClassName: iconClassName, inherit: true },
        iconChildren
      );
    } else if (icon) {
      icon = _react2.default.cloneElement(icon, { inherit: true });
    }

    return _react2.default.createElement(
      _AccessibleFakeInkedButton2.default,
      _extends({}, props, {
        onClick: this._handleClick,
        className: (0, _classnames2.default)('md-bottom-nav', {
          'md-bottom-nav--active': active,
          'md-bottom-nav--fixed': fixed,
          'md-bottom-nav--shifting': !fixed,
          'md-bottom-nav--shifting-active': !fixed && active,
          'md-bottom-nav--shifting-inactive': !fixed && !active
        }, (0, _themeColors2.default)({ primary: !colored && active, text: !active && !colored }, className))
      }),
      icon,
      _react2.default.createElement(
        _Collapse2.default,
        { collapsed: !fixed && !active, animate: animate },
        label
      )
    );
  };

  return BottomNav;
}(_react.PureComponent);

BottomNav.propTypes = {
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  component: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]),
  active: _propTypes2.default.bool,
  fixed: _propTypes2.default.bool,
  children: _propTypes2.default.node,
  index: _propTypes2.default.number.isRequired,
  label: _propTypes2.default.node.isRequired,
  colored: _propTypes2.default.bool,
  iconChildren: _propTypes2.default.node,
  iconClassName: _propTypes2.default.string,
  onClick: _propTypes2.default.func,
  onNavChange: _propTypes2.default.func,
  role: _propTypes2.default.string,
  animate: _propTypes2.default.bool,
  icon: _propTypes2.default.element
};
BottomNav.defaultProps = {
  component: 'a',
  role: null
};
exports.default = BottomNav;

/***/ }),

/***/ "0aw1":
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__("QpHq");

var assertThisInitialized = __webpack_require__("lcrv");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "0dP6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getBtnStyles;

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _themeColors = __webpack_require__("VZNk");

var _themeColors2 = _interopRequireDefault(_themeColors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Since it can be helpful to apply button styles on other components, this is a utlity function
 * to apply those styles based on props.
 */
function getBtnStyles(_ref) {
  var _ref2;

  var flat = _ref.flat,
      raised = _ref.raised,
      icon = _ref.icon,
      floating = _ref.floating,
      disabled = _ref.disabled,
      primary = _ref.primary,
      secondary = _ref.secondary,
      hover = _ref.hover,
      swapTheming = _ref.swapTheming,
      pressed = _ref.pressed,
      mini = _ref.mini,
      fixed = _ref.fixed,
      fixedPosition = _ref.fixedPosition;

  var flatStyles = flat || icon;
  var raisedStyles = raised || floating;
  var textTheming = flatStyles && !swapTheming || raisedStyles && swapTheming;
  var backgroundTheming = (!disabled && raisedStyles && !swapTheming || flatStyles && swapTheming) && (primary || secondary);

  for (var _len = arguments.length, classNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    classNames[_key - 1] = arguments[_key];
  }

  return _classnames2.default.apply(undefined, ['md-btn', (_ref2 = {
    'md-btn--flat': flat || disabled && raised,
    'md-btn--raised': !disabled && raised,
    'md-btn--icon': icon || floating,
    'md-btn--floating': floating,
    'md-btn--text': flat || raised,
    'md-btn--hover': !disabled && hover,
    'md-btn--raised-disabled': disabled && raised,
    'md-btn--raised-pressed': !disabled && raisedStyles && pressed,
    'md-btn--fixed': fixed
  }, _ref2['md-btn--fixed-' + fixedPosition] = floating && fixed, _ref2['md-btn--floating-mini'] = floating && mini, _ref2['md-btn--color-primary-active'] = !disabled && primary && hover && textTheming, _ref2['md-btn--color-secondary-active'] = !disabled && secondary && hover && textTheming, _ref2['md-pointer--hover'] = !disabled, _ref2['md-paper md-paper--2'] = !disabled && floating, _ref2['md-paper--4'] = !disabled && floating && pressed, _ref2), (0, _themeColors2.default)({
    text: !icon && !floating && !backgroundTheming,
    themeText: !backgroundTheming,
    disabled: disabled,
    primary: primary,
    secondary: secondary,
    hover: true,
    ink: true
  })].concat(classNames));
}

/***/ }),

/***/ "10o/":
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "1QXF":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.focusEvents = exports.keyboardEvents = exports.touchEvents = exports.mouseEvents = void 0;
// As defined on the list of supported mouse events: https://reactjs.org/docs/events.html#mouse-events
var mouseEvents = ['onClick', 'onContextMenu', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp']; // As defined on the list of supported touch events: https://reactjs.org/docs/events.html#touch-events

exports.mouseEvents = mouseEvents;
var touchEvents = ['onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart']; // As defined on the list of supported keyboard events: https://reactjs.org/docs/events.html#keyboard-events

exports.touchEvents = touchEvents;
var keyboardEvents = ['onKeyDown', 'onKeyPress', 'onKeyUp']; // As defined on the list of supported keyboard events: https://reactjs.org/docs/events.html#focus-events

exports.keyboardEvents = keyboardEvents;
var focusEvents = ['onFocus', 'onBlur'];
/**
 * Returns an object with on-event callback props curried with provided args.
 * @param {Object} props Props passed to a component.
 * @param {Function=} getArgs A function that returns argument(s) on-event callbacks
 *   shall be curried with.
 */

exports.focusEvents = focusEvents;

var makeEventProps = function makeEventProps(props, getArgs) {
  var eventProps = {};
  [].concat(mouseEvents, touchEvents, keyboardEvents, focusEvents).forEach(function (eventName) {
    if (props[eventName]) {
      eventProps[eventName] = function (event) {
        return getArgs ? props[eventName](event, getArgs(eventName)) : props[eventName](event);
      };
    }
  });
  return eventProps;
};

var _default = makeEventProps;
exports.default = _default;

/***/ }),

/***/ "1VGG":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = __webpack_require__("mXGw");

var _default = (0, _react.createContext)(null);

exports.default = _default;

/***/ }),

/***/ "1obq":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// stepper is used a lot. Saves allocation to return the same array wrapper.
// This is fine and danger-free against mutations because the callsite
// immediately destructures it and gets the numbers inside without passing the


exports.__esModule = true;
exports["default"] = stepper;

var reusedTuple = [0, 0];

function stepper(secondPerFrame, x, v, destX, k, b, precision) {
  // Spring stiffness, in kg / s^2

  // for animations, destX is really spring length (spring at rest). initial
  // position is considered as the stretched/compressed position of a spring
  var Fspring = -k * (x - destX);

  // Damping, in kg / s
  var Fdamper = -b * v;

  // usually we put mass here, but for animation purposes, specifying mass is a
  // bit redundant. you could simply adjust k and b accordingly
  // let a = (Fspring + Fdamper) / mass;
  var a = Fspring + Fdamper;

  var newV = v + a * secondPerFrame;
  var newX = x + newV * secondPerFrame;

  if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {
    reusedTuple[0] = destX;
    reusedTuple[1] = 0;
    return reusedTuple;
  }

  reusedTuple[0] = newX;
  reusedTuple[1] = newV;
  return reusedTuple;
}

module.exports = exports["default"];
// array reference around.

/***/ }),

/***/ "1sm7":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "2KSd":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return Bounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Flip", function() { return Flip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Slide", function() { return Slide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToastContainer", function() { return ToastContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToastPosition", function() { return POSITION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToastType", function() { return TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Zoom", function() { return Zoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssTransition", function() { return cssTransition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toast", function() { return toast; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("Fcif");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("+I+c");
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("7L9N");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("mXGw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("W0B4");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("8Jek");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_transition_group_TransitionGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("m4Rk");
/* harmony import */ var react_transition_group_TransitionGroup__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_transition_group_TransitionGroup__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var react_transition_group_Transition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("LB/S");
/* harmony import */ var react_transition_group_Transition__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_transition_group_Transition__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("xARA");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_8__);










var POSITION = {
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right',
  TOP_CENTER: 'top-center',
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  BOTTOM_CENTER: 'bottom-center'
};
var TYPE = {
  INFO: 'info',
  SUCCESS: 'success',
  WARNING: 'warning',
  ERROR: 'error',
  DEFAULT: 'default'
};
var ACTION = {
  SHOW: 0,
  CLEAR: 1,
  DID_MOUNT: 2,
  WILL_UNMOUNT: 3,
  ON_CHANGE: 4
};
var NOOP = function NOOP() {};

function isValidDelay(val) {
  return typeof val === 'number' && !isNaN(val) && val > 0;
}
function objectValues(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}
var canUseDom = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

function withRequired(fn) {
  fn.isRequired = function (props, propName, componentName) {
    var prop = props[propName];

    if (typeof prop === 'undefined') {
      return new Error("The prop " + propName + " is marked as required in \n      " + componentName + ", but its value is undefined.");
    }

    fn(props, propName, componentName);
  };

  return fn;
}

var falseOrDelay = withRequired(function (props, propName, componentName) {
  var prop = props[propName];

  if (prop !== false && !isValidDelay(prop)) {
    return new Error(componentName + " expect " + propName + " \n      to be a valid Number > 0 or equal to false. " + prop + " given.");
  }

  return null;
});

function ProgressBar(_ref) {
  var _animationEvent;

  var delay = _ref.delay,
      isRunning = _ref.isRunning,
      closeToast = _ref.closeToast,
      type = _ref.type,
      hide = _ref.hide,
      className = _ref.className,
      userStyle = _ref.style,
      controlledProgress = _ref.controlledProgress,
      progress = _ref.progress,
      rtl = _ref.rtl;

  var style = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, userStyle, {
    animationDuration: delay + "ms",
    animationPlayState: isRunning ? 'running' : 'paused',
    opacity: hide ? 0 : 1,
    transform: controlledProgress ? "scaleX(" + progress + ")" : null
  });

  var classNames = classnames__WEBPACK_IMPORTED_MODULE_5___default()('Toastify__progress-bar', controlledProgress ? 'Toastify__progress-bar--controlled' : 'Toastify__progress-bar--animated', "Toastify__progress-bar--" + type, {
    'Toastify__progress-bar--rtl': rtl
  }, className);
  var animationEvent = (_animationEvent = {}, _animationEvent[controlledProgress && progress >= 1 ? 'onTransitionEnd' : 'onAnimationEnd'] = controlledProgress && progress < 1 ? null : closeToast, _animationEvent);
  return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div", Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    className: classNames,
    style: style
  }, animationEvent));
}

ProgressBar.propTypes = {
  /**
   * The animation delay which determine when to close the toast
   */
  delay: falseOrDelay.isRequired,

  /**
   * Whether or not the animation is running or paused
   */
  isRunning: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool.isRequired,

  /**
   * Func to close the current toast
   */
  closeToast: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func.isRequired,

  /**
   * Support rtl content
   */
  rtl: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool.isRequired,

  /**
   * Optional type : info, success ...
   */
  type: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,

  /**
   * Hide or not the progress bar
   */
  hide: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * Optionnal className
   */
  className: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object]),

  /**
   * Controlled progress value
   */
  progress: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,

  /**
   * Tell wether or not controlled progress bar is used
   */
  controlledProgress: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool
};
ProgressBar.defaultProps = {
  type: TYPE.DEFAULT,
  hide: false
};

function getX(e) {
  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.clientX;
}

function getY(e) {
  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.clientY;
}

var iLoveInternetExplorer = canUseDom && /(msie|trident)/i.test(navigator.userAgent);

var Toast =
/*#__PURE__*/
function (_Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(Toast, _Component);

  function Toast() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      isRunning: true,
      preventExitTransition: false
    };
    _this.flag = {
      canCloseOnClick: true,
      canDrag: false
    };
    _this.drag = {
      start: 0,
      x: 0,
      y: 0,
      deltaX: 0,
      removalDistance: 0
    };
    _this.boundingRect = null;
    _this.ref = null;

    _this.pauseToast = function () {
      if (_this.props.autoClose) {
        _this.setState({
          isRunning: false
        });
      }
    };

    _this.playToast = function () {
      if (_this.props.autoClose) {
        _this.setState({
          isRunning: true
        });
      }
    };

    _this.onDragStart = function (e) {
      _this.flag.canCloseOnClick = true;
      _this.flag.canDrag = true;
      _this.boundingRect = _this.ref.getBoundingClientRect();
      _this.ref.style.transition = '';
      _this.drag.start = _this.drag.x = getX(e.nativeEvent);
      _this.drag.removalDistance = _this.ref.offsetWidth * (_this.props.draggablePercent / 100);
    };

    _this.onDragMove = function (e) {
      if (_this.flag.canDrag) {
        if (_this.state.isRunning) {
          _this.pauseToast();
        }

        _this.drag.x = getX(e);
        _this.drag.deltaX = _this.drag.x - _this.drag.start;
        _this.drag.y = getY(e); // prevent false positif during a toast click

        _this.drag.start !== _this.drag.x && (_this.flag.canCloseOnClick = false);
        _this.ref.style.transform = "translateX(" + _this.drag.deltaX + "px)";
        _this.ref.style.opacity = 1 - Math.abs(_this.drag.deltaX / _this.drag.removalDistance);
      }
    };

    _this.onDragEnd = function (e) {
      if (_this.flag.canDrag) {
        _this.flag.canDrag = false;

        if (Math.abs(_this.drag.deltaX) > _this.drag.removalDistance) {
          _this.setState({
            preventExitTransition: true
          }, _this.props.closeToast);

          return;
        }

        _this.ref.style.transition = 'transform 0.2s, opacity 0.2s';
        _this.ref.style.transform = 'translateX(0)';
        _this.ref.style.opacity = 1;
      }
    };

    _this.onDragTransitionEnd = function () {
      if (_this.boundingRect) {
        var _this$boundingRect = _this.boundingRect,
            top = _this$boundingRect.top,
            bottom = _this$boundingRect.bottom,
            left = _this$boundingRect.left,
            right = _this$boundingRect.right;

        if (_this.props.pauseOnHover && _this.drag.x >= left && _this.drag.x <= right && _this.drag.y >= top && _this.drag.y <= bottom) {
          _this.pauseToast();
        } else {
          _this.playToast();
        }
      }
    };

    _this.onExitTransitionEnd = function () {
      if (iLoveInternetExplorer) {
        _this.props.onExited();

        return;
      }

      var height = _this.ref.scrollHeight;
      var style = _this.ref.style;
      requestAnimationFrame(function () {
        style.minHeight = 'initial';
        style.height = height + 'px';
        style.transition = 'all 0.4s ';
        requestAnimationFrame(function () {
          style.height = 0;
          style.padding = 0;
          style.margin = 0;
        });
        setTimeout(function () {
          return _this.props.onExited();
        }, 400);
      });
    };

    return _this;
  }

  var _proto = Toast.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.onOpen(this.props.children.props);

    if (this.props.draggable) {
      this.bindDragEvents();
    } // Maybe I could bind the event in the ToastContainer and rely on delegation


    if (this.props.pauseOnFocusLoss) {
      this.bindFocusEvents();
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.draggable !== this.props.draggable) {
      if (this.props.draggable) {
        this.bindDragEvents();
      } else {
        this.unbindDragEvents();
      }
    }

    if (prevProps.pauseOnFocusLoss !== this.props.pauseOnFocusLoss) {
      if (this.props.pauseOnFocusLoss) {
        this.bindFocusEvents();
      } else {
        this.unbindFocusEvents();
      }
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.onClose(this.props.children.props);

    if (this.props.draggable) {
      this.unbindDragEvents();
    }

    if (this.props.pauseOnFocusLoss) {
      this.unbindFocusEvents();
    }
  };

  _proto.bindFocusEvents = function bindFocusEvents() {
    window.addEventListener('focus', this.playToast);
    window.addEventListener('blur', this.pauseToast);
  };

  _proto.unbindFocusEvents = function unbindFocusEvents() {
    window.removeEventListener('focus', this.playToast);
    window.removeEventListener('blur', this.pauseToast);
  };

  _proto.bindDragEvents = function bindDragEvents() {
    document.addEventListener('mousemove', this.onDragMove);
    document.addEventListener('mouseup', this.onDragEnd);
    document.addEventListener('touchmove', this.onDragMove);
    document.addEventListener('touchend', this.onDragEnd);
  };

  _proto.unbindDragEvents = function unbindDragEvents() {
    document.removeEventListener('mousemove', this.onDragMove);
    document.removeEventListener('mouseup', this.onDragEnd);
    document.removeEventListener('touchmove', this.onDragMove);
    document.removeEventListener('touchend', this.onDragEnd);
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props = this.props,
        closeButton = _this$props.closeButton,
        children = _this$props.children,
        autoClose = _this$props.autoClose,
        pauseOnHover = _this$props.pauseOnHover,
        onClick = _this$props.onClick,
        closeOnClick = _this$props.closeOnClick,
        type = _this$props.type,
        hideProgressBar = _this$props.hideProgressBar,
        closeToast = _this$props.closeToast,
        Transition = _this$props.transition,
        position = _this$props.position,
        className = _this$props.className,
        bodyClassName = _this$props.bodyClassName,
        progressClassName = _this$props.progressClassName,
        progressStyle = _this$props.progressStyle,
        updateId = _this$props.updateId,
        role = _this$props.role,
        progress = _this$props.progress,
        rtl = _this$props.rtl;
    var toastProps = {
      className: classnames__WEBPACK_IMPORTED_MODULE_5___default()('Toastify__toast', "Toastify__toast--" + type, {
        'Toastify__toast--rtl': rtl
      }, className)
    };

    if (autoClose && pauseOnHover) {
      toastProps.onMouseEnter = this.pauseToast;
      toastProps.onMouseLeave = this.playToast;
    } // prevent toast from closing when user drags the toast


    if (closeOnClick) {
      toastProps.onClick = function (e) {
        onClick && onClick(e);
        _this2.flag.canCloseOnClick && closeToast();
      };
    }

    var controlledProgress = parseFloat(progress) === progress;
    return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(Transition, {
      in: this.props.in,
      appear: true,
      onExited: this.onExitTransitionEnd,
      position: position,
      preventExitTransition: this.state.preventExitTransition
    }, react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div", Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
      onClick: onClick
    }, toastProps, {
      ref: function ref(_ref) {
        return _this2.ref = _ref;
      },
      onMouseDown: this.onDragStart,
      onTouchStart: this.onDragStart,
      onMouseUp: this.onDragTransitionEnd,
      onTouchEnd: this.onDragTransitionEnd
    }), react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div", Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.props.in && {
      role: role
    }, {
      className: classnames__WEBPACK_IMPORTED_MODULE_5___default()('Toastify__toast-body', bodyClassName)
    }), children), closeButton && closeButton, (autoClose || controlledProgress) && react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(ProgressBar, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, updateId && !controlledProgress ? {
      key: "pb-" + updateId
    } : {}, {
      rtl: rtl,
      delay: autoClose,
      isRunning: this.state.isRunning,
      closeToast: closeToast,
      hide: hideProgressBar,
      type: type,
      style: progressStyle,
      className: progressClassName,
      controlledProgress: controlledProgress,
      progress: progress
    }))));
  };

  return Toast;
}(react__WEBPACK_IMPORTED_MODULE_3__["Component"]);

Toast.propTypes = {
  closeButton: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool]).isRequired,
  autoClose: falseOrDelay.isRequired,
  children: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node.isRequired,
  closeToast: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func.isRequired,
  position: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOf(objectValues(POSITION)).isRequired,
  pauseOnHover: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool.isRequired,
  pauseOnFocusLoss: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool.isRequired,
  closeOnClick: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool.isRequired,
  transition: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func.isRequired,
  rtl: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool.isRequired,
  hideProgressBar: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool.isRequired,
  draggable: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool.isRequired,
  draggablePercent: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number.isRequired,
  in: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
  onExited: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
  onOpen: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
  onClose: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
  type: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOf(objectValues(TYPE)),
  className: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object]),
  bodyClassName: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object]),
  progressClassName: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object]),
  progressStyle: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
  progress: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,
  updateId: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number]),
  ariaLabel: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
  containerId: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number]),
  role: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string
};
Toast.defaultProps = {
  type: TYPE.DEFAULT,
  in: true,
  onOpen: NOOP,
  onClose: NOOP,
  className: null,
  bodyClassName: null,
  progressClassName: null,
  updateId: null
};

function CloseButton(_ref) {
  var closeToast = _ref.closeToast,
      type = _ref.type,
      ariaLabel = _ref.ariaLabel;
  return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("button", {
    className: "Toastify__close-button Toastify__close-button--" + type,
    type: "button",
    onClick: function onClick(e) {
      e.stopPropagation();
      closeToast(e);
    },
    "aria-label": ariaLabel
  }, "\u2716");
}

CloseButton.propTypes = {
  closeToast: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
  arialLabel: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string
};
CloseButton.defaultProps = {
  ariaLabel: 'close'
};

function cssTransition (_ref) {
  var enter = _ref.enter,
      exit = _ref.exit,
      _ref$duration = _ref.duration,
      duration = _ref$duration === void 0 ? 750 : _ref$duration,
      _ref$appendPosition = _ref.appendPosition,
      appendPosition = _ref$appendPosition === void 0 ? false : _ref$appendPosition;
  return function Animation(_ref2) {
    var children = _ref2.children,
        position = _ref2.position,
        preventExitTransition = _ref2.preventExitTransition,
        props = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_ref2, ["children", "position", "preventExitTransition"]);

    var enterClassName = appendPosition ? enter + "--" + position : enter;
    var exitClassName = appendPosition ? exit + "--" + position : exit;
    var enterDuration, exitDuration;

    if (Array.isArray(duration) && duration.length === 2) {
      enterDuration = duration[0];
      exitDuration = duration[1];
    } else {
      enterDuration = exitDuration = duration;
    }

    var onEnter = function onEnter(node) {
      node.classList.add(enterClassName);
      node.style.animationFillMode = 'forwards';
      node.style.animationDuration = enterDuration * 0.001 + "s";
    };

    var onEntered = function onEntered(node) {
      node.classList.remove(enterClassName);
      node.style.cssText = '';
    };

    var onExit = function onExit(node) {
      node.classList.add(exitClassName);
      node.style.animationFillMode = 'forwards';
      node.style.animationDuration = exitDuration * 0.001 + "s";
    };

    return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(react_transition_group_Transition__WEBPACK_IMPORTED_MODULE_7___default.a, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, props, {
      timeout: preventExitTransition ? 0 : {
        enter: enterDuration,
        exit: exitDuration
      },
      onEnter: onEnter,
      onEntered: onEntered,
      onExit: preventExitTransition ? NOOP : onExit
    }), children);
  };
}

var Bounce = cssTransition({
  enter: 'Toastify__bounce-enter',
  exit: 'Toastify__bounce-exit',
  appendPosition: true
});
var Slide = cssTransition({
  enter: 'Toastify__slide-enter',
  exit: 'Toastify__slide-exit',
  duration: [450, 750],
  appendPosition: true
});
var Zoom = cssTransition({
  enter: 'Toastify__zoom-enter',
  exit: 'Toastify__zoom-exit'
});
var Flip = cssTransition({
  enter: 'Toastify__flip-enter',
  exit: 'Toastify__flip-exit'
});

var eventManager = {
  list: new Map(),
  on: function on(event, callback) {
    this.list.has(event) || this.list.set(event, []);
    this.list.get(event).push(callback);
    return this;
  },
  off: function off(event) {
    this.list.delete(event);
    return this;
  },

  /**
   * Enqueue the event at the end of the call stack
   * Doing so let the user call toast as follow:
   * toast('1')
   * toast('2')
   * toast('3')
   * Without setTimemout the code above will not work
   */
  emit: function emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    this.list.has(event) && this.list.get(event).forEach(function (callback) {
      return setTimeout(function () {
        callback.apply(void 0, args);
      }, 0);
    });
  }
};

var ToastContainer =
/*#__PURE__*/
function (_Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(ToastContainer, _Component);

  function ToastContainer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      toast: []
    };
    _this.toastKey = 1;
    _this.collection = {};

    _this.isToastActive = function (id) {
      return _this.state.toast.indexOf(id) !== -1;
    };

    return _this;
  }

  var _proto = ToastContainer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    eventManager.on(ACTION.SHOW, function (content, options) {
      return _this2.buildToast(content, options);
    }).on(ACTION.CLEAR, function (id) {
      return id == null ? _this2.clear() : _this2.removeToast(id);
    }).emit(ACTION.DID_MOUNT, this);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    eventManager.off(ACTION.SHOW).off(ACTION.CLEAR).emit(ACTION.WILL_UNMOUNT, this);
  };

  _proto.removeToast = function removeToast(id) {
    this.setState({
      toast: this.state.toast.filter(function (v) {
        return v !== id;
      })
    }, this.dispatchChange);
  };

  _proto.dispatchChange = function dispatchChange() {
    eventManager.emit(ACTION.ON_CHANGE, this.state.toast.length);
  };

  _proto.makeCloseButton = function makeCloseButton(toastClose, toastId, type) {
    var _this3 = this;

    var closeButton = this.props.closeButton;

    if (Object(react__WEBPACK_IMPORTED_MODULE_3__["isValidElement"])(toastClose) || toastClose === false) {
      closeButton = toastClose;
    } else if (toastClose === true) {
      closeButton = react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(CloseButton, null);
    }

    return closeButton === false ? false : Object(react__WEBPACK_IMPORTED_MODULE_3__["cloneElement"])(closeButton, {
      closeToast: function closeToast() {
        return _this3.removeToast(toastId);
      },
      type: type
    });
  };

  _proto.getAutoCloseDelay = function getAutoCloseDelay(toastAutoClose) {
    return toastAutoClose === false || isValidDelay(toastAutoClose) ? toastAutoClose : this.props.autoClose;
  };

  _proto.canBeRendered = function canBeRendered(content) {
    return Object(react__WEBPACK_IMPORTED_MODULE_3__["isValidElement"])(content) || typeof content === 'string' || typeof content === 'number' || typeof content === 'function';
  };

  _proto.parseClassName = function parseClassName(prop) {
    if (typeof prop === 'string') {
      return prop;
    } else if (prop !== null && typeof prop === 'object' && 'toString' in prop) {
      return prop.toString();
    }

    return null;
  };

  _proto.belongToContainer = function belongToContainer(_ref) {
    var containerId = _ref.containerId;
    return containerId === this.props.containerId;
  };

  _proto.buildToast = function buildToast(content, _ref2) {
    var _this4 = this;

    var delay = _ref2.delay,
        options = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_ref2, ["delay"]);

    if (!this.canBeRendered(content)) {
      throw new Error("The element you provided cannot be rendered. You provided an element of type " + typeof content);
    }

    var toastId = options.toastId,
        updateId = options.updateId; // Check for multi-container and also for duplicate toastId
    // Maybe it would be better to extract it

    if (this.props.enableMultiContainer && !this.belongToContainer(options) || this.isToastActive(toastId) && updateId == null) {
      return;
    }

    var closeToast = function closeToast() {
      return _this4.removeToast(toastId);
    };

    var toastOptions = {
      id: toastId,
      // ⚠️ if no options.key, this.toastKey - 1 is assigned
      key: options.key || this.toastKey++,
      type: options.type,
      closeToast: closeToast,
      updateId: options.updateId,
      rtl: this.props.rtl,
      position: options.position || this.props.position,
      transition: options.transition || this.props.transition,
      className: this.parseClassName(options.className || this.props.toastClassName),
      bodyClassName: this.parseClassName(options.bodyClassName || this.props.bodyClassName),
      onClick: options.onClick || this.props.onClick,
      closeButton: this.makeCloseButton(options.closeButton, toastId, options.type),
      pauseOnHover: typeof options.pauseOnHover === 'boolean' ? options.pauseOnHover : this.props.pauseOnHover,
      pauseOnFocusLoss: typeof options.pauseOnFocusLoss === 'boolean' ? options.pauseOnFocusLoss : this.props.pauseOnFocusLoss,
      draggable: typeof options.draggable === 'boolean' ? options.draggable : this.props.draggable,
      draggablePercent: typeof options.draggablePercent === 'number' && !isNaN(options.draggablePercent) ? options.draggablePercent : this.props.draggablePercent,
      closeOnClick: typeof options.closeOnClick === 'boolean' ? options.closeOnClick : this.props.closeOnClick,
      progressClassName: this.parseClassName(options.progressClassName || this.props.progressClassName),
      progressStyle: this.props.progressStyle,
      autoClose: this.getAutoCloseDelay(options.autoClose),
      hideProgressBar: typeof options.hideProgressBar === 'boolean' ? options.hideProgressBar : this.props.hideProgressBar,
      progress: parseFloat(options.progress),
      role: typeof options.role === 'string' ? options.role : this.props.role
    };
    typeof options.onOpen === 'function' && (toastOptions.onOpen = options.onOpen);
    typeof options.onClose === 'function' && (toastOptions.onClose = options.onClose); // add closeToast function to react component only

    if (Object(react__WEBPACK_IMPORTED_MODULE_3__["isValidElement"])(content) && typeof content.type !== 'string' && typeof content.type !== 'number') {
      content = Object(react__WEBPACK_IMPORTED_MODULE_3__["cloneElement"])(content, {
        closeToast: closeToast
      });
    } else if (typeof content === 'function') {
      content = content({
        closeToast: closeToast
      });
    }

    if (isValidDelay(delay)) {
      setTimeout(function () {
        _this4.appendToast(toastOptions, content, options.staleToastId);
      }, delay);
    } else {
      this.appendToast(toastOptions, content, options.staleToastId);
    }
  };

  _proto.appendToast = function appendToast(options, content, staleToastId) {
    var _extends2;

    var id = options.id,
        updateId = options.updateId;
    this.collection = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.collection, (_extends2 = {}, _extends2[id] = {
      options: options,
      content: content,
      position: options.position
    }, _extends2));
    this.setState({
      toast: (updateId ? [].concat(this.state.toast) : [].concat(this.state.toast, [id])).filter(function (id) {
        return id !== staleToastId;
      })
    }, this.dispatchChange);
  };

  _proto.clear = function clear() {
    this.setState({
      toast: []
    });
  };

  _proto.renderToast = function renderToast() {
    var _this5 = this;

    var toastToRender = {};
    var _this$props = this.props,
        className = _this$props.className,
        style = _this$props.style,
        newestOnTop = _this$props.newestOnTop;
    var collection = newestOnTop ? Object.keys(this.collection).reverse() : Object.keys(this.collection); // group toast by position

    collection.forEach(function (toastId) {
      var _this5$collection$toa = _this5.collection[toastId],
          position = _this5$collection$toa.position,
          options = _this5$collection$toa.options,
          content = _this5$collection$toa.content;
      toastToRender[position] || (toastToRender[position] = []);

      if (_this5.state.toast.indexOf(options.id) !== -1) {
        toastToRender[position].push(react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(Toast, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, options, {
          isDocumentHidden: _this5.state.isDocumentHidden,
          key: "toast-" + options.key
        }), content));
      } else {
        toastToRender[position].push(null);
        delete _this5.collection[toastId];
      }
    });
    return Object.keys(toastToRender).map(function (position) {
      var disablePointer = toastToRender[position].length === 1 && toastToRender[position][0] === null;
      var props = {
        className: classnames__WEBPACK_IMPORTED_MODULE_5___default()('Toastify__toast-container', "Toastify__toast-container--" + position, {
          'Toastify__toast-container--rtl': _this5.props.rtl
        }, _this5.parseClassName(className)),
        style: disablePointer ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, style, {
          pointerEvents: 'none'
        }) : Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, style)
      };
      return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(react_transition_group_TransitionGroup__WEBPACK_IMPORTED_MODULE_6___default.a, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, props, {
        key: "container-" + position
      }), toastToRender[position]);
    });
  };

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div", {
      className: "Toastify"
    }, this.renderToast());
  };

  return ToastContainer;
}(react__WEBPACK_IMPORTED_MODULE_3__["Component"]);

ToastContainer.propTypes = {
  /**
   * Set toast position
   */
  position: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOf(objectValues(POSITION)),

  /**
   * Disable or set autoClose delay
   */
  autoClose: falseOrDelay,

  /**
   * Disable or set a custom react element for the close button
   */
  closeButton: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool]),

  /**
   * Hide or not progress bar when autoClose is enabled
   */
  hideProgressBar: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * Pause toast duration on hover
   */
  pauseOnHover: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * Dismiss toast on click
   */
  closeOnClick: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * Newest on top
   */
  newestOnTop: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * An optional className
   */
  className: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object]),

  /**
   * An optional style
   */
  style: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,

  /**
   * An optional className for the toast
   */
  toastClassName: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object]),

  /**
   * An optional className for the toast body
   */
  bodyClassName: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object]),

  /**
   * An optional className for the toast progress bar
   */
  progressClassName: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object]),

  /**
   * An optional style for the toast progress bar
   */
  progressStyle: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,

  /**
   * Define enter and exit transition using react-transition-group
   */
  transition: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,

  /**
   * Support rtl display
   */
  rtl: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * Allow toast to be draggable
   */
  draggable: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * The percentage of the toast's width it takes for a drag to dismiss a toast
   */
  draggablePercent: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,

  /**
   * Pause the toast on focus loss
   */
  pauseOnFocusLoss: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * Show the toast only if it includes containerId and it's the same as containerId
   */
  enableMultiContainer: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * Set id to handle multiple container
   */
  containerId: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number]),

  /**
   * Set role attribute for the toast body
   */
  role: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,

  /**
   * Fired when clicking inside toaster
   */
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func
};
ToastContainer.defaultProps = {
  position: POSITION.TOP_RIGHT,
  transition: Bounce,
  rtl: false,
  autoClose: 5000,
  hideProgressBar: false,
  closeButton: react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(CloseButton, null),
  pauseOnHover: true,
  pauseOnFocusLoss: true,
  closeOnClick: true,
  newestOnTop: false,
  draggable: true,
  draggablePercent: 80,
  className: null,
  style: null,
  toastClassName: null,
  bodyClassName: null,
  progressClassName: null,
  progressStyle: null,
  role: 'alert'
};

var containers = new Map();
var latestInstance = null;
var containerDomNode = null;
var containerConfig = {};
var queue = [];
var lazy = false;
/**
 * Check whether any container is currently mounted in the DOM
 */

function isAnyContainerMounted() {
  return containers.size > 0;
}
/**
 * Get the container by id. Returns the last container declared when no id is given.
 */


function getContainer(containerId) {
  if (!isAnyContainerMounted()) return null;
  if (!containerId) return containers.get(latestInstance);
  return containers.get(containerId);
}
/**
 * Get the toast by id, given it's in the DOM, otherwise returns null
 */


function getToast(toastId, _ref) {
  var containerId = _ref.containerId;
  var container = getContainer(containerId);
  if (!container) return null;
  var toast = container.collection[toastId];
  if (typeof toast === 'undefined') return null;
  return toast;
}
/**
 * Merge provided options with the defaults settings and generate the toastId
 */


function mergeOptions(options, type) {
  return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, options, {
    type: type,
    toastId: getToastId(options)
  });
}
/**
 * Generate a random toastId
 */


function generateToastId() {
  return (Math.random().toString(36) + Date.now().toString(36)).substr(2, 10);
}
/**
 * Generate a toastId or use the one provided
 */


function getToastId(options) {
  if (options && (typeof options.toastId === 'string' || typeof options.toastId === 'number' && !isNaN(options.toastId))) {
    return options.toastId;
  }

  return generateToastId();
}
/**
 * If the container is not mounted, the toast is enqueued and
 * the container lazy mounted
 */


function dispatchToast(content, options) {
  if (isAnyContainerMounted()) {
    eventManager.emit(ACTION.SHOW, content, options);
  } else {
    queue.push({
      action: ACTION.SHOW,
      content: content,
      options: options
    });

    if (lazy && canUseDom) {
      lazy = false;
      containerDomNode = document.createElement('div');
      document.body.appendChild(containerDomNode);
      Object(react_dom__WEBPACK_IMPORTED_MODULE_8__["render"])(react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(ToastContainer, containerConfig), containerDomNode);
    }
  }

  return options.toastId;
}

var toast = function toast(content, options) {
  return dispatchToast(content, mergeOptions(options, options && options.type || TYPE.DEFAULT));
};
/**
 * For each available type create a shortcut
 */


var _loop = function _loop(t) {
  if (TYPE[t] !== TYPE.DEFAULT) {
    toast[TYPE[t].toLowerCase()] = function (content, options) {
      return dispatchToast(content, mergeOptions(options, options && options.type || TYPE[t]));
    };
  }
};

for (var t in TYPE) {
  _loop(t);
}
/**
 * Maybe I should remove warning in favor of warn, I don't know
 */


toast.warn = toast.warning;
/**
 * Remove toast programmaticaly
 */

toast.dismiss = function (id) {
  if (id === void 0) {
    id = null;
  }

  return isAnyContainerMounted() && eventManager.emit(ACTION.CLEAR, id);
};
/**
 * Do nothing until the container is mounted. Reassigned later
 */


toast.isActive = NOOP;

toast.update = function (toastId, options) {
  if (options === void 0) {
    options = {};
  }

  // if you call toast and toast.update directly nothing will be displayed
  // this is why I defered the update
  setTimeout(function () {
    var toast = getToast(toastId, options);

    if (toast) {
      var oldOptions = toast.options,
          oldContent = toast.content;

      var nextOptions = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, oldOptions, options, {
        toastId: options.toastId || toastId
      });

      if (!options.toastId || options.toastId === toastId) {
        nextOptions.updateId = generateToastId();
      } else {
        nextOptions.staleToastId = toastId;
      }

      var content = typeof nextOptions.render !== 'undefined' ? nextOptions.render : oldContent;
      delete nextOptions.render;
      dispatchToast(content, nextOptions);
    }
  }, 0);
};
/**
 * Used for controlled progress bar.
 */


toast.done = function (id) {
  toast.update(id, {
    progress: 1
  });
};
/**
 * Track changes. The callback get the number of toast displayed
 */


toast.onChange = function (callback) {
  if (typeof callback === 'function') {
    eventManager.on(ACTION.ON_CHANGE, callback);
  }
};
/**
 * Configure the ToastContainer when lazy mounted
 */


toast.configure = function (config) {
  lazy = true;
  containerConfig = config;
};

toast.POSITION = POSITION;
toast.TYPE = TYPE;
/**
 * Wait until the ToastContainer is mounted to dispatch the toast
 * and attach isActive method
 */

eventManager.on(ACTION.DID_MOUNT, function (containerInstance) {
  latestInstance = containerInstance.props.containerId || containerInstance;
  containers.set(latestInstance, containerInstance);

  toast.isActive = function (id) {
    return containerInstance.isToastActive(id);
  };

  queue.forEach(function (item) {
    eventManager.emit(item.action, item.content, item.options);
  });
  queue = [];
}).on(ACTION.WILL_UNMOUNT, function (containerInstance) {
  if (containerInstance) containers.delete(containerInstance.props.containerId || containerInstance);else containers.clear();
  toast.isActive = NOOP;

  if (canUseDom && containerDomNode) {
    document.body.removeChild(containerDomNode);
  }
});




/***/ }),

/***/ "2gDV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `TileAddon` component is used to render either a `FontIcon` or an `Avatar`
 * next to the `ListTileText` for a `ListItem`.
 */
var TileAddon = function (_PureComponent) {
  _inherits(TileAddon, _PureComponent);

  function TileAddon() {
    _classCallCheck(this, TileAddon);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  TileAddon.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        icon = _props.icon,
        avatar = _props.avatar,
        active = _props.active,
        activeClassName = _props.activeClassName,
        style = _props.style,
        className = _props.className;

    if (!icon && !avatar) {
      return null;
    }

    var avatarIcon = false;
    if (avatar) {
      var avatarChild = _react2.default.Children.only(avatar);
      if (avatarChild.props.iconSized) {
        avatarIcon = true;
      }
    }
    return _react2.default.createElement(
      'div',
      {
        style: style,
        className: (0, _classnames2.default)('md-tile-addon', (_cn = {
          'md-tile-addon--icon': icon || avatarIcon,
          'md-tile-addon--avatar': avatar && !avatarIcon
        }, _cn[activeClassName] = active, _cn), className)
      },
      icon || avatar
    );
  };

  return TileAddon;
}(_react.PureComponent);

TileAddon.propTypes = {
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  active: _propTypes2.default.bool,
  activeClassName: _propTypes2.default.string,
  icon: _propTypes2.default.node,
  avatar: _propTypes2.default.node
};
exports.default = TileAddon;

/***/ }),

/***/ "2oCQ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _between = __webpack_require__("jjyK");

var _between2 = _interopRequireDefault(_between);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `Paper` component is a simple wrapper that adds box-shadow.
 *
 * You can also use the SCSS mixin instead of paper.
 *
 * ```scss
 * @include md-box-shadow(5);
 * ```
 */
var Paper = function (_PureComponent) {
  _inherits(Paper, _PureComponent);

  function Paper() {
    _classCallCheck(this, Paper);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Paper.prototype.render = function render() {
    var _props = this.props,
        Component = _props.component,
        zDepth = _props.zDepth,
        className = _props.className,
        raiseOnHover = _props.raiseOnHover,
        props = _objectWithoutProperties(_props, ['component', 'zDepth', 'className', 'raiseOnHover']);

    return _react2.default.createElement(Component, _extends({}, props, {
      className: (0, _classnames2.default)('md-paper md-paper--' + zDepth, {
        'md-paper--0-hover': zDepth === 0 && raiseOnHover
      }, className)
    }));
  };

  return Paper;
}(_react.PureComponent);

Paper.propTypes = {
  /**
   * The component to render the paper as.
   */
  component: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired,

  /**
   * An optional className to apply.
   */
  className: _propTypes2.default.string,

  /**
   * The depth of the paper. This should be a number between 0 - 5. If
   * the depth is 0, it will raise to a depth of 3 on hover.
   */
  zDepth: (0, _between2.default)(_propTypes2.default.number.isRequired, 0, 5),

  /**
   * Any children to display in the paper.
   */
  children: _propTypes2.default.node,

  /**
   * Boolean if the paper should raise to the `zDepth` of `3` on hover when the initial
   * `zDepth` is `0`.
   */
  raiseOnHover: _propTypes2.default.bool
};
Paper.defaultProps = {
  zDepth: 1,
  component: 'div'
};
exports.default = Paper;

/***/ }),

/***/ "3Yb6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("10o/");

exports.__esModule = true;
exports.default = void 0;

var _inDOM = _interopRequireDefault(__webpack_require__("Dhpq"));

var on = function on() {};

if (_inDOM.default) {
  on = function () {
    if (document.addEventListener) return function (node, eventName, handler, capture) {
      return node.addEventListener(eventName, handler, capture || false);
    };else if (document.attachEvent) return function (node, eventName, handler) {
      return node.attachEvent('on' + eventName, function (e) {
        e = e || window.event;
        e.target = e.target || e.srcElement;
        e.currentTarget = node;
        handler.call(node, e);
      });
    };
  }();
}

var _default = on;
exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "3Zmt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// core keys merging algorithm. If previous render's keys are [a, b], and the
// next render's [c, b, d], what's the final merged keys and ordering?

// - c and a must both be before b
// - b before d
// - ordering between a and c ambiguous

// this reduces to merging two partially ordered lists (e.g. lists where not
// every item has a definite ordering, like comparing a and c above). For the
// ambiguous ordering we deterministically choose to place the next render's
// item after the previous'; so c after a

// this is called a topological sorting. Except the existing algorithms don't
// work well with js bc of the amount of allocation, and isn't optimized for our
// current use-case bc the runtime is linear in terms of edges (see wiki for
// meaning), which is huge when two lists have many common elements


exports.__esModule = true;
exports['default'] = mergeDiff;

function mergeDiff(prev, next, onRemove) {
  // bookkeeping for easier access of a key's index below. This is 2 allocations +
  // potentially triggering chrome hash map mode for objs (so it might be faster

  var prevKeyIndex = {};
  for (var i = 0; i < prev.length; i++) {
    prevKeyIndex[prev[i].key] = i;
  }
  var nextKeyIndex = {};
  for (var i = 0; i < next.length; i++) {
    nextKeyIndex[next[i].key] = i;
  }

  // first, an overly elaborate way of merging prev and next, eliminating
  // duplicates (in terms of keys). If there's dupe, keep the item in next).
  // This way of writing it saves allocations
  var ret = [];
  for (var i = 0; i < next.length; i++) {
    ret[i] = next[i];
  }
  for (var i = 0; i < prev.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(nextKeyIndex, prev[i].key)) {
      // this is called my TM's `mergeAndSync`, which calls willLeave. We don't
      // merge in keys that the user desires to kill
      var fill = onRemove(i, prev[i]);
      if (fill != null) {
        ret.push(fill);
      }
    }
  }

  // now all the items all present. Core sorting logic to have the right order
  return ret.sort(function (a, b) {
    var nextOrderA = nextKeyIndex[a.key];
    var nextOrderB = nextKeyIndex[b.key];
    var prevOrderA = prevKeyIndex[a.key];
    var prevOrderB = prevKeyIndex[b.key];

    if (nextOrderA != null && nextOrderB != null) {
      // both keys in next
      return nextKeyIndex[a.key] - nextKeyIndex[b.key];
    } else if (prevOrderA != null && prevOrderB != null) {
      // both keys in prev
      return prevKeyIndex[a.key] - prevKeyIndex[b.key];
    } else if (nextOrderA != null) {
      // key a in next, key b in prev

      // how to determine the order between a and b? We find a "pivot" (term
      // abuse), a key present in both prev and next, that is sandwiched between
      // a and b. In the context of our above example, if we're comparing a and
      // d, b's (the only) pivot
      for (var i = 0; i < next.length; i++) {
        var pivot = next[i].key;
        if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {
          continue;
        }

        if (nextOrderA < nextKeyIndex[pivot] && prevOrderB > prevKeyIndex[pivot]) {
          return -1;
        } else if (nextOrderA > nextKeyIndex[pivot] && prevOrderB < prevKeyIndex[pivot]) {
          return 1;
        }
      }
      // pluggable. default to: next bigger than prev
      return 1;
    }
    // prevOrderA, nextOrderB
    for (var i = 0; i < next.length; i++) {
      var pivot = next[i].key;
      if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {
        continue;
      }
      if (nextOrderB < nextKeyIndex[pivot] && prevOrderA > prevKeyIndex[pivot]) {
        return 1;
      } else if (nextOrderB > nextKeyIndex[pivot] && prevOrderA < prevKeyIndex[pivot]) {
        return -1;
      }
    }
    // pluggable. default to: next bigger than prev
    return -1;
  });
}

module.exports = exports['default'];
// to loop through and find a key's index each time), but I no longer care

/***/ }),

/***/ "3iwl":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/react-md/node_modules/prop-types/index.js
var prop_types = __webpack_require__("5+ba");
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ../node_modules/react-dom/index.js
var react_dom = __webpack_require__("xARA");

// EXTERNAL MODULE: ../node_modules/react-md/node_modules/react-transition-group/CSSTransitionGroup.js
var CSSTransitionGroup = __webpack_require__("snpA");
var CSSTransitionGroup_default = /*#__PURE__*/__webpack_require__.n(CSSTransitionGroup);

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// CONCATENATED MODULE: ../node_modules/react-md/es/utils/getField.js
/** @module utils/getField */

/**
 * Gets the current field for a component that can the field
 * as either uncontrolled or controlled.
 *
 * @param {Object} props - the props object.
 * @param {Object} state = the state object.
 * @param {string=} field - the field to extract a value from. Defaults to 'value'.
 *
 * @return the field's value.
 */
function getField(props, state) {
  var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'value';

  return typeof props[field] !== 'undefined' ? props[field] : state[field];
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/omit.js
/** @module utils/omit */

/**
 * This should hopefully be very similar to lodash's omit function. It will
 * take an object and return a new object without any of the given keys.
 *
 * @param {Object} obj - The object to omit keys from.
 * @param {Array.<String>} keys - a list of keys to remove.
 */
function omit(obj, keys) {
  if (!obj) {
    return {};
  } else if (!keys || !keys.length) {
    return obj;
  }

  return Object.keys(obj).filter(function (key) {
    return keys.indexOf(key) === -1;
  }).reduce(function (newProps, key) {
    newProps[key] = obj[key];

    return newProps;
  }, {});
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/findIgnoreCase.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** @module utils/findIgnoreCase */


/**
 * This function finds the first item in a `haystack` that starts with every
 * letter of the `value` in order. It will ignore:
 *  - null or undefined
 *  - valid React components
 *
 * @param {Array.<string|number|Object|function>} haystack - the haystack to search.
 * @param {string} value - the current value to use.
 * @param {string=} dataLabel - the object key to use to extract the comparing value.
 *
 * @return {string} the found element or the empty string.
 */
function findIgnoreCase(haystack, value, dataLabel) {
  var needle = value ? value.toLowerCase() : '';

  if (!needle) {
    return needle;
  }

  var suggestion = '';
  haystack.some(function (hay) {
    if (hay === null || typeof hay === 'undefined' || react_default.a.isValidElement(hay)) {
      return false;
    }

    var hayStr = (typeof hay === 'undefined' ? 'undefined' : _typeof(hay)) === 'object' ? hay[dataLabel] : hay.toString();

    if (hayStr.toLowerCase().indexOf(needle) === 0) {
      suggestion = hayStr;
    }

    return suggestion;
  });

  return suggestion;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/fuzzyFilter.js
var fuzzyFilter_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** @module utils/fuzzyFilter */


/**
 * This function does a simple fuzzy search of some `needle` for every
 * item in a `haystack`. It will only include items that are:
 *  - not null or undefined
 *  - valid React Components
 *  - a number or string that contains each letter/number in order ignoring case
 *  - an object's `dataLabel` value that contains each letter/number in order ignoring case.
 *
 * Example:
 * ```js
 * const haystack = ['Apple', 'Banana', 'Orange'];
 * fuzzyFilter(haystack, 'An') // ['Banana', 'Orange'];
 * fuzzyFilter(haystack, 'ae') // ['Apple']
 * ```
 *
 * @param {Array.<string|number|Object|function>} haystack - the haystack to search
 * @param {string} needle - the filter text to use.
 * @param {string=} dataLabel - the data label to use if the element is an object.
 *
 * @return {Array.<string|number|Object|function>} a filtered list.
 */
function fuzzyFilter(haystack, needle, dataLabel) {
  // Create an amazing regex that matches the letters in order
  // and escapes any strings that could be part of a regex.
  var reg = new RegExp(('' + needle).split('').join('\\w*').replace(/(\(|\||\)|\\(?!w\*)|\[|\|-|\.|\^|\+|\$|\?|^(?!w)\*)/g, '\\$1')
  // Couldn't get the matching of two '*' working, so replace them here..
  .replace(/\*\*/g, '*\\*'), 'i');

  return haystack.filter(function (hay) {
    if (hay === null || typeof hay === 'undefined') {
      return false;
    } else if (react_default.a.isValidElement(hay)) {
      return true;
    }

    var value = void 0;
    switch (typeof hay === 'undefined' ? 'undefined' : fuzzyFilter_typeof(hay)) {
      case 'string':
      case 'number':
        value = hay.toString();
        break;
      default:
        value = hay[dataLabel];
    }

    return value && value.match(reg);
  });
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/caseInsensitiveFilter.js
var caseInsensitiveFilter_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** @module utils/caseInsensitiveFilter */


/**
 * This function does a simple ignore case search of some `filterText` for every
 * item in a `haystack`. It will only include items that are:
 *  - not null or undefined
 *  - valid React Components
 *  - a number or string that contains each letter/number in exact order ignoring case
 *  - an object's `dataLabel` value that contains each letter/number in exact order ignoring case.
 *
 * Example:
 *
 * ```js
 * const haystack = ['Apple', 'Banana', 'Orange'];
 * caseInsensitiveFilter(haystack, 'An') // ['Banana', 'Orange'];
 * caseInsensitiveFilter(haystack, 'ae') // []
 * ```
 *
 * @param {Array.<string|number|Object|function>} haystack - the haystack to search
 * @param {string} filterText - the filter text to use.
 * @param {string=} dataLabel - the data label to use if the element is an object.
 *
 * @return {Array.<string|number|Object|function>} a filtered list.
 */
function caseInsensitiveFilter(haystack, filterText, dataLabel) {
  var needle = filterText.toLowerCase();

  return haystack.filter(function (hay) {
    if (hay === null || typeof hay === 'undefined') {
      return false;
    } else if (react_default.a.isValidElement(hay)) {
      return true;
    }

    var value = void 0;
    switch (typeof hay === 'undefined' ? 'undefined' : caseInsensitiveFilter_typeof(hay)) {
      case 'string':
      case 'number':
        value = hay.toString();
        break;
      default:
        value = hay[dataLabel];
    }

    return value && value.toLowerCase().indexOf(needle) !== -1;
  });
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/Positioning/getTextWidth.js
/** @module utils/Positioning/getTextWidth */

var cachedCanvas = void 0;

/**
 * A utility function to measure the width (in px) of any text. It will require a canvas
 * and an element to use to determine the current fonts to apply since different fonts will
 * have different widths.
 *
 * This isn't fully accurate since some browsers handle the calculations a bit differently so
 * they are off by a 0-3px
 *
 * @param {String} text - The text to measure the width
 * @param {HTMLElement} el - The element to use to determine the current font for the text.
 * @param {HTMLElement=} canvas - An optional canvas to use for doing the calculations. If this
 *    is omitted, it will just use the locally created canvas to do the calculations.
 * @return {number} this will either return null if there is a problem calculating the width or
 *    the length (in px) of the text.
 */
function getTextWidth(text, el, canvas) {
  if (!el) {
    return null;
  }

  if (!canvas) {
    if (!cachedCanvas) {
      cachedCanvas = document.createElement('canvas');
    }

    canvas = cachedCanvas;
  }

  var context = canvas.getContext('2d');
  if (!context) {
    // context doesn't exist in testing without complicated mocks
    return null;
  }

  var styles = window.getComputedStyle(el);
  var font = styles.font;
  // Some browsers do not actually supply the font style since they are on an older version of CSSProperties,
  // so the font string needs to be made manually.
  if (!font) {
    // font-style font-variant font-weight font-size/line-height font-family
    var sizing = styles.fontSize + ' / ' + styles.lineHeight + ' ' + styles.fontFamily;
    font = styles.fontStyle + ' ' + styles.fontVariant + ' ' + styles.fontWeight + ' ' + sizing;
  }

  context.font = font;
  return context.measureText(text).width;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/PropTypes/oneRequiredForA11y.js
/** @module utils/PropTypes/oneRequiredForA11y */

/**
 * This validator checks that either the current prop is defined and valid or that one of the
 * other given prop names are defined. If it fails it returns an error for a11y.
 *
 * @param {function} validator - The React PropTypes validator to use for the given prop.
 * @param {String[]} otherPropNames - Any other prop names to validate against.
 * @return {Error} an error or null
 */
function oneRequiredForA11y(validator) {
  for (var _len = arguments.length, otherPropNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    otherPropNames[_key - 1] = arguments[_key];
  }

  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;
    var allPropNames = [propFullNameSafe].concat(otherPropNames);

    for (var _len2 = arguments.length, args = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      args[_key2 - 5] = arguments[_key2];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (!err && !allPropNames.filter(function (pn) {
      return typeof props[pn] !== 'undefined';
    }).length) {
      err = new Error('One of the following props are required to make ' + componentNameSafe + ' accessible ' + ('for users of assistive technologies such as screen readers. `' + allPropNames.join('`, `') + '`.'));
    }

    return err;
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/PropTypes/controlled.js
/** @module utils/PropTypes/controlled */


/**
 * Validates the a component is fully controlled or uncontrolled.  If the given prop is not
 * `undefined`, it will check if the `funcName` is defined and a function. A missing function
 * will generate an error similar to the built-in React controlled validation message.
 *
 * @param {String} funcName - The function name to use for additional validation.
 * @param {function} validator - The PropTypes validator to use for the given prop.
 * @return {Error} an error or null.
 */
function controlled(validator, funcName) {
  var fallbackPropName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'defaultValue';

  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      args[_key - 5] = arguments[_key];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (!err && typeof props[propName] !== 'undefined' && !props.readOnly && !props.disabled) {
      var _PropTypes$func;

      var funcError = (_PropTypes$func = prop_types_default.a.func).isRequired.apply(_PropTypes$func, [props, funcName, componentName, location, propFullName].concat(args));
      if (funcError) {
        err = new Error('You provided a `' + propFullNameSafe + '` ' + location + ' to the ' + componentNameSafe + ' without a ' + ('`' + funcName + '` handler. This will render a read only field. Set either the `' + funcName + '` ') + ('or use the `' + fallbackPropName + '` instead.'));
      }
    }

    return err;
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/PropTypes/invalidIf.js
/** @module utils/PropTypes/invalidIf */

/**
 * A custom validator that will throw an error if any of the `ifDefinedProps` are also defined.
 *
 * @param {function} validator - The PropTypes validator to use.
 * @param {String...} ifDefinedProps - any othe rprop names to validate against
 * @return {Error} an error or null
 */
function invalidIf(validator) {
  for (var _len = arguments.length, ifDefinedProps = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    ifDefinedProps[_key - 1] = arguments[_key];
  }

  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    for (var _len2 = arguments.length, args = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      args[_key2 - 5] = arguments[_key2];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (err) {
      return err;
    }

    var defined = typeof props[propName] !== 'undefined' && !!props[propName];
    var othersDefined = ifDefinedProps.filter(function (name) {
      return typeof props[name] !== 'undefined' && !!props[name];
    });
    if (defined && othersDefined.length) {
      var names = '`' + othersDefined.join('`, `') + '`';
      if (othersDefined.length === 1) {
        return new Error('You provided both a `' + propFullNameSafe + '` and ' + names + ' prop to the ' + componentNameSafe + ' ' + 'but only one can be given.');
      }

      return new Error('You provided a `' + propFullNameSafe + '` ' + location + ' to the ' + componentNameSafe + ' when ' + ('the following props were defined: ' + names + '. Either remove the `' + propFullNameSafe + '` ') + 'or use the remove all the other props.');
    }

    return null;
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/constants/keyCodes.js
var LEFT_MOUSE = 0;
var RIGHT_MOUSE = 2;

var TAB = 9;
var ENTER = 13;
var ESC = 27;
var SPACE = 32;
var PAGE_UP = 33;
var PAGE_DOWN = 34;
var END = 35;
var HOME = 36;
var LEFT = 37;
var UP = 38;
var RIGHT = 39;
var DOWN = 40;

var ZERO = 48;
var NINE = 57;
var KEYPAD_ZERO = 96;
var KEYPAD_NINE = 105;
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/HorizontalAnchors.js
/** @module Helpers/HorizontalAnchors */

/**
 * An enum for all the different types of horizontal anchors on a layover.
 *
 * @readonly
 * @enum {string}
 */
var HorizontalAnchors = {
  /**
   * Positions the layover to the outside left on the toggle component
   * so that it does not overlap.
   */
  LEFT: 'left',

  /**
   * Positions the layover to the inner left of the toggle component so
   * that it will overlap.
   */
  INNER_LEFT: 'inner left',

  /**
   * Positions the layover so that it overlaps the toggle component
   * by positioning itself in the cetner of the toggle component's width.
   */
  CENTER: 'center',

  /**
   * Positions the layover to the outside right on the toggle component
   * so that it does not overlap.
   */
  RIGHT: 'right',

  /**
   * Positions the layover to the outside right on the toggle component
   * so that it will overlap.
   */
  INNER_RIGHT: 'inner right'
};

/* harmony default export */ var Helpers_HorizontalAnchors = (HorizontalAnchors);
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/VerticalAnchors.js
/** @module Helpers/VerticalAnchors */

/**
 * An enum for all the different types of horizontal anchors on a layover.
 *
 * @readonly
 * @enum {string}
 */
var VerticalAnchors = {
  /**
   * Positions the layover to be placed over the toggle component so that
   * it will never overlay the toggle component.
   */
  TOP: 'top',

  /**
   * Positions the layover so that it will be centered over the toggle component
   * based on the layover's height.
   */
  CENTER: 'center',

  /**
   * Positions the layover so that it will overlap the toggle component by
   * fixing to the top of the toggle.
   */
  OVERLAP: 'overlap',

  /**
   * Positions the layover to be placed below the toggle component so that
   * it will never overlay the toggle component.
   */
  BOTTOM: 'bottom'
};

/* harmony default export */ var Helpers_VerticalAnchors = (VerticalAnchors);
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/anchorShape.js




/* harmony default export */ var anchorShape = (prop_types_default.a.shape({
  x: prop_types_default.a.oneOf([Helpers_HorizontalAnchors.LEFT, Helpers_HorizontalAnchors.INNER_LEFT, Helpers_HorizontalAnchors.CENTER, Helpers_HorizontalAnchors.RIGHT, Helpers_HorizontalAnchors.INNER_RIGHT]).isRequired,
  y: prop_types_default.a.oneOf([Helpers_VerticalAnchors.TOP, Helpers_VerticalAnchors.CENTER, Helpers_VerticalAnchors.OVERLAP, Helpers_VerticalAnchors.BOTTOM]).isRequired
}));
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/fixedToShape.js


/* harmony default export */ var fixedToShape = (prop_types_default.a.oneOfType([prop_types_default.a.object, prop_types_default.a.shape({
  x: prop_types_default.a.object,
  y: prop_types_default.a.object
})]));
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/Positions.js
/** @module Helpers/Positions */

/**
 * An enum for all the animation positions for a layover appearing.
 *
 * @readonly
 * @enum {string}
 */
var Positions = {
  /**
   * The layover will appear by transitioning from the top left and expand
   * down right.
   */
  TOP_LEFT: 'tl',

  /**
   * The layover will appear by transitioning from the top right and expand
   * down left.
   */
  TOP_RIGHT: 'tr',

  /**
   * The layover will appear by transitioning from the bottom left and expand
   * top right.
   */
  BOTTOM_LEFT: 'bl',

  /**
   * The layover will appear by transitioning from the bottom right and expand
   * top left.
   */
  BOTTOM_RIGHT: 'br',

  /**
   * The layover will appear by just transitioning downwards from the bottom
   * of the toggle component.
   */
  BELOW: 'below'
};

/* harmony default export */ var Helpers_Positions = (Positions);
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/positionShape.js



/* harmony default export */ var positionShape = (prop_types_default.a.oneOfType([prop_types_default.a.oneOf([Helpers_Positions.TOP_LEFT, Helpers_Positions.TOP_RIGHT, Helpers_Positions.BOTTOM_LEFT, Helpers_Positions.BOTTOM_RIGHT, Helpers_Positions.BELOW]), prop_types_default.a.string]));
// EXTERNAL MODULE: ../node_modules/react-prop-types/lib/deprecated.js
var deprecated = __webpack_require__("PioW");
var deprecated_default = /*#__PURE__*/__webpack_require__.n(deprecated);

// CONCATENATED MODULE: ../node_modules/react-md/es/utils/themeColors.js
/** @module utils/themeColors */


/**
 * This is a utility function to apply the different text colors as a class name.
 *
 * @param {Object} options - The options to use to figure out which styles to apply.
 * @param {boolean?} options.text - Boolean if the base text color should attempt to be
 *    applied. This will only be applied if all the other states are not true.
 * @param {boolean?} options.disabled - Boolean if the text should be disabled.
 * @param {boolean?} options.error - Boolean if the error color should attempt to be applied.
 *    This will only be applied if the disabled state is false.
 * @param {boolean?} options.primary - Boolean if the primary color should be applied. This
 *    will only be applied if all the other states are false.
 * @param {boolean?} options.secondary - Boolean if the secondary color should be applied.
 *    This will only be applied if all the other states are false.
 * @param {boolean?} options.inherit - Boolean if the color should be inherited by a parent.
 *    This will only be applied if the error and disabled states are false.
 * @return {String} the class name
 */
function themeColors() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$themeText = _ref.themeText,
      themeText = _ref$themeText === undefined ? true : _ref$themeText,
      _ref$text = _ref.text,
      text = _ref$text === undefined ? false : _ref$text,
      _ref$background = _ref.background,
      background = _ref$background === undefined ? false : _ref$background,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === undefined ? false : _ref$disabled,
      _ref$error = _ref.error,
      error = _ref$error === undefined ? false : _ref$error,
      _ref$hint = _ref.hint,
      hint = _ref$hint === undefined ? false : _ref$hint,
      _ref$primary = _ref.primary,
      primary = _ref$primary === undefined ? false : _ref$primary,
      _ref$secondary = _ref.secondary,
      secondary = _ref$secondary === undefined ? false : _ref$secondary,
      _ref$inherit = _ref.inherit,
      inherit = _ref$inherit === undefined ? false : _ref$inherit,
      _ref$ink = _ref.ink,
      ink = _ref$ink === undefined ? false : _ref$ink,
      _ref$card = _ref.card,
      card = _ref$card === undefined ? false : _ref$card,
      _ref$hover = _ref.hover,
      hover = _ref$hover === undefined ? false : _ref$hover;

  var className = arguments[1];

  var colors = '';
  if (themeText) {
    if (disabled) {
      colors = 'md-text--disabled';
    } else if (error) {
      colors = 'md-text--error';
    } else if (inherit) {
      colors = 'md-text--inherit';
    } else {
      colors = classnames_default()({
        'md-text': text && !primary && !secondary && !hint,
        'md-text--secondary': hint,
        'md-text--theme-primary': !hint && primary,
        'md-text--theme-secondary': !hint && secondary,
        'md-ink--primary': ink && primary,
        'md-ink--secondary': ink && secondary
      });
    }
  } else {
    colors = classnames_default()({
      'md-background': background && !primary && !secondary && !card,
      'md-background--card': card,
      'md-background--primary': primary,
      'md-background--primary-hover': primary && hover,
      'md-background--secondary': secondary,
      'md-background--secondary-hover': secondary && hover
    });
  }

  return classnames_default()(colors, className);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/getCollapserStyles.js


/**
 * A simple utility function to get the dynamic collapser styles.
 */
function getCollapserStyles(_ref) {
  var _ref2;

  var flipped = _ref.flipped,
      suffix = _ref.suffix,
      suffixFlipped = _ref.suffixFlipped;

  for (var _len = arguments.length, classNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    classNames[_key - 1] = arguments[_key];
  }

  return classnames_default.a.apply(undefined, ['md-collapser', (_ref2 = {
    'md-collapser--flipped': flipped && (!suffixFlipped || !suffix)
  }, _ref2['md-collapser--' + suffix] = suffix, _ref2['md-collapser--' + suffix + '-flipped'] = suffix && flipped && suffixFlipped, _ref2)].concat(classNames));
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/closest.js
/** @module utils/closest */

/**
 * A _very_ primitive polyfill for the Element.closest function. If this is a browser that doesn't
 * support it (IE, Edge, etc), it will just keep searching the parent elements until the nodeName
 * matches the provided type.
 *
 * @param {Element} el - the html element to find a closest node type for
 * @param {String} type - the html element type to find.
 * @return {Element} the found element or null.
 */
function closest(el, type) {
  if (typeof el.closest === 'function') {
    return el.closest(type);
  }

  var nodeType = type.toUpperCase();
  var node = el.parentElement;
  while (node && node.parentElement) {
    if (node.nodeName === nodeType) {
      return node;
    }

    node = node.parentElement;
  }

  return null;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/isFormPartRole.js
/** @module utils/isFormPartRole */

/**
 * A simple utility function to determine if an element has a role that should
 * be used as a form part. This is mostly used for changing the behavior of keyboard
 * events.
 *
 * A form part role is one of the following:
 * - checkbox
 * - radio
 * - listbox
 * - input
 *
 * @param {HTMLElement} el - the element to check.
 * @return {boolean} true if the element is considered an element part of a form.
 */
function isFormPartRole(el) {
  if (!el) {
    return false;
  } else if (el.nodeName === 'INPUT') {
    return true;
  }

  var role = el.getAttribute('role');
  return role === 'checkbox' || role === 'radio' || role === 'listbox';
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/EventUtils/handleKeyboardAccessibility.js
/** @module utils/EventUtils/handleKeyboardAccessibility */





/**
 * A utility function for adding keyboard accessibility to elements that are not a natively
 * clickable (div, span, etc). When the space or enter key is pressed while focusing the
 * element, different flows will happen.
 *
 * - space - The click event will be triggered and the default page scrolling behavior of the
 *      spacebar will be prevented
 * - enter - If the element has a form role ('checkbox' or 'radio'), the click event will not
 *      be triggered. Instead, it will find out if the element is inside a form. If it is, it
 *      will emulate the default behavior of attempting to submit the form. If the element does
 *      not have a form role, the click event will be triggered.
 *
 * @param {Event} e - the keydown event
 * @param {function} onClick - the on click event to be triggered if space or enter was pressed
 * @param {boolean=true} listenToEnter - boolean if the enter key should be used to trigger the
 *      the click event. Even if this is true, the click event will not be triggered if the role
 *      is for a form role.
 * @param {boolean=true} listenToSpace - boolean if the space key should be used to trigger the
 *      click event.
 * @return {Boolean} true if the enter or space keys were pressed while their listener is also active.
 */
function handleKeyboardAccessibility(e, onClick) {
  var listenToEnter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var listenToSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var key = e.which || e.keyCode;
  var space = listenToSpace && key === SPACE;
  var enter = key === ENTER;

  var tagName = e.target.tagName;
  // it is valid to press space in text fields, contenteditable, and buttons

  if (space && !tagName.match(/input|textarea|button/i) && e.target.getAttribute('contenteditable') !== 'true') {
    // Stop page scrolling
    e.preventDefault();
  }

  if (enter && isFormPartRole(e.target)) {
    var form = closest(e.target, 'form');
    var submit = form ? form.querySelector('*[type="submit"]') : null;
    if (submit) {
      submit.click();
    }

    return true;
  }

  if (enter && listenToEnter || space) {
    onClick(e);

    return true;
  }

  return false;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/AccessibleFakeButton.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








/**
 * The `AccessibleFakeButton` is a generic component that can be used to render
 * a `div` or any other non `button` components as a button. This should not be
 * used often.
 *
 * The `AccessibleFakeButton` allows the user to tab focus the element, use the
 * space or enter key to trigger the `onClick` event, and toggles the `aria-pressed`
 * attribute.
 */

var AccessibleFakeButton_AccessibleFakeButton = function (_PureComponent) {
  _inherits(AccessibleFakeButton, _PureComponent);

  function AccessibleFakeButton() {
    var _temp, _this, _ret;

    _classCallCheck(this, AccessibleFakeButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { pressed: false, tabFocused: false }, _this.focus = function () {
      if (_this._node) {
        _this._node.focus();
      }
    }, _this.blur = function () {
      if (_this._node) {
        _this._node.blur();
      }
    }, _this._setNode = function (node) {
      if (node) {
        _this._node = Object(react_dom["findDOMNode"])(node);
      }
    }, _this._handleClick = function (e) {
      if (_this.props.disabled) {
        return;
      }

      if (_this.props.onClick) {
        _this.props.onClick(e);
      }

      _this._node.focus();
      _this.setState({ pressed: !_this.state.pressed });
    }, _this._handleKeyDown = function (e) {
      var _this$props = _this.props,
          disabled = _this$props.disabled,
          onKeyDown = _this$props.onKeyDown,
          listenToEnter = _this$props.listenToEnter,
          listenToSpace = _this$props.listenToSpace;

      if (disabled) {
        return;
      }

      if (onKeyDown) {
        onKeyDown(e);
      }

      handleKeyboardAccessibility(e, _this._handleClick, listenToEnter, listenToSpace);
    }, _this._handleKeyUp = function (e) {
      var _this$props2 = _this.props,
          onKeyUp = _this$props2.onKeyUp,
          onTabFocus = _this$props2.onTabFocus;

      if (onKeyUp) {
        onKeyUp(e);
      }

      if ((e.which || e.keyCode) === TAB) {
        if (onTabFocus) {
          onTabFocus(e);
        }

        _this.setState({ tabFocused: true });
      }
    }, _this._handleBlur = function (e) {
      if (_this.props.onBlur) {
        _this.props.onBlur(e);
      }

      if (_this.state.tabFocused) {
        _this.setState({ tabFocused: false });
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  /**
   * Focuses the button.
   */


  /**
   * Blurs the button.
   */


  AccessibleFakeButton.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        Component = _props.component,
        children = _props.children,
        className = _props.className,
        tabbedClassName = _props.tabbedClassName,
        disabled = _props.disabled,
        tabIndex = _props.tabIndex,
        ink = _props.ink,
        noFocusOutline = _props.noFocusOutline,
        onBlur = _props.onBlur,
        onClick = _props.onClick,
        onKeyUp = _props.onKeyUp,
        onKeyDown = _props.onKeyDown,
        onTabFocus = _props.onTabFocus,
        listenToEnter = _props.listenToEnter,
        listenToSpace = _props.listenToSpace,
        props = _objectWithoutProperties(_props, ['component', 'children', 'className', 'tabbedClassName', 'disabled', 'tabIndex', 'ink', 'noFocusOutline', 'onBlur', 'onClick', 'onKeyUp', 'onKeyDown', 'onTabFocus', 'listenToEnter', 'listenToSpace']);

    var childElements = children;
    if (ink) {
      childElements = react["Children"].toArray(children);
      childElements.unshift(ink);
    }

    return react_default.a.createElement(
      Component,
      _extends({}, props, {
        ref: this._setNode,
        className: classnames_default()('md-fake-btn', (_cn = {
          'md-pointer--hover': !disabled,
          'md-fake-btn--no-outline': noFocusOutline
        }, _cn[tabbedClassName] = tabbedClassName && this.state.tabFocused, _cn), className),
        disabled: disabled,
        tabIndex: disabled ? null : tabIndex,
        onBlur: this._handleBlur,
        onClick: this._handleClick,
        onKeyUp: this._handleKeyUp,
        onKeyDown: this._handleKeyDown,
        'aria-pressed': this.state.pressed
      }),
      childElements
    );
  };

  return AccessibleFakeButton;
}(react["PureComponent"]);

AccessibleFakeButton_AccessibleFakeButton.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * An optional function to call only when the button has been focused with the tab key.
   */
  tabbedClassName: prop_types_default.a.string,

  /**
   * Any children to display in the Accessible Fake Button.
   */
  children: prop_types_default.a.node,

  /**
   * An optional onClick function to call when the user clicks the
   * button or presses space || enter.
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional onKeyDown function to call.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * An optional onBlur function to call.
   */
  onBlur: prop_types_default.a.func,

  /**
   * An optional onKeyUp function to call.
   */
  onKeyUp: prop_types_default.a.func,

  /**
   * An optional function to call when the element is focused with the tab key.
   */
  onTabFocus: prop_types_default.a.func,

  /**
   * The component to render the Fake button as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * Boolean if the default outline should be removed the when the fake button has been focused.
   *
   * @see {@link #tabbedClassName}
   */
  noFocusOutline: prop_types_default.a.bool,

  /**
   * The tab index to use for the Fake button so it is keyboard focusable.
   */
  tabIndex: prop_types_default.a.number,

  /**
   * Boolean if the Button is disabled. This will prevent tab focus.
   */
  disabled: prop_types_default.a.bool,

  /**
   * The role for the accessible fake button. It is recommended to keep it
   * the default of `button` unless you are rendering it as an `a` tag.
   */
  role: prop_types_default.a.string,

  /**
   * The ink when coming from the AccessibleFakeInkedButton
   * @access private
   */
  ink: prop_types_default.a.node,

  /**
   * Boolean if the spacebar should be used to trigger the click event. This _should_ be `true`
   * is almost all cases.
   */
  listenToSpace: prop_types_default.a.bool,

  /**
   * Boolean if the enter key should be used to trigger the click event. This _should_ be `true`
   * in most cases. By default, the param will be ignored if the `role` attribute is for a `checkbox`
   * or `radio`. When it is a checkbox or radio, it will attempt to submit the form on the enter
   * keypress instead like the native elements.
   */
  listenToEnter: prop_types_default.a.bool
};
AccessibleFakeButton_AccessibleFakeButton.defaultProps = {
  component: 'div',
  tabIndex: 0,
  role: 'button',
  noFocusOutline: true,
  listenToEnter: true,
  listenToSpace: true
};
/* harmony default export */ var Helpers_AccessibleFakeButton = (AccessibleFakeButton_AccessibleFakeButton);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/StringUtils/getDisplayName.js
/** @module utils/StringUtils/getDisplayName */

/**
 * Gets the display name for a composed component.
 *
 * @param {function|Object} ComposedComponent - The composed component to use
 * @param {String} hoc - The higher order component's name to use.
 * @return {String} the new name of the component.
 */
function getDisplayName(ComposedComponent, hoc) {
  var name = '' + (ComposedComponent.displayName || ComposedComponent.name || 'Component');

  return 'with' + hoc + '(' + name + ')';
}
// EXTERNAL MODULE: ../node_modules/react-md/node_modules/react-transition-group/TransitionGroup.js
var TransitionGroup = __webpack_require__("kFlJ");
var TransitionGroup_default = /*#__PURE__*/__webpack_require__.n(TransitionGroup);

// CONCATENATED MODULE: ../node_modules/react-md/es/utils/Positioning/getPagePosition.js
/** @module utils/Positioning/getPagePosition */

/**
 * Gets the current page position.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY
 * @param {String} direction - The direction that should be retrieved. This
 *    should be either 'x' or 'y'.
 * @return {number} the position of the direction on the page.
 */
function getPagePosition(direction) {
  var scroll = 'scroll' + (direction === 'x' ? 'Left' : 'Top');
  if (typeof window.pageXOffset !== 'undefined') {
    return window['page' + direction.toUpperCase() + 'Offset'];
  } else if ((document.compatMode || '') === 'CSS1Compat') {
    return document.documentElement[scroll];
  } else {
    return document.body[scroll];
  }
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/Positioning/calcPageOffset.js
/** @module utils/Positioning/calcPageOffset */


/**
 * Calculates the page offset of an element. If the element
 * is false-ish, an empty object will be returned.
 *
 * This is really only used for calculating an ink position.
 *
 * @param {Node} el - An html node to find a page offset for.
 * @return {Object} an object with a left and top attribute for the page
 *    offset.
 */
function calcPageOffset(el) {
  if (!el) {
    return { left: null, right: null };
  }

  var rect = el.getBoundingClientRect();
  return {
    left: rect.left + getPagePosition('x'),
    top: rect.top + getPagePosition('y')
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/EventUtils/isValidClick.js
/** @module utils/EventUtils/isValidClick */


/**
 * Checks if an event is a valid click event by ignoring
 * any clisk that are not the left mouse button and not
 * clicks that involve the shift key.
 *
 * @param {Object} e - the event to check
 * @return {Boolean} true if the event is valid.
 */
function isValidClick(e) {
  return e.button === LEFT_MOUSE && !e.shiftKey;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/EventUtils/touches.js
var touches_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
var supportsPassive = void 0;
try {
  var opts = Object.defineProperty({}, 'passive', {
    get: function get() {
      supportsPassive = true;
    }
  });
  window.addEventListener('test', null, opts);
} catch (e) {
  supportsPassive = false;
}

/**
 * A helper function for manually setting touch events on elements with the passive
 * option (when it is supported).
 *
 * @param {boolean} add - Boolean if the event listener should be added or removed.
 * @param {HTMLElement} el - The element to add the listener to.
 * @param {String} type - the event type to set. This should be 'start', 'move', or 'end'
 * @param {function} callback - The event listener callback function.
 * @param {Object=} options - any additional options to apply.
 */
function setTouchEvent(add, el, eventType, callback, options) {
  return el[(add ? 'add' : 'remove') + 'EventListener']('touch' + eventType, callback, supportsPassive ? touches_extends({ passive: true }, options) : false);
}

/**
 * A helper function for manually adding touch events on elements with the passive
 * option (when it is supported).
 *
 * @param {HTMLElement} el - The element to add the listener to.
 * @param {String} type - the event type to set. This should be 'start', 'move', or 'end'
 * @param {function} callback - The event listener callback function.
 * @param {Object=} options - any additional options to apply.
 */
function addTouchEvent(el, type, callback, options) {
  return setTouchEvent(true, el, type, callback, options);
}

/**
 * A helper function for manually removing touch events on elements with the passive
 * option (when it is supported).
 *
 * @param {HTMLElement} el - The element to add the listener to.
 * @param {String} type - the event type to set. This should be 'start', 'move', or 'end'
 * @param {function} callback - The event listener callback function.
 * @param {Object=} options - any additional options to apply.
 */
function removeTouchEvent(el, type, callback, options) {
  return setTouchEvent(false, el, type, callback, options);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/EventUtils/captureNextEvent.js
/** @module utils/EventUtils/captureNextEvent */

/**
 * This function will capture the next event and stop propagation during the
 * bubbling cycle of events. This is really only useful if you want to stop
 * the default behavior of chained events.
 *
 * @param {String} type - The event type to capture.
 * @param {Object|func=} target - Either the DOM node to target, a callback function
 *      to call once the event has been captured, or undefined. If this is undefined,
 *      the event will be captured on the window.
 * @param {func=} callback - An optional callback function to call once the event
 *      has been captured.
 */
function captureNextEvent(type, target, callback) {
  var el = typeof target !== 'function' && target ? target : window;
  var cb = typeof target === 'function' ? target : callback;

  var capture = function capture(e) {
    e.stopPropagation();
    if (cb) {
      cb(e);
    }

    el.removeEventListener(type, capture, true);
  };

  el.addEventListener(type, capture, true);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/NumberUtils/calculateHypotenuse.js
/** @module utils/NumberUtils/calculateHypotenuse */

/**
 * Calculates the hypotenuse using the x and y coordinates given.
 *
 * @param {number} a the x coordinate
 * @param {number} b the y coordinate
 * @return {number} the hypotenuse length for the given x and y coordinates.
 */
function calculateHypotenuse(a, b) {
  return Math.sqrt(a * a + b * b);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/constants/CSSTransitionGroupTick.js
// This will need to keep in sync with the `ReactCSSTransitionGroupChild` `TICK` const.
// https://github.com/facebook/react/blob/master/src/addons/transitions/ReactCSSTransitionGroupChild.js#L22

/* harmony default export */ var CSSTransitionGroupTick = (17);
// CONCATENATED MODULE: ../node_modules/react-md/es/Inks/Ink.js
function Ink_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Ink_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Ink_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var Ink_Ink = function (_PureComponent) {
  Ink_inherits(Ink, _PureComponent);

  function Ink(props) {
    Ink_classCallCheck(this, Ink);

    var _this = Ink_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = {
      active: false,
      expanded: false,
      pulsing: false,
      leaving: false
    };
    return _this;
  }

  Ink.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (!this.props.aborted && nextProps.aborted) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }

      if (this._abort) {
        this._abort();
      }

      this.setState({ active: false, expanding: false, pulsing: false, leaving: false });
    }
  };

  Ink.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  Ink.prototype.componentWillEnter = function componentWillEnter(cb) {
    var _this2 = this;

    if (this.props.aborted) {
      cb();
      return;
    }

    var _props = this.props,
        transitionOverlap = _props.transitionOverlap,
        transitionEnterTimeout = _props.transitionEnterTimeout;

    this._abort = cb;

    this._timeout = setTimeout(function () {
      _this2._timeout = setTimeout(function () {
        _this2._timeout = null;
        _this2._abort = null;

        cb();
      }, transitionEnterTimeout - transitionOverlap);

      _this2.setState({ expanded: true });
    }, CSSTransitionGroupTick);

    this.setState({ active: true });
  };

  Ink.prototype.componentDidEnter = function componentDidEnter() {
    var _this3 = this;

    if (this.props.pulse) {
      this._timeout = setTimeout(function () {
        _this3._timeout = null;

        _this3.setState({ pulsing: true });
      }, this.props.transitionEnterTimeout);
    }
  };

  Ink.prototype.componentWillLeave = function componentWillLeave(cb) {
    var _this4 = this;

    if (this.props.aborted) {
      cb();
      return;
    }

    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    this._abort = cb;
    this._timeout = setTimeout(function () {
      _this4._timeout = null;

      cb();
    }, this.props.transitionLeaveTimeout);

    this.setState({ pulsing: false, leaving: true });
  };

  Ink.prototype.componentDidLeave = function componentDidLeave() {
    if (!this.props.aborted && this.props.onRemove) {
      this.props.onRemove();
    }
  };

  Ink.prototype.render = function render() {
    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        left = _props2.left,
        top = _props2.top,
        size = _props2.size;
    var _state = this.state,
        active = _state.active,
        expanded = _state.expanded,
        pulsing = _state.pulsing,
        leaving = _state.leaving;


    return react_default.a.createElement('span', {
      style: Object.assign({}, style, {
        left: left,
        top: top,
        height: size,
        width: size
      }),
      className: classnames_default()('md-ink', {
        'md-ink--active': active,
        'md-ink--expanded': expanded,
        'md-ink--pulsing': pulsing,
        'md-ink--leaving': leaving
      }, className)
    });
  };

  return Ink;
}(react["PureComponent"]);

Ink_Ink.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  aborted: prop_types_default.a.bool,
  onRemove: prop_types_default.a.func,
  left: prop_types_default.a.number.isRequired,
  top: prop_types_default.a.number.isRequired,
  size: prop_types_default.a.number.isRequired,
  transitionOverlap: prop_types_default.a.number.isRequired,
  transitionEnterTimeout: prop_types_default.a.number.isRequired,
  transitionLeaveTimeout: prop_types_default.a.number.isRequired,
  pulse: prop_types_default.a.bool
};
/* harmony default export */ var Inks_Ink = (Ink_Ink);
// CONCATENATED MODULE: ../node_modules/react-md/es/Inks/InkContainer.js
var InkContainer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function InkContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function InkContainer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function InkContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

















/**
 * The `InkContainer` is used for holding the list of inks that get created by touch,
 * click, or keyboard focus.
 *
 * If the container element has the `type="submit"` attribute, the ink will also be
 * triggered when the user presses enter anywhere in the form.
 */

var InkContainer_InkContainer = function (_PureComponent) {
  InkContainer_inherits(InkContainer, _PureComponent);

  function InkContainer() {
    var _temp, _this, _ret;

    InkContainer_classCallCheck(this, InkContainer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = InkContainer_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { inks: [] }, _this.createInk = function (pageX, pageY) {
      _this._createInk(pageX, pageY);
      _this._removeTimeout = setTimeout(function () {
        _this._removeTimeout = null;
        _this._removeInk();
      }, _this.props.transitionOverlap);
    }, _this.focus = function () {
      _this._getKeyboardContainer().focus();
    }, _this._createInk = function (pageX, pageY) {
      var _this$_inkContainer = _this._inkContainer,
          offsetWidth = _this$_inkContainer.offsetWidth,
          offsetHeight = _this$_inkContainer.offsetHeight;


      var x = void 0;
      var y = void 0;
      if (typeof pageX !== 'undefined' && typeof pageY !== 'undefined') {
        var pageOffset = calcPageOffset(_this._inkContainer);

        x = pageX - pageOffset.left;
        y = pageY - pageOffset.top;
      } else {
        x = offsetWidth / 2;
        y = offsetHeight / 2;
      }

      var r = Math.max(calculateHypotenuse(x, y), calculateHypotenuse(offsetWidth - x, y), calculateHypotenuse(offsetWidth - x, offsetHeight - y), calculateHypotenuse(x, offsetHeight - y));

      var ink = {
        left: x - r,
        top: y - r,
        size: r * 2,
        key: Date.now()
      };

      var inks = _this.state.inks.slice();
      inks.push(ink);
      _this.setState({ inks: inks });
    }, _this._removeInk = function () {
      var inks = _this.state.inks.slice();
      inks.pop();

      _this.setState({ inks: inks });
    }, _this._getKeyboardContainer = function () {
      if (_this._container.classList.contains('md-text-field-container')) {
        return _this._container.querySelector('.md-text-field');
      }

      return _this._container;
    }, _this._setContainers = function (group) {
      if (group !== null) {
        _this._inkContainer = Object(react_dom["findDOMNode"])(group);
        _this._container = _this._inkContainer.parentElement;

        if (_this._container) {
          _this._initOrRemoveEvents(_this.props);
        }
      }
    }, _this._initOrRemoveEvents = function (props) {
      var keyboardDiff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var mouseDiff = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var touchDiff = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      var mouseDisabled = _this._isListenerDisabled('mouse', props.disabledInteractions);
      var touchDisabled = _this._isListenerDisabled('touch', props.disabledInteractions);
      var keyboardDisabled = _this._isListenerDisabled('keyboard', props.disabledInteractions);

      if (keyboardDiff) {
        var fn = (keyboardDisabled ? 'remove' : 'add') + 'EventListener';
        _this._getKeyboardContainer()[fn]('focus', _this._handleFocus);
        _this._getKeyboardContainer()[fn]('keydown', _this._handleKeyDown);

        if (_this._container.getAttribute('type') === 'submit') {
          window[fn]('submit', _this._handleSubmit);
        }

        if (mouseDiff) {
          _this._container[(!mouseDisabled ? 'add' : 'remove') + 'EventListener']('mousedown', _this._stopPropagationToFocus);
        }

        if (touchDiff) {
          setTouchEvent(!touchDisabled, _this._container, 'start', _this._stopPropagationToFocus);
        }
      }

      if (mouseDiff) {
        var _fn = (mouseDisabled ? 'remove' : 'add') + 'EventListener';
        _this._container[_fn]('mousedown', _this._handleMouseDown);
        _this._container[_fn]('mouseup', _this._handleMouseUp);
      }

      if (touchDiff) {
        setTouchEvent(!touchDisabled, _this._container, 'start', _this._handleTouchStart);
        setTouchEvent(!touchDisabled, _this._container, 'end', _this._handleTouchEnd);
      }
    }, _this._maybeDelayClick = function () {
      if (!_this.props.waitForInkTransition) {
        return;
      }

      captureNextEvent('click', _this._container);
    }, _this._handleRemove = function () {
      if (_this._clicked && _this.props.waitForInkTransition) {
        // For some reason if the click event will make the ink unmount, it will no longer
        // have a debug id in the TransitionGroup and it displays a warning. Adding a 1ms timeout
        // fixes that issue... It only happens on an actual click instead of an enter click.
        setTimeout(function () {
          _this._container.click();
        }, 1);
      }

      _this._clicked = false;
    }, _this._handleKeyDown = function (e) {
      var key = e.which || e.keyCode;
      var enter = key === ENTER;
      var space = key === SPACE;
      // Don't trigger ink when enter key is pressed and the target has an input inside of it (SelectField)
      if (space || enter && !isFormPartRole(e.target) && !e.target.querySelector('input')) {
        _this._clicked = true;
        _this.createInk();
        _this._maybeDelayClick();
      }
    }, _this._handleFocus = function () {
      if (_this._clicked) {
        return;
      }

      _this._createInk();
      _this._getKeyboardContainer().addEventListener('blur', _this._handleBlur);
    }, _this._handleBlur = function () {
      _this._getKeyboardContainer().removeEventListener('blur', _this._handleBlur);
      _this._removeInk();
    }, _this._handleMouseDown = function (e) {
      _this._clicked = true;
      if (!isValidClick(e) || _this._skipNextMouse) {
        _this._skipNextMouse = false;
        return;
      }

      _this._mouseLeave = false;
      _this._container.addEventListener('mouseleave', _this._handleMouseLeave);
      _this._createInk(e.pageX, e.pageY);
    }, _this._handleMouseLeave = function () {
      _this._container.removeEventListener('mouseleave', _this._handleMouseLeave);
      _this._mouseLeave = true;
      _this._removeInk();
    }, _this._handleMouseUp = function () {
      if (_this._mouseLeave) {
        return;
      }

      _this._maybeDelayClick();
      _this._container.removeEventListener('mouseleave', _this._handleMouseLeave);
      _this._removeInk();
    }, _this._handleTouchStart = function (e) {
      _this._aborted = false;
      _this._clicked = true;
      _this._skipNextMouse = true;
      addTouchEvent(window, 'move', _this._handleTouchMove);

      var _e$changedTouches$ = e.changedTouches[0],
          pageX = _e$changedTouches$.pageX,
          pageY = _e$changedTouches$.pageY;

      _this._createInk(pageX, pageY);
    }, _this._handleTouchMove = function () {
      removeTouchEvent(window, 'move', _this._handleTouchMove);
      var lastInk = _this.state.inks[_this.state.inks.length - 1];
      if (!lastInk || Date.now() > lastInk.key + 200) {
        _this._aborted = false;
        return;
      }

      var inks = _this.state.inks.slice();
      var index = inks.length - 1;

      var abortedInk = Object.assign({}, lastInk, { aborted: true });
      inks.splice(index, 1, abortedInk);

      _this._aborted = true;
      _this.setState({ inks: inks }, _this._removeInk);
    }, _this._handleTouchEnd = function () {
      _this._skipNextMouse = true;

      if (_this._aborted) {
        return;
      } else {
        removeTouchEvent(window, 'move', _this._handleTouchMove);
      }

      _this._removeInk();
    }, _this._handleSubmit = function (e) {
      if (document.activeElement === _this._container || !e.target.contains(_this._container)) {
        return;
      }

      _this._maybeDelayClick();
      _this.createInk();
    }, _this._stopPropagationToFocus = function (e) {
      switch (e.type) {
        case 'touchstart':
          addTouchEvent(window, 'end', _this._stopPropagationToFocus, { capture: true });
          break;
        case 'touchend':
          removeTouchEvent(window, 'end', _this._stopPropagationToFocus, { capture: true });
          break;
        case 'mousedown':
          window.addEventListener('mouseup', _this._stopPropagationToFocus, true);
          break;
        case 'mouseup':
          window.removeEventListener('mouseup', _this._stopPropagationToFocus, true);
          break;
        default:
      }
    }, _temp), InkContainer_possibleConstructorReturn(_this, _ret);
  }

  InkContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var di = this.props.disabledInteractions;
    var ndi = nextProps.disabledInteractions;

    if (di === ndi || !this._container) {
      return;
    }

    var mouseDisabledDiff = this._isListenerDisabledDiff('mouse', di, ndi);
    var touchDisabledDiff = this._isListenerDisabledDiff('touch', di, ndi);
    var keyboardDisabledDiff = this._isListenerDisabledDiff('keyboard', di, ndi);
    this._initOrRemoveEvents(nextProps, keyboardDisabledDiff, mouseDisabledDiff, touchDisabledDiff);
  };

  InkContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._removeTimeout) {
      clearTimeout(this._removeTimeout);
    }

    if (this._container) {
      this._initOrRemoveEvents({ disabledInteractions: ['keyboard', 'mouse', 'touch'] });
      this._getKeyboardContainer().removeEventListener('blur', this._handleBlur);
    }
  };

  /**
   * Creates an ink from pageX and pageY coordinates. These values should either come
   * from the `changedTouches` or just the base event (if clicked). These coordinates
   * are used to position the ink correctly in the container from touch/click point.
   * If either value is undefined, an ink will be created from the center of the
   * container.
   *
   * It will also automatically remove the ink.
   *
   * @param {number} pageX - The page x coordinate of the click or touch event.
   * @param {number} pageY - The page y coordinate of the click or touch event.
   */


  /**
   * Focuses the main element.
   */


  InkContainer.prototype._isListenerDisabledDiff = function _isListenerDisabledDiff(interaction, disabledInteractions, nextDisabledInteractions) {
    var i = disabledInteractions.indexOf(interaction);
    var ni = nextDisabledInteractions.indexOf(interaction);

    return i < 0 && ni >= 0 || i >= 0 && ni < 0;
  };

  InkContainer.prototype._isListenerDisabled = function _isListenerDisabled(interaction, disabledInteractions) {
    return disabledInteractions && disabledInteractions.indexOf(interaction) !== -1;
  };

  /**
   * Creates an ink from pageX and pageY coordinates. These values should either come
   * from the `changedTouches` or just the base event (if clicked). These coordinates
   * are used to position the ink correctly in the container from touch/click point.
   * If either value is undefined, an ink will be created from the center of the
   * container.
   *
   * @param {number} pageX - The page x coordinate of the click or touch event.
   * @param {number} pageY - The page y coordinate of the click or touch event.
   */


  /**
   * Removes an ink from the container.
   */


  /**
   * Gets the container for any keyboard events. This will almost always be the main element,
   * but text fields will need to be the input itself.
   */


  /**
   * Sets the ink container and the main container from the ref callback. When the component
   * is mounting, the keyboard, mouse, and keyboard events will be initialized.
   */


  /**
   * This function will either add or remove the event listeners for creating inks.
   *
   * @param {Object} props - The current props to use for figuring out if the events should
   *    be added or removed.
   * @param {bool=} keyboardDiff - Boolean if there was a difference between the current props and either
   *    the previous or next props for the keyboard interactions being disabled.
   * @param {bool=} mouseDiff - Boolean if there was a difference between the current props and either
   *    the previous or next props for the mouse interactions being disabled.
   * @param {bool=} touchDiff - Boolean if there was a difference between the current props and either
   *    the previous or next props for the touch interactions being disabled.
   */


  /**
   * If a form was submitted that contains the container of the ink and the current focus element
   * is not the container, trigger an ink effect.
   *
   * The current focus check is added so that two inks are not created.
   */


  InkContainer.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        style = _props.style,
        className = _props.className,
        inkStyle = _props.inkStyle,
        inkClassName = _props.inkClassName,
        transitionOverlap = _props.transitionOverlap,
        transitionEnterTimeout = _props.transitionEnterTimeout,
        transitionLeaveTimeout = _props.transitionLeaveTimeout,
        pulse = _props.pulse;

    var inks = this.state.inks.map(function (props) {
      return react_default.a.createElement(Inks_Ink, InkContainer_extends({}, props, {
        pulse: pulse,
        style: inkStyle,
        className: inkClassName,
        onRemove: _this2._handleRemove,
        transitionOverlap: transitionOverlap,
        transitionEnterTimeout: transitionEnterTimeout,
        transitionLeaveTimeout: transitionLeaveTimeout
      }));
    });

    return react_default.a.createElement(
      TransitionGroup_default.a,
      {
        component: 'div',
        style: style,
        className: classnames_default()('md-ink-container', className),
        ref: this._setContainers
      },
      inks
    );
  };

  return InkContainer;
}(react["PureComponent"]);

InkContainer_InkContainer.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  inkStyle: prop_types_default.a.object,
  inkClassName: prop_types_default.a.string,
  waitForInkTransition: prop_types_default.a.bool,
  disabledInteractions: prop_types_default.a.arrayOf(prop_types_default.a.oneOf(['keyboard', 'mouse', 'touch'])),
  transitionOverlap: prop_types_default.a.number.isRequired,
  transitionEnterTimeout: prop_types_default.a.number.isRequired,
  transitionLeaveTimeout: prop_types_default.a.number.isRequired,
  pulse: prop_types_default.a.bool
};
InkContainer_InkContainer.defaultProps = {
  transitionOverlap: 150,
  transitionEnterTimeout: 450,
  transitionLeaveTimeout: 300
};
/* harmony default export */ var Inks_InkContainer = (InkContainer_InkContainer);
// CONCATENATED MODULE: ../node_modules/react-md/es/Inks/inkContextTypes.js


/* harmony default export */ var inkContextTypes = ({
  inkDisabled: prop_types_default.a.bool,
  inkDisabledInteractions: prop_types_default.a.arrayOf(prop_types_default.a.oneOf(['keyboard', 'mouse', 'touch']))
});
// CONCATENATED MODULE: ../node_modules/react-md/es/Inks/injectInk.js
function injectInk_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function injectInk_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function injectInk_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function injectInk_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











/**
 * Takes any component and injects an ink container for having the Material Design Ink effect.
 *
 * The default triggers for an ink are:
 * - mouse down event
 * - touch start event
 * - keyboard focus
 * - form submit
 *
 * The form submit ink will only be triggered if the `ComposedComponent` has the attribute
 * `type="submit"`, the `ComposedComponent` is in a form, and the user hits the `enter` key
 * while not actively focusing the `ComposedComponent`.
 *
 * ```js
 * @param {function} ComposedComponent - The React Component to inject an `ink` prop into.
 * @return {function} a new React class rendering the `ComposedComponent` and adding an
 *    `ink` pop.
 * ```
 */
/* harmony default export */ var injectInk = (function (ComposedComponent) {
  var _class, _temp2;

  return _temp2 = _class = function (_PureComponent) {
    injectInk_inherits(InkedComponent, _PureComponent);

    function InkedComponent() {
      var _temp, _this, _ret;

      injectInk_classCallCheck(this, InkedComponent);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = injectInk_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.createInk = function (pageX, pageY) {
        if (_this._inkContainer && !_this.props.disabled && !_this.props.inkDisabled) {
          _this._inkContainer.createInk(pageX, pageY);
        }
      }, _this.focus = function () {
        if (_this.props.inkDisabled) {
          var composed = Object(react_dom["findDOMNode"])(_this._composed);
          if (composed) {
            composed.focus();
          }
        } else if (_this._inkContainer) {
          _this._inkContainer.focus();
        }
      }, _this.getComposedComponent = function () {
        return _this._composed;
      }, _this._setInkRef = function (inkContainer) {
        if (inkContainer) {
          _this._inkContainer = inkContainer;
        }
      }, _this._setComposedComponent = function (component) {
        _this._composed = component;
      }, _temp), injectInk_possibleConstructorReturn(_this, _ret);
    }

    InkedComponent.prototype.componentDidMount = function componentDidMount() {
      var ref = this.props.__SUPER_SECRET_REF__;
      // Emulate the ref callback...

      if (ref) {
        ref(this);
      }
    };

    InkedComponent.prototype.componentWillUnmount = function componentWillUnmount() {
      var ref = this.props.__SUPER_SECRET_REF__;
      // Emulate the ref callback...

      if (ref) {
        ref(null);
      }
    };

    /**
     * A publicly accessible way to manually create an ink. This can be used with the `refs`.
     * The ink can either be created by using the `pageX` and `pageY` from a click/touch event
     * or it will be created in the center of the `ComposedComponent`.
     *
     * ```js
     * <SomeInkedComponent ref={inkHOC => inkHOC.createInk()} />
     * ```
     *
     * @param {number=} pageX - An optional pageX of the click or touch event.
     * @param {number=} pageY - An optional pageY of the click or touch event.
     */


    /**
     * This will attempt to focus the composed component. If the component is disabled, nothing
     * will happen. If the `disabled` and `inkDisabled` props are not set to `true`, an ink will
     * also be created.
     *
     * ```js
     * <SomeInkedComponent ref={inkHOC => inkHOC.focus()} />
     * ```
     */


    /**
     * Gets the composed component as a ref. This is useful if you need to access the ref of the
     * composed component instead of the `injectInk` HOC to use some publicly accessible methods.
     *
     * ```js
     * <SomeInkedComponent
     *   ref={inkHOC => {
     *     inkHOC.getComposedComponent().focus();
     *   }}
     * />
     * ```
     */


    InkedComponent.prototype.render = function render() {
      var _props = this.props,
          transitionOverlap = _props.inkTransitionOverlap,
          transitionEnterTimeout = _props.inkTransitionEnterTimeout,
          transitionLeaveTimeout = _props.inkTransitionLeaveTimeout,
          inkStyle = _props.inkStyle,
          inkClassName = _props.inkClassName,
          inkContainerStyle = _props.inkContainerStyle,
          inkContainerClassName = _props.inkContainerClassName,
          waitForInkTransition = _props.waitForInkTransition,
          disabledInteractions = _props.disabledInteractions,
          pulse = _props.pulse,
          propInkDisabled = _props.inkDisabled,
          __SUPER_SECRET_REF__ = _props.__SUPER_SECRET_REF__,
          props = injectInk_objectWithoutProperties(_props, ['inkTransitionOverlap', 'inkTransitionEnterTimeout', 'inkTransitionLeaveTimeout', 'inkStyle', 'inkClassName', 'inkContainerStyle', 'inkContainerClassName', 'waitForInkTransition', 'disabledInteractions', 'pulse', 'inkDisabled', '__SUPER_SECRET_REF__']);

      var inkDisabled = getField(this.props, this.context, 'inkDisabled');
      var inkDisabledInteractions = typeof disabledInteractions !== 'undefined' ? disabledInteractions : this.context.inkDisabledInteractions;

      if (!(props.disabled || inkDisabled)) {
        props.ink = react_default.a.createElement(Inks_InkContainer, {
          ref: this._setInkRef,
          key: 'ink-container',
          pulse: pulse,
          style: inkContainerStyle,
          className: inkContainerClassName,
          inkStyle: inkStyle,
          inkClassName: inkClassName,
          disabledInteractions: inkDisabledInteractions,
          transitionOverlap: transitionOverlap,
          transitionEnterTimeout: transitionEnterTimeout,
          transitionLeaveTimeout: transitionLeaveTimeout,
          waitForInkTransition: waitForInkTransition
        });
      }

      props.ref = this._setComposedComponent;

      return react_default.a.createElement(ComposedComponent, props);
    };

    return InkedComponent;
  }(react["PureComponent"]), _class.displayName = getDisplayName(ComposedComponent, 'Ink'), _class.propTypes = {
    /**
     * An optional style to apply to each ink that gets generated.
     */
    inkStyle: prop_types_default.a.object,

    /**
     * An optional className to apply to each ink that gets generated.
     */
    inkClassName: prop_types_default.a.string,

    /**
     * An optional style to apply to the ink's container.
     */
    inkContainerStyle: prop_types_default.a.object,

    /**
     * An optional className to apply to the ink's container.
     */
    inkContainerClassName: prop_types_default.a.string,

    /**
     * Boolean if the composed component or the ink is disabled.
     */
    disabled: prop_types_default.a.bool,

    /**
     * Boolean if only the ink is disabled for the composed component.
     */
    inkDisabled: prop_types_default.a.bool,

    /**
     * The time (in ms) that the enter and leave transitions for the ink should overlap.
     * This really just allows for a more _fluid_ looking ink when something is quickly
     * touched or clicked by having it fade out while growing.
     */
    inkTransitionOverlap: prop_types_default.a.number.isRequired,

    /**
     * The transition time for the ink to be considered fully entered. This should really
     * map up to whatever value you set for `$md-ink-enter-transition-time`.
     */
    inkTransitionEnterTimeout: prop_types_default.a.number.isRequired,

    /**
     * The transition time for the ink to be considered fully leaved (left?). This should really
     * map up to whatever value you set for `$md-ink-leave-transition-time`.
     */
    inkTransitionLeaveTimeout: prop_types_default.a.number.isRequired,

    /**
     * Boolean if the `ComposedComponent`'s click event only after the ink has finished transitioning
     * in and out. This is really only to get a more _fluid_ looking click event when clicking on
     * the `ComposedComponent` ends up taking it out of the view. (ex: Closing a Dialog).
     */
    waitForInkTransition: prop_types_default.a.bool,

    /**
     * An optional array of interactions that can be disabled for the ink. This is a *very* limited
     * use case where `Switches` needed the ink disabled only when using a mouse.
     */
    disabledInteractions: prop_types_default.a.arrayOf(prop_types_default.a.oneOf(['keyboard', 'mouse', 'touch'])),

    /**
     * Boolean if the ink should do a pulse animation while focused. This was enabled by default in
     * previous versions.
     */
    pulse: prop_types_default.a.bool,

    /**
     * When using inked components in a `TransitionGroup`, the ref callback is not actually invoked.
     * This is a little _hack_ to get it to work by not using `ref`, but this name.
     */
    __SUPER_SECRET_REF__: prop_types_default.a.func
  }, _class.defaultProps = {
    inkTransitionOverlap: 150,
    inkTransitionEnterTimeout: 450,
    inkTransitionLeaveTimeout: 300
  }, _class.contextTypes = inkContextTypes, _temp2;
});
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/AccessibleFakeInkedButton.js



/* harmony default export */ var AccessibleFakeInkedButton = (injectInk(Helpers_AccessibleFakeButton));
// EXTERNAL MODULE: ../node_modules/react-motion/lib/react-motion.js
var react_motion = __webpack_require__("wMFK");

// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/Collapse.js
var Collapse_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Collapse_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Collapse_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Collapse_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The `Collapse` component is used to animate a single child entering
 * or leaving. This uses the `react-motion` library to animate the height,
 * padding-top, and padding-bottom of an element when the `collapsed` prop
 * changes.
 */

var Collapse_Collapse = function (_PureComponent) {
  Collapse_inherits(Collapse, _PureComponent);

  function Collapse(props) {
    Collapse_classCallCheck(this, Collapse);

    var _this = Collapse_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setHeight = function (child) {
      if (_this._child && typeof _this._child.ref === 'function') {
        _this._child.ref(child);
      }

      var height = 0;
      var paddingTop = 0;
      var paddingBottom = 0;
      if (child !== null) {
        var node = Object(react_dom["findDOMNode"])(child);
        var cs = window.getComputedStyle(node);
        height = node.offsetHeight;
        paddingTop = parseInt(cs.getPropertyValue('padding-top'), 10);
        paddingBottom = parseInt(cs.getPropertyValue('padding-bottom'), 10);
      }

      height = Math.max(_this.props.minHeight, height);

      _this.setState({ height: height, paddingTop: paddingTop, paddingBottom: paddingBottom });
    };

    if (!props.collapsed) {
      _this.state = { initialOpen: true };
    } else {
      _this.state = {
        height: props.minHeight,
        paddingTop: 0,
        paddingBottom: 0
      };
    }
    return _this;
  }

  Collapse.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.state.initialOpen && nextProps.collapsed) {
      this.setState({ initialOpen: false });
    }
  };

  Collapse.prototype._spring = function _spring(collapsed, initialOpen, value, config) {
    var min = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    var nextValue = !collapsed ? Math.max(min, value) : min;
    if (initialOpen && !collapsed) {
      return nextValue;
    }

    return Object(react_motion["spring"])(nextValue, config);
  };

  Collapse.prototype.render = function render() {
    var _this2 = this;

    var _state = this.state,
        height = _state.height,
        paddingTop = _state.paddingTop,
        paddingBottom = _state.paddingBottom,
        initialOpen = _state.initialOpen;
    var _props = this.props,
        children = _props.children,
        collapsed = _props.collapsed,
        defaultStyle = _props.defaultStyle,
        motionStyle = _props.style,
        springConfig = _props.springConfig,
        animate = _props.animate,
        minHeight = _props.minHeight;


    if (!animate) {
      return collapsed ? null : children;
    }

    return react_default.a.createElement(
      react_motion["Motion"],
      {
        style: Collapse_extends({}, motionStyle, {
          height: this._spring(collapsed, initialOpen, height, springConfig, minHeight),
          paddingTop: this._spring(collapsed, initialOpen, paddingTop, springConfig),
          paddingBottom: this._spring(collapsed, initialOpen, paddingBottom, springConfig)
        }),
        defaultStyle: Collapse_extends({}, defaultStyle, {
          height: height,
          paddingTop: paddingTop,
          paddingBottom: paddingBottom
        })
      },
      function (style) {
        if (collapsed && !style.height) {
          return null;
        }

        var child = react["Children"].only(children);
        _this2._child = child;
        var nextStyle = child.props.style;
        if (collapsed && (!minHeight || style.height !== minHeight) || style.height !== height) {
          nextStyle = Collapse_extends({}, child.props.style, style, {
            overflow: 'hidden'
          });
        }
        return Object(react["cloneElement"])(child, {
          ref: !collapsed ? _this2._setHeight : null,
          style: nextStyle
        });
      }
    );
  };

  return Collapse;
}(react["PureComponent"]);

Collapse_Collapse.propTypes = {
  /**
   * An optional style to merge with the `Motion` style.
   */
  style: prop_types_default.a.object,

  /**
   * An optional default style to merge with the `Motion` default style.
   */
  defaultStyle: prop_types_default.a.object,

  /**
   * Boolean if the children are currently collapsed.
   */
  collapsed: prop_types_default.a.bool.isRequired,

  /**
   * A single child to collapse or expand.
   */
  children: prop_types_default.a.element.isRequired,

  /**
   * The spring config to use for the animation.
   */
  springConfig: prop_types_default.a.object.isRequired,

  /**
   * Boolean if the single child entering or leaving should be animated.
   */
  animate: prop_types_default.a.bool,

  /**
   * The min height to apply for the collapse div.
   */
  minHeight: prop_types_default.a.number.isRequired
};
Collapse_Collapse.defaultProps = {
  animate: true,
  springConfig: {
    precision: 0.5
  },
  minHeight: 0
};
/* harmony default export */ var Helpers_Collapse = (Collapse_Collapse);
// CONCATENATED MODULE: ../node_modules/react-md/es/Dividers/Divider.js
var Divider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Divider_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Divider_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Divider_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Divider_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The divider component will pass all other props such as style or
 * event listeners on to the component.
 */

var Divider_Divider = function (_PureComponent) {
  Divider_inherits(Divider, _PureComponent);

  function Divider() {
    Divider_classCallCheck(this, Divider);

    return Divider_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Divider.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        inset = _props.inset,
        vertical = _props.vertical,
        props = Divider_objectWithoutProperties(_props, ['className', 'inset', 'vertical']);

    var Component = vertical ? 'div' : 'hr';

    return react_default.a.createElement(Component, Divider_extends({}, props, {
      className: classnames_default()('md-divider', {
        'md-divider--vertical': vertical,
        'md-divider--inset': inset
      }, className)
    }));
  };

  return Divider;
}(react["PureComponent"]);

Divider_Divider.propTypes = {
  /*
   * An optional style to apply to the divider.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the divider.
   */
  className: prop_types_default.a.string,

  /**
   * Boolean if this divider should be inset relative to it's container
   * component. This means that if it is in a `List` with `Avatar`, it
   * will start the divider  to the left of the main text in the list.
   */
  inset: prop_types_default.a.bool,

  /**
   * Boolean if the divider should be vertical instead of horizontal.
   */
  vertical: prop_types_default.a.bool
};
/* harmony default export */ var Dividers_Divider = (Divider_Divider);
// CONCATENATED MODULE: ../node_modules/react-md/es/FontIcons/FontIcon.js
var FontIcon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function FontIcon_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function FontIcon_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FontIcon_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function FontIcon_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var ICON_SIZE = 24;

/**
 * The \`FontIcon\` component is used for rendering a font-icon library's
 * icon. The default is to use the `material-icons` library, but others
 * can be used as well.
 *
 * If you are using another font-icon library that does not always create
 * icons with a perfect 1:1 scale (such as font-awesome), it is recommended
 * to update the `.md-icon` styles to set the width and height to `$md-font-icon-size`.
 * However, this will prevent different sided icons.
 *
 * ```scss
 * .md-icon.fa {
 *   height: $md-font-icon-size;
 *   width: $md-font-icon-size;
 * }
 * ```
 */

var FontIcon_FontIcon = function (_PureComponent) {
  FontIcon_inherits(FontIcon, _PureComponent);

  function FontIcon(props) {
    FontIcon_classCallCheck(this, FontIcon);

    var _this = FontIcon_possibleConstructorReturn(this, _PureComponent.call(this));

    FontIcon_initialiseProps.call(_this);

    _this.state = { styles: _this._mergeStyles(props) };
    return _this;
  }

  FontIcon.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        style = _props.style,
        forceSize = _props.forceSize,
        forceFontSize = _props.forceFontSize;

    if (style !== nextProps.style || forceSize !== nextProps.forceSize || forceFontSize !== nextProps.forceFontSize) {
      this.setState({ styles: this._mergeStyles(nextProps) });
    }
  };

  FontIcon.prototype.render = function render() {
    var styles = this.state.styles;

    var _props2 = this.props,
        iconClassName = _props2.iconClassName,
        className = _props2.className,
        children = _props2.children,
        disabled = _props2.disabled,
        primary = _props2.primary,
        secondary = _props2.secondary,
        error = _props2.error,
        inherit = _props2.inherit,
        style = _props2.style,
        forceSize = _props2.forceSize,
        forceFontSize = _props2.forceFontSize,
        props = FontIcon_objectWithoutProperties(_props2, ['iconClassName', 'className', 'children', 'disabled', 'primary', 'secondary', 'error', 'inherit', 'style', 'forceSize', 'forceFontSize']);

    var classes = classnames_default()('md-icon', iconClassName, themeColors({
      disabled: disabled,
      error: error,
      inherit: inherit,
      primary: primary,
      secondary: secondary
    }), className);

    return react_default.a.createElement(
      'i',
      FontIcon_extends({}, props, { style: styles, className: classes }),
      children
    );
  };

  return FontIcon;
}(react["PureComponent"]);

FontIcon_FontIcon.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the `FontIcon`.
   */
  className: prop_types_default.a.string,

  /**
   * The icon font library className to use to display the icon.
   */
  iconClassName: prop_types_default.a.string.isRequired,

  /**
   * Boolean if the primary theme color should be applied.
   */
  primary: prop_types_default.a.bool,

  /**
   * Boolean if the secondary theme color should be applied.
   */
  secondary: prop_types_default.a.bool,

  /**
   * Boolean if the icon is considered disabled and should inherit the
   * disabled color.
   */
  disabled: prop_types_default.a.bool,

  /**
   * Boolean if the error color should be applied to the icon.
   */
  error: prop_types_default.a.bool,

  /**
   * Boolean if the color of the icon should be inherited by parent elements.
   */
  inherit: prop_types_default.a.bool,

  /**
   * Either a boolean that will enforce the 24x24 size of the font icon or a number of the size
   * to enforce. This is useful when using other font icon libraries that do not have a consistent
   * size.
   */
  forceSize: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.number]),

  /**
   * Boolean if the `forceSize` prop should also force the `font-size` instead of only `width` and `height`.
   */
  forceFontSize: function forceFontSize(props, propName, component) {
    for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    var error = prop_types_default.a.bool.apply(prop_types_default.a, [props, propName, component].concat(args));
    if (!error && typeof props.forceSize === 'undefined' && props[propName]) {
      error = new Error('You provided a `forceFontSize` prop to the ' + component + ' component, without specifying the `forceSize` ' + ('prop. Either set the `forceSize` prop to a boolean or a number, or disable `' + propName + '`.'));
    }

    return error;
  },

  /**
   * Any children required to display the icon with the font library.
   */
  children: prop_types_default.a.node
};
FontIcon_FontIcon.defaultProps = {
  iconClassName: 'material-icons'
};

var FontIcon_initialiseProps = function _initialiseProps() {
  this._mergeStyles = function (_ref) {
    var style = _ref.style,
        forceSize = _ref.forceSize,
        forceFontSize = _ref.forceFontSize;

    var styles = style;
    if (typeof forceSize === 'boolean') {
      styles = FontIcon_extends({
        height: ICON_SIZE,
        width: ICON_SIZE,
        fontSize: forceFontSize ? ICON_SIZE : undefined
      }, style);
    } else if (typeof forceSize === 'number') {
      styles = FontIcon_extends({
        height: forceSize,
        width: forceSize,
        fontSize: forceFontSize ? forceSize : undefined
      }, style);
    }

    return styles;
  };
};

/* harmony default export */ var FontIcons_FontIcon = (FontIcon_FontIcon);
// CONCATENATED MODULE: ../node_modules/react-md/es/FontIcons/getDeprecatedIcon.js



function getDeprecatedIcon(className, children, icon) {
  if (className || children) {
    return react_default.a.createElement(
      FontIcons_FontIcon,
      { iconClassName: className },
      children
    );
  }

  return icon;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Lists/TileAddon.js
function TileAddon_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TileAddon_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TileAddon_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The `TileAddon` component is used to render either a `FontIcon` or an `Avatar`
 * next to the `ListTileText` for a `ListItem`.
 */

var TileAddon_TileAddon = function (_PureComponent) {
  TileAddon_inherits(TileAddon, _PureComponent);

  function TileAddon() {
    TileAddon_classCallCheck(this, TileAddon);

    return TileAddon_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  TileAddon.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        icon = _props.icon,
        avatar = _props.avatar,
        active = _props.active,
        activeClassName = _props.activeClassName,
        style = _props.style,
        className = _props.className;

    if (!icon && !avatar) {
      return null;
    }

    var avatarIcon = false;
    if (avatar) {
      var avatarChild = react_default.a.Children.only(avatar);
      if (avatarChild.props.iconSized) {
        avatarIcon = true;
      }
    }
    return react_default.a.createElement(
      'div',
      {
        style: style,
        className: classnames_default()('md-tile-addon', (_cn = {
          'md-tile-addon--icon': icon || avatarIcon,
          'md-tile-addon--avatar': avatar && !avatarIcon
        }, _cn[activeClassName] = active, _cn), className)
      },
      icon || avatar
    );
  };

  return TileAddon;
}(react["PureComponent"]);

TileAddon_TileAddon.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  active: prop_types_default.a.bool,
  activeClassName: prop_types_default.a.string,
  icon: prop_types_default.a.node,
  avatar: prop_types_default.a.node
};
/* harmony default export */ var Lists_TileAddon = (TileAddon_TileAddon);
// CONCATENATED MODULE: ../node_modules/react-md/es/Lists/ListItemText.js
var ListItemText_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function ListItemText_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ListItemText_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ListItemText_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ListItemText_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The `ListItemText` component is used to render the `primaryText` and an optional
 * `secondaryText` for a `ListItem`.
 */

var ListItemText_ListItemText = function (_PureComponent) {
  ListItemText_inherits(ListItemText, _PureComponent);

  function ListItemText() {
    ListItemText_classCallCheck(this, ListItemText);

    return ListItemText_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  ListItemText.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        active = _props.active,
        activeClassName = _props.activeClassName,
        disabled = _props.disabled,
        primaryText = _props.primaryText,
        primaryTextStyle = _props.primaryTextStyle,
        primaryTextClassName = _props.primaryTextClassName,
        secondaryText = _props.secondaryText,
        secondaryTextStyle = _props.secondaryTextStyle,
        secondaryTextClassName = _props.secondaryTextClassName,
        className = _props.className,
        threeLines = _props.threeLines,
        props = ListItemText_objectWithoutProperties(_props, ['active', 'activeClassName', 'disabled', 'primaryText', 'primaryTextStyle', 'primaryTextClassName', 'secondaryText', 'secondaryTextStyle', 'secondaryTextClassName', 'className', 'threeLines']);

    var secondaryTextNode = void 0;
    if (secondaryText) {
      secondaryTextNode = react_default.a.createElement(
        'div',
        {
          style: secondaryTextStyle,
          className: classnames_default()('md-tile-text--secondary', {
            'md-tile-text--three-lines': threeLines
          }, themeColors({ disabled: disabled, hint: !disabled }), secondaryTextClassName)
        },
        secondaryText
      );
    }

    return react_default.a.createElement(
      'div',
      ListItemText_extends({}, props, { className: classnames_default()('md-tile-content', className) }),
      react_default.a.createElement(
        'div',
        {
          style: primaryTextStyle,
          className: classnames_default()('md-tile-text--primary', (_cn = {}, _cn[activeClassName] = !disabled && active, _cn), themeColors({ disabled: disabled, text: !active }), primaryTextClassName)
        },
        primaryText
      ),
      secondaryTextNode
    );
  };

  return ListItemText;
}(react["PureComponent"]);

ListItemText_ListItemText.propTypes = {
  active: prop_types_default.a.bool,
  activeClassName: prop_types_default.a.string,
  disabled: prop_types_default.a.bool,
  primaryText: prop_types_default.a.node.isRequired,
  primaryTextStyle: prop_types_default.a.object,
  primaryTextClassName: prop_types_default.a.string,
  secondaryText: prop_types_default.a.node,
  secondaryTextStyle: prop_types_default.a.object,
  secondaryTextClassName: prop_types_default.a.string,
  className: prop_types_default.a.string,
  threeLines: prop_types_default.a.bool
};
/* harmony default export */ var Lists_ListItemText = (ListItemText_ListItemText);
// CONCATENATED MODULE: ../node_modules/react-md/es/Subheaders/Subheader.js
var Subheader_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Subheader_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Subheader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Subheader_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Subheader_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The `Subheader` component is generally used inside of lists or menus.
 */

var Subheader_Subheader = function (_PureComponent) {
  Subheader_inherits(Subheader, _PureComponent);

  function Subheader() {
    Subheader_classCallCheck(this, Subheader);

    return Subheader_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Subheader.prototype.render = function render() {
    var _props = this.props,
        Component = _props.component,
        inset = _props.inset,
        primary = _props.primary,
        primaryText = _props.primaryText,
        className = _props.className,
        children = _props.children,
        props = Subheader_objectWithoutProperties(_props, ['component', 'inset', 'primary', 'primaryText', 'className', 'children']);

    return react_default.a.createElement(
      Component,
      Subheader_extends({}, props, {
        className: classnames_default()('md-subheader', {
          'md-list-item--inset': inset
        }, themeColors({ primary: primary, hint: !primary }), className)
      }),
      primaryText,
      children
    );
  };

  return Subheader;
}(react["PureComponent"]);

Subheader_Subheader.propTypes = {
  /**
   * An optional style to apply to the subheader.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the subheader.
   */
  className: prop_types_default.a.string,

  /**
   * Boolean if the subheader should be styled with the primary color.
   */
  primary: prop_types_default.a.bool,

  /**
   * Boolean if the subheader is inset in the list. This will add additional
   * spacing to align the subheader.
   */
  inset: prop_types_default.a.bool,

  /**
   * The primary text to use in the subheader.
   */
  primaryText: prop_types_default.a.node.isRequired,

  /**
   * Any optional children to display after the `primaryText`. This prop is
   * not recommended.
   */
  children: prop_types_default.a.node,

  /**
   * The component to render the Subheader as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired
};
Subheader_Subheader.defaultProps = {
  component: 'li'
};
/* harmony default export */ var Subheaders_Subheader = (Subheader_Subheader);
// CONCATENATED MODULE: ../node_modules/react-md/es/Subheaders/index.js

/* harmony default export */ var Subheaders = (Subheaders_Subheader);



// CONCATENATED MODULE: ../node_modules/react-md/es/Lists/List.js
var List_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function List_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function List_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function List_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function List_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











/**
 * Lists present multiple line items vertically as a single continuous element.
 */

var List_List = function (_PureComponent) {
  List_inherits(List, _PureComponent);

  function List() {
    var _temp, _this, _ret;

    List_classCallCheck(this, List);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = List_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = {}, _temp), List_possibleConstructorReturn(_this, _ret);
  }

  List.prototype.getChildContext = function getChildContext() {
    var _context = this.context,
        listLevel = _context.listLevel,
        context = List_objectWithoutProperties(_context, ['listLevel']);

    var cascadingFixedTo = getField(this.state, this.context, 'cascadingFixedTo');
    return List_extends({}, context, {
      cascadingFixedTo: cascadingFixedTo,
      listLevel: typeof listLevel === 'undefined' ? 1 : listLevel + 1
    });
  };

  List.prototype.componentDidMount = function componentDidMount() {
    if (this.context.cascadingMenu) {
      var list = Object(react_dom["findDOMNode"])(this);
      if (list.offsetHeight < list.scrollHeight) {
        var cascadingFixedTo = { y: Object(react_dom["findDOMNode"])(this) };
        this.setState({ cascadingFixedTo: cascadingFixedTo }); // eslint-disable-line react/no-did-mount-set-state
      }
    }
  };

  List.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        className = _props.className,
        ordered = _props.ordered,
        children = _props.children,
        subheader = _props.subheader,
        inline = _props.inline,
        primarySubheader = _props.primarySubheader,
        props = List_objectWithoutProperties(_props, ['className', 'ordered', 'children', 'subheader', 'inline', 'primarySubheader']);

    var _context2 = this.context,
        cascadingMenu = _context2.cascadingMenu,
        cascadingZDepth = _context2.cascadingZDepth,
        listLevel = _context2.listLevel;


    var subheaderEl = void 0;
    if (subheader) {
      subheaderEl = react_default.a.createElement(Subheaders, { key: 'subheader', primaryText: subheader, primary: primarySubheader });
    }

    var Component = ordered ? 'ol' : 'ul';
    return react_default.a.createElement(
      Component,
      List_extends({}, props, {
        className: classnames_default()('md-list', (_cn = {
          'md-list--inline': inline,
          'md-list--menu-cascading': cascadingMenu
        }, _cn['md-paper md-paper--' + cascadingZDepth] = cascadingZDepth && cascadingMenu && listLevel > 0, _cn['md-list--nested-' + listLevel] = listLevel && !cascadingMenu, _cn), className)
      }),
      subheaderEl,
      children
    );
  };

  return List;
}(react["PureComponent"]);

List_List.propTypes = {
  /**
   * An optional style to apply to the list.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the list.
   */
  className: prop_types_default.a.string,

  /**
   * Boolean if this should be an ordered list (`<ol>`) component. Otherwise, it will
   * be rendered as `<ul>`.
   */
  ordered: prop_types_default.a.bool,

  /**
   * This *should* be a list of `ListItem`, `ListItemControl`, `Divider`, or
   * `Subheader`.
   */
  children: prop_types_default.a.node,

  /**
   * Boolean if the list should appear horizontally instead of vertically.
   */
  inline: prop_types_default.a.bool,
  subheader: deprecated_default()(prop_types_default.a.string, 'Use the `Subheader` component as a child instead'),
  primarySubheader: deprecated_default()(prop_types_default.a.bool, 'Use the `Subheader` component as a child instead')
};
List_List.childContextTypes = {
  listLevel: prop_types_default.a.number,
  cascadingMenu: prop_types_default.a.bool,
  cascadingFixedTo: fixedToShape,
  cascadingZDepth: prop_types_default.a.number
};
List_List.contextTypes = {
  listLevel: prop_types_default.a.number,
  cascadingMenu: prop_types_default.a.bool,
  cascadingFixedTo: fixedToShape,
  cascadingZDepth: prop_types_default.a.number
};
/* harmony default export */ var Lists_List = (List_List);
// EXTERNAL MODULE: ../node_modules/react-prop-types/lib/isRequiredForA11y.js
var isRequiredForA11y = __webpack_require__("nHLA");
var isRequiredForA11y_default = /*#__PURE__*/__webpack_require__.n(isRequiredForA11y);

// CONCATENATED MODULE: ../node_modules/react-md/es/utils/EventUtils/handleWindowClickListeners.js
/** @module utils/EventUtils/handleWindowClickListeners */
var mobileSafari = void 0;

/**
 * Since mobile safari doesn't delegate click events to the window (it only does touch events),
 * this utility function will hack a fix to allow the delegation by updaging the body's cursor
 * to be a pointer.
 *
 * Hopefully this can be removed one day....
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Events/click#Safari_Mobile
 * @param {function} cb - the callback function to use for a window click event.
 * @param {boolean} enabled - boolean if the click event is enabled.
 */
function handleWindowClickListeners(cb) {
  var enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (typeof mobileSafari === 'undefined' && typeof window !== 'undefined') {
    var ua = window.navigator.userAgent;
    var iOS = ua.match(/iP(ad|hone)/i);
    var webkit = ua.match(/WebKit/i);
    mobileSafari = iOS && webkit && !ua.match(/CriOS/i);

    if (mobileSafari) {
      document.body.style.cursor = 'pointer';
    }
  }

  var listener = window[(enabled ? 'add' : 'remove') + 'EventListener'];
  listener('click', cb);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/getSelectedText.js
/** @module utils/getSelectedText */

/**
 * A utility function that gets the current selected text in the document. I think
 * that all the browsers I support have `window.getSelection`, but it falls back to
 * support others.
 *
 * @return {String} the current selection on the page
 */
function getSelectedText() {
  if (typeof window.getSelection !== 'undefined') {
    return window.getSelection().toString();
  } else if (typeof document.selection !== 'undefined' && document.selection.type === 'Text') {
    return document.selection.createRange().text;
  }

  return '';
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/Positioning/getSelectedTextPosition.js
/** @module utils/Positoning/getSelectedTextPosition */



var ZERO_WIDTH_CHARACTER = '\u200B';

/**
 * A utility function to attempt to get the current highlighted text position.
 *
 * When a context menu is opened, this function attempts to find the bounding client rect
 * for the highlighted text. However, if the text is in the text field, some weird stuff
 * happens and it is unable to get it correctly.
 */
function getSelectedTextPosition(e) {
  var height = void 0;
  var target = e.target,
      clientX = e.clientX,
      clientY = e.clientY;

  var text = getSelectedText();
  var width = Math.round(getTextWidth(text, target) || 0);
  if (!text || target.classList.contains('md-text-field')) {
    height = parseInt(window.getComputedStyle(target).fontSize, 10);
    return {
      width: width,
      height: height,
      left: clientX - width,
      top: clientY
    };
  }

  // All browsers I am supporting have window.getSelection, but better safe than sorry
  if (window.getSelection) {
    var selection = window.getSelection();
    if (selection.rangeCount) {
      var range = selection.getRangeAt(0).cloneRange();
      var rect = null;
      if (range.getClientRects) {
        var rects = range.getClientRects();
        if (rects.length > 0) {
          rect = rects[0];
        }
      }

      if (!rect) {
        var span = document.createElement('span');
        span.appendChild(document.createTextNode(ZERO_WIDTH_CHARACTER));
        range.insertNode(span);
        rect = span.getBoundingClientRect();

        var spanParent = span.parentNode;
        spanParent.removeChild(span);
        spanParent.normalize();
      }

      return rect;
    }
  }

  return null;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/Positioning/getScroll.js
/** @module utils/Positioning/getScroll */

/**
 * A utility function to just get an element's scroll x and y
 * values. This is really just needed because `window` uses
 * different attributes.
 *
 * @param {Object} el - The element to get a scroll value from.
 * @return {Object} an object containing the scrollX and scrollY of the element.
 */
function getScroll(el) {
  if (typeof el.scrollX !== 'undefined' && typeof el.scrollY !== 'undefined') {
    return { x: el.scrollX, y: el.scrollY };
  } else if (typeof el.scrollLeft !== 'undefined' && typeof el.scrollTop !== 'undefined') {
    return { x: el.scrollLeft, y: el.scrollTop };
  }

  return { x: 0, y: 0 };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/Positioning/getScreenSize.js
/** @module utils/Positioning/getScreenSize */

/**
 * A utility function to get the height or width of the of the browser with
 * a fallback for older browsers.
 *
 * @param {String} position - the position to get the screen size for
 * @return {number} the screen size for the provided position.
 */
function getScreenSize(position) {
  if (position !== 'Height' && position !== 'Width' && "production" !== 'production') {
    throw new Error('The \'getScreenSize\' function requires either a position of \'Height\' or \'Width\' ' + ('but received `' + position + '`'));
  }

  return window['inner' + position] || document.documentElement['client' + position];
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/Positioning/viewport.js
/** @module utils/Positioning/viewport */


/**
 * Determines if an element is still in the viewport. If it is,
 * it will return a `true` boolean. If it is not, it will return
 * an object containing booleans for top, right, bottom, and left
 * where a `false` value will mean it is out of the viewport for that
 * position.
 *
 * @param {Object} el - The element to test.
 * @return {boolean|Object} the results.
 */
function viewport(el) {
  if (!el) {
    return {};
  }

  var rect = el.getBoundingClientRect();
  var top = rect.top >= 0;
  var right = rect.right <= getScreenSize('Width');
  var bottom = rect.bottom <= getScreenSize('Height');
  var left = rect.left >= 0;

  return top && right && bottom && left || { top: top, right: right, bottom: bottom, left: left };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/Positioning/isOutOfBounds.js
/** @module utils/Positioning/isOutOfBounds */



function isOutHorizontally(fixedTo, child, threshold) {
  var _fixedTo$getBoundingC = fixedTo.getBoundingClientRect(),
      fixedLeft = _fixedTo$getBoundingC.left,
      fixedRight = _fixedTo$getBoundingC.right;

  var _child$getBoundingCli = child.getBoundingClientRect(),
      childLeft = _child$getBoundingCli.left,
      childRight = _child$getBoundingCli.right;

  var offset = child.offsetWidth * threshold;

  var left = childLeft + offset;
  var right = childRight - offset;

  var screenEdge = childLeft === 0 || getScreenSize('Width') === childRight;
  return fixedLeft > left || fixedRight < right || screenEdge;
}

function isOutVertically(fixedTo, child, toggle, threshold) {
  var _fixedTo$getBoundingC2 = fixedTo.getBoundingClientRect(),
      fixedTop = _fixedTo$getBoundingC2.top,
      fixedBottom = _fixedTo$getBoundingC2.bottom;

  var _child$getBoundingCli2 = child.getBoundingClientRect(),
      childTop = _child$getBoundingCli2.top,
      childBottom = _child$getBoundingCli2.bottom;

  var offset = toggle.offsetHeight * threshold;

  var screenEdge = childTop === 0 || getScreenSize('Height') === childBottom;
  return fixedTop > childTop + offset || fixedBottom < childTop - offset || screenEdge;
}

/**
 * Checks if the fixedTo object for the Layover component is considered
 * out of bounds relative to the container.
 *
 * @param {Object} fixedTo - The Layover's `fixedTo` prop.
 * @param {Object} child - The Layover's `children` prop as a DOM element.
 * @param {Object} toggle - The Layover's `toggle` prop as a DOM element.
 * @param {number} verticalThreshold - The vertical threshold multiplier to apply.
 * @param {number} horizontalThreshold - The horizontal threshold multiplier to apply.
 * @return {boolean} true if the Layover's `fixedTo` prop is considered out of bounds.
 */
function isOutOfBounds(fixedTo, child, toggle, verticalThreshold, horizontalThreshold) {
  if (fixedTo === window) {
    return false;
  } else if (fixedTo.x || fixedTo.y) {
    var x = fixedTo.x,
        y = fixedTo.y;

    return !!y && isOutVertically(y, child, toggle, verticalThreshold) || !!x && isOutHorizontally(x, child, horizontalThreshold);
  }

  return isOutVertically(fixedTo, child, toggle, verticalThreshold) || isOutHorizontally(fixedTo, child, horizontalThreshold);
}
// EXTERNAL MODULE: ../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__("iXzu");

// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/ResizeObserver.js
function ResizeObserver_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ResizeObserver_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ResizeObserver_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The `ResizeObserver` component is a component hook for the
 * [ResizeObserver](http://rawgit.com/WICG/ResizeObserver/master/index.html)
 * using the [resize-observer-polyfill](https://github.com/que-etc/resize-observer-polyfill)
 * for browsers that don't support it yet.
 *
 * This component displays an empty `span` with `aria-hidden` to allow access to the DOM. By
 * default it will attempt to watch changes on its parent component, but it can be configured
 * to watch any element by using the `target` prop.
 */

var ResizeObserver_ResizeObserver = function (_PureComponent) {
  ResizeObserver_inherits(ResizeObserver, _PureComponent);

  function ResizeObserver() {
    var _temp, _this, _ret;

    ResizeObserver_classCallCheck(this, ResizeObserver);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = ResizeObserver_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._container = null, _this._target = null, _this._observer = null, _this._height = null, _this._width = null, _this._scrollHeight = null, _this._scrollWidth = null, _this._measure = function (entries) {
      if (!_this._observer || !_this._target) {
        return;
      }

      for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var entry = _ref;

        if (!entry) {
          return;
        }

        var _entry$contentRect = entry.contentRect,
            height = _entry$contentRect.height,
            width = _entry$contentRect.width;
        var _entry$target = entry.target,
            scrollHeight = _entry$target.scrollHeight,
            scrollWidth = _entry$target.scrollWidth;

        if (_this._isHeightChange(height, scrollHeight) || _this._isWidthChange(width, scrollWidth)) {
          _this._height = height;
          _this._width = width;
          _this._scrollHeight = scrollHeight;
          _this._scrollWidth = scrollWidth;
          _this.props.onResize({ height: height, width: width, scrollHeight: scrollHeight, scrollWidth: scrollWidth, el: entry.target });
        }
      }
    }, _this._isHeightChange = function (height, scrollHeight) {
      return _this.props.watchHeight && (height !== _this._height || scrollHeight !== _this._scrollHeight);
    }, _this._isWidthChange = function (width, scrollWidth) {
      return _this.props.watchWidth && (width !== _this._width || scrollWidth !== _this._scrollWidth);
    }, _this._handleRef = function (container) {
      if (container) {
        _this._container = container;
        _this._target = _this._getTarget(container, _this.props.target);
        _this._observer = new ResizeObserver_es["default"](_this._measure);

        if (_this._target) {
          _this._observer.observe(_this._target);
        }
      } else {
        if (_this._observer) {
          _this._observer.disconnect();
        }

        _this._container = null;
        _this._target = null;
        _this._observer = null;
        _this._height = null;
        _this._width = null;
        _this._scrollHeight = null;
        _this._scrollWidth = null;
      }

      if (_this.props.elRef) {
        _this.props.elRef(_this._target);
      }
    }, _temp), ResizeObserver_possibleConstructorReturn(_this, _ret);
  }

  ResizeObserver.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var target = this.props.target;

    var nextTarget = nextProps.target;
    if (target === nextTarget) {
      return;
    } else if (nextTarget) {
      if (this._target) {
        this._observer.unobserve(this._target);
      }
      this._target = this._getTarget(this._container, nextTarget);
      this._observer.observe(this._target);
    }
  };

  ResizeObserver.prototype._getTarget = function _getTarget(container, target) {
    if (target === null || target && typeof target !== 'string') {
      return target;
    }

    var t = null;
    if (target) {
      t = document.getElementById(target) || document.querySelector(target);
    } else {
      t = container.parentNode;
    }

    if (!t) {
      throw new Error('An HTMLDOMNode is required as the `ResizeObserver`\'s watch target but none were provided/found. ' + ('Please update the target prop to find a valid node since the provided target is invalid. `' + target + '`.'));
    }

    return t;
  };

  ResizeObserver.prototype.render = function render() {
    var Component = this.props.component;

    return react_default.a.createElement(Component, { ref: this._handleRef, 'aria-hidden': true });
  };

  return ResizeObserver;
}(react["PureComponent"]);

ResizeObserver_ResizeObserver.propTypes = {
  /**
   * Boolean if the height should be watched for the resize target.
   */
  watchHeight: prop_types_default.a.bool,

  /**
   * Boolean if the width should be watched for the resize target.
   */
  watchWidth: prop_types_default.a.bool,

  /**
   * An optional target that should be used for detecting resize events. This can either
   * be a HTMLDOMNode or a string to use with `document.getElementById` or `document.querySelector`.
   *
   * If this prop is not provided and not null, it will default to the parent node of this component.
   * If the provided `target={null}`, the observer will not begin until the `target` is `undefined` or
   * it has been correctly passed a target string or object.
   */
  target: prop_types_default.a.oneOfType([prop_types_default.a.object, prop_types_default.a.string]),

  /**
   * The component to be rendered as. This should normally just be the default `span`, but there are cases
   * where the component should be switched to something else for valid html.
   */
  component: prop_types_default.a.string,

  /**
   * A function to call when the height or width has been changed and that attribute is being watched.
   * The callback will include the current height, width, scrollHeight and scrollWidth of the target.
   *
   * ```js
   * onResize({
   *   height: nextHeight,
   *   width: nextWidth,
   *   scrollHeight: nextScrollHeight,
   *   scrollWidth: nextScrollWidth,
   *   el: resizeTarget,
   * });
   * ```
   */
  onResize: prop_types_default.a.func.isRequired,

  /**
   * An optional ref callback that will include the `target` or the parent node of the resize observer. Just
   * like other refs, this will provide null when it unmounts.
   *
   * This is really only helpful if you'd like the DOM node for a parent Component without needing to use
   * `ReactDOM.findDOMNode(this)`.
   */
  elRef: prop_types_default.a.func
};
ResizeObserver_ResizeObserver.defaultProps = {
  watchHeight: false,
  watchWidth: false,
  component: 'span'
};
/* harmony default export */ var Helpers_ResizeObserver = (ResizeObserver_ResizeObserver);
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/Layover.js
var Layover_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Layover_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Layover_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Layover_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Layover_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




















/**
 * The Layover component is used to keep a component fixed to another component
 * while the page is scrolling or a container is scrolling. When the fixed component
 * is considered out of view, it will be closed.
 *
 * > NOTE: Don't look at source code. Plz.
 */

var Layover_Layover = function (_PureComponent) {
  Layover_inherits(Layover, _PureComponent);

  function Layover(props) {
    Layover_classCallCheck(this, Layover);

    var _this = Layover_possibleConstructorReturn(this, _PureComponent.call(this));

    Layover_initialiseProps.call(_this);

    var child = react_default.a.Children.only(props.children);
    _this.state = {
      below: false,
      right: false,
      styles: child.props.style
    };

    _this._lastXFix = null;
    _this._lastYFix = null;
    _this._initialX = null;
    _this._initialY = null;
    _this._initialTop = null;
    _this._initialLeft = null;
    _this._child = null;
    _this._toggle = null;
    return _this;
  }

  Layover.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    if (false) {}

    var _props = this.props,
        visible = _props.visible,
        fixedTo = _props.fixedTo,
        sameWidth = _props.sameWidth,
        centered = _props.centered,
        simplified = _props.simplified;

    var anchor = this._getAnchor(this.props);
    if (visible) {
      handleWindowClickListeners(this._handleOutsideClick, true);

      // Don't worry about any of the other logic for a "simple" layover
      if (simplified) {
        return;
      }

      var rect = this._contextRect || this._toggle.getBoundingClientRect();
      if (this._dialog) {
        this._manageFixedToListener(this._dialog, true);
      } else if (!this._inFixed) {
        this._manageFixedToListener(fixedTo, true);
      }

      this._init(fixedTo, anchor, sameWidth, centered, rect);
    }
  };

  Layover.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var fixedTo = nextProps.fixedTo,
        visible = nextProps.visible,
        children = nextProps.children,
        sameWidth = nextProps.sameWidth,
        centered = nextProps.centered,
        simplified = nextProps.simplified;

    if (simplified) {
      if (this.props.simplified !== simplified) {
        this._reset();
      }
      return;
    }

    var anchor = this._getAnchor(nextProps);
    var visibileDiff = visible !== this.props.visible;
    var childStyle = react_default.a.Children.only(children).props.style;

    if (visibileDiff) {
      if (!visible) {
        this._reset();
      } else {
        // Initialize the layover logic
        var rect = this._contextRect || this._toggle.getBoundingClientRect();
        if (this._dialog) {
          this._manageFixedToListener(this._dialog, true);
        } else if (!this._inFixed) {
          this._manageFixedToListener(fixedTo, true);
        }

        this._init(fixedTo, anchor, sameWidth, centered, rect);
      }
    } else if (fixedTo !== this.props.fixedTo && visible) {
      // swap the fixedTo listeners
      this._manageFixedToListener(this.props.fixedTo, false);
      this._manageFixedToListener(fixedTo, true);
    } else if (childStyle !== react_default.a.Children.only(this.props.children).props.style) {
      // Re-merge styles... This is only required if all the others fail since all the other
      // logic always merges styles with the children styles
      this.setState({ styles: Layover_extends({}, this.state.styles, childStyle) });
    }
  };

  Layover.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this3 = this;

    var _props2 = this.props,
        visible = _props2.visible,
        closeOnOutsideClick = _props2.closeOnOutsideClick;

    var enabled = visible && closeOnOutsideClick;
    var prevEnabled = prevProps.visible && prevProps.closeOnOutsideClick;
    if (enabled !== prevEnabled) {
      if (this._clickTimeout) {
        clearTimeout(this._clickTimeout);
        this._clickTimeout = null;
      }

      // This is really an arbitrary timeout time, but firefox needs to have a timeout
      // so the context menu doesn't close automatically due to an "outside click" being
      // triggered
      this._clickTimeout = setTimeout(function () {
        _this3._clickTimeout = null;
        handleWindowClickListeners(_this3._handleOutsideClick, enabled);
      }, enabled ? 300 : 0);
    }
  };

  Layover.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._clickTimeout) {
      clearTimeout(this._clickTimeout);
      this._clickTimeout = null;
    }
    handleWindowClickListeners(this._handleOutsideClick, false);

    if (!this.props.simplified) {
      this._manageFixedToListener(this.props.fixedTo, false);
      this._manageWindowResizeListener(false);
    }
  };

  Layover.prototype._getAnchor = function _getAnchor(_ref) {
    var anchor = _ref.anchor,
        belowAnchor = _ref.belowAnchor,
        animationPosition = _ref.animationPosition;

    return animationPosition === Layover.Positions.BELOW && belowAnchor || anchor;
  };

  /**
   * Whew. Ok. So since the fixedTo prop can either be two elements or a single item,
   * this utility function is used to add/remove the scrolling event listeners for
   * this prop.
   *
   * When the fixedTo prop has a horizontal and/or vertical attribute, the `window`
   * will be the fallback option. If both the horizontal and vertical attributes are
   * defined, the `window` still needs to have a scroll listener to make sure it
   * doesn't go off screen.
   */


  /**
   * This is just a simple utility function to merge the existing state styles,
   * any new styles, and the children's styles (with most precedence).
   */


  /**
   * This initializes the popover with the default styles, and the initial bookkeeping
   * variables to update while it is open.
   */


  /**
   * Attempts to fix the child by setting it's location ONLY for the entire
   * page viewport. I didn't bother attempting to fix it for additional fixedTo
   * stuff.
   */


  /**
   * When the child is initially mounted, it will update the styles for centering
   * the element (if enabled) and then attempt to fix any viewport issues.
   */


  /**
   * This is the meat of the stuff. Do lots of viewport / container checks to make sure
   * the element should still be visible. If it is still visible, it will update its
   * x and y position for the new scroll position.
   */


  /**
   * Attempts to fix a viewport problem by swapping the positioning. This only does
   * vertical switching right now.
   *
   * @param {Object} vp - The result of the viewport function
   * @return {boolean} true if the fix was able to be done and successful.
   */


  Layover.prototype.render = function render() {
    var _props3 = this.props,
        className = _props3.className,
        block = _props3.block,
        toggle = _props3.toggle,
        visible = _props3.visible,
        children = _props3.children,
        fullWidth = _props3.fullWidth,
        animationPosition = _props3.animationPosition,
        simplified = _props3.simplified,
        fillViewportWidth = _props3.fillViewportWidth,
        fillViewportHeight = _props3.fillViewportHeight,
        anchor = _props3.anchor,
        belowAnchor = _props3.belowAnchor,
        onClose = _props3.onClose,
        repositionOnScroll = _props3.repositionOnScroll,
        repositionOnResize = _props3.repositionOnResize,
        sameWidth = _props3.sameWidth,
        centered = _props3.centered,
        fixedTo = _props3.fixedTo,
        toggleQuery = _props3.toggleQuery,
        yThreshold = _props3.yThreshold,
        xThreshold = _props3.xThreshold,
        onContextMenu = _props3.onContextMenu,
        preventContextMenu = _props3.preventContextMenu,
        closeOnOutsideClick = _props3.closeOnOutsideClick,
        minLeft = _props3.minLeft,
        minRight = _props3.minRight,
        minBottom = _props3.minBottom,
        props = Layover_objectWithoutProperties(_props3, ['className', 'block', 'toggle', 'visible', 'children', 'fullWidth', 'animationPosition', 'simplified', 'fillViewportWidth', 'fillViewportHeight', 'anchor', 'belowAnchor', 'onClose', 'repositionOnScroll', 'repositionOnResize', 'sameWidth', 'centered', 'fixedTo', 'toggleQuery', 'yThreshold', 'xThreshold', 'onContextMenu', 'preventContextMenu', 'closeOnOutsideClick', 'minLeft', 'minRight', 'minBottom']);

    var child = void 0;
    var childId = void 0;
    if (visible) {
      child = react_default.a.Children.only(children);
      if (child.props.id) {
        childId = child.props.id;
      } else if (props.id) {
        childId = props.id + '-layover';
      }

      child = react_default.a.cloneElement(children, {
        ref: this._fixateChild,
        id: childId,
        style: simplified ? child.props.style : this.state.styles,
        className: classnames_default()('md-layover-child md-layover-child--' + animationPosition, {
          'md-layover-child--simplified': simplified
        }, child.props.className)
      });
    }

    var observer = null;
    if (!simplified && !fillViewportWidth && !fillViewportHeight) {
      observer = react_default.a.createElement(Helpers_ResizeObserver, {
        watchWidth: !fillViewportWidth,
        watchHeight: !fillViewportHeight,
        target: this._child,
        onResize: this._handleResize
      });
    }

    return react_default.a.createElement(
      CSSTransitionGroup_default.a,
      Layover_extends({}, props, {
        className: classnames_default()('md-layover', {
          'md-layover--simplified': simplified,
          'md-inline-block': !block && !fullWidth,
          'md-full-width': fullWidth
        }, className),
        ref: this._setContainer,
        'aria-haspopup': true,
        'aria-owns': childId,
        'aria-expanded': visible,
        transitionEnter: props.transitionEnterTimeout !== 0,
        transitionLeave: props.transitionLeaveTimeout !== 0,
        onContextMenu: this._handleContextMenu
      }),
      observer,
      toggle,
      child
    );
  };

  return Layover;
}(react["PureComponent"]);

Layover_Layover.HorizontalAnchors = Helpers_HorizontalAnchors;
Layover_Layover.VerticalAnchors = Helpers_VerticalAnchors;
Layover_Layover.Positions = Helpers_Positions;
Layover_Layover.propTypes = {
  /**
   * A id to give the layover itself. This is generally recommended for accessibility. If the
   * child does not have an id, the child will automatically be updated to be `${id}-layover`.
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply to the layover.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the layover.
   */
  className: prop_types_default.a.string,

  /**
   * Boolean if the layover's child is currently visible.
   */
  visible: prop_types_default.a.bool.isRequired,

  /**
   * This should either be a single element or two elements that the layover recalculates
   * its fixed position when scrolling for horizontal and vertical.
   *
   * When it is a single element, it will recalculate for both horizontal and vertical
   * scrolling. Otherwise, you can specify the element for horizontal scrolling and a
   * separate element for vertical scrolling. If one is omitted, it will default to `window`.
   *
   * If the component is no longer considered to be in view after scrolling, the `onClose`
   * prop will be called.
   */
  fixedTo: fixedToShape.isRequired,

  /**
   * The renderable item that causes the Layover to become visible. This _should_
   * most likely be an `element` or `arrayOf(element)`, but anything is allowed.
   */
  toggle: prop_types_default.a.node,

  /**
   * Since the `toggle` prop can be anything, I need a way to be able to find an
   * element to base all the calculations on. This can either be a string that
   * gets passed to `layover.querySelector`, a DOM Element, or a function that
   * returns a DOM Element.
   */
  toggleQuery: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.object, prop_types_default.a.string]).isRequired,

  /**
   * A single child that should be fixed to the toggle element.
   */
  children: prop_types_default.a.element.isRequired,

  /**
   * Boolean if the Layover should be displayed as a block instead of as an inline block.
   */
  block: prop_types_default.a.bool,

  /**
   * Boolean if the `children` should be centered horizontally and vertically while keeping
   * its height in mind as well. This is *only* valid if both the x and y `anchor` targets
   * are `CENTER`.
   */
  centered: prop_types_default.a.bool,

  /**
   * Boolean if the layover should gain the `md-full-width` class name.
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * Boolean if the width of the children should be updated automatically to be the width
   * of the toggle element.
   */
  sameWidth: prop_types_default.a.bool,

  /**
   * The minimum value the `left` style can be for the child component. This is really just used
   * to make sure it doesn't scroll off the left of the page. It can also be used to make
   * full screen layovers on devices when when the `fillViewportWidth` prop is enabled.
   *
   * This can either be a number of pixels or a string for percentages. If this value is a string
   * **it will always be used over the calculated values** so it is preferred to use a number.
   *
   * @see {@link #minRight}
   * @see {@link #fillViewportWidth}
   */
  minLeft: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,

  /**
   * The minimum value the `right` style can be for the child component. This is really just used
   * to make sure it doesn't scroll off the right of the page when the `fillViewportWidth` prop is
   * enabled.
   *
   * This can either be a number of pixels or a string for percentages. If this value is a string
   * **it will always be used over the calculated values** so it is preferred to use a number.
   *
   * @see {@link #minLeft}
   * @see {@link #fillViewportWidth}
   */
  minRight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,

  /**
   * The minimum value that can be used for the `bottom` prop when the `fillViewportHeight` prop is enabled.
   * It is generally recommended to keep this value at `0` to keep it stretched to the bottom of the viewport
   * or setting it to a small positive number to add some padding.
   *
   * This can either be a number of pixels or a string for percentages. If this value is a string
   * **it will always be used over the calculated values** so it is preferred to use a number.
   *
   * @see {@link #fillViewportHeight}
   */
  minBottom: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the layover should make the child fill the entire viewport's width. This will just
   * style the child element with:
   *
   * ```js
   * childStyle = {
   *   left: this.props.minLeft,
   *   right: this.props.minRight,
   * };
   * ```
   *
   * If you add any additional constraints such as `width` or `max-width`, it will not span the entire viewport's
   * width. This prop should generally really only be used on mobile devices. Using this prop along with
   * `fillViewportHeight` for Autocompletes can create great Android mobile searches. See the `fillViewportHeight`
   * for more information about why it is *only Android*.
   *
   * @see {@link #minLeft}
   * @see {@link #minRight}
   * @see {@link #fillViewportHeight}
   */
  fillViewportWidth: prop_types_default.a.bool,

  /**
   * Boolean if the layover should fill the height of the viewport from the current calculated `top`. This will just
   * style the child element with:
   *
   * ```js
   * childStyle = {
   *   top: currentCalculatedTop,
   *   bottom: this.props.minBottom,
   *   maxHeight: 'none',
   * };
   * ```
   *
   * This is *super* nice on Android devices since it will allow you to create nice toolbar search autocompletes
   * in your app and the list of items will grow until it reaches the soft keyboard. It isn't as nice on iOS since
   * iOS does not subtract the soft keyboard from the viewport's size so the list will still extend to the bottom
   * of the page.
   *
   * @see {@link #minBottom}
   * @see {@link #fillViewportWidth}
   */
  fillViewportHeight: prop_types_default.a.bool,

  /**
   * A function used to hide the visibility of the children when the children are no longer
   * visible or an element outside of the layover is clicked.
   */
  onClose: prop_types_default.a.func.isRequired,

  /**
   * The component to render the Layover as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * The transition name to use for the children appearing/disappearing.
   */
  transitionName: prop_types_default.a.string.isRequired,

  /**
   * The transition duration for the enter animation. The animation can be disabled by setting
   * this value to 0.
   */
  transitionEnterTimeout: prop_types_default.a.number.isRequired,

  /**
   * The transition duration for the leave animation. The animation can be disabled by setting
   * this value to 0.
   */
  transitionLeaveTimeout: prop_types_default.a.number.isRequired,

  /**
   * This is a threshold that is used to calculate if the `children` is still in
   * view by applying this multiplier to the `children`'s width.
   */
  xThreshold: prop_types_default.a.number.isRequired,

  /**
   * This is a threshold that is used to calculate if the `children` is still in
   * view by applying this multiplier to the `toggle`'s height.
   */
  yThreshold: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the `children` should be hidden when an element outside
   * of the `Layout` component has been clicked.
   */
  closeOnOutsideClick: prop_types_default.a.bool.isRequired,

  /**
   * This is how the children get "anchored" to the `toggle` element and how the
   * auto-fix attempts will be made. Right now, the auto fixes will only be handled
   * on viewport boundaries instead of `fixedTo` boundaries. It was too hard for
   * first attempt.
   *
   * The general behavior will be that an equal-opposite of an anchor will be chosen
   * when that direction is out of viewport. So for example, the children are out
   * of viewport for the right of the screen, and the `anchor.x` value is
   * `Layover.HorizontalPositions.RIGHT`, the children will be swapped to be the `LEFT`
   * of the `toggle` component now.
   *
   * So a full list:
   * - `LEFT` / `RIGHT`
   * - `INNER_LEFT` / `INNER_RIGHT`
   * - `TOP` / `BOTTOM`
   *
   * The `CENTER` and `OVERLAP` positions can not be automatically adjusted.
   *
   * > To be safe, you should use the enum values for the `x` and `y` values.
   * @see {@link #VerticalAnchors}
   * @see {@link #HorizontalAnchors}
   */
  anchor: anchorShape.isRequired,

  /**
   * This is how the children get "anchored" when the `animationPositions` is set to `Layover.Positions.BELOW`.
   * Set this to `null` to continue using the base `anchor` prop instead of switching to this anchor.
   *
   * @see {@link #anchor}
   */
  belowAnchor: anchorShape,

  /**
   * This is the position that the children should animate from. It directly ties into
   * the `$md-layover-child-positions` Sass variable.
   */
  animationPosition: positionShape.isRequired,

  /**
   * If you would like the layover to interact as a context menu, provide this prop. It will
   * make the children appear relative to the context menu origin automatically.
   *
   * @see {@link #preventContextMenu}
   */
  onContextMenu: prop_types_default.a.func,

  /**
   * Boolean if the default behavior of the context menu should be prevented when using the
   * `onContextMenu` prop.
   *
   * @see {@link #onContextMenu}
   */
  preventContextMenu: prop_types_default.a.bool,

  /**
   * Boolean if the layover should attempt to automatically adjust the position of the element to
   * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called
   * instead.
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the layover should attempt to automatically adjust the position of the element to
   * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called
   * instead.
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * Boolean if the layover should become "simplified". This basically disables all the logic for
   * keeping the child within the viewport and allows you to manage all the positioning via CSS.
   *
   * When this is enabled, it updates the `Layover` to have `position: relative` while the child will
   * have `position: absolute` which will allow for simple `top`, `right`, `bottom`, and/or `left` CSS
   * to position as wanted.
   *
   * This is really only helpful in cases where the layover can't calculate things correctly due to
   * being in fixed containers somewhere in the page or some other weird stuff. Hopefully this won't
   * really need to be used much.
   */
  simplified: prop_types_default.a.bool
};
Layover_Layover.defaultProps = {
  anchor: {
    x: Layover_Layover.HorizontalAnchors.INNER_LEFT,
    y: Layover_Layover.VerticalAnchors.OVERLAP
  },
  belowAnchor: {
    x: Layover_Layover.HorizontalAnchors.CENTER,
    y: Layover_Layover.VerticalAnchors.BOTTOM
  },
  animationPosition: Layover_Layover.Positions.BELOW,
  repositionOnScroll: true,
  repositionOnResize: false,
  component: 'div',
  fixedTo: typeof window !== 'undefined' ? window : {},
  toggleQuery: '.md-text-field-container,button,*[role="button"],*[role="listbox"]',
  transitionName: 'md-layover',
  transitionEnterTimeout: 200,
  transitionLeaveTimeout: 200,
  yThreshold: 0.38,
  xThreshold: 0.38,
  closeOnOutsideClick: true,
  preventContextMenu: true,
  simplified: false,
  minLeft: 0,
  minRight: 0,
  minBottom: 0,
  fillViewportWidth: false,
  fillViewportHeight: false
};

var Layover_initialiseProps = function _initialiseProps() {
  var _this4 = this;

  this._isCenteredDialog = function () {
    return _this4._dialog && _this4._dialog.classList.contains('md-dialog--centered');
  };

  this._createStyles = function (anchor, centered, child, rect) {
    var x = anchor.x,
        y = anchor.y;
    var offsetWidth = child.offsetWidth,
        offsetHeight = child.offsetHeight;


    var left = void 0;
    var top = void 0;
    if (x === Helpers_HorizontalAnchors.CENTER) {
      left = rect.left + rect.width / 2 - offsetWidth / 2;
    } else if (x === Helpers_HorizontalAnchors.INNER_RIGHT) {
      left = rect.right - offsetWidth;
    } else if (x === Helpers_HorizontalAnchors.LEFT) {
      left = rect.left - offsetWidth;
    } else if (x === Helpers_HorizontalAnchors.RIGHT) {
      left = rect.right;
    }

    if (centered && x === Helpers_HorizontalAnchors.CENTER && y === Helpers_VerticalAnchors.CENTER) {
      top = rect.top - offsetHeight / 2 + rect.height / 2;
    } else if (y === Helpers_VerticalAnchors.TOP) {
      top = rect.top - offsetHeight;
    } else if (y === Helpers_VerticalAnchors.CENTER) {
      top = rect.top + rect.height / 2;
    } else if (y === Helpers_VerticalAnchors.BOTTOM) {
      top = rect.bottom;
    }

    if (_this4._isCenteredDialog()) {
      var dialogRect = _this4._dialog.getBoundingClientRect();
      left -= dialogRect.left;
      top -= dialogRect.top;
    }

    var style = {};
    if (top) {
      style.top = top;
    }

    if (left) {
      style.left = left;
    }

    return style;
  };

  this._manageFixedToListener = function (fixedTo, add) {
    var listener = (add ? 'add' : 'remove') + 'EventListener';
    if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {
      var x = fixedTo.x,
          y = fixedTo.y;

      if (x) {
        x[listener]('scroll', _this4._handleScroll);
      } else {
        window[listener]('scroll', _this4._handleScroll);
      }

      if (y) {
        y[listener]('scroll', _this4._handleScroll);
      } else if (!x) {
        // Only add the window event listener once
        window[listener]('scroll', _this4._handleScroll);
      }

      if (y && y !== window && x && x !== window) {
        window[listener]('scroll', _this4._handleScroll);
      }
    } else {
      fixedTo[listener]('scroll', _this4._handleScroll);

      if (fixedTo !== window) {
        window[listener]('scroll', _this4._handleScroll);
      }
    }
  };

  this._manageWindowResizeListener = function (enabled) {
    if (_this4._windowResizeTimeout) {
      clearTimeout(_this4._windowResizeTimeout);
      _this4._windowResizeTimeout = null;
    }

    if (enabled) {
      // add a 2 second delay before watching resize events since Android soft keyboards trigger a resize event.
      _this4._windowResizeTimeout = setTimeout(function () {
        _this4._windowResizeTimeout = null;
        window.addEventListener('resize', _this4._handleWindowResize);
      }, 2000);
    } else {
      window.removeEventListener('resize', _this4._handleWindowResize);
    }
  };

  this._mergeStyles = function (style) {
    var _props4 = _this4.props,
        minLeft = _props4.minLeft,
        minRight = _props4.minRight,
        minBottom = _props4.minBottom,
        fillViewportWidth = _props4.fillViewportWidth,
        fillViewportHeight = _props4.fillViewportHeight;

    if (fillViewportWidth) {
      style.left = minLeft;
      style.right = minRight;
    } else {
      if (style.left) {
        style.left = Math.max(minLeft, style.left);
      }

      if (style.right) {
        style.right = Math.max(minRight, style.right);
      }
    }

    if (fillViewportHeight) {
      style.bottom = minBottom;
      style.maxHeight = 'none';
    } else {
      // These styles are only created when filling the viewport height, so clear
      // them out again
      style.bottom = null;
      style.maxHeight = null;
    }

    return Layover_extends({}, _this4.state.styles, style, react_default.a.Children.only(_this4.props.children).props.style);
  };

  this._init = function (fixedTo, anchor, sameWidth, centered, rect) {
    if (_this4._child) {
      // The init function can be called again if the user quickly toggles the layover. If that
      // is the case, we want the styles that were set after the _positionChild _attemptFix.
      return;
    }

    var height = rect.height,
        width = rect.width;
    var top = rect.top,
        left = rect.left,
        right = rect.right;

    var x = void 0;
    var y = void 0;
    if (_this4._dialog) {
      var scroll = getScroll(_this4._dialog);
      x = scroll.x;
      y = scroll.y;

      if (_this4._isCenteredDialog()) {
        var dialogRect = _this4._dialog.getBoundingClientRect();
        left -= dialogRect.left;
        top -= dialogRect.top;
        right -= dialogRect.right;
      }
    } else if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {
      x = getScroll(fixedTo.x || window).x;
      y = getScroll(fixedTo.y || window).y;
    } else {
      var _scroll = getScroll(fixedTo);
      x = _scroll.x;
      y = _scroll.y;
    }

    _this4._initialX = x;
    _this4._initialY = y;
    _this4._initialLeft = left;
    _this4._initialTop = top;

    if (anchor.x === Helpers_HorizontalAnchors.INNER_RIGHT) {
      _this4._initialLeft = left + width;
    } else if (anchor.x === Helpers_HorizontalAnchors.RIGHT) {
      _this4._initialLeft = right;
    }

    if (!centered) {
      _this4._lastYFix = anchor.y === Helpers_VerticalAnchors.TOP ? 'bottom' : 'top';
    } else {
      // Centered is not fixable
      _this4._lastYFix = null;
    }
    if (anchor.x === Helpers_HorizontalAnchors.LEFT || anchor.x === Helpers_HorizontalAnchors.INNER_LEFT) {
      _this4._lastXFix = 'right';
    } else if (anchor.x === Helpers_HorizontalAnchors.RIGHT || anchor.x === Helpers_HorizontalAnchors.INNER_RIGHT) {
      _this4._lastXFix = 'left';
    } else {
      // Can't fix others
      _this4._lastXFix = null;
    }

    if (anchor.y === Helpers_VerticalAnchors.BOTTOM) {
      _this4._initialTop = top + height;
    }

    if (fixedTo !== window && !fixedTo.y && !fixedTo.x) {
      var _scroll2 = getScroll(window);
      _this4._initialWinX = _scroll2.x;
      _this4._initialWinY = _scroll2.y;
    }

    var styles = _this4._mergeStyles({
      left: _this4._initialLeft,
      top: _this4._initialTop,
      transformOrigin: undefined,
      width: sameWidth ? width : undefined
    });

    _this4.setState({ styles: styles });
  };

  this._reset = function () {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this4.props,
        fixedTo = _ref2.fixedTo;

    // Reset all the bookkeeping variables for a fresh start on re-visible
    _this4._lastXFix = null;
    _this4._lastYFix = null;
    _this4._initialX = null;
    _this4._initialY = null;
    _this4._initialTop = null;
    _this4._initialLeft = null;

    if (!_this4._inFixed) {
      if (_this4._dialog) {
        _this4._manageFixedToListener(_this4._dialog, false);
      }

      _this4._manageFixedToListener(fixedTo, false);
    }
  };

  this._setContainer = function (container) {
    _this4._container = Object(react_dom["findDOMNode"])(container);
    _this4._toggle = null;
    if (!_this4._container) {
      return;
    }

    var _props5 = _this4.props,
        toggleQuery = _props5.toggleQuery,
        onContextMenu = _props5.onContextMenu;

    if (typeof toggleQuery === 'function') {
      _this4._toggle = toggleQuery();
    } else if (typeof toggleQuery === 'string') {
      _this4._toggle = _this4._container.querySelector(toggleQuery);
    } else {
      _this4._toggle = toggleQuery;
    }

    if (!_this4._toggle && !onContextMenu && "production" !== 'production') {
      var error = new Error('Unable to find a toggle component with the provided `toggleQuery` and `toggle` element. \n' + ('`toggleQuery`: `' + toggleQuery + '`'));
      error.toggleQuery = toggleQuery;
      error.toggle = _this4.props.toggle;

      throw error;
    }

    var node = _this4._container;
    while (node) {
      var fixed = window.getComputedStyle(node).position === 'fixed';
      if (fixed && node.className.match(/md-dialog--(full-page|centered)/)) {
        _this4._dialog = node;
        return;
      } else if (fixed && !node.classList.contains('md-layover-child')) {
        _this4._inFixed = true;
        return;
      }

      node = node.offsetParent;
    }
  };

  this._initialFix = function () {
    // Need to make a clone that disables any transitions to calculate positioning stuff
    var clone = _this4._child.cloneNode(true);
    clone.style.webkitTransform = 'none';
    clone.style.transfrom = 'none';
    clone.style.webkitTransition = 'none';
    clone.style.transition = 'none';

    _this4._child.parentNode.appendChild(clone);
    var vp = viewport(clone);
    var childHeight = clone.offsetHeight,
        childWidth = clone.offsetWidth;

    _this4._child.parentNode.removeChild(clone);

    if (vp === true || !_this4._toggle || !_this4._child) {
      return;
    }

    var _getAnchor2 = _this4._getAnchor(_this4.props),
        x = _getAnchor2.x,
        y = _getAnchor2.y;

    var toggleHeight = void 0;
    var toggleWidth = void 0;
    if (_this4._contextRect) {
      toggleHeight = _this4._contextRect.height;
      toggleWidth = _this4._contextRect.width;
    } else {
      toggleHeight = _this4._toggle.offsetHeight;
      toggleWidth = _this4._toggle.offsetWidth;
    }

    var addToTop = 0;
    var addToLeft = 0;

    // Android devices will never get this far because they consider the keyboard as part
    // of the viewport, iOS will and cause it to be a giant negative number. *sigh*
    // Prevent any additional vertical positioning for iOS
    if (!_this4.props.fillViewportHeight && (!vp.top || !vp.bottom)) {
      var multiplier = vp.top ? -1 : 1;
      if (!vp.bottom && y === Helpers_VerticalAnchors.OVERLAP) {
        addToTop += toggleHeight;
      } else if (y === Helpers_VerticalAnchors.TOP || y === Helpers_VerticalAnchors.BOTTOM) {
        addToTop += multiplier * toggleHeight;
      }

      addToTop += multiplier * childHeight;

      _this4._lastYFix = vp.top ? 'bottom' : 'top';
    }

    if (!_this4.props.fillViewportWidth && x !== Helpers_HorizontalAnchors.CENTER && (!vp.left || !vp.right)) {
      if (!vp.left && x === Helpers_HorizontalAnchors.LEFT) {
        addToLeft += toggleWidth + childWidth;
        _this4._lastXFix = 'left';
      } else if (!vp.left && x === Helpers_HorizontalAnchors.INNER_LEFT) {
        addToLeft += toggleWidth;
        _this4._lastXFix = 'left';
      } else if (!vp.right && x === Helpers_HorizontalAnchors.RIGHT) {
        addToLeft -= toggleWidth + childWidth;
        _this4._lastXFix = 'right';
      } else if (!vp.right && x === Helpers_HorizontalAnchors.INNER_RIGHT) {
        addToLeft -= toggleWidth;
        _this4._lastXFix = 'right';
      }
    }

    if (addToTop !== 0 || addToLeft !== 0) {
      _this4._initialTop += addToTop;
      _this4._initialLeft += addToLeft;

      _this4.setState({ styles: _this4._mergeStyles({ top: _this4._initialTop, left: _this4._initialLeft }) });
    }
  };

  this._fixateChild = function (child) {
    _this4._child = Object(react_dom["findDOMNode"])(child);

    if (_this4._child !== null) {
      _this4._childComponent = react_default.a.Children.only(_this4.props.children);

      // If child also has a ref callback, simulate the same thing
      if (typeof _this4._childComponent.ref === 'function') {
        _this4._childComponent.ref(child);
      }

      if (_this4.props.simplified || !_this4._child || !_this4._toggle && !_this4._contextRect) {
        return;
      }

      if (_this4._dialog && _this4._dialog.classList.contains('md-dialog--centered')) {
        return;
      }

      _this4._manageWindowResizeListener(true);
      _this4._positionChild();
    } else if (_this4._childComponent && typeof _this4._childComponent.ref === 'function') {
      _this4._childComponent.ref(child);
    }
  };

  this._positionChild = function () {
    var centered = _this4.props.centered;

    var anchor = _this4._getAnchor(_this4.props);
    var rect = _this4._contextRect || _this4._toggle.getBoundingClientRect();
    _this4._height = rect.height;
    _this4._width = rect.width;
    var styles = _this4._createStyles(anchor, centered, _this4._child, rect);
    if (styles.top || styles.left) {
      _this4._initialLeft = styles.left || _this4._initialLeft;
      _this4._initialTop = styles.top || _this4._initialTop;
      _this4.setState({ styles: _this4._mergeStyles(styles) }, _this4._initialFix);
    } else {
      _this4._initialFix();
    }
  };

  this._handleResize = function () {
    if (_this4.props.visible) {
      _this4._positionChild();
    }
  };

  this._handleScroll = function (e) {
    if (!_this4.props.repositionOnScroll) {
      _this4._manageFixedToListener(_this4.props.fixedTo, false);
      _this4.props.onClose(e);
    }

    if (!_this4._ticking) {
      requestAnimationFrame(function () {
        return _this4._handleTick(e);
      });
    }

    _this4._ticking = true;
  };

  this._handleTick = function (e) {
    var _props6 = _this4.props,
        fixedTo = _props6.fixedTo,
        xThreshold = _props6.xThreshold,
        yThreshold = _props6.yThreshold;

    var vp = viewport(_this4._child);
    if (vp !== true && vp.left && vp.right) {
      var fixed = !_this4._contextRect && _this4._attemptFix(vp);
      if (!fixed) {
        _this4.props.onClose(e);
        _this4._ticking = false;
      }

      return;
    } else if (isOutOfBounds(fixedTo, _this4._child, _this4._toggle, yThreshold, xThreshold)) {
      _this4.props.onClose(e);
      _this4._ticking = false;
      return;
    }

    var x = void 0;
    var y = void 0;
    if (_this4._dialog) {
      var scroll = getScroll(_this4._dialog);
      x = scroll.x;
      y = scroll.y;
    } else if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {
      x = getScroll(fixedTo.x || window).x;
      y = getScroll(fixedTo.y || window).y;
    } else {
      var _scroll3 = getScroll(fixedTo);
      x = _scroll3.x;
      y = _scroll3.y;
    }

    var winX = void 0;
    var winY = void 0;
    // When using the additional fixedTo stuff, need to also keep track of the entire
    // window's scrolling..
    if (fixedTo !== window && !fixedTo.x && !fixedTo.y) {
      var _scroll4 = getScroll(window);
      winX = _scroll4.x;
      winY = _scroll4.y;
    }

    var styles = _this4.state.styles;
    var left = styles.left,
        top = styles.top;

    if (_this4._initialX !== x) {
      left = _this4._initialX - x + _this4._initialLeft;
    }

    if (winX && _this4._initialWinX !== winX) {
      left = _this4._initialWinX - winX + _this4._initialX;
    }

    if (_this4._initialY !== y) {
      top = _this4._initialY - y + _this4._initialTop;
    }

    if (winY && _this4._initialWinY !== winY) {
      top = _this4._initialWinY - winY + _this4._initialTop + (_this4._initialY - y);
    }

    if (styles.top !== top || styles.left !== left) {
      _this4.setState({ styles: _this4._mergeStyles({ left: left, top: top }) }, function () {
        _this4._ticking = false;
      });
    } else {
      _this4._ticking = false;
    }
  };

  this._handleOutsideClick = function (e) {
    if (_this4._contextRect && _this4._child && !_this4._child.contains(e.target) || _this4._container && !_this4._container.contains(e.target)) {
      _this4.props.onClose(e);
    }
  };

  this._handleWindowResize = function (e) {
    var _props7 = _this4.props,
        onClose = _props7.onClose,
        repositionOnResize = _props7.repositionOnResize;

    if (repositionOnResize) {
      _this4._handleResize();
    } else {
      onClose(e);
      _this4._manageWindowResizeListener(false);
    }
  };

  this._attemptFix = function (vp) {
    var _getAnchor3 = _this4._getAnchor(_this4.props),
        x = _getAnchor3.x,
        y = _getAnchor3.y;

    var centered = x === Helpers_HorizontalAnchors.CENTER && y === Helpers_VerticalAnchors.CENTER && _this4.props.centered;
    if (centered || _this4._lastYFix === 'top' && !vp.top || _this4._lastYFix === 'bottom' && !vp.bottom) {
      return false;
    }

    var toggleTop = _this4._toggle.getBoundingClientRect().top;
    var toggleHeight = _this4._toggle.offsetHeight;
    var childHeight = _this4._child.offsetHeight;

    // Can;t fix if the child can't fit on the page based on the toggle's position

    if (toggleTop + toggleHeight + childHeight > window.innerHeight) {
      return false;
    }

    var _child$getBoundingCli = _this4._child.getBoundingClientRect(),
        top = _child$getBoundingCli.top;

    var newTop = _this4._initialTop;
    var addToTop = childHeight * (vp.top ? -1 : 1);
    if (y === Helpers_VerticalAnchors.OVERLAP) {
      addToTop += (vp.top ? 1 : -1) * toggleHeight;
    } else if (y === Helpers_VerticalAnchors.TOP || y === Helpers_VerticalAnchors.BOTTOM) {
      addToTop += (_this4._lastYFix === 'top' ? -1 : 1) * toggleHeight;
    }

    if (addToTop !== 0) {
      newTop = top + addToTop;
      _this4._lastYFix = vp.top ? 'bottom' : 'top';
    }

    if (newTop !== _this4._initialTop) {
      _this4._initialTop = newTop;
      var fixedTo = _this4.props.fixedTo;

      var scrollEl = fixedTo;
      if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {
        scrollEl = fixedTo.y || window;
      }

      _this4._initialY = getScroll(scrollEl).y;

      _this4.setState({ styles: _this4._mergeStyles({ top: _this4._initialTop }) }, function () {
        _this4._ticking = false;
      });
      return true;
    }

    return false;
  };

  this._handleContextMenu = function (e) {
    var anchor = _this4._getAnchor(_this4.props);
    var _props8 = _this4.props,
        onContextMenu = _props8.onContextMenu,
        preventContextMenu = _props8.preventContextMenu,
        fixedTo = _props8.fixedTo,
        sameWidth = _props8.sameWidth,
        centered = _props8.centered,
        visible = _props8.visible;

    if (!onContextMenu) {
      return;
    }

    _this4._contextRect = getSelectedTextPosition(e);
    if (preventContextMenu && (!_this4._child || !_this4._child.contains(e.target))) {
      e.preventDefault();
    }

    onContextMenu(e);
    if (visible) {
      _this4._init(fixedTo, anchor, sameWidth, centered, _this4._contextRect);
    }
  };
};

/* harmony default export */ var Helpers_Layover = (Layover_Layover);
// CONCATENATED MODULE: ../node_modules/react-md/es/Menus/Menu.js
var Menu_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Menu_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Menu_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Menu_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Menu_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

















/**
 * The `Menu` controlled component is used to display a list of children in the `List`
 * component once the `visible` prop is true.
 */

var Menu_Menu = function (_PureComponent) {
  Menu_inherits(Menu, _PureComponent);

  function Menu() {
    var _temp, _this, _ret;

    Menu_classCallCheck(this, Menu);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Menu_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._handleClose = function (e) {
      var _this$props = _this.props,
          close = _this$props.close,
          onClose = _this$props.onClose;

      if (close || onClose) {
        (close || onClose)(e);
      }
    }, _this._handleClick = function (e) {
      if (_this.props.onClick) {
        _this.props.onClick(e);
      }

      var node = e.target;
      while (_this._container && _this._container.contains(node)) {
        if (_this._isIgnoreTarget(node)) {
          return;
        } else if (_this._isCloseTarget(node)) {
          e.persist();
          // set a timeout so item click events still trigger, and then close
          _this._timeout = setTimeout(function () {
            _this._timeout = null;
            _this._handleClose(e);
          }, CSSTransitionGroupTick);

          return;
        }

        node = node.parentNode;
      }
    }, _this._handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }

      handleKeyboardAccessibility(e, _this._handleClick, true, true);
    }, _temp), Menu_possibleConstructorReturn(_this, _ret);
  }

  Menu.prototype.getChildContext = function getChildContext() {
    var _props = this.props,
        cascading = _props.cascading,
        id = _props.id,
        fixedTo = _props.fixedTo,
        cascadingAnchor = _props.cascadingAnchor;

    var listLevel = this.context.listLevel || 0;
    var cascadingMenu = typeof cascading !== 'undefined' ? cascading : this.context.cascadingMenu;
    var cascadingZDepth = getField(this.context, this.props, 'cascadingZDepth');
    var cascadingFixedTo = typeof fixedTo !== 'undefined' ? fixedTo : this.context.cascadingFixedTo;

    return {
      listLevel: listLevel,
      cascadingId: id + '-level-' + (listLevel + 1),
      cascadingMenu: cascadingMenu,
      cascadingAnchor: cascadingAnchor,
      cascadingZDepth: cascadingZDepth,
      cascadingFixedTo: cascadingFixedTo
    };
  };

  Menu.prototype.componentDidMount = function componentDidMount() {
    this._container = Object(react_dom["findDOMNode"])(this);
  };

  Menu.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  /**
   * Checks if a provided event target or HTML Element is considered a menu click target.
   * This normally is just a ListItem.
   */
  Menu.prototype._isCloseTarget = function _isCloseTarget(target) {
    return target.classList.contains('md-list-item') && !target.classList.contains('md-list-item--nested-container');
  };

  /**
   * Checks if a provided event target or HTML Element is something that should shortcut/break
   * out of the click event loop because it **should not** close menus when clicked.
   */


  Menu.prototype._isIgnoreTarget = function _isIgnoreTarget(target) {
    return target.getAttribute('disabled') !== null || target.classList.contains('md-list-control');
  };

  Menu.prototype.render = function render() {
    var _cn;

    var _props2 = this.props,
        id = _props2.id,
        className = _props2.className,
        listStyle = _props2.listStyle,
        listClassName = _props2.listClassName,
        visible = _props2.visible,
        children = _props2.children,
        listProps = _props2.listProps,
        listZDepth = _props2.listZDepth,
        listInline = _props2.listInline,
        listHeightRestricted = _props2.listHeightRestricted,
        cascading = _props2.cascading,
        sameWidth = _props2.sameWidth,
        simplified = _props2.simplified,
        contained = _props2.contained,
        isOpen = _props2.isOpen,
        propFixedTo = _props2.fixedTo,
        propListId = _props2.listId,
        cascadingAnchor = _props2.cascadingAnchor,
        cascadingZDepth = _props2.cascadingZDepth,
        onClose = _props2.onClose,
        propPosition = _props2.position,
        close = _props2.close,
        autoclose = _props2.autoclose,
        limitHeight = _props2.limitHeight,
        expanderIconChildren = _props2.expanderIconChildren,
        expanderIconClassName = _props2.expanderIconClassName,
        props = Menu_objectWithoutProperties(_props2, ['id', 'className', 'listStyle', 'listClassName', 'visible', 'children', 'listProps', 'listZDepth', 'listInline', 'listHeightRestricted', 'cascading', 'sameWidth', 'simplified', 'contained', 'isOpen', 'fixedTo', 'listId', 'cascadingAnchor', 'cascadingZDepth', 'onClose', 'position', 'close', 'autoclose', 'limitHeight', 'expanderIconChildren', 'expanderIconClassName']);

    var _props3 = this.props,
        listId = _props3.listId,
        position = _props3.position;

    if (!listId) {
      listId = id + '-list';
    }

    // can't have a simplified menu for cascading and context menus
    var simple = !cascading && !props.onContextMenu && position !== 'context' && simplified;
    if (position === 'context') {
      position = Menu.Positions.BELOW;
    }

    var below = position === Menu.Positions.BELOW;
    var fixedTo = typeof propFixedTo !== 'undefined' ? propFixedTo : this.context.cascadingFixedTo;
    var listVisible = typeof isOpen !== 'undefined' ? isOpen : visible;
    return react_default.a.createElement(
      Helpers_Layover,
      Menu_extends({}, props, {
        id: id,
        className: classnames_default()('md-menu-container', {
          'md-menu-container--menu-below': simplified && below
        }, className),
        simplified: simple,
        sameWidth: contained || sameWidth,
        fixedTo: fixedTo,
        onClick: this._handleClick,
        onKeyDown: this._handleKeyDown,
        onClose: this._handleClose,
        animationPosition: position,
        visible: listVisible,
        'aria-haspopup': true,
        'aria-expanded': listVisible,
        'aria-owns': listId
      }),
      react_default.a.createElement(
        Lists_List,
        Menu_extends({}, listProps, {
          id: listId,
          key: 'menu-list',
          style: listStyle,
          className: classnames_default()('md-list--menu', (_cn = {
            'md-list--menu-restricted': listHeightRestricted,
            'md-list--menu-contained': simplified && (sameWidth || contained)
          }, _cn['md-list--menu-' + position] = simplified, _cn['md-paper md-paper--' + listZDepth] = listZDepth, _cn), listClassName),
          inline: listInline
        }),
        children
      )
    );
  };

  return Menu;
}(react["PureComponent"]);

Menu_Menu.HorizontalAnchors = Helpers_Layover.HorizontalAnchors;
Menu_Menu.VerticalAnchors = Helpers_Layover.VerticalAnchors;
Menu_Menu.Positions = {
  // Can't do ...Layover.Positions since it triggers the get for CONTEXT
  TOP_LEFT: Helpers_Layover.Positions.TOP_LEFT,
  TOP_RIGHT: Helpers_Layover.Positions.TOP_RIGHT,
  BOTTOM_LEFT: Helpers_Layover.Positions.BOTTOM_LEFT,
  BOTTOM_RIGHT: Helpers_Layover.Positions.BOTTOM_RIGHT,
  BELOW: Helpers_Layover.Positions.BELOW,
  _warned: false,
  get CONTEXT() {
    if (!this._warned) {
      /* eslint-disable no-console */
      console.error('The `Menu.Positions.CONTEXT` position has been deprecated and will be removed ' + 'in the next major release. To make the `Menu` behave as a context menu, provide ' + 'the `onContextMenu` prop instead.');
      /* eslint-enable no-console */
    }

    this._warned = true;
    return 'context';
  }
};
Menu_Menu.propTypes = {
  /**
   * An id to provide to the menu's container. This is required for accessibility as it generates
   * the `aria-` attributes for dynamic content.
   *
   * @see {@link #listId}
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * An optional id to provide to the menu's list. If this prop is omitted, the list's id will be
   * `\`${id}-list\``
   */
  listId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply to the main container for the menu.
   */
  style: prop_types_default.a.object,

  /**
   * An optional class name to apply to the main container for the menu.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the list once the menu has opened.
   */
  listStyle: prop_types_default.a.object,

  /**
   * An optional class name to apply to the list once the menu has opened.
   */
  listClassName: prop_types_default.a.string,

  /**
   * The component to render the main container as.
   *
   * @see {@link Helpers/Layover#component}
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]),

  /**
   * This is how the menu's `List` gets anchored to the `toggle` element.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  anchor: anchorShape,

  /**
   * This is the optional anchor to use when the `position` is set to `Menu.Positions.BELOW`.
   * Set this to `null` to use the default `anchor` prop.
   *
   * @see {@link Helpers/Layover#belowAnchor}
   */
  belowAnchor: anchorShape,

  /**
   * This is the animation position for the list that appears.
   *
   * @see {@link Helpers/Layover#animationPosition}
   */
  position: positionShape,

  /**
   * This is the component/element that should toggle the menu open.
   *
   * @see {@link Helpers/Layover#toggle}
   */
  toggle: prop_types_default.a.node,

  /**
   * This is how the menu's list will be "fixed" to the `toggle` component.
   *
   * @see {@link Helpers/Layover#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * Any additional props that should be applied to the list in the menu. This is really used
   * when additional `aria-` tags need to be applied.
   */
  listProps: prop_types_default.a.object,

  /**
   * Boolean if the menu's list should appear horizontally instead of vertically.
   */
  listInline: prop_types_default.a.bool,

  /**
   * The list's z-depth for applying box shadow. This should be a number from 0 to 5.
   */
  listZDepth: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the list should have its height restricted to the `$md-menu-mobile-max-height`/
   * `$md-menu-desktop-max-height` values.
   *
   * @see [md-menu-mobile-max-height](/components/menus?tab=2#variable-md-menu-mobile-max-height)
   * @see [md-menu-desktop-max-height](/components/menus?tab=2#variable-md-menu-desktop-max-height)
   */
  listHeightRestricted: prop_types_default.a.bool,

  /**
   * Boolean if the menu's list is visible.
   */
  visible: prop_types_default.a.bool.isRequired,

  /**
   * Any children to render in the menu's list. This _should_ normally be `ListItem`, or
   * `ListItemControl`.
   */
  children: prop_types_default.a.node,

  /**
   * An optional function to call when en element in the menu has been clicked.
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional function to call when a key is pressed anywhere in the menu.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * A function to call to close the menu. This is used for closing on outside clicks,
   * closing when a list item has been clicked, or the user presses escape.
   */
  onClose: prop_types_default.a.func.isRequired,

  /**
   * Boolean if the menu should be cascading. This means that the menu will pop the additional
   * `nestedItems` on any `ListItem` to be appear either to the right or left of the visible list.
   */
  cascading: prop_types_default.a.bool,

  /**
   * This is how the cascading lists get anchored to the list item.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  cascadingAnchor: Helpers_Layover.propTypes.anchor,

  /**
   * This is the z-depth the list should gain for a cascading menu. This only gets applied on
   * items that are more than 1 level deep.
   */
  cascadingZDepth: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the `md-full-width` class name should get applied to the menu's container.
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * Boolean if the menu should be displayed as a block instead of as an inline block.
   *
   * @see {@link #fullWidth}
   */
  block: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#centered}
   */
  centered: Helpers_Layover.propTypes.centered,

  /**
   * @see {@link Helpers/Layover#sameWidth}
   */
  sameWidth: Helpers_Layover.propTypes.sameWidth,

  /**
   * If you would like the menu to interact as a context menu, provide this prop.
   *
   * @see {@link Helpers/Layover#onContextMenu}
   */
  onContextMenu: Helpers_Layover.propTypes.onContextMenu,

  /**
   * Boolean if the default behavior of the context menu should be prevented when using the
   * `onContextMenu` prop.
   *
   * @see {@link Helpers/Layover#preventContextMenu}
   */
  preventContextMenu: Helpers_Layover.propTypes.preventContextMenu,

  /**
   * @see {@link Helpers/Layover#xThreshold}
   */
  xThreshold: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#yThreshold}
   */
  yThreshold: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#closeOnOutsideClick}
   */
  closeOnOutsideClick: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#toggleQuery}
   */
  toggleQuery: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.object, prop_types_default.a.string]),

  /**
   * An optional transition name to use for the list appearing/disappearing.
   *
   * @see {@link Helpers/Layover#transitionName}
   */
  transitionName: prop_types_default.a.string,

  /**
   * @see {@link Helpers/Layover#transitionEnterTimeout}
   */
  transitionEnterTimeout: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#transitionLeaveTimeout}
   */
  transitionLeaveTimeout: prop_types_default.a.number,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#simplified}
   */
  simplified: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#minLeft}
   */
  minLeft: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * @see {@link Helpers/Layover#minRight}
   */
  minRight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * @see {@link Helpers/Layover#minBottom}
   */
  minBottom: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * @see {@link Helpers/Layover#fillViewportWidth}
   */
  fillViewportWidth: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#fillViewportHeight}
   */
  fillViewportHeight: prop_types_default.a.bool,

  isOpen: deprecated_default()(prop_types_default.a.bool, 'Use `visible` instead'),
  close: deprecated_default()(prop_types_default.a.func, 'Use `onClose` instead'),
  autoclose: deprecated_default()(prop_types_default.a.bool, 'The menus will always autoclose as according to the specs'),
  contained: deprecated_default()(prop_types_default.a.bool, 'Use `sameWidth` instead'),
  limitHeight: deprecated_default()(prop_types_default.a.bool, 'The menus will always be limited in height as according to the specs'),
  expanderIconClassName: deprecated_default()(prop_types_default.a.node, 'The expander for cascading menus will now just be a simple rotate of the existing `ListItem` ' + 'expander icon'),
  expanderIconChildren: deprecated_default()(prop_types_default.a.node, 'The expander for cascading menus will now just be a simple rotate of the existing `ListItem` ' + 'expander icon')
};
Menu_Menu.defaultProps = {
  anchor: {
    x: Helpers_Layover.HorizontalAnchors.INNER_RIGHT,
    y: Helpers_Layover.VerticalAnchors.OVERLAP
  },
  cascadingAnchor: {
    x: Helpers_Layover.HorizontalAnchors.RIGHT,
    y: Helpers_Layover.VerticalAnchors.OVERLAP
  },
  position: Helpers_Layover.Positions.TOP_RIGHT,
  fixedTo: typeof window !== 'undefined' ? window : {},
  listZDepth: 2,
  listHeightRestricted: true,
  cascadingZDepth: 3,
  repositionOnScroll: true,
  repositionOnResize: false,
  simplified: true
};
Menu_Menu.contextTypes = {
  listLevel: prop_types_default.a.number,
  cascadingId: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),
  cascadingMenu: prop_types_default.a.bool,
  cascadingAnchor: anchorShape,
  cascadingZDepth: prop_types_default.a.number
};
Menu_Menu.childContextTypes = {
  listLevel: prop_types_default.a.number,
  cascadingId: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),
  cascadingMenu: prop_types_default.a.bool,
  cascadingFixedTo: fixedToShape,
  cascadingAnchor: anchorShape,
  cascadingZDepth: prop_types_default.a.number
};
/* harmony default export */ var Menus_Menu = (Menu_Menu);
// CONCATENATED MODULE: ../node_modules/react-md/es/Lists/ListItem.js
var ListItem_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function ListItem_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ListItem_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ListItem_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ListItem_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }























/**
 * The `ListItem` component is used for rendering a `li` tag with text and optional
 * icons/avatars.
 */

var ListItem_ListItem = function (_PureComponent) {
  ListItem_inherits(ListItem, _PureComponent);

  function ListItem(props) {
    ListItem_classCallCheck(this, ListItem);

    var _this = ListItem_possibleConstructorReturn(this, _PureComponent.call(this, props));

    ListItem_initialiseProps.call(_this);

    _this.state = { active: false };

    if (typeof props.isOpen === 'undefined' && typeof props.visible === 'undefined') {
      var defined = function defined(v) {
        return typeof v !== 'undefined';
      };
      var _this$props = _this.props,
          initiallyOpen = _this$props.initiallyOpen,
          defaultOpen = _this$props.defaultOpen,
          defaultVisible = _this$props.defaultVisible;

      var visible = defined(initiallyOpen) ? initiallyOpen : defaultVisible;
      visible = defined(defaultOpen) ? defaultOpen : visible;
      visible = !!visible;

      _this.state.visible = visible;
    }
    return _this;
  }

  ListItem.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.state.active) {
      window.removeEventListener('click', this._handleOutsideClick);
    }

    if (this._touchTimeout) {
      clearTimeout(this._touchTimeout);
    }
  };

  /**
   * A utility function to focus the `AccessibleFakeInkedButton` in the `ListItem` and also
   * inject an ink to indicate focus.
   */


  /**
   * A utility function to blur the `AccessibleFakeInkedButton` in the `ListItem`.
   */


  ListItem.prototype._renderChildrenIfInside = function _renderChildrenIfInside() {
    var _props = this.props,
        children = _props.children,
        renderChildrenOutside = _props.renderChildrenOutside;


    return !renderChildrenOutside ? children : null;
  };

  ListItem.prototype._renderChildrenIfOutside = function _renderChildrenIfOutside() {
    var _props2 = this.props,
        children = _props2.children,
        renderChildrenOutside = _props2.renderChildrenOutside;


    if (renderChildrenOutside) {
      return react_default.a.createElement(
        'div',
        { className: 'md-list-item--flex' },
        react_default.a.createElement(Dividers_Divider, { vertical: true, className: 'md-list-item--divider-vertical' }),
        react_default.a.createElement(
          'div',
          { className: 'md-list-item--children-inline' },
          children
        )
      );
    }

    return null;
  };

  ListItem.prototype.render = function render() {
    var _cn;

    var _props3 = this.props,
        style = _props3.style,
        className = _props3.className,
        tileStyle = _props3.tileStyle,
        tileClassName = _props3.tileClassName,
        contentStyle = _props3.contentStyle,
        contentClassName = _props3.contentClassName,
        leftNodeStyle = _props3.leftNodeStyle,
        leftNodeClassName = _props3.leftNodeClassName,
        rightNodeStyle = _props3.rightNodeStyle,
        rightNodeClassName = _props3.rightNodeClassName,
        primaryTextStyle = _props3.primaryTextStyle,
        primaryTextClassName = _props3.primaryTextClassName,
        secondaryTextStyle = _props3.secondaryTextStyle,
        secondaryTextClassName = _props3.secondaryTextClassName,
        nestedListStyle = _props3.nestedListStyle,
        nestedListClassName = _props3.nestedListClassName,
        nestedListHeightRestricted = _props3.nestedListHeightRestricted,
        disabled = _props3.disabled,
        leftIcon = _props3.leftIcon,
        leftAvatar = _props3.leftAvatar,
        inset = _props3.inset,
        rightIcon = _props3.rightIcon,
        rightAvatar = _props3.rightAvatar,
        primaryText = _props3.primaryText,
        secondaryText = _props3.secondaryText,
        threeLines = _props3.threeLines,
        nestedItems = _props3.nestedItems,
        prependNested = _props3.prependNested,
        active = _props3.active,
        activeClassName = _props3.activeClassName,
        activeBoxStyle = _props3.activeBoxStyle,
        activeBoxClassName = _props3.activeBoxClassName,
        animateNestedItems = _props3.animateNestedItems,
        expanderIcon = _props3.expanderIcon,
        expanderLeft = _props3.expanderLeft,
        component = _props3.component,
        ItemComponent = _props3.itemComponent,
        itemProps = _props3.itemProps,
        tileProps = _props3.tileProps,
        passPropsToItem = _props3.passPropsToItem,
        ariaSize = _props3['aria-setsize'],
        ariaPos = _props3['aria-posinset'],
        renderChildrenOutside = _props3.renderChildrenOutside,
        isOpen = _props3.isOpen,
        expanderIconChildren = _props3.expanderIconChildren,
        expanderIconClassName = _props3.expanderIconClassName,
        propVisible = _props3.visible,
        defaultVisible = _props3.defaultVisible,
        itemRef = _props3.itemRef,
        defaultOpen = _props3.defaultOpen,
        initiallyOpen = _props3.initiallyOpen,
        props = ListItem_objectWithoutProperties(_props3, ['style', 'className', 'tileStyle', 'tileClassName', 'contentStyle', 'contentClassName', 'leftNodeStyle', 'leftNodeClassName', 'rightNodeStyle', 'rightNodeClassName', 'primaryTextStyle', 'primaryTextClassName', 'secondaryTextStyle', 'secondaryTextClassName', 'nestedListStyle', 'nestedListClassName', 'nestedListHeightRestricted', 'disabled', 'leftIcon', 'leftAvatar', 'inset', 'rightIcon', 'rightAvatar', 'primaryText', 'secondaryText', 'threeLines', 'nestedItems', 'prependNested', 'active', 'activeClassName', 'activeBoxStyle', 'activeBoxClassName', 'animateNestedItems', 'expanderIcon', 'expanderLeft', 'component', 'itemComponent', 'itemProps', 'tileProps', 'passPropsToItem', 'aria-setsize', 'aria-posinset', 'renderChildrenOutside', 'isOpen', 'expanderIconChildren', 'expanderIconClassName', 'visible', 'defaultVisible', 'itemRef', 'defaultOpen', 'initiallyOpen']);

    var _context = this.context,
        cascadingId = _context.cascadingId,
        cascadingMenu = _context.cascadingMenu,
        cascadingAnchor = _context.cascadingAnchor,
        cascadingFixedTo = _context.cascadingFixedTo;

    var visible = getField(this.props, this.state, 'visible');
    if (typeof isOpen !== 'undefined') {
      visible = isOpen;
    }

    var leftNode = react_default.a.createElement(Lists_TileAddon, {
      key: 'left-addon',
      style: leftNodeStyle,
      className: leftNodeClassName,
      active: active,
      activeClassName: activeClassName,
      icon: leftIcon,
      avatar: leftAvatar
    });

    var rightNode = react_default.a.createElement(Lists_TileAddon, {
      key: 'right-addon',
      style: rightNodeStyle,
      className: rightNodeClassName,
      active: active,
      activeClassName: activeClassName,
      icon: rightIcon,
      avatar: rightAvatar
    });

    var nestedList = void 0;
    if (nestedItems) {
      if (!cascadingMenu) {
        nestedList = react_default.a.createElement(
          Helpers_Collapse,
          { collapsed: !visible, animate: animateNestedItems },
          react_default.a.createElement(
            Lists_List,
            { style: nestedListStyle, className: nestedListClassName },
            nestedItems
          )
        );
      }

      var icon = react_default.a.Children.only(getDeprecatedIcon(expanderIconClassName, expanderIconChildren, expanderIcon));
      var collapser = react_default.a.createElement(Lists_TileAddon, {
        key: 'expander-addon',
        icon: react_default.a.cloneElement(icon, {
          className: getCollapserStyles({ flipped: visible }, icon.props.className)
        }),
        avatar: null
      });

      if (expanderLeft) {
        if (!leftIcon && !leftAvatar) {
          leftNode = collapser;
        }
      } else if (!rightIcon && !rightAvatar) {
        rightNode = collapser;
      }
    }

    var icond = !!leftIcon || !!rightIcon || !!nestedItems;
    var avatard = !!leftAvatar || !!rightAvatar;

    var tile = react_default.a.createElement(
      AccessibleFakeInkedButton,
      ListItem_extends({}, tileProps, passPropsToItem ? undefined : props, {
        component: component,
        __SUPER_SECRET_REF__: this._setTile,
        key: 'tile',
        onClick: this._handleClick,
        onMouseOver: this._handleMouseOver,
        onMouseLeave: this._handleMouseLeave,
        onTouchStart: this._handleTouchStart,
        onTouchEnd: this._handleTouchEnd,
        onKeyDown: this._handleKeyDown,
        onKeyUp: this._handleKeyUp,
        disabled: disabled,
        style: tileStyle,
        className: classnames_default()('md-list-tile', {
          'md-list-tile--active': this.state.active && !this._touched,
          'md-list-tile--icon': !secondaryText && icond && !avatard,
          'md-list-tile--avatar': !secondaryText && avatard,
          'md-list-tile--two-lines': secondaryText && !threeLines,
          'md-list-tile--three-lines': secondaryText && threeLines,
          'md-list-item--inset': inset && !leftIcon && !leftAvatar,
          'md-list-item--button-grow': renderChildrenOutside
        }, themeColors({ disabled: disabled, text: true }), tileClassName),
        'aria-expanded': nestedList && !cascadingMenu ? visible : null
      }),
      leftNode,
      react_default.a.createElement(Lists_ListItemText, {
        active: active,
        activeClassName: activeClassName,
        disabled: disabled,
        primaryText: primaryText,
        secondaryText: secondaryText,
        threeLines: threeLines,
        style: contentStyle,
        className: classnames_default()({
          'md-tile-content--left-icon': leftIcon || expanderLeft && nestedItems,
          'md-tile-content--left-avatar': leftAvatar,
          'md-tile-content--right-padding': rightIcon || rightAvatar
        }, contentClassName),
        primaryTextStyle: primaryTextStyle,
        primaryTextClassName: primaryTextClassName,
        secondaryTextStyle: secondaryTextStyle,
        secondaryTextClassName: secondaryTextClassName
      }),
      rightNode,
      this._renderChildrenIfInside()
    );

    var sharedProps = ListItem_extends({}, itemProps, passPropsToItem ? props : undefined, {
      style: Object.assign({}, style, active ? activeBoxStyle : null),
      className: classnames_default()('md-list-item', (_cn = {
        'md-list-item--nested-container': nestedItems
      }, _cn[activeBoxClassName] = activeBoxClassName && active, _cn['md-list-item--flex'] = renderChildrenOutside, _cn), className),
      'aria-setsize': ariaSize,
      'aria-posinset': ariaPos,
      ref: this._setContainer
    });
    if (cascadingMenu && nestedItems) {
      return react_default.a.createElement(
        Menus_Menu,
        ListItem_extends({
          id: cascadingId,
          visible: visible,
          onClose: this._handleClick,
          toggle: tile,
          block: true,
          simplified: false,
          anchor: cascadingAnchor,
          belowAnchor: null,
          position: Menus_Menu.Positions.BELOW,
          component: ItemComponent,
          listStyle: nestedListStyle,
          listClassName: nestedListClassName,
          listHeightRestricted: nestedListHeightRestricted
        }, sharedProps, {
          fixedTo: cascadingFixedTo
        }),
        nestedItems
      );
    }

    return react_default.a.createElement(
      ItemComponent,
      sharedProps,
      prependNested ? nestedList : null,
      tile,
      this._renderChildrenIfOutside(),
      prependNested ? null : nestedList
    );
  };

  return ListItem;
}(react["PureComponent"]);

ListItem_ListItem.propTypes = {
  /**
   * An optional style to apply to the `li` tag.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the `li` tag.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the `.md-list-tile`.
   *
   * @see {@link #component}
   */
  tileStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the `.md-list-tile`.
   *
   * @see {@link #component}
   */
  tileClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the div that surrounds the `primaryText` and `secondaryText`
   * nodes.
   */
  contentStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the div that surrounds the `primaryText` and `secondaryText`
   * nodes.
   */
  contentClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the element that is rendered before content node.
   */
  leftNodeStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the element that is rendered before content node.
   */
  leftNodeClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the element that is rendered after content node.
   */
  rightNodeStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the element that is rendered after content node.
   */
  rightNodeClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the div surrounding the `primaryText`.
   */
  primaryTextStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the div surrounding the `primaryText`.
   */
  primaryTextClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the div surrounding the `secondaryText`.
   */
  secondaryTextStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the div surrounding the `secondaryText`.
   */
  secondaryTextClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the nested `List` that gets created when using `nestedItems`.
   */
  nestedListStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the nested `List` that gets created when using `nestedItems`.
   */
  nestedListClassName: prop_types_default.a.string,

  /**
   * Boolean if the nested `List` in a cascading menu should be restricted.
   */
  nestedListHeightRestricted: prop_types_default.a.bool,

  /**
   * Any additional children to display in the `.md-list-tile`. If you use this prop,
   * you will most likely need to override the `height` for the `.md-list-tile--icon`,
   * `.md-list-tile--avatar`, `.md-list-tile--two-lines`, and/or `.md-list-tile--three-lines`
   * to get it to display correctly unless the children are positioned `absolute`.
   */
  children: prop_types_default.a.node,

  /**
   * Boolean if the `ListItem` is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * An optional tab index for the `.md-list-tile`. If omitted, it will default to the
   * `AccessibleFakeButton`'s `tabIndex` default prop value.
   */
  tabIndex: prop_types_default.a.number,

  /**
   * The primary text to display. This will only be rendered as a single line. Any overflown
   * text will be converted to ellipsis.
   */
  primaryText: prop_types_default.a.node.isRequired,

  /**
   * An optional secondary text to display below the `primaryText`. This can be an additional
   * one or two lines. Like the `primaryText`, and overflown text will be converted to ellipsis.
   *
   * You must set the `threeLines` prop to `true` if you want this to be displayed as two lines.
   */
  secondaryText: prop_types_default.a.node,

  /**
   * An optional `FontIcon` to display to the left of the text.
   */
  leftIcon: prop_types_default.a.node,

  /**
   * An optional `Avatar` to display to the left of the text. If you have a mixed `List` of
   * `FontIcon` and `Avatar`, it is recommended to set the `iconSized` prop on the `Avatar` to
   * `true` so that the `Avatar` will be scaled down to the `FontIcon` size.
   */
  leftAvatar: prop_types_default.a.node,

  /**
   * An optional `FontIcon` to display to the right of the text.
   */
  rightIcon: prop_types_default.a.node,

  /**
   * An optional `Avatar` to display to the right of the text. If you have a mixed `List` of
   * `FontIcon` and `Avatar`, it is recommended to set the `iconSized` prop on the `Avatar` to
   * `true` so that the `Avatar` will be scaled down to the `FontIcon` size.
   */
  rightAvatar: prop_types_default.a.node,

  /**
   * Boolean if the list item should be inset as if there is a `leftIcon` or a `leftAvatar`.
   * This is used for some lists where only a parent contains the icon.
   */
  inset: prop_types_default.a.bool,

  /**
   * Boolean if the `secondaryText` should span two lines instead of one. This will include
   * three lines of text in total when including the `primaryText`.
   */
  threeLines: prop_types_default.a.bool,

  /**
   * The component to render the `.md-list-tile` as. This is mostly useful if you
   * want to use the `ListItem` for navigation and working with the `react-router`'s `Link`
   * component.
   *
   * This prop is **not** the top-most element of the `ListItem` component. To change the
   * top-most element, see the `itemComponent` prop.
   *
   * @see {@link #itemComponent}
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * The component to render the top-most element of the `ListItem` component. This is the
   * `.md-list-item` and defaults to the `<li>` element.
   *
   * @see {@link #component}
   * @see {@link #itemProps}
   */
  itemComponent: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * An optional ref callback to get reference to the top-most element of the `ListItem` component.
   * Just like other refs, this will provide null when it unmounts.
   */
  itemRef: prop_types_default.a.func,

  /**
   * An optional list of `ListItem`, `ListItemControl`, `Divider`, or `Subheader` components
   * to render in a nested list. This will inject an expander icon to the right of the text
   * in the `.md-list-tile` that rotates 180 degrees when open.
   *
   * The nested items will be visible once the user clicks on the `ListItem`.
   *
   * @see {@link #visible}
   */
  nestedItems: prop_types_default.a.arrayOf(prop_types_default.a.node),

  /**
   * An optional parameter determining whether `nestedItems` should be placed before or after `ListItemText`
   */
  prependNested: prop_types_default.a.bool,

  /**
   * Boolean if the `nestedItems` are visible by default.
   */
  defaultVisible: prop_types_default.a.bool,

  /**
   * Boolean if the `nestedItems` are visible. This will make the `nestedItems` controlled
   * and require the `onClick` function to be defined.
   *
   * @see {@link #defaultVisible}
   */
  visible: controlled(prop_types_default.a.bool, 'onClick', 'defaultVisible'),

  /**
   * An icon to use for the expander icon when there are nested items.
   */
  expanderIcon: prop_types_default.a.element,

  /**
   * Boolean if the expander icon should appear as the left icon instead of the right.
   */
  expanderLeft: prop_types_default.a.bool,

  /**
   * An optional function to call when the `.md-list-tile` is clicked. This is required if the
   * `visible` prop is defined.
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `mouseover` event.
   */
  onMouseOver: prop_types_default.a.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `mouseleave` event.
   */
  onMouseLeave: prop_types_default.a.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `touchstart` event.
   */
  onTouchStart: prop_types_default.a.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `touchend` event.
   */
  onTouchEnd: prop_types_default.a.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `keydown` event.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `keyup` event.
   */
  onKeyUp: prop_types_default.a.func,

  /**
   * Boolean if the `ListItem` is currently active. This will apply the `activeClassName` prop
   * to the `leftIcon`, `rightIcon`, and the `primaryText`.
   */
  active: prop_types_default.a.bool,

  /**
   * The className to apply to the `leftIcon`, `rightIcon`, and `primaryText` when the `active`
   * prop is `true`.
   */
  activeClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the top-most element of the `ListItem` component (`.md-list-item`)
   * when the `active` prop is `true`.
   */
  activeBoxStyle: prop_types_default.a.object,

  /**
   * The className to apply to the top-most element of the `ListItem` component (`.md-list-item`)
   * when the `active` prop is `true`.
   */
  activeBoxClassName: prop_types_default.a.string,

  /**
   * Boolean if the nested items should animate when they appear or disappear.
   */
  animateNestedItems: prop_types_default.a.bool,

  /**
   * Boolean if the children should be rendered outside auf the AccessibleFakeButton component.
   */
  renderChildrenOutside: prop_types_default.a.bool,

  /**
   * Defines the number of items in the list. This is only required when all items in the
   * list are not present in the DOM.
   *
   * @see https://www.w3.org/TR/wai-aria/states_and_properties#aria-setsize
   */
  'aria-setsize': prop_types_default.a.number,

  /**
   * Defines the items position in the list. This is only required when all items in the list
   * are not present in the DOM. The custom validation just requires this prop if the `aria-setsize`
   * prop is defined as a helpful reminder.
   *
   * @see https://www.w3.org/TR/wai-aria/states_and_properties#aria-posinset
   */
  'aria-posinset': function ariaPosinset(props, propName) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var validator = prop_types_default.a.number;
    if (typeof props['aria-setsize'] !== 'undefined') {
      validator = validator.isRequired;
    }

    return validator.apply(undefined, [props, propName].concat(args));
  },

  /**
   * Any additional props you would like to supply to the surrounding `<li>` tag for the `ListItem`.
   * By default, all props will be provided to the inner `AccessibleFakeButton`. If the `passPropsToItem`
   * prop is enabled, the remaining props will be provided to the `<li>` tag instead and this prop
   * is probably useless.
   */
  itemProps: prop_types_default.a.object,

  /**
   * Any additional props you would like to add to the inner `AccessibleFakeButton`. By default, all the
   * remaining props will be provided to the `AccessibleFakeButton`, so this prop is probably useless.
   * Enabling the `passPropsToItem` prop will change the default behavior so that the remaining props
   * are provided to the surrounding `<li>` node instead and this prop becomes useful.
   */
  tileProps: prop_types_default.a.object,

  /**
   * All the remaining props should be passed to the surrounding `<li>` node instead of the `AccessibleFakeButton`.
   *
   * > NOTE: This will most likely become the default in the next *major* release. Migration warnings will be added
   * if that is the case.
   */
  passPropsToItem: prop_types_default.a.bool,
  expanderIconChildren: deprecated_default()(prop_types_default.a.node, 'Use `expanderIcon` instead'),
  expanderIconClassName: deprecated_default()(prop_types_default.a.string, 'Use `expanderIcon` instead'),
  initiallyOpen: deprecated_default()(prop_types_default.a.bool, 'Use `defaultVisible` instead'),
  defaultOpen: deprecated_default()(prop_types_default.a.bool, 'Use `defaultVisible` instead'),
  isOpen: deprecated_default()(prop_types_default.a.bool, 'Use `visible` instead')
};
ListItem_ListItem.defaultProps = {
  animateNestedItems: true,
  activeClassName: 'md-text--theme-primary',
  component: 'div',
  itemComponent: 'li',
  expanderIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'keyboard_arrow_down'
  ),
  renderChildrenOutside: false
};
ListItem_ListItem.contextTypes = {
  cascadingId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  cascadingMenu: prop_types_default.a.bool,
  cascadingAnchor: anchorShape,
  cascadingFixedTo: fixedToShape
};

var ListItem_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.focus = function () {
    if (_this2._tile) {
      _this2._tile.focus();
    }
  };

  this.blur = function () {
    if (_this2._tile) {
      _this2._tile.blur();
    }
  };

  this._setTile = function (tile) {
    if (tile) {
      _this2._tile = tile;
      _this2._tileNode = Object(react_dom["findDOMNode"])(tile);
    }
  };

  this._setContainer = function (container) {
    var itemRef = _this2.props.itemRef;

    if (container) {
      _this2._container = Object(react_dom["findDOMNode"])(container);
    }
    if (itemRef) {
      itemRef(container ? _this2._container : null);
    }
  };

  this._handleOutsideClick = function (e) {
    if (_this2._container && !_this2._container.contains(e.target)) {
      window.removeEventListener('click', _this2._handleOutsideClick);
      _this2.setState({ active: false });
    }
  };

  this._handleClick = function (e) {
    if (_this2.props.onClick) {
      _this2.props.onClick(e);
    }

    if (typeof _this2.state.visible !== 'undefined') {
      _this2.setState({ visible: !_this2.state.visible });
    }
  };

  this._handleMouseOver = function (e) {
    if (_this2.props.onMouseOver) {
      _this2.props.onMouseOver(e);
    }

    if (!_this2.props.disabled) {
      _this2.setState({ active: true });
    }
  };

  this._handleMouseLeave = function (e) {
    if (_this2.props.onMouseLeave) {
      _this2.props.onMouseLeave(e);
    }

    if (!_this2.props.disabled) {
      _this2.setState({ active: false });
    }
  };

  this._handleTouchStart = function (e) {
    if (_this2.props.onTouchStart) {
      _this2.props.onTouchStart(e);
    }

    _this2._touched = true;

    _this2.setState({ active: true, touchedAt: Date.now() });
  };

  this._handleTouchEnd = function (e) {
    if (_this2.props.onTouchEnd) {
      _this2.props.onTouchEnd(e);
    }

    var time = Date.now() - _this2.state.touchedAt;
    _this2._touchTimeout = setTimeout(function () {
      _this2._touchTimeout = null;

      _this2.setState({ active: false });
    }, time > 450 ? 0 : 450 - time);
  };

  this._handleKeyUp = function (e) {
    if (_this2.props.onKeyUp) {
      _this2.props.onKeyUp(e);
    }

    if ((e.which || e.keyCode) === TAB) {
      window.addEventListener('click', _this2._handleOutsideClick);
      _this2.setState({ active: true });
    }
  };

  this._handleKeyDown = function (e) {
    if (_this2.props.onKeyDown) {
      _this2.props.onKeyDown(e);
    }

    if ((e.which || e.keyCode) === TAB) {
      window.removeEventListener('click', _this2._handleOutsideClick);
      _this2.setState({ active: false });
    }
  };
};

/* harmony default export */ var Lists_ListItem = (ListItem_ListItem);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/isValued.js
/** @module utils/isValied */

/**
 * A really simple utility function to check if an input's value is considered "valued".
 *
 * @param {string|number} v - the value to check
 * @return {boolean} true if the value is a number or a non-empty string.
 */
function isValued(v) {
  return v === 0 || !!v;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/PropTypes/minNumber.js
/** @module utils/PropTypes/minNumber */


/**
 * Validates the a prop's value is greater than or equal to the minimum value.
 *
 * @param {Number} min - the minimum value for the prop.
 * @param {Boolean} required - Boolean if the prop is required.
 * @return {Error} an error or null.
 */
function minNumber(min, required) {
  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    var validator = prop_types_default.a.number;
    if (required) {
      validator = validator.isRequired;
    }

    for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      args[_key - 5] = arguments[_key];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (!required && !err && props[propName] < min) {
      err = new Error('The ' + location + ' `' + propFullNameSafe + '` must be greater than or equal to the min value ' + ('`' + min + '` but received `' + props[propName] + '` for the `' + componentNameSafe + '` component.'));
    }

    return err;
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/StringUtils/addSuffix.js
/** @module utils/StringUtils/addSuffix */

/**
 * Optionally adds a suffix to a string if it does
 * not already contain that string.
 *
 * @param {String} str - The string to modify
 * @param {String} suffix - The suffix to add
 *
 * @return {String} the string with a suffix
 */
function addSuffix(str, suffix) {
  if (!str || typeof str !== 'string') {
    return str;
  }

  return str.indexOf(suffix) === -1 ? str.trim() + ' ' + suffix : str;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/TextFields/FloatingLabel.js
var FloatingLabel_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function FloatingLabel_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function FloatingLabel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FloatingLabel_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function FloatingLabel_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var FloatingLabel_FloatingLabel = function (_PureComponent) {
  FloatingLabel_inherits(FloatingLabel, _PureComponent);

  function FloatingLabel() {
    FloatingLabel_classCallCheck(this, FloatingLabel);

    return FloatingLabel_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  FloatingLabel.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        label = _props.label,
        htmlFor = _props.htmlFor,
        className = _props.className,
        floating = _props.floating,
        active = _props.active,
        error = _props.error,
        disabled = _props.disabled,
        iconOffset = _props.iconOffset,
        customSize = _props.customSize,
        props = FloatingLabel_objectWithoutProperties(_props, ['label', 'htmlFor', 'className', 'floating', 'active', 'error', 'disabled', 'iconOffset', 'customSize']);

    if (!label) {
      return null;
    }

    return react_default.a.createElement(
      'label',
      FloatingLabel_extends({}, props, {
        htmlFor: htmlFor,
        className: classnames_default()('md-floating-label', (_cn = {
          'md-floating-label--inactive': !floating,
          'md-floating-label--inactive-sized': !floating && !customSize
        }, _cn['md-floating-label--' + customSize] = customSize, _cn['md-floating-label--inactive-' + customSize] = customSize && !floating, _cn['md-floating-label--floating'] = floating, _cn['md-floating-label--icon-offset'] = iconOffset, _cn), themeColors({
          disabled: disabled,
          error: error,
          hint: !active,
          primary: active
        }, className))
      }),
      label
    );
  };

  return FloatingLabel;
}(react["PureComponent"]);

FloatingLabel_FloatingLabel.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  label: prop_types_default.a.node,
  floating: prop_types_default.a.bool,
  error: prop_types_default.a.bool,
  active: prop_types_default.a.bool,
  disabled: prop_types_default.a.bool,
  iconOffset: prop_types_default.a.bool,
  customSize: prop_types_default.a.string,
  htmlFor: prop_types_default.a.string
};
/* harmony default export */ var TextFields_FloatingLabel = (FloatingLabel_FloatingLabel);
// CONCATENATED MODULE: ../node_modules/react-md/es/TextFields/Message.js
function Message_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Message_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Message_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var Message_Message = function (_PureComponent) {
  Message_inherits(Message, _PureComponent);

  function Message() {
    Message_classCallCheck(this, Message);

    return Message_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Message.prototype.render = function render() {
    var _props = this.props,
        active = _props.active,
        children = _props.children,
        className = _props.className;


    if (!children) {
      return null;
    }

    return react_default.a.createElement(
      'div',
      {
        'aria-hidden': !active,
        className: classnames_default()('md-text-field-message', 'md-text-field-message--' + (active ? '' : 'in') + 'active', className)
      },
      children
    );
  };

  return Message;
}(react["PureComponent"]);

Message_Message.propTypes = {
  active: prop_types_default.a.bool,
  className: prop_types_default.a.string,
  children: prop_types_default.a.node
};
/* harmony default export */ var TextFields_Message = (Message_Message);
// CONCATENATED MODULE: ../node_modules/react-md/es/TextFields/TextFieldMessage.js
function TextFieldMessage_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TextFieldMessage_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TextFieldMessage_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var TextFieldMessage_TextFieldMessage = function (_PureComponent) {
  TextFieldMessage_inherits(TextFieldMessage, _PureComponent);

  function TextFieldMessage(props) {
    TextFieldMessage_classCallCheck(this, TextFieldMessage);

    var _this = TextFieldMessage_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = {
      message: props.error && props.errorText || props.helpText || props.errorText,
      isMessageVisible: _this._isMessageVisible(props)
    };
    return _this;
  }

  TextFieldMessage.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var keys = ['active', 'error', 'helpOnFocus', 'helpText', 'errorText'];
    if (this._anyChanges(keys, this.props, nextProps)) {
      this.setState({
        isMessageVisible: this._isMessageVisible(nextProps),
        message: nextProps.error && nextProps.errorText || nextProps.helpText || nextProps.errorText
      });
    }
  };

  TextFieldMessage.prototype._anyChanges = function _anyChanges(keys, p1, p2) {
    var changed = false;
    keys.some(function (key) {
      if (p1[key] !== p2[key]) {
        changed = true;
      }

      return changed;
    });

    return changed;
  };

  TextFieldMessage.prototype._isMessageVisible = function _isMessageVisible(props) {
    var error = props.error,
        errorText = props.errorText,
        helpText = props.helpText,
        helpOnFocus = props.helpOnFocus,
        active = props.active;

    if (error && errorText) {
      return true;
    }

    return !!(helpText && (!helpOnFocus || active));
  };

  TextFieldMessage.prototype.render = function render() {
    var _props = this.props,
        maxLength = _props.maxLength,
        error = _props.error,
        className = _props.className,
        errorText = _props.errorText,
        helpText = _props.helpText,
        currentLength = _props.currentLength,
        leftIcon = _props.leftIcon,
        rightIcon = _props.rightIcon,
        block = _props.block,
        active = _props.active;
    var _state = this.state,
        isMessageVisible = _state.isMessageVisible,
        message = _state.message;


    if (currentLength === 'undefined' || !helpText && !errorText && !maxLength) {
      return null;
    }

    return react_default.a.createElement(
      'div',
      {
        className: classnames_default()('md-text-field-message-container', {
          'md-text-field-message-container--count-only': !message || !isMessageVisible,
          'md-text-field-message-container--left-icon-offset': leftIcon,
          'md-text-field-message-container--right-icon-offset': rightIcon,
          'md-full-width': !block
        }, themeColors({ error: error, disabled: !error }), className)
      },
      react_default.a.createElement(
        TextFields_Message,
        { key: 'message', active: isMessageVisible },
        message
      ),
      react_default.a.createElement(
        TextFields_Message,
        { key: 'counter', className: 'md-text-field-message--counter', active: active },
        maxLength ? currentLength + ' / ' + maxLength : null
      )
    );
  };

  return TextFieldMessage;
}(react["PureComponent"]);

TextFieldMessage_TextFieldMessage.propTypes = {
  className: prop_types_default.a.string,
  error: prop_types_default.a.bool,
  helpText: prop_types_default.a.node,
  errorText: prop_types_default.a.node,
  active: prop_types_default.a.bool,
  helpOnFocus: prop_types_default.a.bool,
  maxLength: prop_types_default.a.number,
  currentLength: prop_types_default.a.number,
  leftIcon: prop_types_default.a.bool,
  rightIcon: prop_types_default.a.bool,
  block: prop_types_default.a.bool
};
/* harmony default export */ var TextFields_TextFieldMessage = (TextFieldMessage_TextFieldMessage);
// CONCATENATED MODULE: ../node_modules/react-md/es/TextFields/PasswordButton.js
var PasswordButton_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function PasswordButton_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function PasswordButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PasswordButton_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function PasswordButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var PasswordButton_PasswordButton = function (_PureComponent) {
  PasswordButton_inherits(PasswordButton, _PureComponent);

  function PasswordButton() {
    var _temp, _this, _ret;

    PasswordButton_classCallCheck(this, PasswordButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = PasswordButton_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { keyboardFocus: false }, _this._handleOutsideClick = function (e) {
      if (_this._button && !_this._button.contains(e.target)) {
        window.removeEventListener('click', _this._handleOutsideClick);
        _this.setState({ keyboardFocus: false });
      }
    }, _this._handleBlur = function () {
      if (_this.state.keyboardFocus) {
        _this.setState({ keyboardFocus: false });
      }
    }, _this._handleKeyUp = function (e) {
      var key = e.which || e.keyCode;
      if (key === TAB) {
        _this.setState({ keyboardFocus: true });
      }
    }, _temp), PasswordButton_possibleConstructorReturn(_this, _ret);
  }

  PasswordButton.prototype.render = function render() {
    var keyboardFocus = this.state.keyboardFocus;

    var _props = this.props,
        active = _props.active,
        passwordVisible = _props.passwordVisible,
        block = _props.block,
        floating = _props.floating,
        icon = _props.icon,
        props = PasswordButton_objectWithoutProperties(_props, ['active', 'passwordVisible', 'block', 'floating', 'icon']);

    return react_default.a.createElement(
      'button',
      PasswordButton_extends({}, props, {
        onBlur: this._handleBlur,
        onKeyUp: this._handleKeyUp,
        type: 'button',
        className: classnames_default()('md-text-field-inline-indicator md-password-btn md-pointer--hover', {
          'md-password-btn--focus': keyboardFocus,
          'md-password-btn--invisible': active && !passwordVisible,
          'md-text-field-inline-indicator--floating': floating,
          'md-text-field-inline-indicator--block': block
        }, themeColors({ disabled: !active, hint: active }))
      }),
      icon
    );
  };

  return PasswordButton;
}(react["PureComponent"]);

PasswordButton_PasswordButton.propTypes = {
  active: prop_types_default.a.bool,
  passwordVisible: prop_types_default.a.bool,
  icon: prop_types_default.a.element,
  block: prop_types_default.a.bool,
  floating: prop_types_default.a.bool
};
/* harmony default export */ var TextFields_PasswordButton = (PasswordButton_PasswordButton);
// CONCATENATED MODULE: ../node_modules/react-md/es/TextFields/TextArea.js
var TextArea_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TextArea_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TextArea_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TextArea_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TextArea_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The `TextArea` component is used to allow a dynamic height for the
 * `textarea`. The height will keep on changing until the maxRows prop
 * is met or infinitely if it does not exist, or is 0.
 */

var TextArea_TextArea = function (_PureComponent) {
  TextArea_inherits(TextArea, _PureComponent);

  function TextArea() {
    var _temp, _this, _ret;

    TextArea_classCallCheck(this, TextArea);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = TextArea_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { height: null }, _this.getField = function () {
      return _this._field;
    }, _this.getValue = function () {
      return _this._field.value;
    }, _this.focus = function () {
      _this._field.focus();
    }, _this.blur = function () {
      _this._field.blur();
    }, _this._calcRowHeight = function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props,
          rows = _ref.rows;

      if (!_this._field) {
        return 19;
      }

      var height = _this._field.style.height;
      _this._field.style.height = 'auto';
      var rowHeight = _this._field.offsetHeight / rows;
      _this._field.style.height = height;
      return rowHeight;
    }, _this._setMask = function (mask) {
      _this._mask = mask;
    }, _this._setField = function (field) {
      _this._field = field;
    }, _this._handleResize = function () {
      _this._rowHeight = _this._calcRowHeight();
      _this._syncHeightWithMask();
    }, _this._syncHeightWithMask = function (value) {
      // The mask is always null in snapshot teseting
      if (!_this._mask) {
        return;
      }

      if (value !== undefined) {
        _this._mask.value = value;
      }

      var height = _this._mask.scrollHeight;
      if (height === undefined) {
        return;
      }

      var _this$props = _this.props,
          rows = _this$props.rows,
          maxRows = _this$props.maxRows;

      if (maxRows && maxRows > 0) {
        height = Math.min(height, _this._rowHeight * maxRows);
      }

      height = Math.max(_this._rowHeight * rows, height);
      _this.setState({ height: height });
    }, _this._handleChange = function (e) {
      _this._syncHeightWithMask(e.target.value, e);

      if (_this.props.onChange) {
        _this.props.onChange(e);
      }
    }, _temp), TextArea_possibleConstructorReturn(_this, _ret);
  }

  TextArea.prototype.componentDidMount = function componentDidMount() {
    this._rowHeight = this._calcRowHeight();
    this._syncHeightWithMask();
  };

  TextArea.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.rows !== nextProps.rows) {
      this._rowHeight = this._calcRowHeight(nextProps);
    }

    if (this.props.value !== nextProps.value || this.props.maxRows !== nextProps.maxRows) {
      this._syncHeightWithMask(nextProps.value);
    }
  };

  TextArea.prototype.render = function render() {
    var height = this.state.height;

    var _props = this.props,
        style = _props.style,
        defaultValue = _props.defaultValue,
        value = _props.value,
        className = _props.className,
        label = _props.label,
        block = _props.block,
        maxRows = _props.maxRows,
        onChange = _props.onChange,
        props = TextArea_objectWithoutProperties(_props, ['style', 'defaultValue', 'value', 'className', 'label', 'block', 'maxRows', 'onChange']);

    return react_default.a.createElement(
      'div',
      {
        style: { height: height && height + 5 },
        className: classnames_default()('md-text-field-multiline-container', {
          'md-text-field--margin': !label && !block,
          'md-text-field--floating-margin': label && !block
        })
      },
      react_default.a.createElement(Helpers_ResizeObserver, { watchWidth: true, onResize: this._handleResize }),
      react_default.a.createElement('textarea', {
        ref: this._setMask,
        className: classnames_default()(className, 'md-text-field--multiline-mask'),
        readOnly: true,
        rows: props.rows,
        tabIndex: -1,
        style: style,
        defaultValue: defaultValue,
        'aria-hidden': true,
        value: value
      }),
      react_default.a.createElement('textarea', TextArea_extends({}, props, {
        ref: this._setField,
        style: Object.assign({}, style, { height: height }),
        className: className,
        defaultValue: defaultValue,
        value: value,
        onChange: this._handleChange
      }))
    );
  };

  return TextArea;
}(react["PureComponent"]);

TextArea_TextArea.propTypes = {
  id: prop_types_default.a.string,
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  rows: prop_types_default.a.number.isRequired,
  maxRows: prop_types_default.a.number,
  onChange: prop_types_default.a.func,
  defaultValue: prop_types_default.a.string,
  floatingLabel: prop_types_default.a.bool,
  value: prop_types_default.a.string,
  block: prop_types_default.a.bool,
  label: prop_types_default.a.node
};
/* harmony default export */ var TextFields_TextArea = (TextArea_TextArea);
// CONCATENATED MODULE: ../node_modules/react-md/es/TextFields/InputField.js
var InputField_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function InputField_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function InputField_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function InputField_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function InputField_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








/**
 * This component either renders a base `input` tag or the `TextArea` component.
 */

var InputField_InputField = function (_PureComponent) {
  InputField_inherits(InputField, _PureComponent);

  function InputField() {
    var _temp, _this, _ret;

    InputField_classCallCheck(this, InputField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = InputField_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.getField = function () {
      // eslint-disable-line arrow-body-style
      return typeof _this.props.rows === 'undefined' ? _this._field : _this._field.getField();
    }, _this.getValue = function () {
      if (typeof _this.props.rows === 'undefined') {
        return _this._field.value;
      }

      return _this._field.getValue();
    }, _this.focus = function () {
      _this._field.focus();
    }, _this.blur = function () {
      _this._field.blur();
    }, _this._setField = function (field) {
      _this._field = field;
    }, _temp), InputField_possibleConstructorReturn(_this, _ret);
  }

  InputField.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        className = _props.className,
        rows = _props.rows,
        label = _props.label,
        customSize = _props.customSize,
        fullWidth = _props.fullWidth,
        type = _props.type,
        passwordVisible = _props.passwordVisible,
        block = _props.block,
        inlineIndicator = _props.inlineIndicator,
        maxRows = _props.maxRows,
        props = InputField_objectWithoutProperties(_props, ['className', 'rows', 'label', 'customSize', 'fullWidth', 'type', 'passwordVisible', 'block', 'inlineIndicator', 'maxRows']);

    var multiline = typeof rows !== 'undefined';
    var Component = multiline ? TextFields_TextArea : 'input';
    if (!multiline) {
      props.type = passwordVisible ? 'text' : type;
    } else {
      props.label = label;
      props.block = block;
      props.maxRows = maxRows;
    }

    return Object(react["createElement"])(Component, InputField_extends({}, props, {
      rows: rows,
      ref: this._setField,
      className: classnames_default()('md-text-field', (_cn = {
        'md-text-field--inline-indicator': inlineIndicator || !multiline && type === 'password',
        'md-text-field--multiline': multiline,
        'md-text-field--margin': !block && !multiline && !label,
        'md-text-field--floating-margin': !block && !multiline && label
      }, _cn['md-text-field--' + customSize] = customSize, _cn['md-full-width'] = fullWidth, _cn), themeColors({ disabled: props.disabled, text: !props.disabled }, className))
    }));
  };

  return InputField;
}(react["PureComponent"]);

InputField_InputField.propTypes = {
  id: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  type: prop_types_default.a.string,
  placeholder: prop_types_default.a.string,
  block: prop_types_default.a.bool,
  disabled: prop_types_default.a.bool,
  rows: prop_types_default.a.number,
  maxRows: prop_types_default.a.number,
  label: prop_types_default.a.node,
  fullWidth: prop_types_default.a.bool,
  customSize: prop_types_default.a.string,
  passwordVisible: prop_types_default.a.bool,
  inlineIndicator: prop_types_default.a.bool
};
/* harmony default export */ var TextFields_InputField = (InputField_InputField);
// CONCATENATED MODULE: ../node_modules/react-md/es/TextFields/TextFieldDivider.js
var TextFieldDivider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TextFieldDivider_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TextFieldDivider_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TextFieldDivider_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TextFieldDivider_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var TextFieldDivider_TextFieldDivider = function (_PureComponent) {
  TextFieldDivider_inherits(TextFieldDivider, _PureComponent);

  function TextFieldDivider() {
    TextFieldDivider_classCallCheck(this, TextFieldDivider);

    return TextFieldDivider_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  TextFieldDivider.prototype.render = function render() {
    var _props = this.props,
        active = _props.active,
        error = _props.error,
        lineDirection = _props.lineDirection,
        className = _props.className,
        props = TextFieldDivider_objectWithoutProperties(_props, ['active', 'error', 'lineDirection', 'className']);

    return react_default.a.createElement(Dividers_Divider, TextFieldDivider_extends({}, props, {
      className: classnames_default()('md-divider--text-field md-divider--expand-from-' + lineDirection, {
        'md-divider--text-field-expanded': active,
        'md-divider--text-field-active': !error && active,
        'md-divider--text-field-error': error
      }, className)
    }));
  };

  return TextFieldDivider;
}(react["PureComponent"]);

TextFieldDivider_TextFieldDivider.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  active: prop_types_default.a.bool,
  error: prop_types_default.a.bool,
  lineDirection: prop_types_default.a.oneOf(['left', 'center', 'right'])
};
/* harmony default export */ var TextFields_TextFieldDivider = (TextFieldDivider_TextFieldDivider);
// CONCATENATED MODULE: ../node_modules/react-md/es/TextFields/TextField.js
var TextField_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function TextField_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TextField_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TextField_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TextField_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






















var DEFAULT_TEXT_FIELD_SIZE = 180;

var WILL_RECEIVE_KEYS = ['style', 'value', 'resize'];
var DID_UPDATE_KEYS = ['leftIcon', 'rightIcon', 'passwordIcon', 'inlineIndicator'];

/**
 * The `TextField` component can either be a single line `input` field or a multiline
 * `textarea` field. `FontIcon`s, messages, and password indicators can also be added
 * to this field.
 *
 * The optional mouse and touch events will be added to the entire container while the
 * text specific events will be added to the `input` or `textarea` tags.
 */

var TextField_TextField = function (_PureComponent) {
  TextField_inherits(TextField, _PureComponent);

  function TextField(props) {
    TextField_classCallCheck(this, TextField);

    var _this = TextField_possibleConstructorReturn(this, _PureComponent.call(this, props));

    TextField_initialiseProps.call(_this);

    var currentLength = _this._getLength(typeof props.value !== 'undefined' ? props.value : props.defaultValue);

    _this._canvas = null;
    var width = null;
    if (typeof props.resize !== 'undefined') {
      width = typeof props.resize.min === 'number' ? props.resize.min : DEFAULT_TEXT_FIELD_SIZE;
    }

    _this.state = {
      active: false,
      error: props.maxLength ? props.maxLength < currentLength : false,
      floating: isValued(props.defaultValue) || isValued(props.value),
      passwordVisible: props.passwordInitiallyVisible,
      currentLength: currentLength,
      styles: width ? TextField_extends({ width: width }, props.style) : props.style
    };
    return _this;
  }

  TextField.prototype.componentDidMount = function componentDidMount() {
    var _props = this.props,
        value = _props.value,
        defaultValue = _props.defaultValue,
        resize = _props.resize,
        style = _props.style;

    var v = typeof value !== 'undefined' ? value : defaultValue;
    /* eslint-disable react/no-did-mount-set-state */
    if (resize) {
      // always want to set width on mount
      this.setState({ styles: TextField_extends({ width: this._calcWidth(v, this.props) }, style) });
    }
  };

  TextField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    var value = nextProps.value,
        resize = nextProps.resize,
        style = nextProps.style;

    var nextState = {};
    if (value !== this.props.value) {
      nextState.error = this._isErrored(nextProps);
      nextState.floating = this._focus || isValued(value);
      nextState.currentLength = this._getLength(value);
    }

    if (WILL_RECEIVE_KEYS.some(function (key) {
      return _this2.props[key] !== nextProps[key];
    })) {
      if (!resize) {
        nextState.styles = style;
      } else {
        var width = this._calcWidth(value, nextProps);
        nextState.styles = TextField_extends({ width: width }, style);
      }
    }

    this.setState(nextState);
  };

  TextField.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this3 = this;

    var _props2 = this.props,
        resize = _props2.resize,
        value = _props2.value,
        style = _props2.style;

    if (resize && DID_UPDATE_KEYS.some(function (key) {
      return _this3.props[key] !== prevProps[key];
    })) {
      var width = this._calcWidth(value, this.props);
      this.setState({ styles: TextField_extends({ width: width }, style) }); // eslint-disable-line react/no-did-update-set-state
    }
  };

  /**
   * A helper function for getting the specific `input` field or the `textarea` in the `TextField`.
   * This is accessible if you use `refs`.
   *
   * Example:
   *
   * ```js
   * <TextField ref={field => this._field = field;} label="Hello" />;
   *
   * this._field.getField(); // `input` node
   * ```
   */


  /**
   * A helper function for focusing the `input` field or the `textarea` in the `TextField`.
   * This is accessibile if you use `refs`.
   * Example:
   *
   * ```js
   * <TextField ref={field => this._field = field;} label="Hello" />;
   *
   * this._field.focus();
   * ```
   */


  /**
   * A helper function for blurring the `input` field or the `textarea` in the `TextField`.
   * This is accessible if you use `refs`.
   * Example:
   *
   * ```js
   * <TextField ref={field => this._field = field;} label="Hello" />;
   *
   * this._field.blur();
   * ```
   */
  TextField.prototype.blur = function blur() {
    this._field.blur();
  };

  TextField.prototype._cloneIcon = function _cloneIcon(icon, active, error, disabled, stateful, block, dir) {
    if (!icon) {
      return icon;
    }

    try {
      var iconEl = react["Children"].only(icon);
      return Object(react["cloneElement"])(iconEl, {
        key: iconEl.key || 'icon-' + dir,
        disabled: stateful ? disabled : undefined,
        primary: stateful ? !error && active : undefined,
        error: stateful ? error : undefined,
        className: classnames_default()('md-text-field-icon', {
          'md-text-field-icon--positioned': !block
        }, iconEl.props.className)
      });
    } catch (e) {
      return icon;
    }
  };

  /**
   * A small utility function for calculating an inline-icon's width keeping the SVG Icons
   * in mind and any margin that gets applied for spacing.
   */


  TextField.prototype.render = function render() {
    var _state = this.state,
        currentLength = _state.currentLength,
        passwordVisible = _state.passwordVisible,
        styles = _state.styles;

    var _props3 = this.props,
        id = _props3.id,
        type = _props3.type,
        className = _props3.className,
        inputStyle = _props3.inputStyle,
        inputClassName = _props3.inputClassName,
        block = _props3.block,
        fullWidth = _props3.fullWidth,
        required = _props3.required,
        customSize = _props3.customSize,
        maxLength = _props3.maxLength,
        errorText = _props3.errorText,
        helpText = _props3.helpText,
        helpOnFocus = _props3.helpOnFocus,
        disabled = _props3.disabled,
        leftIconStateful = _props3.leftIconStateful,
        rightIconStateful = _props3.rightIconStateful,
        lineDirection = _props3.lineDirection,
        paddedBlock = _props3.paddedBlock,
        onDoubleClick = _props3.onDoubleClick,
        onTouchStart = _props3.onTouchStart,
        onTouchMove = _props3.onTouchMove,
        onTouchCancel = _props3.onTouchCancel,
        onTouchEnd = _props3.onTouchEnd,
        onMouseDown = _props3.onMouseDown,
        onMouseUp = _props3.onMouseUp,
        onMouseOver = _props3.onMouseOver,
        onMouseLeave = _props3.onMouseLeave,
        ink = _props3.ink,
        inlineIndicator = _props3.inlineIndicator,
        toolbar = _props3.toolbar,
        propPasswordIcon = _props3.passwordIcon,
        icon = _props3.icon,
        passwordIconChildren = _props3.passwordIconChildren,
        passwordIconClassName = _props3.passwordIconClassName,
        style = _props3.style,
        propLabel = _props3.label,
        propPlaceholder = _props3.placeholder,
        propError = _props3.error,
        propActive = _props3.active,
        propFloating = _props3.floating,
        propLeftIcon = _props3.leftIcon,
        propRightIcon = _props3.rightIcon,
        onClick = _props3.onClick,
        onChange = _props3.onChange,
        onBlur = _props3.onBlur,
        onFocus = _props3.onFocus,
        resize = _props3.resize,
        adjustMinWidth = _props3.adjustMinWidth,
        propFloatingLabel = _props3.floatingLabel,
        props = TextField_objectWithoutProperties(_props3, ['id', 'type', 'className', 'inputStyle', 'inputClassName', 'block', 'fullWidth', 'required', 'customSize', 'maxLength', 'errorText', 'helpText', 'helpOnFocus', 'disabled', 'leftIconStateful', 'rightIconStateful', 'lineDirection', 'paddedBlock', 'onDoubleClick', 'onTouchStart', 'onTouchMove', 'onTouchCancel', 'onTouchEnd', 'onMouseDown', 'onMouseUp', 'onMouseOver', 'onMouseLeave', 'ink', 'inlineIndicator', 'toolbar', 'passwordIcon', 'icon', 'passwordIconChildren', 'passwordIconClassName', 'style', 'label', 'placeholder', 'error', 'active', 'floating', 'leftIcon', 'rightIcon', 'onClick', 'onChange', 'onBlur', 'onFocus', 'resize', 'adjustMinWidth', 'floatingLabel']);

    var _props4 = this.props,
        label = _props4.label,
        placeholder = _props4.placeholder,
        error = _props4.error,
        active = _props4.active,
        floating = _props4.floating,
        leftIcon = _props4.leftIcon,
        rightIcon = _props4.rightIcon;

    active = active || this.state.active;
    error = error || this.state.error;
    floating = floating || this.state.floating;

    if (required) {
      if (label) {
        label = addSuffix(label, '*');
      }

      if (placeholder && !label) {
        placeholder = addSuffix(placeholder, '*');
      }
    }

    if (label && !floating) {
      placeholder = null;
    }

    leftIcon = this._cloneIcon(icon || leftIcon, active, error, disabled, leftIconStateful, block, 'left');
    var passwordIcon = getDeprecatedIcon(passwordIconClassName, passwordIconChildren, propPasswordIcon);
    if (passwordIcon !== null && type === 'password' && !disabled) {
      rightIcon = react_default.a.createElement(TextFields_PasswordButton, {
        key: 'password-btn',
        onClick: this._togglePasswordField,
        active: active,
        passwordVisible: passwordVisible,
        icon: passwordIcon,
        block: block,
        floating: !!label
      });
    } else if (inlineIndicator) {
      var el = react["Children"].only(inlineIndicator);
      rightIcon = Object(react["cloneElement"])(inlineIndicator, {
        key: 'icon-right',
        className: classnames_default()('md-text-field-inline-indicator', {
          'md-text-field-inline-indicator--floating': label,
          'md-text-field-inline-indicator--block': block
        }, el.props.className)
      });
    } else {
      rightIcon = this._cloneIcon(rightIcon, active, error, disabled, rightIconStateful, block, 'right');
    }
    var rightIconed = !!rightIcon && type !== 'password' && !inlineIndicator;

    var floatingLabel = react_default.a.createElement(TextFields_FloatingLabel, {
      key: 'label',
      label: label,
      htmlFor: id,
      active: active,
      error: error,
      floating: floating,
      customSize: customSize,
      disabled: disabled,
      iconOffset: !!leftIcon
    });

    var message = react_default.a.createElement(TextFields_TextFieldMessage, {
      key: 'message',
      active: active,
      error: error,
      errorText: errorText,
      helpText: helpText,
      helpOnFocus: helpOnFocus,
      block: block,
      maxLength: maxLength,
      leftIcon: !!leftIcon,
      rightIcon: !!rightIcon,
      currentLength: currentLength
    });

    var field = react_default.a.createElement(TextFields_InputField, TextField_extends({}, props, {
      required: required,
      key: 'field',
      ref: this._setField,
      id: id,
      type: type,
      label: label,
      style: inputStyle,
      className: classnames_default()({ 'md-text-field--toolbar': toolbar }, inputClassName),
      disabled: disabled,
      customSize: customSize,
      fullWidth: fullWidth,
      passwordVisible: passwordVisible,
      placeholder: placeholder,
      block: block,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      onChange: this._handleChange,
      inlineIndicator: !!inlineIndicator
    }));

    var divider = void 0;
    if (!block) {
      divider = react_default.a.createElement(TextFields_TextFieldDivider, {
        key: 'text-divider',
        active: active,
        error: error,
        lineDirection: lineDirection
      });
    }

    var children = void 0;
    if (leftIcon || rightIconed) {
      children = react_default.a.createElement(
        'div',
        { key: 'icon-divider', className: 'md-text-field-icon-container' },
        leftIcon,
        react_default.a.createElement(
          'div',
          {
            key: 'divider-container',
            className: classnames_default()('md-text-field-divider-container', {
              'md-text-field-divider-container--grow': fullWidth
            })
          },
          field,
          divider
        ),
        rightIcon
      );
    } else {
      children = [leftIcon, field, divider, rightIcon];
    }

    children = [floatingLabel, children, message];

    var multiline = typeof props.rows !== 'undefined';
    return react_default.a.createElement(
      'div',
      {
        style: styles,
        className: classnames_default()('md-text-field-container', {
          'md-inline-block': !fullWidth && !block,
          'md-full-width': block || fullWidth,
          'md-text-field-container--disabled': disabled,
          'md-text-field-container--input': !multiline,
          'md-text-field-container--input-block': block && !multiline,
          'md-text-field-container--multiline': multiline,
          'md-text-field-container--multiline-block': multiline && block,
          'md-text-field-container--padded-block': block && paddedBlock
        }, className),
        onClick: this._handleContainerClick,
        onDoubleClick: onDoubleClick,
        onMouseOver: onMouseOver,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        onMouseUp: onMouseUp,
        onTouchStart: onTouchStart,
        onTouchEnd: onTouchEnd,
        onTouchCancel: onTouchCancel,
        onTouchMove: onTouchMove,
        ref: this._setContainer
      },
      ink,
      children
    );
  };

  _createClass(TextField, [{
    key: 'value',


    /**
     * Gets the current value from the text field. This is used when you have an uncontrolled
     * text field and simply need the value from a ref callback.
     *
     * @return {String} the text field's value
     */
    get: function get() {
      return this.getField().value;
    }
  }]);

  return TextField;
}(react["PureComponent"]);

TextField_TextField.propTypes = {
  /**
   * The id for a text field. This is required when using the `label` prop for accessibility,
   * but normally a good idea to include one anyways.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * An optional style to apply to the text field's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the text field's container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the `input` or `textarea` tag.
   */
  inputStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the `input` or `textarea` tag.
   */
  inputClassName: prop_types_default.a.string,

  /**
   * An optional value to apply to the text field. This will make the component
   * controlled and require the `onChange` prop.
   */
  value: controlled(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]), 'onChange'),

  /**
   * An optional default value for the text field.
   */
  defaultValue: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),

  /**
   * Boolean if the text field should be displayed as a `block`. This is equivalent to
   * the `full width` text field in the Material Design specs. This view will disable
   * floating labels and remove the text divider from the component.
   */
  block: prop_types_default.a.bool,

  /**
   * Boolean if the `block` text field should include padding to the left and right of
   * the text field.
   */
  paddedBlock: prop_types_default.a.bool,

  /**
   * Boolean if the text field is currently disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * An optional label to display with the text field. This will convert the text field
   * into a floating label text field. You can make it single line by only using the
   * `placeholder` prop.
   */
  label: invalidIf(prop_types_default.a.node, 'block'),

  /**
   * An optional placeholder text to display in the text field. If there is no `label` prop,
   * the text field will be displayed as a single line text field. If there is a `label` prop,
   * this will only be visible when there is no value and the user focused the text field.
   */
  placeholder: prop_types_default.a.string,

  /**
   * The type for the text field. This is one of the most import props for mobile accessibility
   * as it will update the keyboard for the text type. This does not get applied on multiline
   * text fields.
   */
  type: prop_types_default.a.oneOf(['text', 'number', 'email', 'search', 'tel', 'url', 'password']).isRequired,

  /**
   * An optional function to call when the text field's container triggers the `click` event.
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional function to call when the text field's container triggers the `doubleclick`
   * event.
   */
  onDoubleClick: prop_types_default.a.func,

  /**
   * An optional function to call when the text field's container triggers the `touchstart`
   * event.
   */
  onTouchStart: prop_types_default.a.func,

  /**
   * An optional function to call when the text field's container triggers the `touchmove`
   * event.
   */
  onTouchMove: prop_types_default.a.func,

  /**
   * An optional function to call when the text field's container triggers the `touchcancel`
   * event.
   */
  onTouchCancel: prop_types_default.a.func,

  /**
   * An optional function to call when the text field's container triggers the `touchend`
   * event.
   */
  onTouchEnd: prop_types_default.a.func,

  /**
   * An optional function to call when the text field's container triggers the `mousedown`
   * event.
   */
  onMouseDown: prop_types_default.a.func,

  /**
   * An optional function to call when the text field's container triggers the `mouseup`
   * event.
   */
  onMouseUp: prop_types_default.a.func,

  /**
   * An optional function to call when the text field's container triggers the `mouseover`
   * event.
   */
  onMouseOver: prop_types_default.a.func,

  /**
   * An optional function to call when the text field's container triggers the `mouseleave`
   * event.
   */
  onMouseLeave: prop_types_default.a.func,

  /**
   * An optional onChange function to call. If the `value` prop is defined, this is
   * required.
   *
   * When the value changes in the text field, this will be called with the new text
   * field's value and the change event.
   *
   * ```js
   * onChange(e.target.value, e);
   * ```
   */
  onChange: prop_types_default.a.func,

  /**
   * An optional function to call when the text field is blurred.
   */
  onBlur: prop_types_default.a.func,

  /**
   * An optional function to call when the text field is focused.
   */
  onFocus: prop_types_default.a.func,

  /**
   * An optional boolean if the `active` state of the text field can be externally
   * modified as well. The text field is usually considered active when it gains focus.
   *
   * If this prop is set, it will check both the active prop and the active state to
   * determine if one is true.
   */
  active: prop_types_default.a.bool,

  /**
   * An optional boolean if the `error` state of the text field can be externally
   * modified as well. The text field is usually considered errored when it is required
   * and there is no value or the current length of the text field's value is greater
   * than the `maxLength` prop.
   *
   * If this prop is set, it will check both the error prop and the error state to
   * determine if one is true.
   */
  error: prop_types_default.a.bool,

  /**
   * An optional boolean if the `floating` state of the text field's floating label can be
   * externally modified as well. The floating state is true when the text field gains focus
   * or there is a value in the text field.
   *
   * If this prop is set, it will check both the floating prop and the floating state to
   * determine if one is true.
   */
  floating: prop_types_default.a.bool,

  /**
   * Boolean if the text field is required. If the user blurs the text field while there is
   * no value and it is required, the `error` state will be set to true.
   */
  required: prop_types_default.a.bool,

  /**
   * The direction that the underline should appear from.
   */
  lineDirection: prop_types_default.a.oneOf(['left', 'center', 'right']).isRequired,

  /**
   * An optional icon to place to the left of the text field.
   */
  leftIcon: prop_types_default.a.element,

  /**
   * Boolean if the left icon should be stateful. This means that the icon will
   * gain the active or error colors with the text field.
   */
  leftIconStateful: prop_types_default.a.bool,

  /**
   * An optional icon to place to the right of the text field.
   */
  rightIcon: prop_types_default.a.element,

  /**
   * Boolean if the right icon should be stateful. This means that the icon will
   * gain the active or error colors with the text field.
   */
  rightIconStateful: prop_types_default.a.bool,

  /**
   * The icon to use for a password text field.
   */
  passwordIcon: prop_types_default.a.element,

  /**
   * Boolean if the password is initially visible.
   */
  passwordInitiallyVisible: prop_types_default.a.bool,

  /**
   * Boolean if the text field should be displayed as full width.
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * The number of rows for the `multiline` text field. This value must be greater than
   * or equal to 1. When this value is set, the text field will be converted to a multiline
   * field.
   */
  rows: minNumber(1, false),

  /**
   * The maximum number of rows for a `multiline` text field. If this value is
   * `undefined`, `0`, or a number less than `0`, the multiline text field will
   * infinitely expand.
   */
  maxRows: prop_types_default.a.number,

  /**
   * An optional custom size to apply to the text field. This is used along with
   * the `$md-text-field-custom-sizes` variable. It basically applies a className of
   * `md-text-field--NAME`.
   */
  customSize: prop_types_default.a.string,

  /**
   * An optional error text to display below the text field. This will only appear when
   * the text field has the `error` state through the `error` prop, the current length
   * of the text field's value is greater than the `maxLength` prop, or the field is
   * required and the user blurs the text field with no value.
   */
  errorText: prop_types_default.a.node,

  /**
   * An optional help text to display below the text field. This will always be visible
   * unless the `helpOnFocus` prop is set to true. Otherwise it will appear on focus.
   */
  helpText: prop_types_default.a.node,

  /**
   * Boolean if the help text should display on focus only.
   */
  helpOnFocus: prop_types_default.a.bool,

  /**
   * An optional max length for the text field. This will insert a counter underneath the
   * text field that appears on focus.
   */
  maxLength: prop_types_default.a.number,

  /**
   * The ink when there is an injectInk above the text field. Used from the SelectField.
   *
   * @access private
   */
  ink: prop_types_default.a.node,

  /**
   * An optional element to display inside of the `TextField` to the farthest right. This will
   * position the indicator absolutely and add some additional padding to the `TextField`.
   */
  inlineIndicator: prop_types_default.a.element,

  /**
   * This prop allows the text field to resize its width to stay between the min and max sizes provided. By
   * default, the field will expand and collapse based on the amount of text provided. The collapsing can
   * be disabled by providing `disableShrink` to the configuration object.
   *
   * If the `min` prop is not provided, it will default to `180` which is about the same size as a default
   * text field.
   */
  resize: prop_types_default.a.shape({
    min: prop_types_default.a.number,
    max: prop_types_default.a.number.isRequired,
    disableShrink: prop_types_default.a.bool
  }),

  /**
   * Boolean if the TextField is in a toolbar and acting as a title. This will apply additional styles to the
   * text field to make it look like the toolbar's title.
   */
  toolbar: prop_types_default.a.bool,

  passwordIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `passwordIcon` prop instead'),
  passwordIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `passwordIcon` prop instead'),
  icon: deprecated_default()(prop_types_default.a.node, 'Use the `leftIcon` or `rightIcon` prop instead'),
  floatingLabel: deprecated_default()(prop_types_default.a.bool, 'The `label` prop is now always floating. To create a non-floating text field, only use the `placeholder` prop'),
  adjustMinWidth: deprecated_default()(prop_types_default.a.bool, 'Manually add a min width style instead')
};
TextField_TextField.defaultProps = {
  type: 'text',
  lineDirection: 'left',
  passwordIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'remove_red_eye'
  ),
  leftIconStateful: true,
  rightIconStateful: true,
  fullWidth: true
};

var TextField_initialiseProps = function _initialiseProps() {
  var _this4 = this;

  this.getField = function () {
    return _this4._field.getField();
  };

  this.focus = function () {
    _this4._field.focus();
  };

  this._getLength = function (v) {
    if (isValued(v)) {
      return String(v).length;
    }

    return 0;
  };

  this._setContainer = function (div) {
    _this4._container = div;
  };

  this._setField = function (field) {
    if (field !== null) {
      _this4._field = field;
    }
  };

  this._calcIconWidth = function (icon) {
    var style = window.getComputedStyle(icon);

    return icon.getBoundingClientRect().width + parseInt(style.marginLeft, 10);
  };

  this._calcWidth = function (value) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this4.props;

    var text = value;
    // if it is a password, use the bullet unicode instead
    if (props.type === 'password') {
      text = Array.from(Array(value.length)).reduce(function (s) {
        return s + '\u2022';
      }, '');
    }

    var field = _this4._field && _this4._field.getField();
    if (!isValued(text) && field) {
      text = field.value;
    }

    var min = getField(props.resize, { min: DEFAULT_TEXT_FIELD_SIZE }, 'min');
    var width = getTextWidth(text, field);
    if (width === null || !field) {
      // some error happened, don't do other logic
      return width || min;
    }

    var max = props.resize.max;


    if (_this4._container) {
      var indicator = _this4._container.querySelector('.md-text-field-inline-indicator');
      if (indicator) {
        width += indicator.getBoundingClientRect().width;
      }

      var iconContainer = _this4._container.querySelector('.md-text-field-icon-container');
      if (iconContainer) {
        // There is conditionally an icon before and after the text field, or only an icon before/after
        var _iconContainer$childr = iconContainer.children,
            first = _iconContainer$childr[0],
            second = _iconContainer$childr[1],
            third = _iconContainer$childr[2];

        if (first.classList.contains('md-icon')) {
          width += first.getBoundingClientRect().width;
          width += parseInt(window.getComputedStyle(second).marginLeft, 10);

          if (third) {
            width += _this4._calcIconWidth(third);
          }
        } else if (second) {
          width += _this4._calcIconWidth(second);
        }
      }
    }

    return Math.ceil(Math.min(max, Math.max(min, width)));
  };

  this._isErrored = function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this4.props,
        value = _ref.value,
        maxLength = _ref.maxLength,
        required = _ref.required;

    var error = _this4.state.error;

    var currentLength = _this4._getLength(value);
    if (required && error) {
      error = !isValued(value);
    }

    if (maxLength) {
      error = error || currentLength > maxLength;
    }

    return error;
  };

  this._handleContainerClick = function (e) {
    if (_this4.props.onClick) {
      _this4.props.onClick(e);
    }

    if (!_this4.props.disabled) {
      _this4.focus();
    }
  };

  this._handleBlur = function (e) {
    _this4._focus = false;
    var _props5 = _this4.props,
        required = _props5.required,
        maxLength = _props5.maxLength,
        onBlur = _props5.onBlur;

    if (onBlur) {
      onBlur(e);
    }

    var value = e.target.value;

    var state = {
      active: false,
      error: required && !isValued(value) || maxLength && String(value).length > maxLength
    };

    if (!_this4.props.block) {
      state.floating = isValued(value);
    }

    _this4.setState(state);
  };

  this._handleFocus = function (e) {
    _this4._focus = true;
    var _props6 = _this4.props,
        onFocus = _props6.onFocus,
        block = _props6.block;

    if (onFocus) {
      onFocus(e);
    }

    var state = { active: true };
    if (!block) {
      state.floating = true;
    }

    _this4.setState(state);
  };

  this._handleChange = function (e) {
    var _props7 = _this4.props,
        onChange = _props7.onChange,
        maxLength = _props7.maxLength,
        required = _props7.required,
        resize = _props7.resize;
    var value = e.target.value;

    if (onChange) {
      onChange(e.target.value, e);
    }

    var currentLength = value.length;
    var state = void 0;
    if (typeof maxLength !== 'undefined') {
      state = { currentLength: currentLength, error: currentLength > maxLength };
    } else if (required && _this4.state.error) {
      state = { error: !currentLength };
    }

    if (typeof _this4.props.value === 'undefined' && resize) {
      var width = _this4._calcWidth(value);
      if (!resize.disableShrink || !_this4.state.styles || width > _this4.state.styles.width) {
        state = state || {};
        state.styles = TextField_extends({}, _this4.state.styles, { width: width });
      }
    }

    if (state) {
      _this4.setState(state);
    }
  };

  this._togglePasswordField = function () {
    _this4.setState({ passwordVisible: !_this4.state.passwordVisible }, _this4.focus);
  };
};

/* harmony default export */ var TextFields_TextField = (TextField_TextField);
// CONCATENATED MODULE: ../node_modules/react-md/es/Autocompletes/Autocomplete.js
var Autocomplete_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Autocomplete_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Autocomplete_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function Autocomplete_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Autocomplete_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Autocomplete_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Autocomplete_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

























/**
 * The `Autocomplete` component is useful for presenting real-time suggestions, completions,
 * or filtering.
 */

var Autocomplete_Autocomplete = function (_PureComponent) {
  Autocomplete_inherits(Autocomplete, _PureComponent);

  function Autocomplete(props) {
    Autocomplete_classCallCheck(this, Autocomplete);

    var _this = Autocomplete_possibleConstructorReturn(this, _PureComponent.call(this, props));

    Autocomplete_initialiseProps.call(_this);

    var defaultValue = props.defaultValue,
        data = props.data,
        dataLabel = props.dataLabel,
        filter = props.filter,
        showUnfilteredData = props.showUnfilteredData;


    var matches = [];
    if (defaultValue && filter) {
      matches = filter(data, defaultValue, dataLabel);
    } else if (!filter || showUnfilteredData) {
      matches = data;
    }

    _this.state = {
      value: defaultValue,
      matches: matches,
      visible: false,
      matchIndex: -1,
      manualFocus: false,
      suggestion: '',
      suggestionIndex: -1
    };
    return _this;
  }

  Autocomplete.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var nextValue = nextProps.value,
        data = nextProps.data,
        filter = nextProps.filter,
        dataLabel = nextProps.dataLabel;

    var dataDiff = data !== this.props.data;
    if (nextValue !== this.props.value || dataDiff) {
      var _state = this.state,
          visible = _state.visible,
          matches = _state.matches;

      var value = getField(nextProps, this.state, 'value');

      if (filter) {
        matches = filter(data, value, dataLabel);
      } else if (dataDiff) {
        matches = data;
      }

      if (this.state.focus) {
        visible = !!matches.length;
      }

      this.setState({ matches: matches, visible: visible });
    }
  };

  Autocomplete.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {
    if (this.state.visible !== nextState.visible) {
      var menuFn = nextProps['onMenu' + (nextState.visible ? 'Open' : 'Close')];
      if (menuFn) {
        menuFn();
      }
    }
  };

  /**
   * Gets the current value from the text field. This is used when you have an uncontrolled
   * text field and simply need the value from a ref callback.
   *
   * @return {String} the text field's value
   */


  Autocomplete.prototype.render = function render() {
    var _state2 = this.state,
        visible = _state2.visible,
        matches = _state2.matches,
        tabbed = _state2.tabbed,
        focus = _state2.focus,
        suggestionStyle = _state2.suggestionStyle;

    var _props = this.props,
        fullWidth = _props.fullWidth,
        block = _props.block,
        style = _props.style,
        className = _props.className,
        listStyle = _props.listStyle,
        listClassName = _props.listClassName,
        textFieldStyle = _props.textFieldStyle,
        textFieldClassName = _props.textFieldClassName,
        inlineSuggestionStyle = _props.inlineSuggestionStyle,
        inlineSuggestionClassName = _props.inlineSuggestionClassName,
        menuId = _props.menuId,
        inline = _props.inline,
        anchor = _props.anchor,
        belowAnchor = _props.belowAnchor,
        position = _props.position,
        fixedTo = _props.fixedTo,
        listId = _props.listId,
        listInline = _props.listInline,
        listZDepth = _props.listZDepth,
        listHeightRestricted = _props.listHeightRestricted,
        xThreshold = _props.xThreshold,
        yThreshold = _props.yThreshold,
        closeOnOutsideClick = _props.closeOnOutsideClick,
        transitionName = _props.transitionName,
        transitionEnterTimeout = _props.transitionEnterTimeout,
        transitionLeaveTimeout = _props.transitionLeaveTimeout,
        centered = _props.centered,
        sameWidth = _props.sameWidth,
        repositionOnScroll = _props.repositionOnScroll,
        repositionOnResize = _props.repositionOnResize,
        simplifiedMenu = _props.simplifiedMenu,
        minLeft = _props.minLeft,
        minRight = _props.minRight,
        minBottom = _props.minBottom,
        fillViewportWidth = _props.fillViewportWidth,
        fillViewportHeight = _props.fillViewportHeight,
        propValue = _props.value,
        total = _props.total,
        offset = _props.offset,
        filter = _props.filter,
        data = _props.data,
        dataLabel = _props.dataLabel,
        dataValue = _props.dataValue,
        deleteKeys = _props.deleteKeys,
        defaultValue = _props.defaultValue,
        clearOnAutocomplete = _props.clearOnAutocomplete,
        autocompleteWithLabel = _props.autocompleteWithLabel,
        findInlineSuggestion = _props.findInlineSuggestion,
        inlineSuggestionPadding = _props.inlineSuggestionPadding,
        onAutocomplete = _props.onAutocomplete,
        onMenuOpen = _props.onMenuOpen,
        onMenuClose = _props.onMenuClose,
        onBlur = _props.onBlur,
        onFocus = _props.onFocus,
        onKeyDown = _props.onKeyDown,
        onMouseDown = _props.onMouseDown,
        onChange = _props.onChange,
        showUnfilteredData = _props.showUnfilteredData,
        props = Autocomplete_objectWithoutProperties(_props, ['fullWidth', 'block', 'style', 'className', 'listStyle', 'listClassName', 'textFieldStyle', 'textFieldClassName', 'inlineSuggestionStyle', 'inlineSuggestionClassName', 'menuId', 'inline', 'anchor', 'belowAnchor', 'position', 'fixedTo', 'listId', 'listInline', 'listZDepth', 'listHeightRestricted', 'xThreshold', 'yThreshold', 'closeOnOutsideClick', 'transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'centered', 'sameWidth', 'repositionOnScroll', 'repositionOnResize', 'simplifiedMenu', 'minLeft', 'minRight', 'minBottom', 'fillViewportWidth', 'fillViewportHeight', 'value', 'total', 'offset', 'filter', 'data', 'dataLabel', 'dataValue', 'deleteKeys', 'defaultValue', 'clearOnAutocomplete', 'autocompleteWithLabel', 'findInlineSuggestion', 'inlineSuggestionPadding', 'onAutocomplete', 'onMenuOpen', 'onMenuClose', 'onBlur', 'onFocus', 'onKeyDown', 'onMouseDown', 'onChange', 'showUnfilteredData']);

    delete props.focusInputOnAutocomplete;

    var value = getField(this.props, this.state, 'value');

    var autocomplete = react_default.a.createElement(TextFields_TextField, Autocomplete_extends({}, props, {
      'aria-autocomplete': inline ? 'inline' : 'list',
      style: textFieldStyle,
      className: classnames_default()('md-autocomplete', textFieldClassName),
      key: 'autocomplete',
      ref: this._setField,
      value: value,
      onKeyDown: this._handleTextFieldKeyDown,
      onMouseDown: this._toggleMenu,
      onChange: this._handleChange,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      fullWidth: fullWidth,
      block: block
    }));

    if (inline) {
      var suggestion = void 0;
      if (focus && this.state.suggestion) {
        suggestion = react_default.a.createElement(
          'span',
          {
            key: 'suggestion',
            style: Autocomplete_extends({}, suggestionStyle, inlineSuggestionStyle),
            className: classnames_default()('md-autocomplete-suggestion', {
              'md-autocomplete-suggestion--floating': props.label,
              'md-autocomplete-suggestion--block': block
            }, inlineSuggestionClassName)
          },
          this.state.suggestion
        );
      }

      return react_default.a.createElement(
        CSSTransitionGroup_default.a,
        {
          component: 'div',
          style: style,
          className: classnames_default()('md-menu-container md-autocomplete-container', className, {
            'md-full-width': fullWidth || block
          }),
          transitionName: 'opacity',
          transitionEnterTimeout: 150,
          transitionLeave: !tabbed,
          transitionLeaveTimeout: 150,
          onTouchStart: this._handleTouchStart
        },
        autocomplete,
        suggestion
      );
    }

    return react_default.a.createElement(
      Menus_Menu,
      {
        id: menuId || props.id + '-menu',
        listId: listId,
        ref: this._setMenu,
        toggle: autocomplete,
        visible: visible,
        onClick: this._handleClick,
        onClose: this._close,
        onKeyDown: this._handleMenuKeyDown,
        simplified: simplifiedMenu,
        sameWidth: sameWidth,
        centered: centered,
        anchor: anchor,
        belowAnchor: belowAnchor,
        position: position,
        fixedTo: fixedTo,
        listInline: listInline,
        listZDepth: listZDepth,
        listHeightRestricted: listHeightRestricted,
        xThreshold: xThreshold,
        yThreshold: yThreshold,
        closeOnOutsideClick: closeOnOutsideClick,
        transitionName: transitionName,
        transitionEnterTimeout: transitionEnterTimeout,
        transitionLeaveTimeout: transitionLeaveTimeout,
        fullWidth: fullWidth || block,
        style: style,
        className: classnames_default()('md-autocomplete-container', className),
        listStyle: listStyle,
        listClassName: classnames_default()('md-autocomplete-list', listClassName),
        repositionOnScroll: repositionOnScroll,
        repositionOnResize: repositionOnResize,
        minLeft: minLeft,
        minRight: minRight,
        minBottom: minBottom,
        fillViewportWidth: fillViewportWidth,
        fillViewportHeight: fillViewportHeight
      },
      matches.map(this._mapToListItem)
    );
  };

  Autocomplete_createClass(Autocomplete, [{
    key: 'value',
    get: function get() {
      return getField(this.props, this.state, 'value');
    }

    /**
     * Just check if the click target is in a list item.. if it is, autocomplete the text field
     * with that item.
     */


    /**
     * The `mousedown` event is used instead of `click` because of the order
     * of the `mousedown`, `focus`, and `click` events.
     */


    /**
     * Allows touch devices to autocomplete the inline view by tapping:
     * - the suggestion text
     * - the text field IF there is a suggestion visible
     */

  }]);

  return Autocomplete;
}(react["PureComponent"]);

Autocomplete_Autocomplete.HorizontalAnchors = Menus_Menu.HorizontalAnchors;
Autocomplete_Autocomplete.VerticalAnchors = Menus_Menu.VerticalAnchors;
Autocomplete_Autocomplete.Positions = Menus_Menu.Positions;
Autocomplete_Autocomplete.fuzzyFilter = fuzzyFilter;
Autocomplete_Autocomplete.caseInsensitiveFilter = caseInsensitiveFilter;
Autocomplete_Autocomplete.findIgnoreCase = findIgnoreCase;
Autocomplete_Autocomplete.propTypes = {
  /**
   * An id to give the autocomplete. Either this or the `menuId` is required for accessibility.
   *
   * @see {@link #menuId}
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * The menu id to provide to the autocomplete. Either this prop or the `id` prop is required. If
   * this props is omitted, the menuId will become: `${id}-menu`
   */
  menuId: oneRequiredForA11y(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]), 'id'),

  /**
   * An optional id to provide to the menu's list.
   *
   * @see {@link Menus/Menu#listId}
   */
  listId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply to the menu that contains the autocomplete.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the menu that contains the autocomplete.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the autocomplete's text field.
   */
  textFieldStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the autocomplete's text field.
   */
  textFieldClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the autocomplete's text field input itself.
   */
  inputStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the autocomplete's input field itself.
   */
  inputClassName: prop_types_default.a.string,

  /**
   * The optional style to apply to the opened menu List if the
   * `Autocomplete` is not using `inline` suggestions.
   */
  listStyle: prop_types_default.a.object,

  /**
   * The optional className to apply to the opened menu List if the
   * `Autocomplete` is not using `inline` suggestions.
   */
  listClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the inline suggestion when using `inline` mode.
   */
  inlineSuggestionStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the inline suggestion when using `inline` mode.
   */
  inlineSuggestionClassName: prop_types_default.a.string,

  /**
   * Boolean if the autocomplete is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * A label to display with the autocomplete.
   */
  label: prop_types_default.a.node,

  /**
   * An optional value to use for the text field. This will force this component
   * to be controlled and require the `onChange` function.
   */
  value: controlled(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]), 'onChange'),

  /**
   * The default value for the autocomplete's text field.
   */
  defaultValue: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),

  /**
   * An object key to use to extract the text to be compared for filtering.
   * This will only be applied if the given `data` prop is an array of objects.
   */
  dataLabel: prop_types_default.a.string.isRequired,

  /**
   * An optional object key to use to extract the `value` of the given `data` prop.
   * This is really only used with generating a unique react key. The unique react
   * key with either be:
   * - the datum if it is a string or number
   * - the `key` attribute of the datum object
   * - the `datum[dataValue]`
   * - or the `datum[dataLabel]`
   */
  dataValue: prop_types_default.a.string,

  /**
   * A single key or an array of keys to delete from your data object before passing
   * to the `ListItem` component.
   */
  deleteKeys: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]),

  /**
   * The data that will be used for autocomplete suggestions. This can either be
   * an array of string, number, or object. If it is an array of objects, the key
   * `dataLabel` is required.
   *
   * ```docgen
   * PropTypes.arrayOf(PropTypes.oneOfType([
   *   PropTypes.element,
   *   PropTypes.string,
   *   PropTypes.number,
   *   PropTypes.shape({
   *     [dataLabel]: PropTypes.oneOfType([
   *       PropTypes.string,
   *       PropTypes.number,
   *       PropTypes.node,
   *     ]).isRequired,
   *   }),
   * ])).isRequired
   * ```
   */
  data: function data(props, propName, component) {
    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      others[_key - 3] = arguments[_key];
    }

    var _PropTypes$arrayOf, _PropTypes$shape;

    var dataLabel = props.dataLabel;

    return (_PropTypes$arrayOf = prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.string, prop_types_default.a.number, prop_types_default.a.shape((_PropTypes$shape = {}, _PropTypes$shape[dataLabel] = prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number, prop_types_default.a.node]).isRequired, _PropTypes$shape))]))).isRequired.apply(_PropTypes$arrayOf, [props, propName, component].concat(others));
  },

  /**
   * An optional number representing the total number of results in the `data` prop.
   * This should really only be used when the data is paginated. When this is set,
   * each item in the suggestion menu will be updated with the `aria-setsize` and
   * `aria-posinset`.
   *
   * @see {@link #offset}
   */
  total: invalidIf(prop_types_default.a.number, 'inline'),

  /**
   * An optional number representing the data's offset if the results were paginated.
   * This is used for accessibility with the `aria-posinset` attribute.
   *
   * @see {@link #total}
   */
  offset: prop_types_default.a.number.isRequired,

  /**
   * An optional function to use to filter the `data`. If you have a sexy backend
   * using solr or some other search/indexer, it is recommended to set this prop to
   * `null`.
   */
  filter: prop_types_default.a.func,

  /**
   * An optional function to call when the `Autocomplete`'s text field has a `keydown` event.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * An optional function to call when the `Autocomplete`'s text field has a `mousedown` event.
   */
  onMouseDown: prop_types_default.a.func,

  /**
   * An optional function to call when the `Autocomplete`'s text field value changes.
   * The callback will be given the new value and the change event.
   *
   * `onChange(textFeldValue, event)`
   */
  onChange: prop_types_default.a.func,

  /**
   * An optional function to call when the `Autocomplete`'s text field is focused.
   */
  onFocus: prop_types_default.a.func,

  /**
   * An optional function to call when the entire `Autocomplete` component is blurred.
   * This will be triggered when the window is clicked or when a user tabs away from
   * the autocomplete.
   */
  onBlur: prop_types_default.a.func,

  /**
   * Boolean if this text field should be styled as a full width text field.
   * Floating labels and the text field indicator will be removed automatically.
   */
  block: prop_types_default.a.bool,

  /**
   * Boolean if the autocomplete should span the entire width.
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * Boolean if the `Autocomplete` should display suggestions inline instead
   * of in a `Menu`.
   */
  inline: prop_types_default.a.bool,

  /**
   * The amount of padding to use between the current text and the inline suggestion text.
   */
  inlineSuggestionPadding: prop_types_default.a.number.isRequired,

  /**
   * The function to call to find a suggestion for an inline autocomplete. This function
   * expects to return a single result of a number or a string.
   *
   * ```js
   * @param {Array<Object|String|Number>} data - The data prop to search.
   * @param {String} value - The current value to use for searching.
   * @param {String} dataLabel - The `dataLabel` prop to use if a datum is an object.
   * @return {String|Number} the found suggestion or false-ish
   * ```
   */
  findInlineSuggestion: prop_types_default.a.func,

  /**
   * An optional function to call when an autocomplete suggestion is clicked either
   * by using the mouse, the enter/space key, or touch. The match index and current
   * `dataLabel` will be given back.
   *
   * `onAutocomplete(suggestion, suggestionIndex, matches);`
   *
   * @see {@link #autocompleteWithLabel}
   */
  onAutocomplete: prop_types_default.a.func,

  /**
   * Boolean if the `onAutocomplete` should attempt send the `suggestion[dataLabel]` instead
   * of `suggestion[dataValue]` when the data is an object.
   *
   * @see {@link #onAutocomplete}
   */
  autocompleteWithLabel: prop_types_default.a.bool,

  /**
   * A boolean if the text field's value should be reset to the empty string when
   * an item is auto-completed. This is useful if you do not want a fully controlled
   * component and the values are stored outside of the `TextField`. (like `Chips`).
   */
  clearOnAutocomplete: prop_types_default.a.bool,

  /**
   * An optional function to call when the `Autocomplete` suggestion menu opens.
   */
  onMenuOpen: prop_types_default.a.func,

  /**
   * An optional function to call when the `Autocomplete` suggestion menu closes.
   */
  onMenuClose: prop_types_default.a.func,

  /**
   * This prop is used for disabling the browser's default autocomplete suggestions
   * of previously typed values in the text field. By default, this is disabled.
   */
  autoComplete: prop_types_default.a.oneOf(['on', 'off']),

  /**
   * Boolean if the `input` should be focused again after a suggestion was clicked.
   *
   * This is really only added for keyboard support and the fact that each of suggestions
   * are focusable.
   */
  focusInputOnAutocomplete: prop_types_default.a.bool,

  /**
   * This is how the menu's `List` gets anchored to the `toggle` element.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  anchor: anchorShape,

  /**
   * This is the anchor to use when the `position` is set to `Autocomplete.Positions.BELOW`.
   *
   * @see {@link Helpers/Layover#belowAnchor}
   */
  belowAnchor: anchorShape,

  /**
   * This is the animation position for the list that appears.
   *
   * @see {@link Helpers/Layover#animationPosition}
   */
  position: positionShape,

  /**
   * This is how the menu's list will be "fixed" to the `toggle` component.
   *
   * @see {@link Helpers/Layover#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * Boolean if the menu's list should appear horizontally instead of vertically.
   */
  listInline: prop_types_default.a.bool,

  /**
   * The list's z-depth for applying box shadow. This should be a number from 0 to 5.
   */
  listZDepth: prop_types_default.a.number,

  /**
   * Boolean if the list should have its height restricted to the `$md-menu-mobile-max-height`/
   * `$md-menu-desktop-max-height` values.
   *
   * @see [md-menu-mobile-max-height](/components/menus?tab=2#variable-md-menu-mobile-max-height)
   * @see [md-menu-desktop-max-height](/components/menus?tab=2#variable-md-menu-desktop-max-height)
   */
  listHeightRestricted: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#xThreshold}
   */
  xThreshold: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#yThreshold}
   */
  yThreshold: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#closeOnOutsideClick}
   */
  closeOnOutsideClick: prop_types_default.a.bool,

  /**
   * An optional transition name to use for the list appearing/disappearing.
   *
   * @see {@link Helpers/Layover#transitionName}
   */
  transitionName: prop_types_default.a.string,

  /**
   * @see {@link Helpers/Layover#transitionEnterTimeout}
   */
  transitionEnterTimeout: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#transitionLeaveTimeout}
   */
  transitionLeaveTimeout: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#centered}
   */
  centered: Menus_Menu.propTypes.centered,

  /**
   * @see {@link Helpers/Layover#sameWidth}
   */
  sameWidth: Menus_Menu.propTypes.sameWidth,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * Boolean if the menu logic should be simplified without any viewport logic and position
   * based on the relative position of the menu. This will most like require some additional
   * styles applied to the menu.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedMenu: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#minLeft}
   */
  minLeft: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#minRight}
   */
  minRight: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#minBottom}
   */
  minBottom: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#fillViewportWidth}
   */
  fillViewportWidth: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#fillViewportHeight}
   */
  fillViewportHeight: prop_types_default.a.bool,

  /**
   * @see {@link TextFields#toolbar}
   */
  toolbar: prop_types_default.a.bool,

  /**
   * Boolean if the list of data should be shown on focus when no filter value has been
   * provided.
   */
  showUnfilteredData: prop_types_default.a.bool
};
Autocomplete_Autocomplete.defaultProps = {
  autocompleteWithLabel: false,
  position: Menus_Menu.Positions.BELOW,
  sameWidth: true,
  offset: 0,
  fullWidth: true,
  defaultValue: '',
  dataLabel: 'primaryText',
  filter: Autocomplete_Autocomplete.fuzzyFilter,
  findInlineSuggestion: Autocomplete_Autocomplete.findIgnoreCase,
  autoComplete: 'off',
  repositionOnScroll: true,
  repositionOnResize: true,
  showUnfilteredData: false,
  inlineSuggestionPadding: 6
};

var Autocomplete_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._close = function (e) {
    if (_this2.props.onBlur) {
      _this2.props.onBlur(e);
    }

    _this2.setState({ visible: false });
  };

  this._handleChange = function (value, event) {
    var _props2 = _this2.props,
        onChange = _props2.onChange,
        filter = _props2.filter,
        findInlineSuggestion = _props2.findInlineSuggestion,
        data = _props2.data,
        dataLabel = _props2.dataLabel,
        inline = _props2.inline,
        showUnfilteredData = _props2.showUnfilteredData;


    if (onChange) {
      onChange(value, event);
    }

    if (inline) {
      // If findInlineSuggestion does not exist, assume that `onChange` will handle it.
      return findInlineSuggestion ? _this2._findInlineSuggestions(value) : null;
    }

    var visible = _this2.state.visible;

    var hasValidValue = value || showUnfilteredData;

    var matches = hasValidValue || !filter ? data : [];
    if (value && filter) {
      matches = filter(data, value, dataLabel);
    }

    if (filter) {
      visible = !!matches.length;
    }

    return _this2.setState({ matches: matches, visible: visible, value: value });
  };

  this._handleFocus = function (e) {
    if (_this2.props.onFocus) {
      _this2.props.onFocus(e);
    }

    var value = e.target.value;

    if (_this2.props.inline && value) {
      if (_this2.props.findInlineSuggestion) {
        _this2._findInlineSuggestions(value);
      }

      return;
    }

    var hasValidValue = !!value || _this2.props.showUnfilteredData;

    _this2.setState({
      matchIndex: -1,
      visible: !_this2.state.manualFocus && hasValidValue && !!_this2.state.matches.length,
      manualFocus: false,
      focus: true
    });
  };

  this._handleBlur = function (e) {
    if (_this2.props.inline || !_this2.state.matches.length) {
      if (_this2.props.onBlur) {
        _this2.props.onBlur(e);
      }
    }

    _this2.setState({ focus: false });
  };

  this._handleInlineAutocomplete = function () {
    var _state3 = _this2.state,
        suggestionIndex = _state3.suggestionIndex,
        matches = _state3.matches;

    if (suggestionIndex === -1) {
      return;
    }

    var _props3 = _this2.props,
        data = _props3.data,
        dataLabel = _props3.dataLabel,
        dataValue = _props3.dataValue,
        label = _props3.autocompleteWithLabel,
        onAutocomplete = _props3.onAutocomplete;


    var value = data[suggestionIndex];
    if (onAutocomplete) {
      var v = value;
      if ((typeof value === 'undefined' ? 'undefined' : Autocomplete_typeof(value)) === 'object') {
        if (!label) {
          v = value[dataValue];
        } else {
          v = value[dataLabel];
        }
      }

      onAutocomplete(v, suggestionIndex, matches);
    }

    if ((typeof value === 'undefined' ? 'undefined' : Autocomplete_typeof(value)) === 'object') {
      value = value[dataLabel];
    }

    _this2.setState({
      value: value,
      suggestion: '',
      suggestionIndex: -1,
      tabbed: true
    });
  };

  this._handleTextFieldKeyDown = function (e) {
    var _props4 = _this2.props,
        inline = _props4.inline,
        onKeyDown = _props4.onKeyDown;
    var suggestionIndex = _this2.state.suggestionIndex;


    var key = e.which || e.keyCode;
    if (onKeyDown) {
      onKeyDown(e);
    }

    if (inline && key === TAB && suggestionIndex !== -1) {
      // Autocomplete the text field
      e.preventDefault();
      _this2._handleInlineAutocomplete();
    }
  };

  this._handleMenuKeyDown = function (e) {
    var key = e.which || e.keyCode;
    if (key === TAB) {
      if (_this2.props.onBlur) {
        _this2.props.onBlur(e);
      }

      _this2.setState({ visible: false });
    } else if (key === UP || key === DOWN) {
      _this2._focusSuggestion(key === UP, e);
    }
  };

  this._handleClick = function (e) {
    var target = e.target;
    while (_this2._menu && _this2._menu.contains(target)) {
      if (target.classList.contains('md-list-item')) {
        var items = target.parentNode.querySelectorAll('.md-list-item');
        items = Array.prototype.slice.call(items);

        return _this2._handleItemClick(items.indexOf(target));
      }

      target = target.parentNode;
    }

    return null;
  };

  this._handleItemClick = function (index) {
    if (index === -1) {
      return;
    }

    var matches = _this2.state.matches;
    var _props5 = _this2.props,
        data = _props5.data,
        dataLabel = _props5.dataLabel,
        dataValue = _props5.dataValue,
        filter = _props5.filter,
        onAutocomplete = _props5.onAutocomplete,
        clearOnAutocomplete = _props5.clearOnAutocomplete,
        focusInputOnAutocomplete = _props5.focusInputOnAutocomplete,
        label = _props5.autocompleteWithLabel;


    var value = matches.filter(function (m) {
      return !react_default.a.isValidElement(m);
    })[index];
    if (onAutocomplete) {
      var v = value;
      if ((typeof v === 'undefined' ? 'undefined' : Autocomplete_typeof(v)) === 'object') {
        if (!label) {
          v = value[dataValue];
        } else {
          v = value[dataLabel];
        }
      }

      onAutocomplete(v, index, matches);
    }

    if ((typeof value === 'undefined' ? 'undefined' : Autocomplete_typeof(value)) === 'object') {
      value = value[dataLabel];
    }

    value = clearOnAutocomplete ? '' : value;
    var callback = void 0;
    if (focusInputOnAutocomplete) {
      callback = function callback() {
        _this2._field.focus();
      };
    }

    _this2.setState({
      visible: false,
      manualFocus: focusInputOnAutocomplete,
      matches: filter ? filter(data, value, dataLabel) : matches,
      value: value
    }, callback);
  };

  this._focusSuggestion = function (negative, e) {
    e.preventDefault();
    var _state4 = _this2.state,
        matchIndex = _state4.matchIndex,
        matches = _state4.matches;

    var l = matches.length;

    var index = void 0;
    if (negative && matchIndex === -1 || !negative && matchIndex >= l) {
      return;
    } else if (negative) {
      index = matchIndex - 1;
      if (index === -1) {
        _this2._field.focus();
      }
    } else {
      index = Math.min(l, matchIndex + 1);
    }

    if (index !== -1 && index !== matchIndex) {
      var item = _this2._menu.querySelectorAll('.md-list-tile')[index];
      if (item) {
        item.focus();
      }
    }

    _this2.setState({ matchIndex: index });
  };

  this._findInlineSuggestions = function (value) {
    var _props6 = _this2.props,
        data = _props6.data,
        dataLabel = _props6.dataLabel,
        findInlineSuggestion = _props6.findInlineSuggestion,
        inlineSuggestionPadding = _props6.inlineSuggestionPadding;


    var suggestion = findInlineSuggestion(data, value, dataLabel);
    if ((typeof suggestion === 'undefined' ? 'undefined' : Autocomplete_typeof(suggestion)) === 'object') {
      throw new Error('`findInlineSuggestion` should return a string or a number, but got an object.', suggestion);
    }

    var suggestionStyle = _this2.state.suggestionStyle;

    var suggestionIndex = -1;
    if (suggestion) {
      // Find index of suggestion
      data.some(function (datum, i) {
        var d = (typeof dataum === 'undefined' ? 'undefined' : Autocomplete_typeof(dataum)) === 'object' ? datum[dataLabel] : datum;
        if (d === suggestion) {
          suggestionIndex = i;
        }

        return suggestionIndex !== -1;
      });

      // Strip already used letters
      suggestion = suggestion.toString().substring(value.length, suggestion.length);

      // Position the inline suggestion next to the text
      var width = getTextWidth(value, _this2._field);
      if (width !== null) {
        width += inlineSuggestionPadding;
      }

      if (width !== null && (!suggestionStyle || suggestionStyle.left !== width)) {
        suggestionStyle = { left: width };
      }
    }

    _this2.setState({
      value: value,
      suggestion: suggestion,
      suggestionIndex: suggestionIndex,
      suggestionStyle: suggestionStyle,
      tabbed: false,
      focus: true
    });
  };

  this._mapToListItem = function (match, i) {
    if (react_default.a.isValidElement(match)) {
      return match;
    }

    var _props7 = _this2.props,
        dataLabel = _props7.dataLabel,
        dataValue = _props7.dataValue,
        deleteKeys = _props7.deleteKeys,
        total = _props7.total,
        offset = _props7.offset,
        data = _props7.data;

    var props = void 0;
    switch (typeof match === 'undefined' ? 'undefined' : Autocomplete_typeof(match)) {
      case 'string':
      case 'number':
        props = {
          key: match,
          primaryText: match
        };
        break;
      default:
        if (deleteKeys) {
          props = omit(match, typeof deleteKeys === 'string' ? [deleteKeys] : deleteKeys);
        } else {
          props = match;
        }

        props = Autocomplete_extends({}, props, {
          key: match.key || dataValue && match[dataValue] || match[dataLabel],
          primaryText: match[dataLabel]
        });
    }

    if (typeof total !== 'undefined' && data.length < total) {
      props['aria-setsize'] = total;
      props['aria-posinset'] = i + 1 + offset;
    }

    // Allows focus, but does not let tab focus. This is so up and down keys work.
    return react_default.a.createElement(Lists_ListItem, Autocomplete_extends({ tabIndex: -1 }, props));
  };

  this._toggleMenu = function (e) {
    if (_this2.props.onMouseDown) {
      _this2.props.onMouseDown(e);
    }

    if (!_this2.props.inline && _this2.state.matches.length && getField(_this2.props, _this2.state, 'value')) {
      _this2.setState({ visible: !_this2.state.visible });
    }
  };

  this._handleTouchStart = function (e) {
    var target = e.target;
    var suggestion = _this2.state.suggestion;

    if (target.classList.contains('md-autocomplete-suggestion') && suggestion) {
      _this2._handleInlineAutocomplete();
    }
  };

  this._setField = function (field) {
    if (field) {
      _this2._field = field.getField();
    }
  };

  this._setMenu = function (menu) {
    _this2._menu = Object(react_dom["findDOMNode"])(menu);
  };
};

/* harmony default export */ var Autocompletes_Autocomplete = (Autocomplete_Autocomplete);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/PropTypes/oneRequiredForA11yIf.js
/** @module utils/PropTypes/oneRequiredForA11yIf */

/**
 * A PropType validator to make sure that any of the other prop names have been defined
 * if the current prop is also defined.
 *
 * This is mostly useful for when adding a prop requires additional accessibility props defined
 * as well.
 *
 * @param {function} validator - The current prop's validator.
 */
function oneRequiredForA11yIf(validator) {
  for (var _len = arguments.length, otherPropNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    otherPropNames[_key - 1] = arguments[_key];
  }

  return function validate(props, propName, componentName, location, propFullName) {
    var filterUndefined = function filterUndefined(pn) {
      return typeof props[pn] !== 'undefined';
    };
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;
    var defined = typeof props[propName] !== 'undefined';
    var allPropNames = [propFullNameSafe].concat(otherPropNames);

    for (var _len2 = arguments.length, args = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      args[_key2 - 5] = arguments[_key2];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (!err && defined && !allPropNames.filter(filterUndefined).length) {
      err = new Error('One of the following props are required to make `' + componentNameSafe + '` accessible ' + ('for users of assistive technologies such as screen readers when using the `' + propFullNameSafe + '` ') + ('prop. `' + allPropNames.join('`, `') + '`.'));
    }

    return err;
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Avatars/Avatar.js
var Avatar_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Avatar_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Avatar_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Avatar_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Avatar_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The avatar component is used to convert a `FontIcon`, an image, or
 * a letter into an avatar.
 *
 * Any other props given to the Avatar component such as event listeners
 * or styles will also be applied.
 */

var Avatar_Avatar = function (_PureComponent) {
  Avatar_inherits(Avatar, _PureComponent);

  function Avatar() {
    var _temp, _this, _ret;

    Avatar_classCallCheck(this, Avatar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Avatar_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { color: null }, _this._setRandomColor = function () {
      var suffixes = _this.props.suffixes;


      var i = Math.floor(Math.random() * (suffixes.length - 1)) + 1;
      _this.setState({ color: suffixes[i] });
    }, _temp), Avatar_possibleConstructorReturn(_this, _ret);
  }

  Avatar.prototype.componentWillMount = function componentWillMount() {
    if (this.props.random) {
      this._setRandomColor();
    }
  };

  Avatar.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.random && (this.props.src !== nextProps.src || this.props.icon !== nextProps.icon)) {
      this._setRandomColor();
    } else if (this.props.random && !nextProps.random) {
      this.setState({ color: null });
    }
  };

  Avatar.prototype._getColor = function _getColor(suffix, suffixes, color) {
    if (suffix) {
      return 'md-avatar--' + suffix;
    } else if (!!suffixes && !color) {
      return 'md-avatar--default';
    }

    return 'md-avatar--' + color;
  };

  Avatar.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        contentStyle = _props.contentStyle,
        contentClassName = _props.contentClassName,
        src = _props.src,
        alt = _props.alt,
        icon = _props.icon,
        children = _props.children,
        suffix = _props.suffix,
        suffixes = _props.suffixes,
        iconSized = _props.iconSized,
        role = _props.role,
        random = _props.random,
        props = Avatar_objectWithoutProperties(_props, ['className', 'contentStyle', 'contentClassName', 'src', 'alt', 'icon', 'children', 'suffix', 'suffixes', 'iconSized', 'role', 'random']);

    var content = void 0;
    if (src) {
      content = react_default.a.createElement('img', {
        src: src,
        alt: alt,
        role: role,
        style: contentStyle,
        className: classnames_default()('md-avatar-img', contentClassName)
      });
    } else {
      content = react_default.a.createElement(
        'div',
        {
          style: contentStyle,
          className: classnames_default()('md-avatar-content', contentClassName)
        },
        icon || children
      );
    }
    return react_default.a.createElement(
      'div',
      Avatar_extends({}, props, {
        className: classnames_default()('md-inline-block md-avatar', this._getColor(suffix, suffixes, this.state.color), {
          'md-avatar--icon-sized': iconSized
        }, className)
      }),
      content
    );
  };

  return Avatar;
}(react["PureComponent"]);

Avatar_Avatar.propTypes = {
  /**
   * An optional className to apply to the avatar.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to either the `<img>` or `<div>` surrounding the content. The `<img>` tag
   * will be used with the `src` prop is defined.
   */
  contentStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to either the `<img>` or `<div>` surrounding the content. The `<img>` tag
   * will be used with the `src` prop is defined.
   */
  contentClassName: prop_types_default.a.string,

  /**
   * An optional image source to use for the avatar.
   */
  src: oneRequiredForA11yIf(prop_types_default.a.string, 'role', 'alt'),

  /**
   * An optional image alt to use for the avatar if it is
   * an image.
   */
  alt: prop_types_default.a.string,

  /**
   * An optional `FontIcon` to convert into an avatar.
   */
  icon: prop_types_default.a.node,

  /**
   * An optional letter to display in the avatar.
   */
  children: prop_types_default.a.node,

  /**
   * A boolean if a random color should be applied to the avatar.
   * This will be one of the `suffixes`.
   */
  random: prop_types_default.a.bool,

  /**
   * A list of available suffixes to use when generating a random
   * color for the avatar.
   */
  suffixes: prop_types_default.a.arrayOf(prop_types_default.a.string),

  /**
   * The suffix to use for a color. This can be any value but
   * *should* be one of the available `suffixes`.
   */
  suffix: prop_types_default.a.string,

  /**
   * Boolean if the `Avatar` should be sized to a `FontIcon` size. This
   * will just set the width and height to the `$md-font-icon-size`.
   */
  iconSized: prop_types_default.a.bool,

  /**
   * A role for the avatar's image. When the `src` prop is set, either a `role` of `presentation`
   * or the `alt` prop must be defined for a11y.
   */
  role: prop_types_default.a.oneOf(['presentation'])
};
Avatar_Avatar.defaultProps = {
  suffixes: ['red', 'pink', 'purple', 'deep-purple', 'indigo', 'blue', 'light-blue', 'cyan', 'teal', 'green', 'light-green', 'lime', 'yellow', 'amber', 'orange', 'deep-orange', 'brown', 'grey', 'blue-grey']
};
/* harmony default export */ var Avatars_Avatar = (Avatar_Avatar);
// CONCATENATED MODULE: ../node_modules/react-md/es/Badges/Badge.js
var Badge_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Badge_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Badge_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Badge_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Badge_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








/**
 * The main use case of the `Badge` component is for notifications. It can
 * however also place any content floating to whatever children are supplied.
 */

var Badge_Badge = function (_PureComponent) {
  Badge_inherits(Badge, _PureComponent);

  function Badge(props) {
    Badge_classCallCheck(this, Badge);

    var _this = Badge_possibleConstructorReturn(this, _PureComponent.call(this, props));

    var single = _this._isSingleChild(props);
    _this.state = {
      single: single,
      element: single && Object(react["isValidElement"])(props.children),
      count: _this._normalizeCount(props)
    };
    return _this;
  }

  Badge.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        badgeContent = _props.badgeContent,
        max = _props.max,
        children = _props.children;

    var nextState = void 0;
    if (badgeContent !== nextProps.badgeContent || max !== nextProps.max) {
      nextState = { count: this._normalizeCount(nextProps) };
    }

    if (children !== nextProps.children) {
      nextState = nextState || {};
      nextState.single = this._isSingleChild(nextProps);
      nextState.element = nextState.single && Object(react["isValidElement"])(nextProps.children);
    }

    if (nextState) {
      this.setState(nextState);
    }
  };

  Badge.prototype._isSingleChild = function _isSingleChild(_ref) {
    var children = _ref.children;

    return react["Children"].count(children) === 1;
  };

  Badge.prototype._normalizeCount = function _normalizeCount(_ref2) {
    var badgeContent = _ref2.badgeContent,
        max = _ref2.max;

    var count = void 0;
    if (max) {
      var n = parseInt(badgeContent, 10);
      if (!Number.isNaN(n) && n.toString() === badgeContent.toString()) {
        count = n > max ? max + '+' : n;
      }
    }

    return count;
  };

  Badge.prototype.render = function render() {
    var _state = this.state,
        count = _state.count,
        single = _state.single,
        element = _state.element;

    var _props2 = this.props,
        className = _props2.className,
        badgeStyle = _props2.badgeStyle,
        badgeClassName = _props2.badgeClassName,
        badgeContent = _props2.badgeContent,
        Component = _props2.component,
        children = _props2.children,
        primary = _props2.primary,
        secondary = _props2.secondary,
        defaultTheme = _props2.default,
        circular = _props2.circular,
        badgeId = _props2.badgeId,
        invisibleOnZero = _props2.invisibleOnZero,
        max = _props2.max,
        props = Badge_objectWithoutProperties(_props2, ['className', 'badgeStyle', 'badgeClassName', 'badgeContent', 'component', 'children', 'primary', 'secondary', 'default', 'circular', 'badgeId', 'invisibleOnZero', 'max']);

    var useCircular = typeof circular !== 'undefined' ? circular : typeof count !== 'undefined';
    var content = children;
    if (single && element) {
      var c = react["Children"].only(content);
      if (!c.props['aria-describedby']) {
        content = Object(react["cloneElement"])(c, { 'aria-describedby': badgeId });
      }
    } else if (single && !element && !props['aria-describedby']) {
      props['aria-describedby'] = badgeId;
    }

    var badge = react_default.a.createElement(
      'span',
      {
        id: badgeId,
        key: 'badge',
        role: 'status',
        style: badgeStyle,
        className: classnames_default()('md-badge', {
          'md-badge--circular': useCircular,
          'md-badge--default': defaultTheme
        }, themeColors({
          primary: primary,
          secondary: secondary,
          text: useCircular,
          themeText: !primary && !secondary
        }, badgeClassName))
      },
      count || badgeContent
    );

    return react_default.a.createElement(
      Component,
      Badge_extends({}, props, {
        className: classnames_default()('md-badge-container md-inline-block', className)
      }),
      content,
      invisibleOnZero && count === 0 ? null : badge
    );
  };

  return Badge;
}(react["PureComponent"]);

Badge_Badge.propTypes = {
  /**
   * An optional style to apply to the badge's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the badge's container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the badge.
   */
  badgeStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the badge.
   */
  badgeClassName: prop_types_default.a.string,

  /**
   * The id to give the badge's content. This is required to help with the
   * `aria-describedby` attribute that should be applied to one of the children.
   *
   * If there is only one child that is a valid React element, the `aria-describedby`
   * will automatically be cloned into that child (so make sure your component passes
   * that prop correctly).
   *
   * If there is only one child, but it is a string or number, the badge's container
   * will be updated to include the `aria-describedby`.
   *
   * If there is more than child, you are required to add it to a child yourself.
   */
  badgeId: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * The content to display with the badge's content. The size of this
   * element is determinate of the location of the content. You might have
   * to update the positioning yourself.
   */
  children: prop_types_default.a.node.isRequired,

  /**
   * The component to render the badge as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * The content to display in the badge. If the content is a number or a number string,
   * the number will be normalized if `normalizeContent` is enabled.
   */
  badgeContent: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string, prop_types_default.a.node]).isRequired,

  /**
   * This will basically update the display value of the content to only be 2 digits. If
   * a number is greater than 99, 99+ will be displayed instead. This is really just to
   * keep the count inside the circular bubble.
   */
  max: prop_types_default.a.number,

  /**
   * Boolean if the primary color background should get applied to the badge's content.
   */
  primary: prop_types_default.a.bool,

  /**
   * Boolean if the secondary color background should get applied to the badge's content.
   */
  secondary: prop_types_default.a.bool,

  /**
   * Boolean if the default styles should be applied.
   */
  default: prop_types_default.a.bool,

  /**
   * Boolean if the badge's content should appear in a circular container. If this is
   * undefined, the content will be in a circular container if the badgeContent is a number.
   */
  circular: prop_types_default.a.bool,

  /**
   * Boolean if the badge's notification should be invisible when the count is 0.
   */
  invisibleOnZero: prop_types_default.a.bool
};
Badge_Badge.defaultProps = {
  max: 99,
  component: 'div'
};
/* harmony default export */ var Badges_Badge = (Badge_Badge);
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/Portal.js
function Portal_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Portal_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Portal_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var isReact16 = typeof react_dom["createPortal"] === 'function';

/**
 * Creates a "Portal" for the children to be rendered in. Basically it will render the
 * children only when the `visible` prop is `true`. When it is visible, a new `component`
 * will be rendered as the first child in the body with the children inside.
 *
 * Unlike all the other components, `style` will not be applied for the `Portal`.
 */

var Portal_Portal = function (_PureComponent) {
  Portal_inherits(Portal, _PureComponent);

  function Portal() {
    var _temp, _this, _ret;

    Portal_classCallCheck(this, Portal);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Portal_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._container = null, _this._portal = null, _this._applyStyles = function (props) {
      if (props.className) {
        _this._container.className = props.className;
      }
    }, _this._renderPortal = function (props) {
      if (!_this._container) {
        _this._container = document.createElement(props.component);

        _this._applyStyles(props);
        var node = props.renderNode || document.body;
        if (props.lastChild) {
          node.appendChild(_this._container);
        } else {
          node.insertBefore(_this._container, node.firstChild);
        }
      } else {
        _this._applyStyles(props);
      }

      if (!isReact16) {
        _this._portal = Object(react_dom["unstable_renderSubtreeIntoContainer"])(_this, props.children, _this._container);
      }
    }, _this._removePortal = function () {
      if (_this.props.onClose) {
        _this.props.onClose();
      }

      if (_this._container) {
        if (!isReact16) {
          Object(react_dom["unmountComponentAtNode"])(_this._container);
        }

        (_this.props.renderNode || document.body).removeChild(_this._container);
      }

      _this._portal = null;
      _this._container = null;
    }, _temp), Portal_possibleConstructorReturn(_this, _ret);
  }

  Portal.prototype.componentDidMount = function componentDidMount() {
    if (this.props.visible) {
      this._renderPortal(this.props);

      if (isReact16) {
        // Need to update after the renderPortal created the DOM element.
        this.forceUpdate();
      }
    }
  };

  Portal.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var visible = nextProps.visible,
        onOpen = nextProps.onOpen;

    if (this.props.visible === visible) {
      if (visible && !isReact16) {
        // Need to just re-render the subtree
        this._renderPortal(nextProps);
      }

      return;
    }

    if (visible) {
      if (onOpen) {
        onOpen();
      }

      this._renderPortal(nextProps);
    } else {
      this._removePortal();
    }
  };

  Portal.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.visible && this.props.onClose) {
      this.props.onClose();
    }
    this._removePortal();
  };

  Portal.prototype.render = function render() {
    var _props = this.props,
        Component = _props.component,
        className = _props.className,
        children = _props.children,
        visible = _props.visible;

    // When doing server side rendering, actually render the component as a direct child of its parent.
    // Once it has been rendered and working client side, it will be removed correctly.

    if (typeof window === 'undefined' && visible) {
      return react_default.a.createElement(
        Component,
        { className: className },
        children
      );
    } else if (isReact16 && visible && this._container && typeof window !== 'undefined') {
      return Object(react_dom["createPortal"])(children, this._container);
    }

    return null;
  };

  return Portal;
}(react["PureComponent"]);

Portal_Portal.propTypes = {
  /**
   * An optional className to apply to the newly created `component` when visible.
   */
  className: prop_types_default.a.string,

  /**
   * Boolean if the children are visible.
   */
  visible: prop_types_default.a.bool.isRequired,

  /**
   * The children to render when visible.
   */
  children: prop_types_default.a.element,

  /**
   * The component to render as. This should be a valid DOM element.
   */
  component: prop_types_default.a.string.isRequired,

  /**
   * An optional function to call when the portal is opened.
   */
  onOpen: prop_types_default.a.func,

  /**
   * An optional function to call when the portal is closed
   */
  onClose: prop_types_default.a.func,

  /**
   * An optional DOM Node to render the portal into. The default is to render as
   * the first child in the `body`.
   */
  renderNode: prop_types_default.a.object,

  /**
   * Boolean if the portal should render the children as the last child of the `renderNode`
   * or `body` instead of the first.
   */
  lastChild: prop_types_default.a.bool
};
Portal_Portal.defaultProps = {
  component: 'span'
};
/* harmony default export */ var Helpers_Portal = (Portal_Portal);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/NumberUtils/isBetween.js
/** @module utils/NumberUtils/isBetween */

/**
 * Checks if a number is between a min and maximum (inclusive)
 *
 * @param {Number} num the number to check
 * @param {Number} min the minimum
 * @param {Number} max the maximum
 * @return {Boolean} true if the number is between the min and max (inclusive)
 */
function isBetween(num, min, max) {
  return num >= min && num <= max;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/PropTypes/between.js
/** @module utils/PropTypes/between */



/**
 * Validates that a number is between a min and max value.
 *
 * @param {function} validator - The number validator to use.
 * @param {number} min - The min number to use.
 * @param {number} max - The max number to use.
 * @return {Error} the prop type error or null
 */
function between(validator, min, max) {
  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      args[_key - 5] = arguments[_key];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    var value = props[propName];
    if (!err && typeof value !== 'undefined' && !isBetween(value, min, max)) {
      err = new Error('You provided a `' + propFullNameSafe + '` ' + location + ' to the ' + componentNameSafe + ' that was ' + ('not within the range from \'' + min + ' - ' + max + '\'. `' + propFullNameSafe + '`: ' + value + '.'));
    }

    return err;
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Papers/Paper.js
var Paper_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Paper_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Paper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Paper_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Paper_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The `Paper` component is a simple wrapper that adds box-shadow.
 *
 * You can also use the SCSS mixin instead of paper.
 *
 * ```scss
 * @include md-box-shadow(5);
 * ```
 */

var Paper_Paper = function (_PureComponent) {
  Paper_inherits(Paper, _PureComponent);

  function Paper() {
    Paper_classCallCheck(this, Paper);

    return Paper_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Paper.prototype.render = function render() {
    var _props = this.props,
        Component = _props.component,
        zDepth = _props.zDepth,
        className = _props.className,
        raiseOnHover = _props.raiseOnHover,
        props = Paper_objectWithoutProperties(_props, ['component', 'zDepth', 'className', 'raiseOnHover']);

    return react_default.a.createElement(Component, Paper_extends({}, props, {
      className: classnames_default()('md-paper md-paper--' + zDepth, {
        'md-paper--0-hover': zDepth === 0 && raiseOnHover
      }, className)
    }));
  };

  return Paper;
}(react["PureComponent"]);

Paper_Paper.propTypes = {
  /**
   * The component to render the paper as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The depth of the paper. This should be a number between 0 - 5. If
   * the depth is 0, it will raise to a depth of 3 on hover.
   */
  zDepth: between(prop_types_default.a.number.isRequired, 0, 5),

  /**
   * Any children to display in the paper.
   */
  children: prop_types_default.a.node,

  /**
   * Boolean if the paper should raise to the `zDepth` of `3` on hover when the initial
   * `zDepth` is `0`.
   */
  raiseOnHover: prop_types_default.a.bool
};
Paper_Paper.defaultProps = {
  zDepth: 1,
  component: 'div'
};
/* harmony default export */ var Papers_Paper = (Paper_Paper);
// CONCATENATED MODULE: ../node_modules/react-md/es/FontIcons/index.js

/* harmony default export */ var FontIcons = (FontIcons_FontIcon);



// CONCATENATED MODULE: ../node_modules/react-md/es/BottomNavigations/BottomNav.js
var BottomNav_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function BottomNav_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function BottomNav_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function BottomNav_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function BottomNav_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }










/**
 * The `BottomNav` component is used for rendering the navigation tab/link in the `BottomNavigation`
 * component.
 */

var BottomNav_BottomNav = function (_PureComponent) {
  BottomNav_inherits(BottomNav, _PureComponent);

  function BottomNav() {
    var _temp, _this, _ret;

    BottomNav_classCallCheck(this, BottomNav);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = BottomNav_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._handleClick = function (e) {
      var _this$props = _this.props,
          onClick = _this$props.onClick,
          onNavChange = _this$props.onNavChange,
          index = _this$props.index;

      if (onClick) {
        onClick(index, e);
      }

      if (onNavChange) {
        onNavChange(index, e);
      }
    }, _temp), BottomNav_possibleConstructorReturn(_this, _ret);
  }

  BottomNav.prototype.render = function render() {
    var _props = this.props,
        active = _props.active,
        fixed = _props.fixed,
        className = _props.className,
        colored = _props.colored,
        animate = _props.animate,
        iconClassName = _props.iconClassName,
        iconChildren = _props.iconChildren,
        index = _props.index,
        propIcon = _props.icon,
        propLabel = _props.label,
        onClick = _props.onClick,
        onNavChange = _props.onNavChange,
        props = BottomNav_objectWithoutProperties(_props, ['active', 'fixed', 'className', 'colored', 'animate', 'iconClassName', 'iconChildren', 'index', 'icon', 'label', 'onClick', 'onNavChange']);

    var _props2 = this.props,
        label = _props2.label,
        icon = _props2.icon;

    var labelClassName = classnames_default()('md-bottom-nav-label', { 'md-bottom-nav-label--shifting-inactive': !active && !fixed });
    if (react["Children"].count(label) === 1 && Object(react["isValidElement"])(label)) {
      var labelEl = react["Children"].only(label);
      label = Object(react["cloneElement"])(label, {
        className: classnames_default()(labelClassName, labelEl.props.className)
      });
    } else {
      label = react_default.a.createElement(
        'div',
        { className: labelClassName },
        label
      );
    }

    if (!icon && (iconClassName || iconChildren)) {
      // Deprecated
      icon = react_default.a.createElement(
        FontIcons,
        { iconClassName: iconClassName, inherit: true },
        iconChildren
      );
    } else if (icon) {
      icon = react_default.a.cloneElement(icon, { inherit: true });
    }

    return react_default.a.createElement(
      AccessibleFakeInkedButton,
      BottomNav_extends({}, props, {
        onClick: this._handleClick,
        className: classnames_default()('md-bottom-nav', {
          'md-bottom-nav--active': active,
          'md-bottom-nav--fixed': fixed,
          'md-bottom-nav--shifting': !fixed,
          'md-bottom-nav--shifting-active': !fixed && active,
          'md-bottom-nav--shifting-inactive': !fixed && !active
        }, themeColors({ primary: !colored && active, text: !active && !colored }, className))
      }),
      icon,
      react_default.a.createElement(
        Helpers_Collapse,
        { collapsed: !fixed && !active, animate: animate },
        label
      )
    );
  };

  return BottomNav;
}(react["PureComponent"]);

BottomNav_BottomNav.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),
  active: prop_types_default.a.bool,
  fixed: prop_types_default.a.bool,
  children: prop_types_default.a.node,
  index: prop_types_default.a.number.isRequired,
  label: prop_types_default.a.node.isRequired,
  colored: prop_types_default.a.bool,
  iconChildren: prop_types_default.a.node,
  iconClassName: prop_types_default.a.string,
  onClick: prop_types_default.a.func,
  onNavChange: prop_types_default.a.func,
  role: prop_types_default.a.string,
  animate: prop_types_default.a.bool,
  icon: prop_types_default.a.element
};
BottomNav_BottomNav.defaultProps = {
  component: 'a',
  role: null
};
/* harmony default export */ var BottomNavigations_BottomNav = (BottomNav_BottomNav);
// CONCATENATED MODULE: ../node_modules/react-md/es/BottomNavigations/BottomNavigation.js
var BottomNavigation_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function BottomNavigation_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function BottomNavigation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function BottomNavigation_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function BottomNavigation_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }













/**
 * The `BottomNavigation` component is an alternative to the `NavigationDrawer` for handling navigation
 * only on mobile devices.
 */

var BottomNavigation_BottomNavigation = function (_PureComponent) {
  BottomNavigation_inherits(BottomNavigation, _PureComponent);

  function BottomNavigation(props) {
    BottomNavigation_classCallCheck(this, BottomNavigation);

    var _this = BottomNavigation_possibleConstructorReturn(this, _PureComponent.call(this, props));

    BottomNavigation_initialiseProps.call(_this);

    var visible = typeof props.initiallyVisible === 'boolean' ? props.initiallyVisible : props.defaultVisible;
    _this.state = {
      visible: visible,
      portalVisible: visible
    };

    if (typeof props.activeIndex === 'undefined') {
      _this.state.activeIndex = props.defaultActiveIndex;
    }
    return _this;
  }

  BottomNavigation.prototype.componentDidMount = function componentDidMount() {
    if (this.props.dynamic) {
      this._addTouchEvents();
    }
  };

  BottomNavigation.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var dynamic = nextProps.dynamic;

    if (this.props.dynamic === dynamic) {
      return;
    }

    if (dynamic) {
      this._addTouchEvents();
    } else {
      this._removeTouchEvents();
    }
  };

  BottomNavigation.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {
    if (this.state.visible !== nextState.visible && nextProps.onVisibilityChange) {
      nextProps.onVisibilityChange(nextState.visible);
    }
  };

  BottomNavigation.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.dynamic) {
      this._removeTouchEvents();
    }

    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  BottomNavigation.prototype.render = function render() {
    var _this2 = this;

    var _state = this.state,
        visible = _state.visible,
        portalVisible = _state.portalVisible;

    var _props = this.props,
        className = _props.className,
        actions = _props.actions,
        colored = _props.colored,
        dynamic = _props.dynamic,
        lastChild = _props.lastChild,
        animate = _props.animate,
        portal = _props.portal,
        propLinks = _props.links,
        propActiveIndex = _props.activeIndex,
        propRenderNode = _props.renderNode,
        onNavChange = _props.onNavChange,
        onVisibilityChange = _props.onVisibilityChange,
        defaultVisible = _props.defaultVisible,
        defaultActiveIndex = _props.defaultActiveIndex,
        dynamicThreshold = _props.dynamicThreshold,
        transitionDuration = _props.transitionDuration,
        onChange = _props.onChange,
        initiallyVisible = _props.initiallyVisible,
        containerStyle = _props.containerStyle,
        containerClassName = _props.containerClassName,
        transitionName = _props.transitionName,
        transitionEnterTimeout = _props.transitionEnterTimeout,
        transitionLeaveTimeout = _props.transitionLeaveTimeout,
        props = BottomNavigation_objectWithoutProperties(_props, ['className', 'actions', 'colored', 'dynamic', 'lastChild', 'animate', 'portal', 'links', 'activeIndex', 'renderNode', 'onNavChange', 'onVisibilityChange', 'defaultVisible', 'defaultActiveIndex', 'dynamicThreshold', 'transitionDuration', 'onChange', 'initiallyVisible', 'containerStyle', 'containerClassName', 'transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout']);

    var links = this.props.links;

    if (actions) {
      links = actions;
    }

    var fixed = links.length === 3;
    var activeIndex = getField(this.props, this.state, 'activeIndex');
    var renderNode = getField(this.props, this.context, 'renderNode');
    var navigation = react_default.a.createElement(
      Papers_Paper,
      BottomNavigation_extends({}, props, {
        key: 'navigation',
        className: classnames_default()('md-bottom-navigation', {
          'md-background--card': !colored,
          'md-background--primary': colored,
          'md-bottom-navigation--dynamic': dynamic,
          'md-bottom-navigation--dynamic-inactive': dynamic && !visible
        }, className),
        role: 'navigation'
      }),
      links.map(function (action, index) {
        return react_default.a.createElement(BottomNavigations_BottomNav, BottomNavigation_extends({}, action, {
          animate: animate,
          key: action.key || index,
          index: index,
          onNavChange: _this2._handleNavChange,
          active: activeIndex === index,
          colored: colored,
          fixed: fixed
        }));
      })
    );

    if (!portal) {
      return portalVisible ? navigation : null;
    }

    return react_default.a.createElement(
      Helpers_Portal,
      { renderNode: renderNode, visible: portalVisible, lastChild: lastChild },
      navigation
    );
  };

  return BottomNavigation;
}(react["PureComponent"]);

BottomNavigation_BottomNavigation.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * A list of objects to generate a bottom navigation link. There must be at least 3 and no more
   * than 5 links. A link gets rendered as the `AccessibleFakeButton` component, so any additional
   * props in the link's shape will be passed along.
   *
   * ```docgen
   * PropTypes.arrayOf(PropTypes.shape({
   *   label: PropTypes.node.isRequired,
   *   icon: PropTypes.element,
   *   component: PropTypes.oneOfType([
   *      PropTypes.func,
   *      PropTypes.string,
   *   ]),
   * }).isRequired
   * ```
   */
  links: function links(props, propName, component) {
    for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    var _PropTypes$arrayOf;

    var links = props[propName] || props.actions;
    var len = links.length;

    if (len < 3) {
      return new Error('Only ' + len + ' `' + propName + '` were given to the ' + component + '. At least 3 are required.');
    } else if (len > 5) {
      return new Error(len + ' `' + propName + '` were given to the ' + component + '. No more than 5 may be given.');
    }

    return (_PropTypes$arrayOf = prop_types_default.a.arrayOf(prop_types_default.a.shape({
      label: prop_types_default.a.node.isRequired,
      icon: prop_types_default.a.element,
      iconChildren: deprecated_default()(prop_types_default.a.node, 'Use `icon` instead'),
      iconClassName: deprecated_default()(prop_types_default.a.string, 'Use `icon` instead'),
      component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string])
    }))).isRequired.apply(_PropTypes$arrayOf, [props, propName, component].concat(args));
  },

  /**
   * Boolean if the bottom navigation should be colored with the primary color or whatever color
   * was a result of the `react-md-theme-bottom-navigations-colored` mixin.
   */
  colored: prop_types_default.a.bool,

  /**
   * Boolean if the bottom navigation should dynamically appear based on scrolling. When the user
   * scrolls the `dynamicThreshold` amount, this component will either disappear (scrolling down)
   * or appear (scrolling up).
   */
  dynamic: prop_types_default.a.bool,

  /**
   * The distance a user must scroll before the bottom navigation appears or disappears when it is `dynamic`.
   */
  dynamicThreshold: prop_types_default.a.number.isRequired,

  /**
   * An optional function to call when a link has been clicked. The callback will
   * include the new active index and the click event.
   *
   * ```js
   * onNavChange(newActiveIndex, event);
   * ```
   */
  onNavChange: prop_types_default.a.func,

  /**
   * An optional active index to use. This will make the component controlled and require the
   * `onNavChange` prop to be defined.
   */
  activeIndex: controlled(prop_types_default.a.number, 'onNavChange', 'defaultActiveIndex'),

  /**
   * The index for the link that is active by default.
   */
  defaultActiveIndex: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the bottom navigation is visible by default. This *should* probably always
   * be true.
   */
  defaultVisible: prop_types_default.a.bool.isRequired,

  /**
   * The component to render the bottom navigation as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the bottom navigation.
   *
   * @see {@link Helpers/Portal}
   */
  portal: prop_types_default.a.bool,

  /**
   * Since the `BottomNavigation` component uses the `Portal` component, you can pass an optional
   * HTML Node to render in.
   */
  renderNode: prop_types_default.a.object,

  /**
   * Boolean if the bottom navigation should render as the last child in the `renderNode` or `body`
   * instead of as the first.
   */
  lastChild: prop_types_default.a.bool,

  /**
   * The transition duration for the dynamic bottom navigation to appear or disappear. This should
   * match the `$md-bottom-navigation-transition-time` variable.
   */
  transitionDuration: prop_types_default.a.number.isRequired,

  /**
   * An optional function to call when the visibility of the bottom navigation changes. The callback
   * will include the new visibility.
   *
   * ```js
   * onVisibilityChange(!visible);
   * ```
   */
  onVisibilityChange: prop_types_default.a.func,

  /**
   * Boolean if the label on a shifting navigation should animate in and out.
   */
  animate: prop_types_default.a.bool,

  onChange: deprecated_default()(prop_types_default.a.func, 'Use `onNavChange` instead'),
  initiallyVisible: deprecated_default()(prop_types_default.a.bool, 'Use `defaultVisible` instead'),
  initialActiveIndex: deprecated_default()(prop_types_default.a.number, 'Use `defaultActiveIndex` instead'),
  containerStyle: deprecated_default()(prop_types_default.a.object, 'Use `style` instead'),
  containerClassName: deprecated_default()(prop_types_default.a.string, 'Use `className` instead'),
  transitionName: deprecated_default()(prop_types_default.a.string, 'There is no CSSTransitionGroup used anymore'),
  transitionEnterTimeout: deprecated_default()(prop_types_default.a.number, 'Use `transitionDuration` instead'),
  transitionLeaveTimeout: deprecated_default()(prop_types_default.a.number, 'Use `transitionDuration` instead'),
  actions: deprecated_default()(prop_types_default.a.array, 'Use `links` instead')
};
BottomNavigation_BottomNavigation.defaultProps = {
  animate: true,
  defaultActiveIndex: 0,
  component: 'footer',
  defaultVisible: true,
  transitionDuration: 300,
  portal: false,
  dynamicThreshold: 5
};
BottomNavigation_BottomNavigation.contextTypes = {
  renderNode: prop_types_default.a.object
};

var BottomNavigation_initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this._addTouchEvents = function () {
    addTouchEvent(window, 'start', _this3._handleTouchStart);
    addTouchEvent(window, 'move', _this3._handleTouchMove);
    addTouchEvent(window, 'end', _this3._handleTouchEnd);
  };

  this._removeTouchEvents = function () {
    removeTouchEvent(window, 'start', _this3._handleTouchStart);
    removeTouchEvent(window, 'move', _this3._handleTouchMove);
    removeTouchEvent(window, 'end', _this3._handleTouchEnd);
  };

  this._animateIn = function () {
    if (_this3._timeout) {
      clearTimeout(_this3._timeout);
    }

    _this3._timeout = setTimeout(function () {
      _this3._timeout = null;
      _this3.setState({ visible: true });
    }, 17);

    _this3.setState({ portalVisible: true });
  };

  this._animateOut = function () {
    if (_this3._timeout) {
      clearTimeout(_this3._timeout);
    }

    _this3._timeout = setTimeout(function () {
      _this3._timeout = null;
      _this3.setState({ portalVisible: false });
    }, _this3.props.transitionDuration);

    _this3.setState({ visible: false });
  };

  this._handleTouchStart = function (e) {
    var pageY = e.changedTouches[0].pageY;


    _this3._pageY = pageY;
    _this3._scrolling = true;
  };

  this._handleTouchMove = function (e) {
    var visible = _this3.state.visible;

    if (!_this3._scrolling) {
      return;
    }

    var touchY = e.changedTouches[0].pageY;
    var dynamicThreshold = _this3.props.dynamicThreshold;

    var passedThreshold = Math.abs(_this3._pageY - touchY) >= dynamicThreshold;
    if (_this3._pageY > touchY && visible && passedThreshold) {
      _this3._pageY = touchY;
      _this3._animateOut();
    } else if (_this3._pageY < touchY && !visible && passedThreshold) {
      _this3._pageY = touchY;
      _this3._animateIn();
    }
  };

  this._handleTouchEnd = function () {
    _this3._scrolling = false;
  };

  this._handleNavChange = function (index, e) {
    if (_this3.props.onNavChange || _this3.props.onChange) {
      (_this3.props.onNavChange || _this3.props.onChange)(index, e);
    }

    if (typeof _this3.props.activeIndex === 'undefined') {
      _this3.setState({ activeIndex: index });
    }
  };
};

/* harmony default export */ var BottomNavigations_BottomNavigation = (BottomNavigation_BottomNavigation);
// CONCATENATED MODULE: ../node_modules/react-md/es/Buttons/getBtnStyles.js



/**
 * Since it can be helpful to apply button styles on other components, this is a utlity function
 * to apply those styles based on props.
 */
function getBtnStyles(_ref) {
  var _ref2;

  var flat = _ref.flat,
      raised = _ref.raised,
      icon = _ref.icon,
      floating = _ref.floating,
      disabled = _ref.disabled,
      primary = _ref.primary,
      secondary = _ref.secondary,
      hover = _ref.hover,
      swapTheming = _ref.swapTheming,
      pressed = _ref.pressed,
      mini = _ref.mini,
      fixed = _ref.fixed,
      fixedPosition = _ref.fixedPosition;

  var flatStyles = flat || icon;
  var raisedStyles = raised || floating;
  var textTheming = flatStyles && !swapTheming || raisedStyles && swapTheming;
  var backgroundTheming = (!disabled && raisedStyles && !swapTheming || flatStyles && swapTheming) && (primary || secondary);

  for (var _len = arguments.length, classNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    classNames[_key - 1] = arguments[_key];
  }

  return classnames_default.a.apply(undefined, ['md-btn', (_ref2 = {
    'md-btn--flat': flat || disabled && raised,
    'md-btn--raised': !disabled && raised,
    'md-btn--icon': icon || floating,
    'md-btn--floating': floating,
    'md-btn--text': flat || raised,
    'md-btn--hover': !disabled && hover,
    'md-btn--raised-disabled': disabled && raised,
    'md-btn--raised-pressed': !disabled && raisedStyles && pressed,
    'md-btn--fixed': fixed
  }, _ref2['md-btn--fixed-' + fixedPosition] = floating && fixed, _ref2['md-btn--floating-mini'] = floating && mini, _ref2['md-btn--color-primary-active'] = !disabled && primary && hover && textTheming, _ref2['md-btn--color-secondary-active'] = !disabled && secondary && hover && textTheming, _ref2['md-pointer--hover'] = !disabled, _ref2['md-paper md-paper--2'] = !disabled && floating, _ref2['md-paper--4'] = !disabled && floating && pressed, _ref2), themeColors({
    text: !icon && !floating && !backgroundTheming,
    themeText: !backgroundTheming,
    disabled: disabled,
    primary: primary,
    secondary: secondary,
    hover: true,
    ink: true
  })].concat(classNames));
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/IconSeparator.js
var IconSeparator_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function IconSeparator_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function IconSeparator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function IconSeparator_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function IconSeparator_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The `IconSeparator` component is a simple helper component to render some text and
 * an icon with some space between them while centering the text. The icon can either
 * come before or after the text.
 */

var IconSeparator_IconSeparator = function (_PureComponent) {
  IconSeparator_inherits(IconSeparator, _PureComponent);

  function IconSeparator() {
    IconSeparator_classCallCheck(this, IconSeparator);

    return IconSeparator_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  IconSeparator.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        labelStyle = _props.labelStyle,
        labelClassName = _props.labelClassName,
        component = _props.component,
        label = _props.label,
        iconBefore = _props.iconBefore,
        children = _props.children,
        props = IconSeparator_objectWithoutProperties(_props, ['className', 'labelStyle', 'labelClassName', 'component', 'label', 'iconBefore', 'children']);

    var text = void 0;
    if (Object(react["isValidElement"])(label)) {
      var labelProps = react["Children"].only(label).props;
      text = Object(react["cloneElement"])(label, {
        className: classnames_default()('md-icon-text', labelClassName, labelProps.className),
        style: IconSeparator_extends({}, labelStyle, labelProps.style)
      });
    } else {
      text = react_default.a.createElement(
        'span',
        { style: labelStyle, className: classnames_default()('md-icon-text', labelClassName) },
        label
      );
    }

    var Component = component;

    return react_default.a.createElement(
      Component,
      IconSeparator_extends({}, props, { className: classnames_default()('md-icon-separator', className) }),
      iconBefore && children,
      text,
      !iconBefore && children
    );
  };

  return IconSeparator;
}(react["PureComponent"]);

IconSeparator_IconSeparator.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the label.
   */
  labelStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the label.
   */
  labelClassName: prop_types_default.a.string,

  /**
   * The label to display.
   */
  label: prop_types_default.a.node.isRequired,

  /**
   * The icon to display.
   */
  children: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the icon should appear before or after the text
   */
  iconBefore: prop_types_default.a.bool,

  /**
   * The component to be rendered as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired
};
IconSeparator_IconSeparator.defaultProps = {
  component: 'div'
};
/* harmony default export */ var Helpers_IconSeparator = (IconSeparator_IconSeparator);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tooltips/Tooltip.js
function Tooltip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tooltip_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Tooltip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var Tooltip_Tooltip = function (_PureComponent) {
  Tooltip_inherits(Tooltip, _PureComponent);

  function Tooltip(props) {
    Tooltip_classCallCheck(this, Tooltip);

    var _this = Tooltip_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = {
      entering: false,
      leaving: false,
      active: false,
      visible: false
    };

    _this._timeout = null;
    return _this;
  }

  Tooltip.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  Tooltip.prototype.componentWillEnter = function componentWillEnter(cb) {
    var _this2 = this;

    this._timeout = setTimeout(function () {
      _this2._timeout = setTimeout(function () {
        _this2._timeout = null;

        cb();
      }, _this2.props.enterTimeout);
      _this2.setState({ active: true });
    }, CSSTransitionGroupTick);

    this.setState({ entering: true });
  };

  Tooltip.prototype.componentDidEnter = function componentDidEnter() {
    this.setState({ entering: false, active: false, visible: true });
  };

  Tooltip.prototype.componentWillLeave = function componentWillLeave(cb) {
    var _this3 = this;

    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    this._timeout = setTimeout(function () {
      _this3._timeout = setTimeout(function () {
        _this3._timeout = null;

        cb();
      }, _this3.props.leaveTimeout);

      _this3.setState({ active: true, visible: false });
    }, CSSTransitionGroupTick);

    this.setState({ leaving: true });
  };

  Tooltip.prototype.render = function render() {
    var _cn;

    var _state = this.state,
        active = _state.active,
        entering = _state.entering,
        leaving = _state.leaving,
        visible = _state.visible;
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        children = _props.children,
        position = _props.position;


    var direction = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical';
    return react_default.a.createElement(
      'span',
      {
        style: style,
        className: classnames_default()('md-tooltip md-tooltip--' + position + ' md-tooltip--' + direction, (_cn = {
          'md-tooltip--active': active,
          'md-tooltip--enter': entering,
          'md-tooltip--enter-active': entering && active,
          'md-tooltip--leave': leaving,
          'md-tooltip--leave-active': leaving && active
        }, _cn['md-tooltip--' + position + '-active'] = visible || entering && active, _cn), className)
      },
      children
    );
  };

  return Tooltip;
}(react["PureComponent"]);

Tooltip_Tooltip.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  position: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),
  children: prop_types_default.a.node.isRequired,
  enterTimeout: prop_types_default.a.number,
  leaveTimeout: prop_types_default.a.number
};
Tooltip_Tooltip.defaultProps = {
  position: 'bottom',
  enterTimeout: 150,
  leaveTimeout: 150
};
/* harmony default export */ var Tooltips_Tooltip = (Tooltip_Tooltip);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tooltips/TooltipContainer.js
function TooltipContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TooltipContainer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TooltipContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }












function getContainer(tooltip) {
  return tooltip.parentNode;
}

var TooltipContainer_TooltipContainer = function (_PureComponent) {
  TooltipContainer_inherits(TooltipContainer, _PureComponent);

  function TooltipContainer() {
    var _temp, _this, _ret;

    TooltipContainer_classCallCheck(this, TooltipContainer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = TooltipContainer_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { visible: false }, _this._delayedTimeout = null, _this._unlinkTarget = function () {
      var target = _this._target;
      if (target) {
        removeTouchEvent(target, 'start', _this._showTooltip);
        removeTouchEvent(target, 'end', _this._hideTooltip);
        target.removeEventListener('mouseover', _this._showTooltip);
        target.removeEventListener('mouseleave', _this._hideTooltip);
        target.removeEventListener('keyup', _this._handleKeyUp);
        target.removeEventListener('blur', _this._hideTooltip);
      }
    }, _this._setTarget = function () {
      var container = _this._container;
      var target = _this.props.target;


      _this._unlinkTarget();

      if (typeof target === 'function') {
        target = target(container, _this);
      }
      target = target ? Object(react_dom["findDOMNode"])(target) : container;
      _this._target = target || null;

      if (target) {
        addTouchEvent(target, 'start', _this._showTooltip);
        addTouchEvent(target, 'end', _this._hideTooltip);
        target.addEventListener('mouseover', _this._showTooltip);
        target.addEventListener('mouseleave', _this._hideTooltip);
        target.addEventListener('keyup', _this._handleKeyUp);
        target.addEventListener('blur', _this._hideTooltip);
      }
    }, _this._setContainers = function (span) {
      if (span) {
        _this._container = _this.props.container(span.parentNode, _this);
      }
    }, _this._stopContextMenu = function (e) {
      e.preventDefault();
      window.removeEventListener('contextmenu', _this._stopContextMenu, true);
      captureNextEvent('click');
      _this.setState({ visible: true });
    }, _this._showTooltip = function (e) {
      if (e.type === 'mouseover' && _this._touched) {
        return;
      }

      if (e.type === 'touchstart') {
        _this._touched = true;

        window.addEventListener('contextmenu', _this._stopContextMenu, true);
        return;
      }

      var delay = _this.props.delay;

      if (_this._delayedTimeout) {
        clearTimeout(_this._delayedTimeout);
      }

      if (delay) {
        _this._delayedTimeout = setTimeout(function () {
          _this._delayedTimeout = null;

          _this.setState({ visible: true });
        }, delay);
      } else {
        _this.setState({ visible: true });
      }
    }, _this._hideTooltip = function (e) {
      if (_this._delayedTimeout) {
        clearTimeout(_this._delayedTimeout);
      }

      if (e.type === 'mouseover' && _this._touched) {
        return;
      }

      _this.setState({ visible: false });
    }, _this._handleKeyUp = function (e) {
      if ((e.which || e.keyCode) === TAB) {
        _this._showTooltip(e);
      }
    }, _temp), TooltipContainer_possibleConstructorReturn(_this, _ret);
  }

  TooltipContainer.prototype.componentDidMount = function componentDidMount() {
    this._setTarget();
  };

  TooltipContainer.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.target !== prevProps.target) {
      this._setTarget();
    }
  };

  TooltipContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    this._unlinkTarget();
    this._target = null;

    if (this._delayedTimeout) {
      clearTimeout(this._delayedTimeout);
    }
  };

  TooltipContainer.prototype.render = function render() {
    var visible = this.state.visible;
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        tooltipStyle = _props.tooltipStyle,
        tooltipClassName = _props.tooltipClassName,
        label = _props.label,
        position = _props.position,
        enterTimeout = _props.enterTimeout,
        leaveTimeout = _props.leaveTimeout;


    var tooltip = react_default.a.createElement(
      Tooltips_Tooltip,
      {
        key: 'tooltip',
        style: tooltipStyle,
        className: tooltipClassName,
        position: position,
        enterTimeout: enterTimeout,
        leaveTimeout: leaveTimeout
      },
      label
    );

    return react_default.a.createElement(
      TransitionGroup_default.a,
      {
        style: style,
        className: classnames_default()('md-tooltip-container', className),
        component: 'div'
      },
      react_default.a.createElement('span', { ref: this._setContainers, 'aria-hidden': true }),
      visible ? tooltip : null
    );
  };

  return TooltipContainer;
}(react["PureComponent"]);

TooltipContainer_TooltipContainer.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  tooltipStyle: prop_types_default.a.object,
  tooltipClassName: prop_types_default.a.string,
  label: prop_types_default.a.node.isRequired,
  position: Tooltips_Tooltip.propTypes.position,
  delay: prop_types_default.a.number,
  enterTimeout: Tooltips_Tooltip.propTypes.enterTimeout,
  leaveTimeout: Tooltips_Tooltip.propTypes.leaveTimeout,
  /**
   * A function that returns a DOM element that will be used as the tooltip's container.
   * A ref to the tooltip's DOM element will be passed into the function.
   */
  container: prop_types_default.a.func,
  /**
   * A component/element the tooltip should be linked to,
   * or a function that returns such a component/element.
   * A ref to the tooltip's container will be passed into the function.
   *
   * By default the tooltip's container will be used as the target.
   */
  target: prop_types_default.a.oneOfType([prop_types_default.a.object, prop_types_default.a.func])
};
TooltipContainer_TooltipContainer.defaultProps = {
  container: getContainer,
  delay: 0
};
/* harmony default export */ var Tooltips_TooltipContainer = (TooltipContainer_TooltipContainer);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tooltips/injectTooltip.js
function injectTooltip_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function injectTooltip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function injectTooltip_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function injectTooltip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * Takes any component and injects a tooltip container as a prop. The tooltip container
 * will add event listeners for touch, mouse, and keyboard events so that a tooltip will appear
 * in the ComposedComponent.
 *
 * If the `tooltipLabel` prop is omitted, the tooltip and event listeners will not
 * be included.
 *
 * ```js
 * @param {function} ComposedComponent the component to compose with the tooltip functionality.
 * @return {function} the ComposedComponent with a tooltip.
 * ```
 */
/* harmony default export */ var injectTooltip = (function (ComposedComponent) {
  var _class, _temp2;

  return _temp2 = _class = function (_PureComponent) {
    injectTooltip_inherits(TooltipedComponent, _PureComponent);

    function TooltipedComponent() {
      var _temp, _this, _ret;

      injectTooltip_classCallCheck(this, TooltipedComponent);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = injectTooltip_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._composed = null, _this.getComposedComponent = function () {
        return _this._composed;
      }, _this._setComposedComponent = function (component) {
        _this._composed = component;
      }, _temp), injectTooltip_possibleConstructorReturn(_this, _ret);
    }

    /**
     * Gets the composed component as a ref. This is useful if you need to access the ref of the
     * composed component instead of the `injectTooltip` HOC to use some publicly accessible methods.
     *
     * ```js
     * <SomeTooltippedComponent
     *   ref={tooltipHOC => {
     *     tooltipHOC.getComposedComponent().focus();
     *   }}
     * />
     * ```
     *
     * > NOTE: This can be `null`, so make sure to do a null check before using.
     */


    TooltipedComponent.prototype.render = function render() {
      var _props = this.props,
          tooltipLabel = _props.tooltipLabel,
          tooltipDelay = _props.tooltipDelay,
          tooltipPosition = _props.tooltipPosition,
          tooltipStyle = _props.tooltipStyle,
          tooltipClassName = _props.tooltipClassName,
          tooltipContainerStyle = _props.tooltipContainerStyle,
          tooltipContainerClassName = _props.tooltipContainerClassName,
          tooltipTransitionEnterTimeout = _props.tooltipTransitionEnterTimeout,
          tooltipTransitionLeaveTimeout = _props.tooltipTransitionLeaveTimeout,
          props = injectTooltip_objectWithoutProperties(_props, ['tooltipLabel', 'tooltipDelay', 'tooltipPosition', 'tooltipStyle', 'tooltipClassName', 'tooltipContainerStyle', 'tooltipContainerClassName', 'tooltipTransitionEnterTimeout', 'tooltipTransitionLeaveTimeout']);

      if (tooltipLabel) {
        props.tooltip = react_default.a.createElement(Tooltips_TooltipContainer, {
          key: 'tooltipContainer',
          label: tooltipLabel,
          delay: tooltipDelay,
          position: tooltipPosition,
          enterTimeout: tooltipTransitionEnterTimeout,
          leaveTimeout: tooltipTransitionLeaveTimeout,
          style: tooltipContainerStyle,
          className: tooltipContainerClassName,
          tooltipStyle: tooltipStyle,
          tooltipClassName: tooltipClassName
        });
      }

      props.ref = this._setComposedComponent;

      return react_default.a.createElement(ComposedComponent, props);
    };

    return TooltipedComponent;
  }(react["PureComponent"]), _class.displayName = getDisplayName(ComposedComponent, 'Tooltip'), _class.propTypes = {
    /**
     * An optional style to apply to the tooltip container.
     */
    tooltipContainerStyle: prop_types_default.a.object,

    /**
     * An optional className to apply to the tooltip container.
     */
    tooltipContainerClassName: prop_types_default.a.string,

    /**
     * An optional style to apply to the tooltip itself.
     */
    tooltipStyle: prop_types_default.a.object,

    /**
     * An optional className to the tooltip itself.
     */
    tooltipClassName: prop_types_default.a.string,

    /**
     * The tooltip to display. If omitted, the `tooltip` prop will not be injected.
     */
    tooltipLabel: prop_types_default.a.node,

    /**
     * The amount of delay before the tooltip will appear on hover, touch, or keyboard focus.
     */
    tooltipDelay: Tooltips_TooltipContainer.propTypes.delay,

    /**
     * The position that the tooltip should appear related to the composed component.
     */
    tooltipPosition: Tooltips_TooltipContainer.propTypes.position,

    /**
     * The transition time for the tooltip appearing.
     */
    tooltipTransitionEnterTimeout: Tooltips_TooltipContainer.propTypes.enterTimeout,

    /**
     * The transition time for the tooltip disappearing.
     */
    tooltipTransitionLeaveTimeout: Tooltips_TooltipContainer.propTypes.leaveTimeout
  }, _temp2;
});
// CONCATENATED MODULE: ../node_modules/react-md/es/Buttons/Button.js
var Button_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Button_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Button_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Button_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Button_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }















/**
 * The `Button` component can either be a `FlatButton`, `RaisedButton`, `IconButton`, or a
 * `FloatingButton`.
 *
 * A `FlatButton` is a button with no depth on the screen that is ideally used in `Dialog`s
 * or `CardActions`. The text can be optionally styled with the `primary` or `secondary` colors.
 *
 * A `RaisedButton` is a button with some depth to help actions have more prominent in flat
 * layouts or layouts with varying content. The background can be styled by the light/dark theme,
 * or optionally the `primary` or `secondary` color.
 *
 * An `IconButton` is a button that just displays a `FontIcon` as the child in a circle.
 * The `FontIcon` can be optionally styled with the `primary` or `secondary` color.
 *
 * A `FloatingButton` is a special case. Woop
 */

var Button_Button = function (_PureComponent) {
  Button_inherits(Button, _PureComponent);

  function Button() {
    var _temp, _this, _ret;

    Button_classCallCheck(this, Button);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Button_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), Button_initialiseProps.call(_this), _temp), Button_possibleConstructorReturn(_this, _ret);
  }

  Button.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.disabled && !nextProps.disabled && this.state.hover) {
      this.setState({ hover: false });
    }
  };

  Button.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {
    var _this2 = this;

    if (!this.state.pressed && nextState.pressed) {
      this._timeout = setTimeout(function () {
        _this2._timeout = null;
        if (_this2._attemptedBlur) {
          _this2._attemptedBlur = false;

          _this2.setState({ pressed: false });
        }
      }, 450);
    }
  };

  Button.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    if (this._snackbarTimeout) {
      clearTimeout(this._snackbarTimeout);
    }

    window.removeEventListener('click', this._blur);
  };

  Button.prototype.render = function render() {
    var _getBtnStyles;

    var _props = this.props,
        className = _props.className,
        iconClassName = _props.iconClassName,
        iconChildren = _props.iconChildren,
        iconBefore = _props.iconBefore,
        href = _props.href,
        primary = _props.primary,
        secondary = _props.secondary,
        flat = _props.flat,
        raised = _props.raised,
        floating = _props.floating,
        mini = _props.mini,
        fixed = _props.fixed,
        fixedPosition = _props.fixedPosition,
        disabled = _props.disabled,
        component = _props.component,
        ink = _props.ink,
        tooltip = _props.tooltip,
        icon = _props.icon,
        forceIconSize = _props.forceIconSize,
        forceIconFontSize = _props.forceIconFontSize,
        type = _props.type,
        children = _props.children,
        swapTheming = _props.swapTheming,
        svg = _props.svg,
        propIconEl = _props.iconEl,
        label = _props.label,
        props = Button_objectWithoutProperties(_props, ['className', 'iconClassName', 'iconChildren', 'iconBefore', 'href', 'primary', 'secondary', 'flat', 'raised', 'floating', 'mini', 'fixed', 'fixedPosition', 'disabled', 'component', 'ink', 'tooltip', 'icon', 'forceIconSize', 'forceIconFontSize', 'type', 'children', 'swapTheming', 'svg', 'iconEl', 'label']);

    var iconEl = this.props.iconEl;


    if (!href) {
      props.type = type;
    }

    var _state = this.state,
        pressed = _state.pressed,
        hover = _state.hover,
        snackbar = _state.snackbar,
        snackbarType = _state.snackbarType;

    var iconBtnType = icon || floating;

    var visibleChildren = void 0;
    if (!iconEl && !svg && (iconClassName || iconChildren || iconBtnType || label && children)) {
      var resolvedIconChildren = iconChildren;
      if (typeof iconChildren === 'undefined') {
        resolvedIconChildren = iconBtnType || label ? children : null;
      }

      iconEl = react_default.a.createElement(
        FontIcons_FontIcon,
        { iconClassName: iconClassName, forceSize: forceIconSize, forceFontSize: forceIconFontSize, inherit: true },
        resolvedIconChildren
      );
    } else if (iconEl || svg) {
      var el = react_default.a.Children.only(iconEl || children);
      iconEl = react_default.a.cloneElement(el, { inherit: !el.props.error });
    }

    if (!iconBtnType) {
      visibleChildren = label || children;
      if (iconEl) {
        visibleChildren = react_default.a.createElement(
          Helpers_IconSeparator,
          { label: visibleChildren, iconBefore: iconBefore },
          iconEl
        );
      }
    } else {
      visibleChildren = iconEl;
    }

    var Component = component || (href ? 'a' : 'button');
    return react_default.a.createElement(
      Component,
      Button_extends({}, props, {
        disabled: disabled,
        onTouchStart: this._handleTouchStart,
        onTouchEnd: this._handleTouchEnd,
        onMouseDown: this._handleMouseDown,
        onMouseUp: this._handleMouseUp,
        onKeyDown: this._handleKeyDown,
        onKeyUp: this._handleKeyUp,
        onMouseEnter: this._handleMouseEnter,
        onMouseLeave: this._handleMouseLeave,
        href: href,
        className: getBtnStyles({
          flat: flat,
          raised: raised,
          icon: icon,
          floating: floating,
          disabled: disabled,
          primary: primary,
          secondary: secondary,
          hover: hover,
          swapTheming: swapTheming,
          pressed: pressed,
          mini: mini,
          fixed: fixed,
          fixedPosition: fixedPosition
        }, (_getBtnStyles = {
          'md-btn--tooltip': tooltip,
          'md-btn--snackbar-floating': snackbar
        }, _getBtnStyles['md-btn--snackbar-floating-' + snackbarType + 'adjust'] = snackbar && snackbarType !== null, _getBtnStyles), 'md-inline-block', className)
      }),
      ink,
      tooltip,
      visibleChildren
    );
  };

  return Button;
}(react["PureComponent"]);

Button_Button.propTypes = {
  /**
   * An optional style to apply to the button.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the button.
   */
  className: prop_types_default.a.string,

  /**
   * A boolean if the icon should appear before or after the text for a `FlatButton` or
   * a `RaisedButton`.
   */
  iconBefore: prop_types_default.a.bool,

  /**
   * Any children used to display the button. When the button type is `icon` or `floating`,
   * this can be used to render the `FontIcon` instead of the `iconChildren` prop.
   *
   * When the button type is `raised` or `flat`, this will be the label or any other elements
   * you'd like to display in the button. This can work hand-in-hand with the `iconClassName`
   * and `iconChildren` to make a button with an icon and text.
   */
  children: prop_types_default.a.node,

  /**
   * An icon className to use in an optional `FontIcon` in any version of the button. This will
   * be used with the `children` prop. If the `floating` or `icon` props are set to true, this or
   * the children are required.
   *
   * @see {@link #iconEl}
   */
  iconClassName: prop_types_default.a.string,

  /**
   * Any children to use to display an icon in the button.
   *
   * @see {@link #iconEl}
   */
  iconChildren: prop_types_default.a.node,

  /**
   * An optional icon to display. This prop is recommended over the `iconClassName` and `iconChildren`
   * props since it allows more control for you. There is also better SVG support since it won't wrap
   * the SVG with the `FontIcon` element.
   */
  iconEl: prop_types_default.a.element,

  /**
   * The type for the button. This is required when the `component` prop is not
   * the 'a' tag, a `function`, or when the `href` prop is defined.
   */
  type: function type(props, propName, component) {
    for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      args[_key2 - 3] = arguments[_key2];
    }

    var c = props.component;
    var validator = prop_types_default.a.oneOf(['button', 'submit', 'reset']);
    if (!props.href && c !== 'a' && typeof c !== 'function') {
      validator = validator.isRequired;
    }

    return validator.apply(undefined, [props, propName, component].concat(args));
  },

  /**
   * Boolean if the button should be styled with the primary color.
   */
  primary: prop_types_default.a.bool,

  /**
   * Boolean if the button should be styled with the secondary color.
   */
  secondary: prop_types_default.a.bool,

  /**
   * Boolean if the button is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * An optional href for the button. This will style the `a` tag as a button.
   */
  href: prop_types_default.a.string,

  /**
   * An optional component to render the button as. This allows you to get all the styles and functionality
   * of the Button, but as a custom React component.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]),

  /**
   * An optional function to call when the `click` event is triggered.
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional function to call when the `touchstart` event is triggered.
   */
  onTouchStart: prop_types_default.a.func,

  /**
   * An optional function to call when the `touchend` event is triggered.
   */
  onTouchEnd: prop_types_default.a.func,

  /**
   * An optional function to call when the `mousedown` event is triggered.
   */
  onMouseDown: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseup` event is triggered.
   */
  onMouseUp: prop_types_default.a.func,

  /**
   * An optional function to call when the `keyup` event is triggered.
   */
  onKeyUp: prop_types_default.a.func,

  /**
   * An optional function to call when the `keydown` event is triggered.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseenter` event is triggered.
   */
  onMouseEnter: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseleave` event is triggered.
   */
  onMouseLeave: prop_types_default.a.func,

  /**
   * Boolean if the `FloatingButton` should be fixed to the page. This prop can
   * only be enabled if the `floating` prop is true.
   */
  fixed: invalidIf(prop_types_default.a.bool, 'flat', 'raised', 'icon'),

  /**
   * The position that the `FloatingButton` should be fixed to the page. It will
   * either be fixed to the top right, top left, bottom right, or bottom left of
   * the page. This prop is only used if the `floating` prop and `fixed` prop are
   * `true`.
   */
  fixedPosition: prop_types_default.a.oneOf(['tr', 'tl', 'br', 'bl']).isRequired,

  /**
   * Boolean if the `FloatingButton` should be `mini`. This prop can only be used
   * when the `floating` prop is true.
   */
  mini: invalidIf(prop_types_default.a.bool, 'flat', 'raised', 'icon'),

  /**
   * Boolean if the `Button` should be styled as a `FlatButton`.
   */
  flat: prop_types_default.a.bool,

  /**
   * Boolean if the `Button` should be styled as a `RaisedButton`.
   */
  raised: prop_types_default.a.bool,

  /**
   * Boolean if the `Button` should be styled as a `IconButton`.
   *
   * @see {@link #svg}
   */
  icon: prop_types_default.a.bool,

  /**
   * Boolean if the `Button` should be styled as a `FloatingButton`.
   *
   * @see {@link #svg}
   */
  floating: prop_types_default.a.bool,

  /**
   * Boolean if the theming of `primary` or `secondary` should be swapped. By default,
   * only flat and icon buttons can gain the theme colors as text color while the raised
   * and floating buttons can gain the theme colors as background color.
   *
   * If this prop is enabled, the flat and icon buttons will gain the theme background colors
   * while the raised and icon will gain the theme text colors instead.
   *
   * @see {@link #primary}
   * @see {@link #secondary}
   */
  swapTheming: prop_types_default.a.bool,

  /**
   * An optional label to use for the tooltip. This is normally only used for
   * `IconButton`s or `FloatingButton`s, but can be used on `FlatButton`s and
   * `RaisedButton`s if you wish. Knock yourself out!
   *
   * If this prop is omitted, no tooltip will be included.
   */
  tooltipLabel: prop_types_default.a.node,

  /**
   * An optional delay before the tooltip appears on mouse over.
   */
  tooltipDelay: prop_types_default.a.number,

  /**
   * The position for the tooltip.
   */
  tooltipPosition: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * An ink from `injectInk`.
   * @access private
   */
  ink: prop_types_default.a.node,

  /**
   * A tooltip from `injectTooltip`
   * @access private
   */
  tooltip: prop_types_default.a.node,

  /**
   * Custom validator for verifying that only one type is defined and that
   * at one type is defined.
   */
  _typeValidator: function _typeValidator(props, propName, component) {
    var flat = props.flat,
        raised = props.raised,
        icon = props.icon,
        floating = props.floating;


    var defined = [raised, flat, icon, floating].filter(function (d) {
      return d;
    });
    var len = defined.length;
    if (len === 0) {
      return new Error('A material design button type must be specified in the `' + component + '` but none were ' + 'given. Valid types are `flat`, `raised`, `icon`, or `floating`.');
    } else if (len !== 1) {
      return new Error('Only one material design button type may be specified in the `' + component + '` but `' + len + '` ' + 'were given. Select only one of `flat`, `raised`, `icon`, or `floating`.');
    }

    return null;
  },

  /**
   * Either a boolean that will enforce the 24x24 size of the font icon or a number of the size
   * to enforce. This is useful when using other font icon libraries that do not have a consistent
   * size.
   */
  forceIconSize: FontIcons_FontIcon.propTypes.forceSize,

  /**
   * Boolean if the `forceIconSize` prop should also force the `font-size` instead of only `width` and `height`.
   */
  forceIconFontSize: prop_types_default.a.bool,

  /**
   * Boolean if the child is an SVGIcon or FontIcon when using the `icon` or `floating` props. This is only needed
   * until the next release when the `label` migration can be removed.
   */
  svg: prop_types_default.a.bool,

  label: deprecated_default()(prop_types_default.a.node, 'Use the `children` prop instead'),
  noIcon: deprecated_default()(prop_types_default.a.bool, 'This has been removed during the alpha release. Children will always attempt to be rendered outside of an ' + 'icon by default for flat and raised buttons')
};
Button_Button.defaultProps = {
  type: 'button',
  iconBefore: true,
  fixedPosition: 'br'
};

var Button_initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.state = {
    pressed: false,
    snackbar: false,
    snackbarType: null
  };

  this._blur = function () {
    if (_this3.props.disabled) {
      return;
    }

    if (_this3._timeout) {
      _this3._attemptedBlur = true;
    } else {
      _this3.setState({ pressed: false });
    }
  };

  this._handleMouseUp = function (e) {
    if (_this3.props.onMouseUp) {
      _this3.props.onMouseUp(e);
    }

    _this3._blur();
  };

  this._handleMouseDown = function (e) {
    if (_this3.props.onMouseDown) {
      _this3.props.onMouseDown(e);
    }

    if (!_this3.props.disabled) {
      _this3.setState({ pressed: true });
    }
  };

  this._handleTouchStart = function (e) {
    if (_this3.props.onTouchStart) {
      _this3.props.onTouchStart(e);
    }

    if (!_this3.props.disabled) {
      _this3.setState({ pressed: true });
    }
  };

  this._handleTouchEnd = function (e) {
    if (_this3.props.onTouchEnd) {
      _this3.props.onTouchEnd(e);
    }

    _this3._blur();
    captureNextEvent('mouseover');
  };

  this._handleKeyUp = function (e) {
    if (_this3.props.onKeyUp) {
      _this3.props.onKeyUp(e);
    }

    if ((e.which || e.keyCode) === TAB) {
      window.addEventListener('click', _this3._blur);
      _this3.setState({ pressed: true });
    }
  };

  this._handleKeyDown = function (e) {
    if (_this3.props.onKeyDown) {
      _this3.props.onKeyDown(e);
    }

    if ((e.which || e.keyCode) === TAB) {
      window.removeEventListener('click', _this3._blur);
      _this3.setState({ pressed: false });
    }
  };

  this._handleMouseEnter = function (e) {
    if (_this3.props.onMouseEnter) {
      _this3.props.onMouseEnter(e);
    }

    if (!_this3.props.disabled) {
      _this3.setState({ hover: true });
    }
  };

  this._handleMouseLeave = function (e) {
    if (_this3.props.onMouseLeave) {
      _this3.props.onMouseLeave(e);
    }

    if (!_this3.props.disabled) {
      _this3.setState({ hover: false });
    }
  };

  this._animateForSnackbar = function (multiline, leaveTimeout) {
    if (typeof leaveTimeout === 'number') {
      _this3._snackbarTimeout = setTimeout(function () {
        _this3._snackbarTimeout = setTimeout(function () {
          _this3._snackbarTimeout = null;

          _this3.setState({ snackbar: false });
        }, leaveTimeout + 150);

        _this3.setState({ snackbarType: null });
      }, CSSTransitionGroupTick);
    } else {
      _this3._snackbarTimeout = setTimeout(function () {
        _this3._snackbarTimeout = null;

        _this3.setState({ snackbar: true, snackbarType: multiline ? 'multiline-' : '' });
      }, CSSTransitionGroupTick);
    }
  };
};

/* harmony default export */ var Buttons_Button = (injectInk(injectTooltip(Button_Button)));
// CONCATENATED MODULE: ../node_modules/react-md/es/Cards/contextTypes.js


/* harmony default export */ var contextTypes = ({
  onExpandClick: prop_types_default.a.func,
  expanded: prop_types_default.a.bool,
  icon: prop_types_default.a.element,
  tooltipPosition: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),
  tooltipLabel: prop_types_default.a.node,
  tooltipDelay: prop_types_default.a.number
});
// CONCATENATED MODULE: ../node_modules/react-md/es/Cards/Card.js
var Card_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Card_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Card_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Card_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Card_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }














var Card_Card = function (_PureComponent) {
  Card_inherits(Card, _PureComponent);

  function Card(props) {
    Card_classCallCheck(this, Card);

    var _this = Card_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._handleMouseOver = function (e) {
      if (_this.props.onMouseOver) {
        _this.props.onMouseOver(e);
      }

      if (_this.props.raise && !_this._touched) {
        _this.setState({ zDepth: 4 });
      }
    };

    _this._handleMouseLeave = function (e) {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave(e);
      }

      _this._touched = false;
      if (_this.props.raise && _this.state.zDepth !== 1) {
        _this.setState({ zDepth: 1 });
      }
    };

    _this._handleTouchStart = function (e) {
      if (_this.props.onTouchStart) {
        _this.props.onTouchStart(e);
      }

      _this._touched = true;
    };

    _this._handleExpandClick = function (e) {
      var onExpanderClick = _this.props.onExpanderClick;

      var expanded = !getField(_this.props, _this.state, 'expanded');
      if (onExpanderClick) {
        onExpanderClick(expanded, e);
      }

      if (typeof _this.props.expanded === 'undefined') {
        _this.setState({ expanded: expanded });
      }
    };

    _this.state = {
      zDepth: 1,
      expanded: typeof props.initiallyExpanded !== 'undefined' ? props.initiallyExpanded : !!props.defaultExpanded
    };
    return _this;
  }

  Card.prototype.getChildContext = function getChildContext() {
    var _props = this.props,
        expanderTooltipLabel = _props.expanderTooltipLabel,
        expanderTooltipDelay = _props.expanderTooltipDelay,
        expanderTooltipPosition = _props.expanderTooltipPosition,
        expanderIcon = _props.expanderIcon,
        iconClassName = _props.iconClassName,
        iconChildren = _props.iconChildren,
        expanderIconClassName = _props.expanderIconClassName,
        expanderIconChildren = _props.expanderIconChildren;


    var expanded = typeof this.props.isExpanded !== 'undefined' ? this.props.isExpanded : getField(this.props, this.state, 'expanded');

    return {
      expanded: expanded,
      onExpandClick: this._handleExpandClick,
      icon: getDeprecatedIcon(iconChildren || expanderIconChildren, iconClassName || expanderIconClassName, expanderIcon),
      tooltipLabel: expanderTooltipLabel,
      tooltipDelay: expanderTooltipDelay,
      tooltipPosition: expanderTooltipPosition
    };
  };

  Card.prototype.render = function render() {
    var zDepth = this.state.zDepth;

    var _props2 = this.props,
        className = _props2.className,
        raise = _props2.raise,
        tableCard = _props2.tableCard,
        children = _props2.children,
        animate = _props2.animate,
        propExpanded = _props2.expanded,
        onExpanderClick = _props2.onExpanderClick,
        defaultExpanded = _props2.defaultExpanded,
        expanderIcon = _props2.expanderIcon,
        expanderIconChildren = _props2.expanderIconChildren,
        expanderIconClassName = _props2.expanderIconClassName,
        expanderTooltipLabel = _props2.expanderTooltipLabel,
        expanderTooltipDelay = _props2.expanderTooltipDelay,
        expanderTooltipPosition = _props2.expanderTooltipPosition,
        iconChildren = _props2.iconChildren,
        iconClassName = _props2.iconClassName,
        isExpanded = _props2.isExpanded,
        initiallyExpanded = _props2.initiallyExpanded,
        props = Card_objectWithoutProperties(_props2, ['className', 'raise', 'tableCard', 'children', 'animate', 'expanded', 'onExpanderClick', 'defaultExpanded', 'expanderIcon', 'expanderIconChildren', 'expanderIconClassName', 'expanderTooltipLabel', 'expanderTooltipDelay', 'expanderTooltipPosition', 'iconChildren', 'iconClassName', 'isExpanded', 'initiallyExpanded']);

    var expanded = typeof this.props.isExpanded !== 'undefined' ? this.props.isExpanded : getField(this.props, this.state, 'expanded');
    var expanderIndex = -1;
    var parts = react["Children"].map(react["Children"].toArray(children), function (child, i) {
      if (!child || !child.props) {
        return child;
      } else if (expanderIndex < 0 && (child.props.isExpander || child.props.expander)) {
        expanderIndex = i;
      }

      if (!child.props.expandable) {
        return child;
      }

      var collapsed = expanderIndex === -1 || expanderIndex === i || !expanded;
      return react_default.a.createElement(
        Helpers_Collapse,
        { collapsed: collapsed, animate: animate },
        child
      );
    });

    return react_default.a.createElement(
      Papers_Paper,
      Card_extends({}, props, {
        zDepth: zDepth,
        className: classnames_default()('md-card', {
          'md-card--raise': raise,
          'md-card--table': tableCard
        }, 'md-background--card', className),
        onMouseOver: this._handleMouseOver,
        onMouseLeave: this._handleMouseLeave,
        onTouchStart: this._handleTouchStart
      }),
      parts
    );
  };

  return Card;
}(react["PureComponent"]);

Card_Card.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the card.
   */
  className: prop_types_default.a.string,

  /**
   * Any Card parts that should be rendered.
   */
  children: prop_types_default.a.node,

  /**
   * Boolean if the card is expanded by default when there is an expander
   * component.
   */
  defaultExpanded: prop_types_default.a.bool,

  /**
   * Boolean if the card should raise on hover when on a desktop display.
   */
  raise: prop_types_default.a.bool,

  /**
   * Boolean if the card is currently expanded. This will require the `onExpanderClick` function
   * to toggle the state. The card will become controlled if this is not `undefined`.
   */
  expanded: controlled(prop_types_default.a.bool, 'onExpanderClick', 'defaultExpanded'),

  /**
   * An optional function to call when the expander is clicked.
   */
  onExpanderClick: prop_types_default.a.func,

  /**
   * The icon to use for the expander button. It is recommended to use this prop over
   * the `expaderIconChildren` and `expanderIconClassName` since it provides more control.
   */
  expanderIcon: prop_types_default.a.element,

  /**
   * The tooltip position for the expander icon.
   */
  expanderTooltipPosition: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * The optional tooltip to display for the expander icon.
   */
  expanderTooltipLabel: prop_types_default.a.node,

  /**
   * An optional delay before the tooltip appears for the expander icon on hover.
   */
  expanderTooltipDelay: prop_types_default.a.number,

  /**
   * Boolean if the card contains a table. It will update the styling accordingly.
   * When using the `DataTable` component, do not wrap it in a `CardText` component.
   *
   * ```js
   * <Card tableCard={true}>
   *   <CardTitle title="Example />
   *   <DataTable>
   *     ...
   *   </DataTable>
   * </Card>
   * ```
   */
  tableCard: prop_types_default.a.bool,

  /**
   * An optional function to call when the mouseover event is triggered.
   */
  onMouseOver: prop_types_default.a.func,

  /**
   * An optional function to call when the mouseleave event is triggered.
   */
  onMouseLeave: prop_types_default.a.func,

  /**
   * An optional function to call when the touchstart event is triggered.
   */
  onTouchStart: prop_types_default.a.func,

  /**
   * Boolean if the card expansion should be animated.
   */
  animate: prop_types_default.a.bool,

  expanderIconClassName: deprecated_default()(prop_types_default.a.string, 'Use `expanderIcon` instead'),
  expanderIconChildren: deprecated_default()(prop_types_default.a.node, 'Use `expanderIcon` instead'),
  initiallyExpanded: deprecated_default()(prop_types_default.a.bool, 'Use `defaultExpanded` instead'),
  isExpanded: deprecated_default()(prop_types_default.a.bool, 'Use `expanded` instead'),
  iconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `expanderIconChildren` prop instead'),
  iconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `expanderIconClassName` prop instead')
};
Card_Card.defaultProps = {
  animate: true,
  expanderIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'keyboard_arrow_down'
  ),
  expanderTooltipPosition: 'left'
};
Card_Card.childContextTypes = contextTypes;
/* harmony default export */ var Cards_Card = (Card_Card);
// CONCATENATED MODULE: ../node_modules/react-md/es/Cards/CardExpander.js
function CardExpander_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CardExpander_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CardExpander_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The CardExpander component is just a simple `IconButton` that
 * gets generated through the `Card`'s `contextTypes`. Props are not used
 * at all.
 *
 * Any component below a component that has this component inject into it
 * and has the prop `expandable={true}` will be toggleable when this is clicked.
 *
 * You can manually inject the `CardExpander` component yourself if you want to
 * use a component that is not a `CardActions` or a `CardTitle`.
 */

var CardExpander_CardExpander = function (_Component) {
  CardExpander_inherits(CardExpander, _Component);

  function CardExpander() {
    CardExpander_classCallCheck(this, CardExpander);

    return CardExpander_possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  CardExpander.prototype.render = function render() {
    var _context = this.context,
        expanded = _context.expanded,
        onExpandClick = _context.onExpandClick,
        icon = _context.icon,
        tooltipPosition = _context.tooltipPosition,
        tooltipLabel = _context.tooltipLabel,
        tooltipDelay = _context.tooltipDelay;


    return react_default.a.createElement(Buttons_Button, {
      icon: true,
      className: getCollapserStyles({ flipped: expanded }, 'md-collapser--card'),
      onClick: onExpandClick,
      tooltipLabel: tooltipLabel,
      tooltipDelay: tooltipDelay,
      tooltipPosition: tooltipPosition,
      iconEl: icon
    });
  };

  return CardExpander;
}(react["Component"]);

CardExpander_CardExpander.contextTypes = contextTypes;
/* harmony default export */ var Cards_CardExpander = (CardExpander_CardExpander);
// CONCATENATED MODULE: ../node_modules/react-md/es/Cards/CardActions.js
var CardActions_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function CardActions_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function CardActions_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CardActions_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CardActions_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








/**
 * The `CardActions` component is used for adding actions on your card.
 * The actions should be `FlatButton`s or `IconButton`s.
 *
 * This component can act as a `CardExpander`.
 */

var CardActions_CardActions = function (_Component) {
  CardActions_inherits(CardActions, _Component);

  function CardActions() {
    CardActions_classCallCheck(this, CardActions);

    return CardActions_possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  CardActions.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        children = _props.children,
        isExpander = _props.isExpander,
        expander = _props.expander,
        centered = _props.centered,
        stacked = _props.stacked,
        props = CardActions_objectWithoutProperties(_props, ['className', 'children', 'isExpander', 'expander', 'centered', 'stacked']);

    return react_default.a.createElement(
      'section',
      CardActions_extends({}, props, {
        className: classnames_default()('md-dialog-footer--card', {
          'md-dialog-footer--inline': !stacked,
          'md-dialog-footer--stacked': stacked,
          'md-dialog-footer--card-centered': centered
        }, className)
      }),
      children,
      isExpander || expander && react_default.a.createElement(Cards_CardExpander, null)
    );
  };

  return CardActions;
}(react["Component"]);

CardActions_CardActions.propTypes = {
  /**
   * Boolean if this component should act as an expander and inject the
   * `CardExpander`.
   */
  expander: prop_types_default.a.bool,

  /**
   * An optional className to apply to the actions container.
   */
  className: prop_types_default.a.string,

  /**
   * An actions to display.
   */
  children: prop_types_default.a.node,

  /**
   * Boolean if the actions should be centered.
   */
  centered: prop_types_default.a.bool,

  /**
   * Boolean if the actions should be stacked.
   */
  stacked: prop_types_default.a.bool,

  isExpander: deprecated_default()(prop_types_default.a.bool, 'Use `expander` instead')
};
/* harmony default export */ var Cards_CardActions = (CardActions_CardActions);
// CONCATENATED MODULE: ../node_modules/react-md/es/Cards/CardTitleBlock.js
function CardTitleBlock_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CardTitleBlock_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CardTitleBlock_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var CardTitleBlock_CardTitleBlock = function (_PureComponent) {
  CardTitleBlock_inherits(CardTitleBlock, _PureComponent);

  function CardTitleBlock() {
    CardTitleBlock_classCallCheck(this, CardTitleBlock);

    return CardTitleBlock_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  CardTitleBlock.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        subtitle = _props.subtitle,
        avatar = _props.avatar;
    var title = this.props.title;

    title = react_default.a.createElement(
      'h2',
      {
        id: id,
        className: classnames_default()('md-card-title--title', {
          'md-card-title--large': !avatar
        }, themeColors({ text: true })),
        tabIndex: id ? -1 : null
      },
      title
    );

    if (!subtitle) {
      return title;
    }

    return react_default.a.createElement(
      'div',
      {
        className: classnames_default()('md-card-title--title-block', {
          'md-card-title--one-line': avatar
        })
      },
      title,
      react_default.a.createElement(
        'h3',
        { className: 'md-card-title--title ' + themeColors({ hint: true }) },
        subtitle
      )
    );
  };

  return CardTitleBlock;
}(react["PureComponent"]);

CardTitleBlock_CardTitleBlock.propTypes = {
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  title: prop_types_default.a.node.isRequired,
  subtitle: prop_types_default.a.node,
  avatar: prop_types_default.a.bool
};
/* harmony default export */ var Cards_CardTitleBlock = (CardTitleBlock_CardTitleBlock);
// CONCATENATED MODULE: ../node_modules/react-md/es/Cards/CardTitle.js
var CardTitle_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function CardTitle_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function CardTitle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CardTitle_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CardTitle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









/**
 * The `CardTitle` component is used to render a title in a Card along
 * with an optional subtitle or avatar.
 */

var CardTitle_CardTitle = function (_Component) {
  CardTitle_inherits(CardTitle, _Component);

  function CardTitle() {
    CardTitle_classCallCheck(this, CardTitle);

    return CardTitle_possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  CardTitle.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        style = _props.style,
        className = _props.className,
        title = _props.title,
        subtitle = _props.subtitle,
        expander = _props.expander,
        isExpander = _props.isExpander,
        children = _props.children,
        propAvatar = _props.avatar,
        props = CardTitle_objectWithoutProperties(_props, ['id', 'style', 'className', 'title', 'subtitle', 'expander', 'isExpander', 'children', 'avatar']);

    var avatar = this.props.avatar;

    if (avatar) {
      var avatarClassName = react["Children"].only(avatar).props.className;

      avatar = Object(react["cloneElement"])(avatar, {
        className: classnames_default()('md-avatar--card', avatarClassName)
      });
    }
    return react_default.a.createElement(
      'div',
      CardTitle_extends({}, props, {
        style: style,
        className: classnames_default()('md-card-title', {
          'md-card-title--primary': !avatar
        }, className)
      }),
      avatar,
      react_default.a.createElement(Cards_CardTitleBlock, { id: id, title: title, subtitle: subtitle, avatar: !!avatar }),
      children,
      isExpander || expander && react_default.a.createElement(Cards_CardExpander, null)
    );
  };

  return CardTitle;
}(react["Component"]);

CardTitle_CardTitle.propTypes = {
  /**
   * An optional id to add to the `title`.
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The title to display.
   */
  title: prop_types_default.a.node.isRequired,

  /**
   * An optional subtitle to display.
   */
  subtitle: prop_types_default.a.node,

  /**
   * Any additional children to display in the title block
   * after the avatar, title, and subtitle.
   */
  children: prop_types_default.a.node,

  /**
   * An optional avatar to display before the title and subtitle.
   */
  avatar: prop_types_default.a.element,

  /**
   * Boolean if the `CardTitle` component should inject a button
   * for expanding all children below it.
   */
  expander: prop_types_default.a.bool,

  isExpander: deprecated_default()(prop_types_default.a.bool, 'Use `expander` instead')
};
/* harmony default export */ var Cards_CardTitle = (CardTitle_CardTitle);
// CONCATENATED MODULE: ../node_modules/react-md/es/Cards/CardText.js
var CardText_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function CardText_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function CardText_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CardText_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CardText_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The `CardText` component is a simple wrapper for text or any content in a `Card`.
 * It really just adds correct padding and font color.
 */

var CardText_CardText = function (_PureComponent) {
  CardText_inherits(CardText, _PureComponent);

  function CardText() {
    CardText_classCallCheck(this, CardText);

    return CardText_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  CardText.prototype.render = function render() {
    var _props = this.props,
        Component = _props.component,
        className = _props.className,
        expandable = _props.expandable,
        props = CardText_objectWithoutProperties(_props, ['component', 'className', 'expandable']);

    return react_default.a.createElement(Component, CardText_extends({}, props, { className: classnames_default()('md-card-text', className) }));
  };

  return CardText;
}(react["PureComponent"]);

CardText_CardText.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The children to display.
   */
  children: prop_types_default.a.node,

  /**
   * The component to render as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * Boolean if this component should be expandable when there is a `CardExpander`
   * above it in the `Card`.
   */
  expandable: prop_types_default.a.bool
};
CardText_CardText.defaultProps = {
  component: 'section'
};
/* harmony default export */ var Cards_CardText = (CardText_CardText);
// CONCATENATED MODULE: ../node_modules/react-md/es/Chips/Chip.js
var Chip_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Chip_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Chip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Chip_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Chip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var Chip_Chip = function (_PureComponent) {
  Chip_inherits(Chip, _PureComponent);

  function Chip() {
    var _temp, _this, _ret;

    Chip_classCallCheck(this, Chip);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Chip_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { hover: false }, _this._handleMouseEnter = function (e) {
      if (_this.props.onMouseEnter) {
        _this.props.onMouseEnter(e);
      }

      _this.setState({ hover: true });
    }, _this._handleMouseLeave = function (e) {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave(e);
      }

      _this.setState({ hover: false });
    }, _temp), Chip_possibleConstructorReturn(_this, _ret);
  }

  Chip.prototype.render = function render() {
    var hover = this.state.hover;

    var _props = this.props,
        label = _props.label,
        className = _props.className,
        labelStyle = _props.labelStyle,
        labelClassName = _props.labelClassName,
        avatar = _props.avatar,
        children = _props.children,
        removable = _props.removable,
        remove = _props.remove,
        onClick = _props.onClick,
        rotateIcon = _props.rotateIcon,
        iconClassName = _props.iconClassName,
        removeIconChildren = _props.removeIconChildren,
        removeIconClassName = _props.removeIconClassName,
        props = Chip_objectWithoutProperties(_props, ['label', 'className', 'labelStyle', 'labelClassName', 'avatar', 'children', 'removable', 'remove', 'onClick', 'rotateIcon', 'iconClassName', 'removeIconChildren', 'removeIconClassName']);

    var icon = void 0;
    if (removable || remove) {
      var chipIconCN = classnames_default()('md-chip-icon', {
        'md-chip-icon--rotate': rotateIcon,
        'md-chip-text--hover': hover
      });

      if (react_default.a.isValidElement(children)) {
        icon = react_default.a.Children.only(children);
        icon = react_default.a.cloneElement(icon, { className: classnames_default()(chipIconCN, icon.props.className) });
      } else {
        icon = react_default.a.createElement(
          FontIcons_FontIcon,
          { className: chipIconCN, iconClassName: iconClassName },
          children
        );
      }
    }

    return react_default.a.createElement(
      'button',
      Chip_extends({
        type: 'button'
      }, props, {
        className: classnames_default()('md-chip', {
          'md-chip--avatar': avatar,
          'md-chip--remove': removable,
          'md-chip--hover': hover
        }, className),
        onClick: remove || onClick,
        onMouseEnter: this._handleMouseEnter,
        onMouseLeave: this._handleMouseLeave
      }),
      avatar,
      react_default.a.createElement(
        'span',
        {
          style: labelStyle,
          className: classnames_default()('md-chip-text', {
            'md-chip-text--hover': hover
          }, labelClassName)
        },
        label
      ),
      icon
    );
  };

  return Chip;
}(react["PureComponent"]);

Chip_Chip.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the chip's label.
   */
  labelStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the chip's label.
   */
  labelClassName: prop_types_default.a.string,

  /**
   * Boolean if the `.md-chip-icon--rotate` style should be applied to the remove icon.
   * The `.md-chip-icon--rotate` just rotates the icon 45 degrees.
   */
  rotateIcon: prop_types_default.a.bool,

  /**
   * Any children used to display the remove icon when `removable`.
   */
  children: prop_types_default.a.node,

  /**
   * The label to display on the chip.
   */
  label: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the chip is removable.
   */
  removable: prop_types_default.a.bool,

  /**
   * An optional avatar to display on the chip.
   */
  avatar: prop_types_default.a.element,

  /**
   * An optional function to call when the `click` event is triggered.
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseenter` event is triggered.
   */
  onMouseEnter: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseleave` event is triggered.
   */
  onMouseLeave: prop_types_default.a.func,

  iconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `children` prop as a single FontIcon or SVGIcon instead'),
  remove: deprecated_default()(prop_types_default.a.func, 'Use `removable` and `onClick` instead'),
  removeIconChildren: deprecated_default()(prop_types_default.a.node, 'Use `children` instead'),
  removeIconClassName: deprecated_default()(prop_types_default.a.string, 'Use `children` prop as a single FontIcon or SVGIcon instead')
};
Chip_Chip.defaultProps = {
  rotateIcon: true,
  children: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'add_circle'
  )
};
/* harmony default export */ var Chips_Chip = (Chip_Chip);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/PropTypes/requiredForA11yIfNot.js
/** @module utils/PropTypes/requiredForA11yIfNot */

/**
 * This validator checks that the current prop is valid and defined ONLY if
 * any of the `otherPropNames` are not true or defined.
 *
 * @param {function} validator - The React PropTypes validator to use for the given prop.
 * @param {String[]} otherPropNames - Any other prop names to validate against.
 * @return {Error} an error or null
 */
function requiredForA11yIfNot(validator) {
  for (var _len = arguments.length, otherPropNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    otherPropNames[_key - 1] = arguments[_key];
  }

  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;
    var defined = typeof props[propName] !== 'undefined';

    for (var _len2 = arguments.length, args = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      args[_key2 - 5] = arguments[_key2];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (!err && !defined && !otherPropNames.filter(function (pn) {
      return !!props[pn];
    }).length) {
      err = new Error('The `' + propFullNameSafe + '` ' + location + ' is required to make `' + componentNameSafe + '` accessible ' + 'for users of assistive technologies such as screen readers.');
    }

    return err;
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/contextTypes.js


/* harmony default export */ var DataTables_contextTypes = ({
  checkedIcon: prop_types_default.a.element,
  uncheckedIcon: prop_types_default.a.element,
  indeterminateIcon: prop_types_default.a.element,
  indeterminate: prop_types_default.a.bool,
  plain: prop_types_default.a.bool,
  selectableRows: prop_types_default.a.bool.isRequired,
  allSelected: prop_types_default.a.bool.isRequired,
  selectedRows: prop_types_default.a.arrayOf(prop_types_default.a.bool).isRequired,
  createCheckbox: prop_types_default.a.func.isRequired,
  removeCheckbox: prop_types_default.a.func.isRequired,
  toggleSelectedRow: prop_types_default.a.func.isRequired,
  baseId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  baseName: prop_types_default.a.string,
  checkboxHeaderLabel: prop_types_default.a.string.isRequired,
  checkboxLabelTemplate: prop_types_default.a.string.isRequired,
  fixedHeader: prop_types_default.a.bool.isRequired,
  fixedFooter: prop_types_default.a.bool.isRequired
});
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/DataTable.js
var DataTable_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function DataTable_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function DataTable_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DataTable_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DataTable_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }












/**
 * The `DataTable` component is used to manage the state of all rows.
 * This can either be a __plain__ table or a __data__ table.
 *
 * A __data__ table will include checkboxes on each row while a __plain__ table
 * will not.
 */

var DataTable_DataTable = function (_PureComponent) {
  DataTable_inherits(DataTable, _PureComponent);

  function DataTable(props) {
    DataTable_classCallCheck(this, DataTable);

    var _this = DataTable_possibleConstructorReturn(this, _PureComponent.call(this));

    DataTable_initialiseProps.call(_this);

    var rows = props.defaultSelectedRows;
    _this.state = {
      header: false,
      indeterminate: props.indeterminate ? false : undefined,
      allSelected: _this._allSelected(rows),
      selectedRows: rows
    };

    _this._removed = 0;
    _this._initial = true;
    return _this;
  }

  DataTable.prototype.getChildContext = function getChildContext() {
    var _props = this.props,
        checkedIcon = _props.checkedIcon,
        uncheckedIcon = _props.uncheckedIcon,
        indeterminateIcon = _props.indeterminateIcon,
        plain = _props.plain,
        baseId = _props.baseId,
        selectableRows = _props.selectableRows,
        checkboxHeaderLabel = _props.checkboxHeaderLabel,
        checkboxLabelTemplate = _props.checkboxLabelTemplate,
        fixedHeader = _props.fixedHeader,
        fixedFooter = _props.fixedFooter,
        checkedIconChildren = _props.checkedIconChildren,
        checkedIconClassName = _props.checkedIconClassName,
        uncheckedIconChildren = _props.uncheckedIconChildren,
        uncheckedIconClassName = _props.uncheckedIconClassName,
        indeterminateIconChildren = _props.indeterminateIconChildren,
        indeterminateIconClassName = _props.indeterminateIconClassName;


    return {
      checkedIcon: getDeprecatedIcon(checkedIconClassName, checkedIconChildren, checkedIcon),
      uncheckedIcon: getDeprecatedIcon(uncheckedIconClassName, uncheckedIconChildren, uncheckedIcon),
      indeterminateIcon: getDeprecatedIcon(indeterminateIconClassName, indeterminateIconChildren, indeterminateIcon),
      indeterminate: this.state.indeterminate,
      plain: plain,
      allSelected: this.state.allSelected,
      selectedRows: this.state.selectedRows,
      toggleSelectedRow: this._toggleSelectedRow,
      createCheckbox: this._createCheckbox,
      removeCheckbox: this._removeCheckbox,
      baseId: baseId,
      baseName: baseId + '-control',
      selectableRows: selectableRows,
      checkboxHeaderLabel: checkboxHeaderLabel,
      checkboxLabelTemplate: checkboxLabelTemplate,
      fixedHeader: fixedHeader,
      fixedFooter: fixedFooter
    };
  };

  DataTable.prototype.componentDidUpdate = function componentDidUpdate() {
    this._removed = 0;
    this._initial = false;
  };

  DataTable.prototype._allSelected = function _allSelected(rows) {
    var all = rows.length !== 0;
    rows.some(function (checked) {
      if (!checked) {
        all = false;
      }

      return !all;
    });

    return all;
  };

  DataTable.prototype.render = function render() {
    var _cn;

    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        tableStyle = _props2.tableStyle,
        tableClassName = _props2.tableClassName,
        fixedWrapperStyle = _props2.fixedWrapperStyle,
        fixedWrapperClassName = _props2.fixedWrapperClassName,
        fixedScrollWrapperStyle = _props2.fixedScrollWrapperStyle,
        fixedScrollWrapperClassName = _props2.fixedScrollWrapperClassName,
        children = _props2.children,
        plain = _props2.plain,
        responsive = _props2.responsive,
        fixedHeader = _props2.fixedHeader,
        fixedFooter = _props2.fixedFooter,
        fixedDividers = _props2.fixedDividers,
        fixedHeight = _props2.fixedHeight,
        fixedWidth = _props2.fixedWidth,
        headerHeight = _props2.headerHeight,
        footerHeight = _props2.footerHeight,
        fullWidth = _props2.fullWidth,
        indeterminate = _props2.indeterminate,
        indeterminateIcon = _props2.indeterminateIcon,
        checkedIcon = _props2.checkedIcon,
        uncheckedIcon = _props2.uncheckedIcon,
        defaultSelectedRows = _props2.defaultSelectedRows,
        baseId = _props2.baseId,
        onRowToggle = _props2.onRowToggle,
        selectableRows = _props2.selectableRows,
        checkboxHeaderLabel = _props2.checkboxHeaderLabel,
        checkboxLabelTemplate = _props2.checkboxLabelTemplate,
        checkedIconChildren = _props2.checkedIconChildren,
        checkedIconClassName = _props2.checkedIconClassName,
        uncheckedIconChildren = _props2.uncheckedIconChildren,
        uncheckedIconClassName = _props2.uncheckedIconClassName,
        indeterminateIconChildren = _props2.indeterminateIconChildren,
        indeterminateIconClassName = _props2.indeterminateIconClassName,
        props = DataTable_objectWithoutProperties(_props2, ['style', 'className', 'tableStyle', 'tableClassName', 'fixedWrapperStyle', 'fixedWrapperClassName', 'fixedScrollWrapperStyle', 'fixedScrollWrapperClassName', 'children', 'plain', 'responsive', 'fixedHeader', 'fixedFooter', 'fixedDividers', 'fixedHeight', 'fixedWidth', 'headerHeight', 'footerHeight', 'fullWidth', 'indeterminate', 'indeterminateIcon', 'checkedIcon', 'uncheckedIcon', 'defaultSelectedRows', 'baseId', 'onRowToggle', 'selectableRows', 'checkboxHeaderLabel', 'checkboxLabelTemplate', 'checkedIconChildren', 'checkedIconClassName', 'uncheckedIconChildren', 'uncheckedIconClassName', 'indeterminateIconChildren', 'indeterminateIconClassName']);

    var table = react_default.a.createElement(
      'table',
      DataTable_extends({}, props, {
        ref: this._setTable,
        style: responsive ? tableStyle : style,
        className: classnames_default()('md-data-table', (_cn = {
          'md-data-table--plain': plain,
          'md-data-table--full-width': fullWidth
        }, _cn[className] = !responsive && className, _cn[tableClassName] = responsive && tableClassName, _cn))
      }),
      children
    );

    if (!responsive) {
      return table;
    }

    var content = table;
    if (fixedHeader || fixedFooter) {
      var height = fixedHeight;
      if (fixedHeight) {
        if (fixedHeader) {
          height -= headerHeight;
        }

        if (fixedFooter) {
          height -= footerHeight;
        }
      }

      var borderTop = fixedHeader;
      var borderBot = fixedFooter;
      if (typeof fixedDividers === 'boolean') {
        borderTop = borderTop && fixedDividers;
        borderBot = borderBot && fixedDividers;
      } else {
        borderTop = borderTop && (typeof fixedDividers.header === 'undefined' || fixedDividers.header);
        borderBot = borderBot && (typeof fixedDividers.footer === 'undefined' || fixedDividers.footer);
      }

      content = react_default.a.createElement(
        'div',
        {
          style: fixedWrapperStyle,
          className: classnames_default()('md-data-table__fixed-wrapper', {
            'md-data-table__fixed-wrapper--header': fixedHeader,
            'md-data-table__fixed-wrapper--footer': fixedFooter
          }, fixedWrapperClassName)
        },
        react_default.a.createElement(
          'div',
          {
            style: DataTable_extends({ height: height }, fixedScrollWrapperStyle),
            className: classnames_default()('md-data-table__scroll-wrapper', {
              'md-divider-border': fixedDividers,
              'md-divider-border--top': borderTop,
              'md-divider-border--bottom': borderBot
            }, fixedScrollWrapperClassName)
          },
          table
        )
      );
    }

    return react_default.a.createElement(
      'div',
      {
        style: DataTable_extends({ width: fixedWidth }, style),
        className: classnames_default()('md-data-table--responsive', {
          'md-data-table--fixed': fixedHeader || fixedFooter
        }, className)
      },
      content
    );
  };

  return DataTable;
}(react["PureComponent"]);

DataTable_DataTable.propTypes = {
  /**
   * A base id to use for every checkbox or `EditDialogColumn` in the data table. This is
   * required for a11y if the data table is not plain. It is recommended to always provide
   * this prop if you are using any of the advanced table components to auto-generate unique
   * ids for each element.
   *
   * @see {@link DataTables/EditDialogColumn}
   * @see {@link DataTables/SelectFieldColumn}
   * @see {@link DataTables/DropdownMenuColumn}
   * @see {@link DataTables/MenuButtonColumn}
   * @see {@link DataTables/TablePagination}
   */
  baseId: requiredForA11yIfNot(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]), 'plain'),

  /**
   * Optional style to apply to the table. If the table is `responsive`, this will be applied to the surrounding `div`
   * instead of the table itself. Use the `tableStyle` in this case.
   *
   * @see {@link #tableStyle}
   * @see {@link #responsive}
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the table. If the table is `responsive`, this will be applied to the
   * surrounding `div` instead of the table itself. Use the `tableClassName` in this case.
   *
   * @see {@link #tableClassName}
   * @see {@link #responsive}
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the `table` itself when the `responsive` prop is enabled. If the table is not
   * `responsive`, use the `style` prop.
   *
   * @see {@link #style}
   * @see {@link #responsive}
   */
  tableStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the `table` itself when the `responsive` prop is enabled. If the table is not
   * `responsive`, use the `className` prop.
   *
   * @see {@link #className}
   * @see {@link #responsive}
   */
  tableClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the fixed table wrapper that appears when there is a fixed
   * header or a fixed footer.
   *
   * @see {@link #fixedHeader}
   * @see {@link #fixedFooter}
   * @see {@link #fixedWrapperClassName}
   * @see {@link #fixedScrollWrapperStyle}
   * @see {@link #fixedScrollWrapperClassName}
   */
  fixedWrapperStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the fixed table wrapper that appears when there is a fixed
   * header or a fixed footer.
   *
   * @see {@link #fixedHeader}
   * @see {@link #fixedFooter}
   * @see {@link #fixedWrapperStyle}
   * @see {@link #fixedScrollWrapperStyle}
   * @see {@link #fixedScrollWrapperClassName}
   */
  fixedWrapperClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the fixed table wrapper's scroll container that appears when there is a fixed
   * header or a fixed footer.
   *
   * @see {@link #fixedHeader}
   * @see {@link #fixedFooter}
   * @see {@link #fixedWrapperStyle}
   * @see {@link #fixedWrapperClassName}
   * @see {@link #fixedScrollWrapperStyle}
   */
  fixedScrollWrapperStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the fixed table wrapper's scroll container that appears when there is a fixed
   * header or a fixed footer.
   *
   * @see {@link #fixedHeader}
   * @see {@link #fixedFooter}
   * @see {@link #fixedWrapperStyle}
   * @see {@link #fixedWrapperClassName}
   * @see {@link #fixedScrollWrapperStyle}
   */
  fixedScrollWrapperClassName: prop_types_default.a.string,

  /**
   * The table contents to display. This *should* be a list of `TableHeader` and `TableBody`
   * components.
   */
  children: prop_types_default.a.node.isRequired,

  /**
   * An optional array of booleans denoting if a row is selected.
   * This is an associative array so the index must match the row
   * number in the `TableBody` component.
   */
  defaultSelectedRows: prop_types_default.a.arrayOf(prop_types_default.a.bool).isRequired,

  /**
   * Boolean if the table is responsive. This will wrap the table in a container
   * that allows scrolling to the right if overflow exists.
   */
  responsive: prop_types_default.a.bool.isRequired,

  /**
   * Boolean if this table should not include the checkboxes on each row.
   * This really means that the entire table is unselectable and you wish
   * to display as a normal table.
   */
  plain: prop_types_default.a.bool,

  /**
   * The checked checkbox icon to display when a row is selected. This really defaults
   * to the `checkedCheckboxIcon` prop from the `SelectionControl`.
   *
   * @see {@link SelectionControls/SelectionControl#checkedCheckboxIcon}
   */
  checkedIcon: prop_types_default.a.element,

  /**
   * The unchecked checkbox icon to display when a row is selected. This really defaults
   * to the `uncheckedCheckboxIcon` prop from the `SelectionControl`.
   *
   * @see {@link SelectionControls/SelectionControl#uncheckedCheckboxIcon}
   */
  uncheckedIcon: prop_types_default.a.element,

  /**
   * An optional function to call when a non-plain data table has a row toggled. The callback
   * will include:
   * - the row id
   * - boolean if the row is now checked
   * - the total count of rows selected
   * - the change event
   *
   * All rows will be toggled on or off when the row id is 0 and a `thead` exists in the table.
   */
  onRowToggle: invalidIf(prop_types_default.a.func, 'plain'),

  /**
   * Boolean if the `DataTable` should inject checkboxes at the start of each row.
   */
  selectableRows: prop_types_default.a.bool,

  /**
   * Boolean if the checkboxes in the table should also include an _indeterminate_ state.
   * It will use the `indeterminateIconChildren` and `indeterminateIconClassName` when at least
   * 1 row has been checked, but not all rows.
   */
  indeterminate: prop_types_default.a.bool,

  /**
   * An optional icon to display when the selected state is indeterminate.
   *
   * @see {@link #indeterminate}
   */
  indeterminateIcon: prop_types_default.a.element,

  /**
   * This is the aria-label to apply to the checkbox in the table's header. This
   * is just used for accessibility since the checkboxes have no visible label.
   */
  checkboxHeaderLabel: prop_types_default.a.string.isRequired,

  /**
   * This is the aria-label to apply to a checkbox in the table's body. This can either
   * be a constant string that will replace `{{row}}` with the current row index, or
   * a function that takes the row index and returns a string.
   *
   * ```js
   * checkboxLabelTemplate={rowIndex => `Toggle row ${row}`}
   * ```
   */
  checkboxLabelTemplate: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * Boolean if the table should include a fixed header. This will allow the `TableHeader` component
   * to stay fixed to the top of the table while the `TableBody` scrolls horizontally.
   *
   * @see {@link #fixedFooter}
   * @see [react-md-make-fixed-table](/components/data-tables?tab=2#mixin-react-md-make-fixed-table)
   */
  fixedHeader: prop_types_default.a.bool,

  /**
   * Boolean if the table should include a fixed footer. This will allow the `TableFooter` component
   * to stay fixed to the bottom of the table while the `TableBody` scrolls horizontally.
   *
   * @see {@link #fixedHeader}
   * @see [react-md-make-fixed-table](/components/data-tables?tab=2#mixin-react-md-make-fixed-table)
   */
  fixedFooter: prop_types_default.a.bool,

  /**
   * Either a boolean or a shape of booleans for if a divider should appear at the top or bottom of the table
   * when there is a fixed header/footer. By default, this will automatically create dividers.
   *
   * @see {@link #fixedHeader}
   * @see {@link #fixedFooter}
   */
  fixedDividers: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.shape({
    header: prop_types_default.a.bool,
    footer: prop_types_default.a.bool
  })]),

  /**
   * An optional height to set for a table with a fixed header and/or a fixed footer. It is recommended to use
   * the related `react-md-make-fixed-table` mixin instead.
   *
   * @see {@link #headerHeight}
   * @see {@link #footerHeight}
   */
  fixedHeight: prop_types_default.a.number,

  /**
   * An optional width to set for a table with a fixed header and/or a fixed footer. It is recommended to use
   * the related `react-md-make-fixed-table` mixin instead.
   */
  fixedWidth: prop_types_default.a.number,

  /**
   * This is the height of the table's header columns. This should be equal to the `md-data-table-header-height`
   * variable.
   *
   * @see [md-data-table-header-height](/components/data-tables?tab=2#variable-md-data-table-header-height)
   * @see {@link #fixedHeight}
   */
  headerHeight: prop_types_default.a.number.isRequired,

  /**
   * This is the height of the table's header columns. This should be equal to the `md-data-table-header-height`
   * variable.
   *
   * @see [md-data-table-column-height](/components/data-tables?tab=2#variable-md-data-table-column-height)
   * @see {@link #fixedHeight}
   */
  footerHeight: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the `<table>` element should always span the entire width of its container.
   */
  fullWidth: prop_types_default.a.bool,

  indeterminateIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `indeterminateIcon` prop instead'),
  indeterminateIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `indeterminateIcon` prop instead'),
  checkedIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `checkedIcon` prop instead'),
  checkedIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `checkedIcon` prop instead'),
  uncheckedIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `uncheckedIcon` prop instead'),
  uncheckedIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `uncheckedIcon` prop instead')
};
DataTable_DataTable.defaultProps = {
  indeterminateIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'indeterminate_check_box'
  ),
  defaultSelectedRows: [],
  responsive: true,
  selectableRows: true,
  checkboxHeaderLabel: 'Toggle All Rows',
  checkboxLabelTemplate: 'Toggle row {{row}}',
  fixedHeader: false,
  fixedFooter: false,
  fixedDividers: true,
  headerHeight: 56,
  footerHeight: 48,
  fullWidth: true
};
DataTable_DataTable.childContextTypes = DataTables_contextTypes;

var DataTable_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setTable = function (table) {
    _this2._table = table;
  };

  this._createCheckbox = function (index) {
    _this2.setState(function (state, props) {
      var selectedRows = state.selectedRows.slice();
      // Only use the default selected rows prop on first mount. If other changes occur after,
      // default to false.
      var selected = _this2._initial && props.defaultSelectedRows[index] || false;
      selectedRows.splice(index, 0, selected);
      return { selectedRows: selectedRows, allSelected: _this2._allSelected(selectedRows) };
    });
  };

  this._removeCheckbox = function (index) {
    _this2.setState(function (state) {
      // When multiple checkboxes are removed in a render cycle, they are removed in list order.
      // So to keep the index correct while removing, need to keep subtract the provided index by
      // the current number of removed elements. This value gets reset to 0 after a finished cycle.
      var selectedRows = state.selectedRows.slice();

      // This is really ugly. React 16 doesn't need to track all this while React 15 does
      if (react_default.a.version && react_default.a.version.match(/^16\./)) {
        selectedRows.splice(index, 1);
      } else {
        selectedRows.splice(index - _this2._removed, 1);
        _this2._removed += 1;
      }
      return { selectedRows: selectedRows, allSelected: _this2._allSelected(selectedRows) };
    });
  };

  this._toggleSelectedRow = function (row, header, e) {
    var selectedRows = void 0;
    var allSelected = _this2.state.allSelected;
    var selectedCount = 0;
    var i = _this2._table && _this2._table.querySelector('.md-table-header') ? row - 1 : row;
    var checked = e.target.checked;

    if (header) {
      selectedRows = _this2.state.selectedRows.map(function () {
        return checked;
      });
      allSelected = checked;
      selectedCount = !checked ? 0 : selectedRows.length;
    } else {
      selectedRows = _this2.state.selectedRows.slice();
      selectedRows[i] = !selectedRows[i];
      selectedCount = selectedRows.filter(function (b) {
        return b;
      }).length;
      allSelected = selectedCount === selectedRows.length;
    }

    if (_this2.props.onRowToggle) {
      _this2.props.onRowToggle(row, checked, selectedCount, e);
    }

    var indeterminate = _this2.props.indeterminate && !allSelected && selectedCount > 0;

    _this2.setState({ selectedRows: selectedRows, allSelected: allSelected, indeterminate: indeterminate });
  };
};

/* harmony default export */ var DataTables_DataTable = (DataTable_DataTable);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/headerContextTypes.js
var headerContextTypes_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




/* harmony default export */ var headerContextTypes = (headerContextTypes_extends({}, DataTables_contextTypes, { header: prop_types_default.a.bool }));
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/TableHeader.js
var TableHeader_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TableHeader_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TableHeader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TableHeader_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TableHeader_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * A `thead` component to use in the `DataTable` component. This
 * will automatically update the header row to check if it is selected
 * and inject a function to toggle all rows selected if the row is
 * uncontrolled. It will also automatically attempt to set the `TableColumn`
 * components to be the header type.
 */

var TableHeader_TableHeader = function (_Component) {
  TableHeader_inherits(TableHeader, _Component);

  function TableHeader() {
    TableHeader_classCallCheck(this, TableHeader);

    return TableHeader_possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  TableHeader.prototype.getChildContext = function getChildContext() {
    return TableHeader_extends({}, this.context, {
      header: true
    });
  };

  TableHeader.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        children = _props.children,
        props = TableHeader_objectWithoutProperties(_props, ['className', 'children']);

    var allSelected = this.context.allSelected;

    var header = react_default.a.Children.only(children);
    var selected = typeof header.props.selected === 'undefined' ? allSelected : header.props.selected;

    var row = react_default.a.cloneElement(header, { selected: selected });

    return react_default.a.createElement(
      'thead',
      TableHeader_extends({}, props, { className: classnames_default()('md-table-header', className) }),
      row
    );
  };

  return TableHeader;
}(react["Component"]);

TableHeader_TableHeader.contextTypes = DataTables_contextTypes;
TableHeader_TableHeader.childContextTypes = headerContextTypes;
TableHeader_TableHeader.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the table header
   */
  className: prop_types_default.a.string,

  /**
   * This should be a single `TableRow` component. The `custom` validation will
   * warn you if there are more than one children given or none at all.
   */
  children: function children(props, propName, component) {
    try {
      react_default.a.Children.only(props.children);
      return null;
    } catch (e) {
      var amt = props.children ? props.children.length : 0;
      return new Error('There must only be one child in a \'' + component + '\', but ' + amt + ' were given.');
    }
  }
};
/* harmony default export */ var DataTables_TableHeader = (TableHeader_TableHeader);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/TableBody.js
var TableBody_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TableBody_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TableBody_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TableBody_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TableBody_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The `TableBody` component is used for managing the state of all
 * `TableRow` inside of it.
 */

var TableBody_TableBody = function (_Component) {
  TableBody_inherits(TableBody, _Component);

  function TableBody() {
    TableBody_classCallCheck(this, TableBody);

    return TableBody_possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  TableBody.prototype.render = function render() {
    var _props = this.props,
        children = _props.children,
        className = _props.className,
        props = TableBody_objectWithoutProperties(_props, ['children', 'className']);

    var selectedRows = this.context.selectedRows;


    var rows = children ? react["Children"].map(react["Children"].toArray(children), function (row, i) {
      var uncontrolled = typeof row.props.selected === 'undefined';
      return react_default.a.cloneElement(row, {
        selected: uncontrolled ? selectedRows[i] : row.props.selected
      });
    }) : null;

    return react_default.a.createElement(
      'tbody',
      TableBody_extends({}, props, { className: classnames_default()('md-table-body', className) }),
      rows
    );
  };

  return TableBody;
}(react["Component"]);

TableBody_TableBody.propTypes = {
  /**
   * An optional style to apply to the tbody.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the tbody.
   */
  className: prop_types_default.a.string,

  /**
   * A list or a single item of `TableRow` components to render.
   */
  children: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.arrayOf(prop_types_default.a.element)])
};
TableBody_TableBody.contextTypes = DataTables_contextTypes;
/* harmony default export */ var DataTables_TableBody = (TableBody_TableBody);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/TableFooter.js
var TableFooter_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TableFooter_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TableFooter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TableFooter_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TableFooter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * This is just a simple <tfoot> component.
 */

var TableFooter_TableFooter = function (_PureComponent) {
  TableFooter_inherits(TableFooter, _PureComponent);

  function TableFooter() {
    TableFooter_classCallCheck(this, TableFooter);

    return TableFooter_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  TableFooter.prototype.getChildContext = function getChildContext() {
    return { footer: true };
  };

  TableFooter.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        children = _props.children,
        props = TableFooter_objectWithoutProperties(_props, ['className', 'children']);

    return react_default.a.createElement(
      'tfoot',
      TableFooter_extends({ className: classnames_default()('md-table-footer', className) }, props),
      children
    );
  };

  return TableFooter;
}(react["PureComponent"]);

TableFooter_TableFooter.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The children to display. This should really be one or a list of `TableRow`
   * components.
   */
  children: prop_types_default.a.node
};
TableFooter_TableFooter.childContextTypes = {
  footer: prop_types_default.a.bool
};
/* harmony default export */ var DataTables_TableFooter = (TableFooter_TableFooter);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/rowContextTypes.js
var rowContextTypes_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var rowContextTypes = omit(rowContextTypes_extends({}, headerContextTypes, {
  rowId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])
}), ['baseId']);

/* harmony default export */ var DataTables_rowContextTypes = (rowContextTypes);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/StringUtils/capitalizeFirst.js
/** @module utils/StringUtils/capitlizeFirst */

/**
 * Capitalizes the first letter of a string. If the string is falsish, it will be
 * returned as is. If the string is only one letter long, it will be capitalized;
 *
 * @param {String} str - The string to capitalize.
 * @return {String} the updated string or false-ish self.
 */
function capitalizeFirst(str) {
  if (!str) {
    return str;
  } else if (str.length === 1) {
    return str.toUpperCase();
  }

  return "" + str.charAt(0).toUpperCase() + str.substring(1, str.length);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectionControls/SwitchThumb.js
var SwitchThumb_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function SwitchThumb_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SwitchThumb_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SwitchThumb_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SwitchThumb_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var DISABLED_INTERACTIONS = ['mouse'];

/**
 * This is the `Thumb` for the switch. The `ink` in the Thumb is only active on touch and keyboard
 * interactions, so the `AccessibleFakeInkButton` does not work for this case.
 *
 * This component really just is used for custom inkage.
 */

var SwitchThumb_SwitchThumb = function (_PureComponent) {
  SwitchThumb_inherits(SwitchThumb, _PureComponent);

  function SwitchThumb() {
    SwitchThumb_classCallCheck(this, SwitchThumb);

    return SwitchThumb_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  SwitchThumb.prototype.render = function render() {
    var _props = this.props,
        disabled = _props.disabled,
        checked = _props.checked,
        className = _props.className,
        disabledInteractions = _props.disabledInteractions,
        props = SwitchThumb_objectWithoutProperties(_props, ['disabled', 'checked', 'className', 'disabledInteractions']);

    return react_default.a.createElement(AccessibleFakeInkedButton, SwitchThumb_extends({}, props, {
      role: 'checkbox',
      'aria-checked': checked,
      disabled: disabled,
      disabledInteractions: disabledInteractions || DISABLED_INTERACTIONS,
      inkContainerClassName: 'md-ink-container--2x',
      className: classnames_default()('md-switch-thumb', {
        'md-switch-thumb--disabled': disabled,
        'md-switch-thumb--on': checked,
        'md-switch-thumb--off': !checked
      }, className)
    }));
  };

  return SwitchThumb;
}(react["PureComponent"]);

SwitchThumb_SwitchThumb.propTypes = {
  className: prop_types_default.a.string,
  disabled: prop_types_default.a.bool,
  checked: prop_types_default.a.bool,
  onClick: prop_types_default.a.func,
  disabledInteractions: prop_types_default.a.arrayOf(prop_types_default.a.oneOf(['keyboard', 'touch', 'mouse'])),
  'aria-label': oneRequiredForA11y(prop_types_default.a.string, 'aria-labelledby'),
  'aria-labelledby': prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])
};
/* harmony default export */ var SelectionControls_SwitchThumb = (SwitchThumb_SwitchThumb);
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectionControls/SwitchTrack.js
var SwitchTrack_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function SwitchTrack_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SwitchTrack_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SwitchTrack_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SwitchTrack_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var SwitchTrack_SwitchTrack = function (_PureComponent) {
  SwitchTrack_inherits(SwitchTrack, _PureComponent);

  function SwitchTrack() {
    SwitchTrack_classCallCheck(this, SwitchTrack);

    return SwitchTrack_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  SwitchTrack.prototype.render = function render() {
    var _props = this.props,
        disabled = _props.disabled,
        checked = _props.checked,
        className = _props.className,
        inkDisabled = _props.inkDisabled,
        disabledInteractions = _props.disabledInteractions,
        ariaLabel = _props['aria-label'],
        ariaLabelledBy = _props['aria-labelledby'],
        props = SwitchTrack_objectWithoutProperties(_props, ['disabled', 'checked', 'className', 'inkDisabled', 'disabledInteractions', 'aria-label', 'aria-labelledby']);

    return react_default.a.createElement(
      'div',
      SwitchTrack_extends({}, props, {
        className: classnames_default()('md-switch-track', {
          'md-pointer--hover': !disabled,
          'md-switch-track--disabled': disabled,
          'md-switch-track--on': checked,
          'md-switch-track--off': !checked
        }, className)
      }),
      react_default.a.createElement(SelectionControls_SwitchThumb, {
        disabled: disabled,
        checked: checked,
        onClick: props.onClick,
        inkDisabled: inkDisabled,
        disabledInteractions: disabledInteractions,
        'aria-label': ariaLabel,
        'aria-labelledby': ariaLabelledBy
      })
    );
  };

  return SwitchTrack;
}(react["PureComponent"]);

SwitchTrack_SwitchTrack.propTypes = {
  className: prop_types_default.a.string,
  disabled: prop_types_default.a.bool,
  checked: prop_types_default.a.bool,
  inkDisabled: prop_types_default.a.bool,
  disabledInteractions: prop_types_default.a.arrayOf(prop_types_default.a.oneOf(['keyboard', 'touch', 'mouse'])),
  'aria-label': oneRequiredForA11y(prop_types_default.a.string, 'aria-labelledby'),
  'aria-labelledby': prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])
};
/* harmony default export */ var SelectionControls_SwitchTrack = (SwitchTrack_SwitchTrack);
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectionControls/SelectionControl.js
var SelectionControl_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var SelectionControl_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function SelectionControl_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SelectionControl_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SelectionControl_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SelectionControl_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
















/**
 * Prevents a second warning from appearing when using the deprecated or a11y required
 * props by using the `__superSecretProp`.... So secret!
 */
function preventDouble(validator) {
  return function validate(props, propName) {
    for (var _len = arguments.length, others = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      others[_key - 2] = arguments[_key];
    }

    var err = validator.apply(undefined, [props, propName].concat(others));
    if (err && props.__superSecreteProp) {
      err = null;
    }

    return err;
  };
}

/**
 * The `SelectionControl` component is used to render any of the `Radio`, `Checkbox`, or `Switch`
 * selection control type. This component might eventually replace all three since they use this
 * anyways. I am not sure yet though.
 */

var SelectionControl_SelectionControl = function (_PureComponent) {
  SelectionControl_inherits(SelectionControl, _PureComponent);

  function SelectionControl(props) {
    SelectionControl_classCallCheck(this, SelectionControl);

    var _this = SelectionControl_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setInput = function (input) {
      _this._input = input;
    };

    _this._setControl = function (control) {
      _this._control = control;
    };

    _this._setContainer = function (container) {
      _this._container = container;
    };

    _this._getIcon = function () {
      var _this$props = _this.props,
          checkedIcon = _this$props.checkedIcon,
          uncheckedIcon = _this$props.uncheckedIcon,
          type = _this$props.type;

      var checked = getField(_this.props, _this.state, 'checked');
      if (checkedIcon || uncheckedIcon) {
        return checked ? checkedIcon : uncheckedIcon;
      }

      var prefix = (checked ? '' : 'un') + 'checked' + capitalizeFirst(type) + 'Icon';
      var iconClassName = _this.props[prefix + 'ClassName'];
      var children = _this.props[prefix + 'Children'];

      if (iconClassName || children) {
        return react_default.a.createElement(
          FontIcons_FontIcon,
          { iconClassName: iconClassName, inherit: true },
          children
        );
      }

      var icon = _this.props[prefix];
      return icon ? react_default.a.cloneElement(icon, { inherit: true }) : null;
    };

    _this._handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }

      var key = e.which || e.keyCode;
      if (key === SPACE) {
        _this._input.click();
      }
    };

    _this._handleChange = function (e) {
      var _this$props2 = _this.props,
          type = _this$props2.type,
          onChange = _this$props2.onChange;

      var checked = !getField(_this.props, _this.state, 'checked');
      if (onChange) {
        onChange(type === 'radio' ? e.target.value : checked, e);
      }

      if (typeof _this.props.checked === 'undefined') {
        _this.setState({ checked: checked });
      }
    };

    _this.state = {};
    if (typeof props.checked === 'undefined') {
      _this.state.checked = !!props.defaultChecked;
    }
    return _this;
  }

  /**
   * Gets the current checked value from the selection control. This is used when you have
   * an uncontrolled selection control and simply need the checked state from a ref callback.
   *
   * @return {boolean} the checked state for the selection control.\
   */


  SelectionControl.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        style = _props.style,
        className = _props.className,
        inline = _props.inline,
        type = _props.type,
        name = _props.name,
        value = _props.value,
        disabled = _props.disabled,
        labelBefore = _props.labelBefore,
        tabIndex = _props.tabIndex,
        inkDisabled = _props.inkDisabled,
        disabledInteractions = _props.disabledInteractions,
        ariaLabel = _props['aria-label'],
        ariaLabelledBy = _props['aria-labelledby'],
        ariaDescribedBy = _props['aria-describedby'],
        propLabel = _props.label,
        propChildren = _props.checked,
        onChange = _props.onChange,
        tooltip = _props.tooltip,
        checkedCheckboxIcon = _props.checkedCheckboxIcon,
        uncheckedCheckboxIcon = _props.uncheckedCheckboxIcon,
        checkedRadioIcon = _props.checkedRadioIcon,
        uncheckedRadioIcon = _props.uncheckedRadioIcon,
        __superSecreteProp = _props.__superSecreteProp,
        checkedIcon = _props.checkedIcon,
        uncheckedIcon = _props.uncheckedIcon,
        checkedRadioIconChildren = _props.checkedRadioIconChildren,
        checkedRadioIconClassName = _props.checkedRadioIconClassName,
        uncheckedRadioIconChildren = _props.uncheckedRadioIconChildren,
        uncheckedRadioIconClassName = _props.uncheckedRadioIconClassName,
        checkedCheckboxIconChildren = _props.checkedCheckboxIconChildren,
        checkedCheckboxIconClassName = _props.checkedCheckboxIconClassName,
        uncheckedCheckboxIconChildren = _props.uncheckedCheckboxIconChildren,
        uncheckedCheckboxIconClassName = _props.uncheckedCheckboxIconClassName,
        props = SelectionControl_objectWithoutProperties(_props, ['id', 'style', 'className', 'inline', 'type', 'name', 'value', 'disabled', 'labelBefore', 'tabIndex', 'inkDisabled', 'disabledInteractions', 'aria-label', 'aria-labelledby', 'aria-describedby', 'label', 'checked', 'onChange', 'tooltip', 'checkedCheckboxIcon', 'uncheckedCheckboxIcon', 'checkedRadioIcon', 'uncheckedRadioIcon', '__superSecreteProp', 'checkedIcon', 'uncheckedIcon', 'checkedRadioIconChildren', 'checkedRadioIconClassName', 'uncheckedRadioIconChildren', 'uncheckedRadioIconClassName', 'checkedCheckboxIconChildren', 'checkedCheckboxIconClassName', 'uncheckedCheckboxIconChildren', 'uncheckedCheckboxIconClassName']);

    var checked = getField(this.props, this.state, 'checked');
    var isSwitch = type === 'switch';
    var labelId = this.props.label && id + '-label';
    var label = this.props.label && react_default.a.createElement(
      'span',
      { id: labelId },
      this.props.label
    );

    var control = void 0;
    if (isSwitch) {
      control = react_default.a.createElement(SelectionControls_SwitchTrack, {
        disabled: disabled,
        checked: checked,
        'aria-label': ariaLabel,
        'aria-labelledby': ariaLabelledBy || labelId
      });
    } else {
      control = react_default.a.createElement(
        AccessibleFakeInkedButton,
        {
          inkDisabled: inkDisabled,
          disabledInteractions: disabledInteractions,
          role: type,
          className: classnames_default()('md-selection-control-toggle md-btn md-btn--icon', themeColors({
            disabled: disabled,
            hint: !checked,
            secondary: checked
          })),
          'aria-checked': checked,
          'aria-label': ariaLabel,
          'aria-labelledby': ariaLabelledBy || labelId,
          'aria-describedby': ariaDescribedBy,
          tabIndex: tabIndex,
          disabled: disabled
        },
        tooltip,
        this._getIcon()
      );
    }

    return react_default.a.createElement(
      'div',
      SelectionControl_extends({}, props, {
        style: style,
        className: classnames_default()('md-selection-control-container', {
          'md-selection-control-container--inline': inline,
          'md-switch-container': isSwitch
        }, className),
        onKeyDown: this._handleKeyDown
      }),
      react_default.a.createElement('input', {
        ref: this._setInput,
        id: id,
        type: isSwitch ? 'checkbox' : type,
        checked: checked,
        onChange: this._handleChange,
        disabled: disabled,
        className: 'md-selection-control-input',
        name: name,
        value: value,
        'aria-hidden': true
      }),
      react_default.a.createElement(
        'label',
        {
          htmlFor: id,
          className: classnames_default()('md-selection-control-label', {
            'md-pointer--hover': !disabled
          }, themeColors({ disabled: disabled, text: !disabled }))
        },
        labelBefore && label,
        control,
        !labelBefore && label
      )
    );
  };

  SelectionControl_createClass(SelectionControl, [{
    key: 'checked',
    get: function get() {
      return getField(this.props, this.state, 'checked');
    }
  }]);

  return SelectionControl;
}(react["PureComponent"]);

SelectionControl_SelectionControl.propTypes = {
  /**
   * An id to use with the selection control. This is used for accessibility and so that the label
   * triggers the selection control toggle.
   */
  id: preventDouble(isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]))),

  /**
   * An optional label to apply to the checkbox when there is no visible label.
   */
  'aria-label': oneRequiredForA11y(prop_types_default.a.string, 'label', 'aria-labelledby'),

  /**
   * An optional id that points to a label for the selection control when there is no visible label.
   */
  'aria-labelledby': prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id of an element that describes this selection control.
   * In the case of a fieldset, this should be the id of the fieldset legend which ensures
   * screen readers provides additional context about the selection control
   */
  'aria-describedby': prop_types_default.a.string,

  /**
   * An optional style to apply to the selection control's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the selection control's container.
   */
  className: prop_types_default.a.string,

  /**
   * The type of selection control to render.
   */
  type: prop_types_default.a.oneOf(['checkbox', 'radio', 'switch']).isRequired,

  /**
   * A label to display with the selection control. This is required for accessibility and triggering
   * the toggle.
   */
  label: prop_types_default.a.node,

  /**
   * Boolean if the label should appear before the checkbox/radio icon or switch.
   */
  labelBefore: prop_types_default.a.bool,

  /**
   * A name to use for the `SelectionControl`. This is required for accessibility. If the `type`
   * is a `checkbox` and it is part of a group, it is recommended to make this a string ending
   * in `[]` so that the value can be found from `document.querySelector('input[name="someName[]"]').value`.
   */
  name: preventDouble(isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]))),

  /**
   * Boolean if the `Radio` is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * A function to call when the `SelectionControl` triggers the `change` event. The `onChange`
   * callback will either include:
   * - the currently changed radio's value
   * - the next checked state for the `Switch` or `Checkbox`.
   *
   * as the first parameter followed by the change event.
   *
   * ```js
   * // Radio
   * onChange(changeEvent.target.value, changeEvent);
   *
   * // Checkbox or Switch
   * onChange(changeEvent.target.checked, changeEvent);
   * ```
   */
  onChange: prop_types_default.a.func,

  /**
   * An optional function to call when the `keydown` event is triggered.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * The value for the `SelectionControl`. It is not required for `Checkbox` and `Switch`,
   * but it is recommended.
   */
  value: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * A boolean if the `SelectionControl` is currently checked. This _really_ makes the `onChange`
   * prop required, but since there are cases you might want to have the `onChange` listener on a
   * `fieldset` or something above the component, it is never set to `required`. It will however
   * prevent updates if there is no change listener.
   */
  checked: prop_types_default.a.bool,

  /**
   * Boolean if the `Checkbox` or `Switch` are checked by default. This prop is invalid for a
   * `Radio`.
   */
  defaultChecked: prop_types_default.a.bool,

  /**
   * Boolean if the `SelectionControl` should be displayed inline instead of a block.
   */
  inline: prop_types_default.a.bool,

  /**
   * The icon to use for a checked `checkbox` selection control.
   */
  checkedCheckboxIcon: prop_types_default.a.element,

  /**
   * The icon to use for an unchecked `checkbox` selection control.
   */
  uncheckedCheckboxIcon: prop_types_default.a.element,

  /**
   * The icon to use for a checked `radio` selection control.
   */
  checkedRadioIcon: prop_types_default.a.element,

  /**
   * The icon to use for an unchecked `radio` selection control.
   */
  uncheckedRadioIcon: prop_types_default.a.element,

  /**
   * An optional tooltip to render with the control. This is only used if you inject the
   * tooltip manually yourself.
   *
   * `const TooltippedSelectionControl = injectTooltip(SelectionControl);`
   */
  tooltip: prop_types_default.a.node,

  /**
   * Boolean if the ink should be disabled for radios or checkboxes.
   *
   * @see {@link Inks#inkDisabled}
   */
  inkDisabled: prop_types_default.a.bool,

  /**
   * An optional list of ink interactions that should be disabled.
   *
   * @see {@link Inks#disabledInteractions}
   */
  disabledInteractions: prop_types_default.a.arrayOf(prop_types_default.a.oneOf(['keyboard', 'touch', 'mouse'])),

  /**
   * An optional tab index to apply to the selection control.
   */
  tabIndex: prop_types_default.a.number,

  checkedIcon: preventDouble(deprecated_default()(prop_types_default.a.node, 'Use the `checkedCheckboxIconChildren` and `checkedCheckboxIconClassName`  or the ' + '`checkedRadioIconChildren` and `checkedRadioIconClassName` props instead')),
  uncheckedIcon: preventDouble(deprecated_default()(prop_types_default.a.node, 'Use the `uncheckedCheckboxIconChildren` and `uncheckedCheckboxIconClassName`  or the ' + '`uncheckedRadioIconChildren` and `uncheckedRadioIconClassName` props instead')),
  checkedCheckboxIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `checkedCheckboxIcon` prop instead'),
  checkedCheckboxIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `checkedCheckboxIcon` prop instead'),
  uncheckedCheckboxIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `uncheckedCheckboxIcon` prop instead'),
  uncheckedCheckboxIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `uncheckedCheckboxIcon` prop instead'),
  checkedRadioIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `checkedRadioIcon` prop instead'),
  checkedRadioIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `checkedRadioIcon` prop instead'),
  uncheckedRadioIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `uncheckedRadioIcon` prop instead'),
  uncheckedRadioIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `uncheckedRadioIcon` prop instead'),

  /* maybe removed once upgrade again? */
  __superSecreteProp: prop_types_default.a.bool
};
SelectionControl_SelectionControl.defaultProps = {
  checkedCheckboxIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'check_box'
  ),
  uncheckedCheckboxIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'check_box_outline_blank'
  ),
  checkedRadioIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'radio_button_checked'
  ),
  uncheckedRadioIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'radio_button_unchecked'
  )
};
/* harmony default export */ var SelectionControls_SelectionControl = (SelectionControl_SelectionControl);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/findTable.js
/**
 * Attempts fo find the base table component from an element in the table.
 * This will either be the wrapper for responsive data tables, or the table element.
 *
 * @param {Object} el - The element to traverse from
 * @param {Object} the table or null.
 */
function findTable(el) {
  var table = void 0;
  var node = el;
  while (node && node.parentNode) {
    if (node.classList) {
      if (node.classList.contains('md-data-table')) {
        table = node;
      } else if (node.classList.contains('md-data-table--responsive')) {
        return node;
      } else if (node.classList.contains('md-data-table__scroll-wrapper')) {
        // fixed-wrapper then responsive
        return node.parentNode.parentNode;
      } else if (table) {
        return table;
      }
    }

    node = node.parentNode;
  }

  return null;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/TableCheckbox.js
var TableCheckbox_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TableCheckbox_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TableCheckbox_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TableCheckbox_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TableCheckbox_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var TableCheckbox_TableCheckbox = function (_Component) {
  TableCheckbox_inherits(TableCheckbox, _Component);

  function TableCheckbox() {
    var _temp, _this, _ret;

    TableCheckbox_classCallCheck(this, TableCheckbox);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = TableCheckbox_possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this._td = null, _this._header = false, _this._handleMount = function (td) {
      if (td) {
        var header = findTable(td).querySelector('thead');
        var index = td.parentNode.rowIndex - (header ? 1 : 0);

        if (td.parentNode.parentNode.tagName === 'TBODY') {
          _this.context.createCheckbox(index);
        }
        _this._td = td;
        _this._header = header;
      } else if (_this._td) {
        var _index = _this._td.parentNode.rowIndex;
        _this.context.removeCheckbox(_index - (_this._header ? 1 : 0));
        _this._td = null;
        _this._header = false;
      }
    }, _temp), TableCheckbox_possibleConstructorReturn(_this, _ret);
  }

  TableCheckbox.prototype.render = function render() {
    var _props = this.props,
        checked = _props.checked,
        index = _props.index,
        props = TableCheckbox_objectWithoutProperties(_props, ['checked', 'index']);

    var _context = this.context,
        checkedIcon = _context.checkedIcon,
        uncheckedIcon = _context.uncheckedIcon,
        indeterminateIcon = _context.indeterminateIcon,
        indeterminate = _context.indeterminate,
        header = _context.header,
        footer = _context.footer,
        rowId = _context.rowId,
        baseName = _context.baseName,
        checkboxHeaderLabel = _context.checkboxHeaderLabel,
        checkboxLabelTemplate = _context.checkboxLabelTemplate;


    var Cell = header ? 'th' : 'td';
    var label = void 0;
    if (header) {
      label = checkboxHeaderLabel;
    } else if (typeof checkboxLabelTemplate === 'function') {
      label = checkboxLabelTemplate(index);
    } else {
      label = checkboxLabelTemplate.replace(/{{row}}/g, index);
    }

    var content = react_default.a.createElement(SelectionControls_SelectionControl, TableCheckbox_extends({}, props, {
      id: rowId,
      name: baseName + '-checkbox',
      type: 'checkbox',
      checked: checked,
      checkedCheckboxIcon: checkedIcon,
      uncheckedCheckboxIcon: header && indeterminate ? indeterminateIcon : uncheckedIcon,
      'aria-label': label
    }));
    var fixedHeader = header && this.context.fixedHeader;
    var fixedFooter = footer && this.context.fixedFooter;

    if (fixedHeader) {
      content = react_default.a.createElement(
        'div',
        {
          className: classnames_default()('md-table-column__fixed', {
            'md-table-column__fixed--header': fixedHeader,
            'md-table-column__fixed--footer': fixedFooter
          })
        },
        react_default.a.cloneElement(content, {
          className: classnames_default()({
            'md-table-checkbox--header': header,
            'md-table-checkbox--footer': footer
          })
        })
      );
    }

    return react_default.a.createElement(
      Cell,
      {
        className: classnames_default()('md-table-checkbox', {
          'md-table-column--fixed': fixedHeader
        }),
        scope: header ? 'col' : undefined,
        ref: this._handleMount
      },
      content
    );
  };

  return TableCheckbox;
}(react["Component"]);

TableCheckbox_TableCheckbox.propTypes = {
  index: prop_types_default.a.number,
  checked: prop_types_default.a.bool
};
TableCheckbox_TableCheckbox.contextTypes = {
  rowId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  baseName: prop_types_default.a.string.isRequired,
  indeterminate: prop_types_default.a.bool,
  checkedIcon: prop_types_default.a.element,
  uncheckedIcon: prop_types_default.a.element,
  indeterminateIcon: prop_types_default.a.element,
  checkboxHeaderLabel: prop_types_default.a.string.isRequired,
  checkboxLabelTemplate: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,
  createCheckbox: prop_types_default.a.func.isRequired,
  removeCheckbox: prop_types_default.a.func.isRequired,
  header: prop_types_default.a.bool,
  footer: prop_types_default.a.bool,
  fixedHeader: prop_types_default.a.bool.isRequired,
  fixedFooter: prop_types_default.a.bool.isRequired
};
/* harmony default export */ var DataTables_TableCheckbox = (TableCheckbox_TableCheckbox);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/TableRow.js
var TableRow_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TableRow_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TableRow_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TableRow_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TableRow_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











/**
 * A component for displaying a row in a `DataTable`. This will
 * automatically add a `Checkbox` component to the row if it is not
 * a `plain` table.
 */

var TableRow_TableRow = function (_Component) {
  TableRow_inherits(TableRow, _Component);

  function TableRow(props, context) {
    TableRow_classCallCheck(this, TableRow);

    var _this = TableRow_possibleConstructorReturn(this, _Component.call(this, props, context));

    _this._handleMouseOver = function (e) {
      if (_this.props.onMouseOver) {
        _this.props.onMouseOver(e);
      }

      if (_this.context.header) {
        return;
      }

      var target = e.target;
      while (target && target.parentNode) {
        if (target.classList && _this._ignoreHoverState(target.classList)) {
          _this.setState({ hover: false });
          return;
        }

        target = target.parentNode;
      }

      _this.setState({ hover: true });
    };

    _this._handleMouseLeave = function (e) {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave(e);
      }

      if (_this.context.header) {
        return;
      }

      _this.setState({ hover: false });
    };

    _this._handleCheckboxClick = function (checked, e) {
      var rowIndex = _this._row.rowIndex;

      if (_this.props.onCheckboxClick) {
        _this.props.onCheckboxClick(rowIndex, checked, e);
      }

      _this.context.toggleSelectedRow(rowIndex, _this.context.header, e);
    };

    _this._setRow = function (row) {
      _this._row = row;
    };

    _this.state = { hover: false };
    return _this;
  }

  TableRow.prototype.getChildContext = function getChildContext() {
    var _context = this.context,
        baseId = _context.baseId,
        context = TableRow_objectWithoutProperties(_context, ['baseId']);

    var id = baseId + '-' + (this._row ? this._row.rowIndex : null);
    return TableRow_extends({}, context, {
      rowId: context.header ? baseId + '-toggle-all' : id
    });
  };

  /**
   * Need to ignore adding the hover state if the mouse is over a menu/menu item
   * or the edit dialog is open.
   *
   * @param {Function} classList - the classList to use for checking cn
   * @return {Boolean} true if the hover state should be ignored for this classList
   */


  TableRow.prototype._ignoreHoverState = function _ignoreHoverState(classList) {
    return classList.contains('md-list--menu') || classList.contains('md-edit-dialog');
  };

  TableRow.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        className = _props.className,
        children = _props.children,
        selected = _props.selected,
        selectable = _props.selectable,
        onCheckboxClick = _props.onCheckboxClick,
        autoAdjust = _props.autoAdjust,
        props = TableRow_objectWithoutProperties(_props, ['className', 'children', 'selected', 'selectable', 'onCheckboxClick', 'autoAdjust']);

    var hover = this.state.hover;


    var checkbox = void 0;
    if (typeof selectable !== 'undefined' ? selectable : !this.context.plain && this.context.selectableRows) {
      checkbox = react_default.a.createElement(DataTables_TableCheckbox, {
        key: 'checkbox',
        checked: selected,
        onChange: this._handleCheckboxClick,
        index: this._row ? this._row.rowIndex : null
      });
    }

    var length = react["Children"].count(children) - 1;
    var columns = react["Children"].map(react["Children"].toArray(children), function (col, i) {
      var adjusted = col.props.adjusted;
      if (typeof adjusted === 'undefined') {
        adjusted = i === length ? false : undefined;
      }

      return Object(react["cloneElement"])(col, {
        cellIndex: i + (checkbox ? 1 : 0),
        header: getField(col.props, _this2.context, 'header'),
        adjusted: adjusted
      });
    });

    return react_default.a.createElement(
      'tr',
      TableRow_extends({}, props, {
        ref: this._setRow,
        className: classnames_default()('md-table-row', className, {
          'md-table-row--hover': hover,
          'md-table-row--active': !this.context.header && selected
        }),
        onMouseOver: this._handleMouseOver,
        onMouseLeave: this._handleMouseLeave
      }),
      checkbox,
      columns
    );
  };

  return TableRow;
}(react["Component"]);

TableRow_TableRow.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the row.
   */
  className: prop_types_default.a.string,

  /**
   * A single or list of `TableColumn` to display in the table.
   *
   * > The specs "require" at least 3 columns for a non-plain data table, but that isn't
   * strictly enforced here.
   */
  children: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.arrayOf(prop_types_default.a.element)]).isRequired,

  /**
   * An optional onClick function to call when a row is clicked.
   */
  onClick: prop_types_default.a.func,

  /**
   * A function to call when the checkbox is clicked. This
   * function will will be called with `(rowIndex, checked, event)`.
   * The `TableBody` and `TableHeader` components will automatically
   * merge in a function to toggle the checkbox.
   */
  onCheckboxClick: prop_types_default.a.func,

  /**
   * An optional function to call onMouseOver.
   */
  onMouseOver: prop_types_default.a.func,

  /**
   * An optional function to call onMouseLeave.
   */
  onMouseLeave: prop_types_default.a.func,

  /**
   * Boolean if the row is currently selected. If this value will be
   * injected by the `TableHeader` or `TableBody` component.
   */
  selected: prop_types_default.a.bool,

  /**
   * Boolean if the current row is selectable. This value will take precedence over anything inherited
   * by the `DataTable`.
   */
  selectable: prop_types_default.a.bool,

  autoAdjust: deprecated_default()(prop_types_default.a.bool, 'Manually specify `grow` on one of the columns instead')
};
TableRow_TableRow.contextTypes = headerContextTypes;
TableRow_TableRow.childContextTypes = DataTables_rowContextTypes;
/* harmony default export */ var DataTables_TableRow = (TableRow_TableRow);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/TableColumn.js
var TableColumn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TableColumn_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TableColumn_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TableColumn_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TableColumn_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }














var CELL_SCOPE = {
  header: {
    scope: 'col'
  },
  noop: {}
};

/**
 * A column in a table. This is either the `th` or `td` component.
 */

var TableColumn_TableColumn = function (_PureComponent) {
  TableColumn_inherits(TableColumn, _PureComponent);

  function TableColumn() {
    TableColumn_classCallCheck(this, TableColumn);

    return TableColumn_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  TableColumn.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        className = _props.className,
        fixedStyle = _props.fixedStyle,
        fixedClassName = _props.fixedClassName,
        numeric = _props.numeric,
        header = _props.header,
        children = _props.children,
        sorted = _props.sorted,
        sortIcon = _props.sortIcon,
        tooltip = _props.tooltip,
        selectColumnHeader = _props.selectColumnHeader,
        adjusted = _props.adjusted,
        grow = _props.grow,
        sortIconBefore = _props.sortIconBefore,
        propPlain = _props.plain,
        propScope = _props.scope,
        cellIndex = _props.cellIndex,
        sortIconChildren = _props.sortIconChildren,
        sortIconClassName = _props.sortIconClassName,
        props = TableColumn_objectWithoutProperties(_props, ['className', 'fixedStyle', 'fixedClassName', 'numeric', 'header', 'children', 'sorted', 'sortIcon', 'tooltip', 'selectColumnHeader', 'adjusted', 'grow', 'sortIconBefore', 'plain', 'scope', 'cellIndex', 'sortIconChildren', 'sortIconClassName']);

    var sortable = typeof sorted === 'boolean';
    var plain = getField(this.props, this.context, 'plain');
    var Component = header ? 'th' : 'td';
    var scope = getField(this.props, CELL_SCOPE[header ? 'header' : 'noop'], 'scope');

    var displayedChildren = children;
    var ariaSort = void 0;
    if (sortable) {
      ariaSort = sorted ? 'ascending' : 'descending';
      var icon = react_default.a.Children.only(getDeprecatedIcon(sortIconClassName, sortIconChildren, sortIcon));
      displayedChildren = react_default.a.createElement(
        Helpers_IconSeparator,
        { label: children, iconBefore: sortIconBefore },
        react_default.a.cloneElement(icon, { className: getCollapserStyles({ flipped: !sorted }, icon.props.className) })
      );
    }

    var fixedHeader = header && this.context.fixedHeader;
    var fixedFooter = this.context.footer && this.context.fixedFooter;
    var fixed = fixedHeader || fixedFooter;
    var baseClassNames = themeColors({ text: !header, hint: header }, {
      'md-table-column--relative': tooltip,
      'md-table-column--select-field': selectColumnHeader
    });

    var mergedClassNames = classnames_default()((_cn = {
      'md-table-column--header': header,
      'md-table-column--data': !header && !plain,
      'md-table-column--plain': !header && plain,
      'md-table-column--adjusted': adjusted && !grow && !selectColumnHeader,
      'md-table-column--grow': grow,
      'md-table-column--sortable md-pointer--hover': sortable
    }, _cn[baseClassNames] = !fixed, _cn), className);

    if (fixed) {
      displayedChildren = react_default.a.createElement(
        'div',
        {
          className: classnames_default()('md-table-column__fixed', {
            'md-table-column__fixed--header': fixedHeader,
            'md-table-column__fixed--footer': fixedFooter
          })
        },
        react_default.a.createElement(
          'div',
          {
            style: fixedStyle,
            className: classnames_default()(baseClassNames, mergedClassNames, 'md-table-column__fixed--flex', {
              'md-table-column__fixed--flex-right': numeric
            }, fixedClassName)
          },
          tooltip,
          displayedChildren
        )
      );
    }

    return react_default.a.createElement(
      Component,
      TableColumn_extends({
        'aria-sort': ariaSort
      }, props, {
        scope: scope,
        className: classnames_default()('md-table-column', {
          'md-table-column--fixed': fixed,
          'md-text-left': !numeric && !fixed,
          'md-text-right': numeric && !fixed
        }, mergedClassNames)
      }),
      !fixedHeader && !fixedFooter && tooltip,
      displayedChildren
    );
  };

  return TableColumn;
}(react["PureComponent"]);

TableColumn_TableColumn.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * The optional className for the table column
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the surrounding div when the DataTable has been
   * set to include a fixed header or a fixed footer.
   */
  fixedStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the surrounding div when the DataTable has been
   * set to include a fixed header or a fixed footer.
   */
  fixedClassName: prop_types_default.a.string,

  /**
   * The children to display in the column.
   */
  children: prop_types_default.a.node,

  /**
   * Boolean if the column is currently sorted. If this prop is not `undefined`,
   * it will add the sort icon unto this column. You will also need to use the
   * `onClick` function to toggle the `sorted` prop as well as handling the sorting
   * of data.
   *
   * This value should really only be set in the `TableHeader` component.
   */
  sorted: prop_types_default.a.bool,

  /**
   * The icon to show when a column is sortable.
   */
  sortIcon: prop_types_default.a.element,

  /**
   * Boolean if the sortIcon should appear before the text in the column.
   */
  sortIconBefore: prop_types_default.a.bool,

  /**
   * A boolean if the column has numeric data. It will right-align the data.
   */
  numeric: prop_types_default.a.bool,

  /**
   * Boolean if the table column should gain the `.md-data-table--adjusted` class name. By default,
   * every column will gain this class name unless it is an `EditDialogColumn`, a `SelectFieldColumn`,
   * or the `grow` prop is enabled.
   */
  adjusted: prop_types_default.a.bool,

  /**
   * Boolean if the column should expand to fill any remaining width in the container. There should
   * really only be one column with the `grow` prop enabled. In addition, it should really only be
   * applied to one of the columns in the TableHeader.
   */
  grow: prop_types_default.a.bool,

  /**
   * Boolean if this column is the `th` for a column of `SelectFieldColumn`. This will apply
   * additional styling to the column to position with the select field.
   */
  selectColumnHeader: prop_types_default.a.bool,

  /**
   * Boolean if this is a `th` component. This value **should** be set
   * automatically for you if it is in the `TableHeader` component.
   */
  header: prop_types_default.a.bool.isRequired,

  /**
   * The optional tooltip to render on hover.
   */
  tooltipLabel: prop_types_default.a.node,

  /**
   * An optional delay to apply to the tooltip before it appears.
   */
  tooltipDelay: prop_types_default.a.number,

  /**
   * The position of the tooltip.
   */
  tooltipPosition: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * The injected tooltip.
   * @access private
   */
  tooltip: prop_types_default.a.node,

  /**
   * Boolean if the `TableColumn` should gain the `plain` styles. This means that the text
   * in the column can wrap and there is no height limit enforced with some additional padding.
   */
  plain: prop_types_default.a.bool,

  /**
   * An optional scope to apply to the table column. If omitted, the scope will be set to
   * `'col'` if inside of the `TableHeader` component. This is really only needed for
   * header columns.
   */
  scope: prop_types_default.a.oneOf(['row', 'col']),

  /**
   * This is injected by the `TableRow` component to help with generating ids
   * @access private
   */
  cellIndex: prop_types_default.a.number,
  sortIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `sortIcon` prop instead'),
  sortIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `sortIcon` prop instead')
};
TableColumn_TableColumn.defaultProps = {
  header: false,
  adjusted: true,
  sortIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'arrow_upward'
  ),
  sortIconBefore: true
};
TableColumn_TableColumn.contextTypes = {
  plain: prop_types_default.a.bool,
  footer: prop_types_default.a.bool,
  fixedHeader: prop_types_default.a.bool,
  fixedFooter: prop_types_default.a.bool
};


/* harmony default export */ var DataTables_TableColumn = (injectTooltip(TableColumn_TableColumn));
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectFields/SelectFieldInput.js
var SelectFieldInput_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function SelectFieldInput_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SelectFieldInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SelectFieldInput_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SelectFieldInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }













var SelectFieldInput_SelectFieldInput = function (_PureComponent) {
  SelectFieldInput_inherits(SelectFieldInput, _PureComponent);

  function SelectFieldInput() {
    var _temp, _this, _ret;

    SelectFieldInput_classCallCheck(this, SelectFieldInput);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = SelectFieldInput_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { transition: null }, _this._timeout = null, _this._transitionNewValue = function () {
      var _this$props = _this.props,
          transitionTime = _this$props.transitionTime,
          transitionName = _this$props.transitionName;

      if (_this._timeout) {
        clearTimeout(_this._timeout);
      }

      _this._timeout = setTimeout(function () {
        _this._timeout = setTimeout(function () {
          _this._timeout = null;
          _this.setState({ transition: null });
        }, transitionTime);

        _this.setState({ transition: _this.state.transition + ' ' + transitionName + '-enter-active' });
      }, CSSTransitionGroupTick);

      _this.setState({ transition: transitionName + '-enter' });
    }, _temp), SelectFieldInput_possibleConstructorReturn(_this, _ret);
  }

  SelectFieldInput.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.value !== nextProps.value) {
      this._transitionNewValue();
    }
  };

  SelectFieldInput.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  SelectFieldInput.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        className = _props.className,
        name = _props.name,
        value = _props.value,
        label = _props.label,
        placeholder = _props.placeholder,
        active = _props.active,
        activeLabel = _props.activeLabel,
        error = _props.error,
        disabled = _props.disabled,
        required = _props.required,
        toolbar = _props.toolbar,
        below = _props.below,
        lineDirection = _props.lineDirection,
        dropdownIcon = _props.dropdownIcon,
        iconChildren = _props.iconChildren,
        iconClassName = _props.iconClassName,
        transitionName = _props.transitionName,
        transitionTime = _props.transitionTime,
        props = SelectFieldInput_objectWithoutProperties(_props, ['id', 'className', 'name', 'value', 'label', 'placeholder', 'active', 'activeLabel', 'error', 'disabled', 'required', 'toolbar', 'below', 'lineDirection', 'dropdownIcon', 'iconChildren', 'iconClassName', 'transitionName', 'transitionTime']);

    var transition = this.state.transition;


    var divider = void 0;
    if (!below && !toolbar) {
      divider = react_default.a.createElement(TextFields_TextFieldDivider, {
        key: 'text-divider',
        active: active,
        error: error,
        lineDirection: lineDirection,
        className: 'md-divider--select-field'
      });
    }

    var visibleLabel = activeLabel;
    if (!activeLabel && activeLabel !== 0) {
      visibleLabel = (!label || active) && placeholder || '';
    }

    var labelActive = !!activeLabel || activeLabel === 0;

    var icon = dropdownIcon;
    if (iconClassName || iconChildren) {
      icon = react_default.a.createElement(
        FontIcons_FontIcon,
        { iconClassName: iconClassName },
        iconChildren
      );
    }
    icon = react_default.a.cloneElement(icon, { disabled: disabled });

    return react_default.a.createElement(
      AccessibleFakeInkedButton,
      SelectFieldInput_extends({}, props, {
        id: id + '-toggle',
        role: 'listbox',
        disabled: disabled,
        component: Papers_Paper,
        zDepth: below && active ? 1 : 0,
        inkDisabled: !below,
        className: classnames_default()('md-select-field', themeColors({
          disabled: disabled,
          hint: !labelActive && placeholder,
          text: labelActive
        }), className)
      }),
      react_default.a.createElement(
        Helpers_IconSeparator,
        {
          label: visibleLabel,
          labelClassName: transition,
          className: classnames_default()('md-text-field', {
            'md-text-field--margin': !below && !label,
            'md-text-field--floating-margin': label,
            'md-text-field--toolbar': toolbar && !below,
            'md-select-field--text-field': !below,
            'md-select-field--btn': below
          })
        },
        icon
      ),
      divider,
      react_default.a.createElement('input', {
        key: 'value',
        type: 'hidden',
        id: id,
        name: name,
        value: value,
        required: required,
        disabled: disabled
      })
    );
  };

  return SelectFieldInput;
}(react["PureComponent"]);

SelectFieldInput_SelectFieldInput.propTypes = {
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  name: prop_types_default.a.string,
  value: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  disabled: prop_types_default.a.bool,
  required: prop_types_default.a.bool,
  label: prop_types_default.a.node,
  placeholder: prop_types_default.a.string,
  active: prop_types_default.a.bool,
  activeLabel: prop_types_default.a.node,
  below: prop_types_default.a.bool,
  error: prop_types_default.a.bool,
  toolbar: prop_types_default.a.bool,
  dropdownIcon: prop_types_default.a.element,
  iconClassName: prop_types_default.a.string,
  iconChildren: prop_types_default.a.node,
  transitionName: prop_types_default.a.string.isRequired,
  transitionTime: prop_types_default.a.number.isRequired,
  lineDirection: TextFields_TextFieldDivider.propTypes.lineDirection
};
SelectFieldInput_SelectFieldInput.defaultProps = {
  transitionName: 'md-drop',
  transitionTime: 300
};
/* harmony default export */ var SelectFields_SelectFieldInput = (SelectFieldInput_SelectFieldInput);
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectFields/SelectFieldToggle.js
var SelectFieldToggle_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function SelectFieldToggle_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SelectFieldToggle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SelectFieldToggle_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SelectFieldToggle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }












var SelectFieldToggle_SelectFieldToggle = function (_PureComponent) {
  SelectFieldToggle_inherits(SelectFieldToggle, _PureComponent);

  function SelectFieldToggle() {
    SelectFieldToggle_classCallCheck(this, SelectFieldToggle);

    return SelectFieldToggle_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  SelectFieldToggle.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        style = _props.style,
        className = _props.className,
        inputStyle = _props.inputStyle,
        inputClassName = _props.inputClassName,
        required = _props.required,
        disabled = _props.disabled,
        active = _props.active,
        error = _props.error,
        errorText = _props.errorText,
        helpText = _props.helpText,
        helpOnFocus = _props.helpOnFocus,
        visible = _props.visible,
        activeLabel = _props.activeLabel,
        propLabel = _props.label,
        propPlaceholder = _props.placeholder,
        props = SelectFieldToggle_objectWithoutProperties(_props, ['id', 'style', 'className', 'inputStyle', 'inputClassName', 'required', 'disabled', 'active', 'error', 'errorText', 'helpText', 'helpOnFocus', 'visible', 'activeLabel', 'label', 'placeholder']);

    var _props2 = this.props,
        label = _props2.label,
        placeholder = _props2.placeholder;

    if (required) {
      if (label) {
        label = addSuffix(label, '*');
      }

      if (placeholder && !label) {
        placeholder = addSuffix(placeholder, '*');
      }
    }

    return react_default.a.createElement(
      'div',
      { style: style, className: classnames_default()('md-select-field__toggle', className) },
      react_default.a.createElement(TextFields_FloatingLabel, {
        label: label,
        htmlFor: id,
        active: active || visible,
        error: error,
        floating: isValued(activeLabel) || active || visible,
        disabled: disabled
      }),
      react_default.a.createElement(SelectFields_SelectFieldInput, SelectFieldToggle_extends({}, props, {
        id: id,
        style: inputStyle,
        className: inputClassName,
        label: label,
        placeholder: placeholder,
        activeLabel: activeLabel,
        active: active,
        error: error,
        disabled: disabled
      })),
      react_default.a.createElement(TextFields_TextFieldMessage, {
        active: active || visible,
        error: error,
        errorText: errorText,
        helpText: helpText,
        helpOnFocus: helpOnFocus,
        leftIcon: false,
        rightIcon: false
      })
    );
  };

  return SelectFieldToggle;
}(react["PureComponent"]);

SelectFieldToggle_SelectFieldToggle.propTypes = {
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  inputStyle: prop_types_default.a.object,
  inputClassName: prop_types_default.a.string,
  activeLabel: prop_types_default.a.node,
  value: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  required: prop_types_default.a.bool,
  disabled: prop_types_default.a.bool,
  label: prop_types_default.a.string,
  placeholder: prop_types_default.a.string,
  active: prop_types_default.a.bool,
  error: prop_types_default.a.bool,
  errorText: prop_types_default.a.node,
  helpText: prop_types_default.a.node,
  helpOnFocus: prop_types_default.a.bool,
  below: prop_types_default.a.bool,
  visible: prop_types_default.a.bool
};
/* harmony default export */ var SelectFields_SelectFieldToggle = (SelectFieldToggle_SelectFieldToggle);
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectFields/SelectField.js
var SelectField_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var SelectField_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var SelectField_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function SelectField_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SelectField_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SelectField_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SelectField_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
























var MOBILE_LIST_PADDING = 8;
var ARIA_ACTIVE = 'aria-activedescendant';

var SelectField_SelectField = function (_PureComponent) {
  SelectField_inherits(SelectField, _PureComponent);

  function SelectField(props) {
    var _listProps;

    SelectField_classCallCheck(this, SelectField);

    var _this = SelectField_possibleConstructorReturn(this, _PureComponent.call(this, props));

    SelectField_initialiseProps.call(_this);

    _this.state = SelectField_extends({
      error: false,
      active: false
    }, _this._getActive(props, { value: props.defaultValue }), {
      listProps: (_listProps = {
        role: 'listbox',
        ref: _this._scrollActiveIntoView
      }, _listProps[ARIA_ACTIVE] = null, _listProps),
      match: null,
      lastSearch: null,
      value: props.defaultValue,
      visible: props.defaultVisible
    });

    _this._items = [];
    _this._activeItem = null;
    _this._deleteKeys = _this._getDeleteKeys(props);
    return _this;
  }

  SelectField.prototype.componentDidMount = function componentDidMount() {
    this._container = Object(react_dom["findDOMNode"])(this);
    this._field = this._container.querySelector('.md-select-field');
  };

  SelectField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        itemLabel = _props.itemLabel,
        itemValue = _props.itemValue,
        deleteKeys = _props.deleteKeys;

    if (deleteKeys !== nextProps.deleteKeys || itemLabel !== nextProps.itemLabel || itemValue !== nextProps.itemValue) {
      this._deleteKeys = this._getDeleteKeys(nextProps);
    }

    if (this.props.value !== nextProps.value || this.props.menuItems !== nextProps.menuItems) {
      this.setState(this._getActive(nextProps, this.state));
    }
  };

  /**
   * Gets the current value from the select field. This is used when you have an uncontrolled
   * text field and simply need the value from a ref callback.
   *
   * @return {String} the select field's value
   */


  SelectField.prototype._getItemPart = function _getItemPart(item, itemLabel, itemValue) {
    var preferLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var type = typeof item === 'undefined' ? 'undefined' : SelectField_typeof(item);
    if (type === 'number' || type === 'string') {
      return item;
    } else if (type === 'object') {
      var key1 = preferLabel ? itemLabel : itemValue;
      var key2 = preferLabel ? itemValue : itemLabel;
      return typeof item[key1] !== 'undefined' ? item[key1] : item[key2];
    }

    return '';
  };

  SelectField.prototype._getDeleteKeys = function _getDeleteKeys(_ref) {
    var itemLabel = _ref.itemLabel,
        itemValue = _ref.itemValue,
        itemProps = _ref.itemProps,
        deleteKeys = _ref.deleteKeys;

    var keys = [itemLabel, itemValue, itemProps];
    if (deleteKeys) {
      return keys.concat(Array.isArray(deleteKeys) ? deleteKeys : [deleteKeys]);
    }

    return keys;
  };

  SelectField.prototype.render = function render() {
    var _props2 = this.props,
        id = _props2.id,
        style = _props2.style,
        className = _props2.className,
        listStyle = _props2.listStyle,
        listClassName = _props2.listClassName,
        toggleStyle = _props2.toggleStyle,
        toggleClassName = _props2.toggleClassName,
        menuItems = _props2.menuItems,
        anchor = _props2.anchor,
        belowAnchor = _props2.belowAnchor,
        fixedTo = _props2.fixedTo,
        position = _props2.position,
        xThreshold = _props2.xThreshold,
        yThreshold = _props2.yThreshold,
        listZDepth = _props2.listZDepth,
        listInline = _props2.listInline,
        listHeightRestricted = _props2.listHeightRestricted,
        block = _props2.block,
        centered = _props2.centered,
        sameWidth = _props2.sameWidth,
        fullWidth = _props2.fullWidth,
        repositionOnScroll = _props2.repositionOnScroll,
        repositionOnResize = _props2.repositionOnResize,
        simplifiedMenu = _props2.simplifiedMenu,
        minLeft = _props2.minLeft,
        minRight = _props2.minRight,
        minBottom = _props2.minBottom,
        fillViewportWidth = _props2.fillViewportWidth,
        fillViewportHeight = _props2.fillViewportHeight,
        menuTransitionName = _props2.menuTransitionName,
        menuTransitionEnterTimeout = _props2.menuTransitionEnterTimeout,
        menuTransitionLeaveTimeout = _props2.menuTransitionLeaveTimeout,
        isOpen = _props2.isOpen,
        propError = _props2.error,
        propMenuId = _props2.menuId,
        propVisible = _props2.visible,
        itemLabel = _props2.itemLabel,
        itemValue = _props2.itemValue,
        itemProps = _props2.itemProps,
        getItemProps = _props2.getItemProps,
        defaultValue = _props2.defaultValue,
        defaultVisible = _props2.defaultVisible,
        onClick = _props2.onClick,
        onKeyDown = _props2.onKeyDown,
        onVisibilityChange = _props2.onVisibilityChange,
        deleteKeys = _props2.deleteKeys,
        stripActiveItem = _props2.stripActiveItem,
        keyboardMatchingTimeout = _props2.keyboardMatchingTimeout,
        defaultOpen = _props2.defaultOpen,
        initiallyOpen = _props2.initiallyOpen,
        onMenuToggle = _props2.onMenuToggle,
        stretchList = _props2.stretchList,
        menuStyle = _props2.menuStyle,
        menuClassName = _props2.menuClassName,
        floatingLabel = _props2.floatingLabel,
        noAutoAdjust = _props2.noAutoAdjust,
        adjustMinWidth = _props2.adjustMinWidth,
        props = SelectField_objectWithoutProperties(_props2, ['id', 'style', 'className', 'listStyle', 'listClassName', 'toggleStyle', 'toggleClassName', 'menuItems', 'anchor', 'belowAnchor', 'fixedTo', 'position', 'xThreshold', 'yThreshold', 'listZDepth', 'listInline', 'listHeightRestricted', 'block', 'centered', 'sameWidth', 'fullWidth', 'repositionOnScroll', 'repositionOnResize', 'simplifiedMenu', 'minLeft', 'minRight', 'minBottom', 'fillViewportWidth', 'fillViewportHeight', 'menuTransitionName', 'menuTransitionEnterTimeout', 'menuTransitionLeaveTimeout', 'isOpen', 'error', 'menuId', 'visible', 'itemLabel', 'itemValue', 'itemProps', 'getItemProps', 'defaultValue', 'defaultVisible', 'onClick', 'onKeyDown', 'onVisibilityChange', 'deleteKeys', 'stripActiveItem', 'keyboardMatchingTimeout', 'defaultOpen', 'initiallyOpen', 'onMenuToggle', 'stretchList', 'menuStyle', 'menuClassName', 'floatingLabel', 'noAutoAdjust', 'adjustMinWidth']);

    var _props3 = this.props,
        menuId = _props3.menuId,
        listId = _props3.listId,
        error = _props3.error;

    error = error || this.state.error;
    if (!menuId) {
      menuId = id + '-menu';
    }

    if (!listId) {
      listId = menuId + '-options';
    }

    var _state = this.state,
        listProps = _state.listProps,
        active = _state.active,
        activeLabel = _state.activeLabel;

    var below = position === SelectField.Positions.BELOW;
    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(this.props, this.state, 'visible');
    var value = getField(this.props, this.state, 'value');
    var useSameWidth = typeof sameWidth !== 'undefined' ? sameWidth : below;

    var toggle = react_default.a.createElement(SelectFields_SelectFieldToggle, SelectField_extends({}, props, {
      id: id,
      style: toggleStyle,
      className: toggleClassName,
      visible: visible,
      value: value,
      below: below,
      error: error,
      active: active,
      activeLabel: activeLabel,
      onClick: this._toggle,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur
    }));

    return react_default.a.createElement(
      Menus_Menu,
      {
        id: menuId,
        listId: listId,
        style: style,
        className: classnames_default()('md-menu--select-field', className),
        listProps: listProps,
        listStyle: listStyle,
        listClassName: listClassName,
        toggle: toggle,
        visible: visible,
        onClose: this._close,
        onKeyDown: this._handleKeyDown,
        onClick: this._handleClick,
        simplified: simplifiedMenu,
        anchor: anchor,
        belowAnchor: belowAnchor,
        fixedTo: fixedTo,
        position: position,
        xThreshold: xThreshold,
        yThreshold: yThreshold,
        listZDepth: listZDepth,
        listInline: listInline,
        listHeightRestricted: listHeightRestricted,
        sameWidth: useSameWidth,
        block: block,
        centered: centered,
        fullWidth: fullWidth,
        minLeft: minLeft,
        minRight: minRight,
        minBottom: minBottom,
        fillViewportWidth: fillViewportWidth,
        fillViewportHeight: fillViewportHeight,
        repositionOnScroll: repositionOnScroll,
        repositionOnResize: repositionOnResize,
        transitionName: menuTransitionName,
        transitionEnterTimeout: menuTransitionEnterTimeout,
        transitionLeaveTimeout: menuTransitionLeaveTimeout
      },
      menuItems.reduce(this._reduceItems, [])
    );
  };

  SelectField_createClass(SelectField, [{
    key: 'value',
    get: function get() {
      return getField(this.props, this.state, 'value');
    }
  }]);

  return SelectField;
}(react["PureComponent"]);

SelectField_SelectField.HorizontalAnchors = Menus_Menu.HorizontalAnchors;
SelectField_SelectField.VerticalAnchors = Menus_Menu.VerticalAnchors;
SelectField_SelectField.Positions = Menus_Menu.Positions;
SelectField_SelectField.propTypes = {
  /**
   * An id to give the select field. This is required for accessibility.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * An optional name to give to the select field.
   */
  name: prop_types_default.a.string,

  /**
   * An optional id to provide to the select field's menu. If this is omitted,
   * it will default to `${id}-menu`.
   */
  menuId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the select field's list.
   *
   * @see {@link #menuId}
   * @see {@link Menus/Menu#menuId}
   */
  listId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply to the select field's container (the menu).
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the select field's container (the menu).
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the menu's list.
   */
  listStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the menu's list.
   */
  listClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the select field's toggle.
   */
  toggleStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the select field's toggle.
   */
  toggleClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the `AccessibleFakeInkedButton` that is the trigger
   * for the select field.
   */
  inputStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the `AccessibleFakeInkedButton` that is the trigger
   * for the select field.
   */
  inputClassName: prop_types_default.a.string,

  /**
   * Boolean if the select field should be have the menu's list visible by default.
   */
  defaultVisible: prop_types_default.a.bool.isRequired,

  /**
   * Boolean if the select field should have the menu's list visible. This will make
   * the select field controlled and require the `onVisibilityChange` prop to be defined,
   */
  visible: controlled(prop_types_default.a.bool, 'onVisibilityChange', 'defaultVisible'),

  /**
   * An optional function to call when the select field's menu has it's visibility changed. The callback
   * will include the next visible state and the event that triggered it.
   */
  onVisibilityChange: prop_types_default.a.func,

  /**
   * A list of `number`, `string`, or `object` that should be used to create `ListItem`
   * in the menu's list. When it is an `object`, it will use the `itemLabel` prop as the
   * `primaryText` and use the value of `itemValue`.
   *
   * @see {@link #itemLabel}
   * @see {@link #itemValue}
   */
  menuItems: prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string, prop_types_default.a.object, prop_types_default.a.element])).isRequired,

  /**
   * The amount of time that a list of letters should be used when finding a menu item
   * while typing. Since a user can select items by typing multiple letters in a row,
   * this will be used as the timeout for clearing those letters.
   *
   * For example:
   * - User types `g`
   *
   * Full match is now `'g'`.
   *
   * - User delays 200ms and types `u`
   *
   * Full match is now `'gu'`
   *
   * - User delays 1000ms and types `a`.
   *
   * Full match is now `'a'`
   */
  keyboardMatchingTimeout: prop_types_default.a.number.isRequired,

  /**
   * The key to use for extracting a menu item's label if the menu item is an object.
   *
   * Example:
   *
   * ```js
   * const item = { something: 'My Label', somethingElse: 'value' };
   * const itemLabel = 'something';
   * const itemValue = 'somethingElse';
   * ```
   */
  itemLabel: prop_types_default.a.string.isRequired,

  /**
   * The key to use for extracting a menu item's value if the menu item is an object.
   *
   * Example:
   *
   * ```js
   * const item = { something: 'My Label', somethingElse: 'value' };
   * const itemLabel = 'something';
   * const itemValue = 'somethingElse';
   * ```
   */
  itemValue: prop_types_default.a.string.isRequired,

  /**
   * The key to use for extracting a menu item's function
   * to get additional `ListItem` props if the menu item is an object.
   *
   * Example:
   *
   * ```js
   * const item = { something: 'My Label', addProps: ({active}) => active ? {secondaryText: 'some text'} : null };
   * const itemLabel = 'something';
   * const itemProps = 'addProps';
   * ```
   *
   * @see {@link #getItemProps}
   */
  itemProps: prop_types_default.a.string.isRequired,

  /**
   * An optional function to get additional `ListItem` props if the menu item is an object.
   *
   * An object with the following fields will be passed into the function:
   * - `index` - item's index
   * - `active` - whether item is active
   * - `disabled` - whether item is disabled
   * - `itemValue` - item's value
   * - `value` - current list value
   * - `props` - default `ListItem` props
   * - `item` - source item's data
   * - `field` - reference to the component instance
   */
  getItemProps: prop_types_default.a.func,

  /**
   * The default value to use for the select field. If this is set, it should either match
   * one of the `number` or `string` in your `menuItems` list or be the empty string. If
   * the `menuItems` is a list of `object`, this value should match one of the menu item's
   * `itemValue` or be the empty string.
   *
   * ```js
   * const menuItems = [{ label: 'Something': value: 0 }, { label: 'Something else', value: 1 }];
   *
   * // both valid
   * defaultValue={0}
   * defaultValue=""
   * ```
   */
  defaultValue: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,

  /**
   * The value to use for the select field. If this is defined, it becomes a controlled component
   * and requires the `onChange` prop to be defined. See the `defaultValue` for more behavior info.
   *
   * @see {@link #defaultValue}
   */
  value: controlled(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]), 'onChange', 'defaultValue'),

  /**
   * An optional function to call when the select field's value has been changed either when the user
   * has click/touched/keyboard selected a value in the list, or the user has selected a value by typing
   * in the select field while the menu's list is closed.
   *
   * The callback will include the next text field value, the selected item's index, the event that
   * triggered the change, and the id, name, and value of the select field.
   *
   * ```js
   * onChange(value, index, event, { id, name, value });
   * ```
   */
  onChange: prop_types_default.a.func,

  /**
   * An optional label to use with the select field. This will be a floating label as seen on the text field.
   */
  label: prop_types_default.a.node,

  /**
   * An optional placeholder to use in the select field. This will only appear when no value has been selected.
   */
  placeholder: prop_types_default.a.string,

  /**
   * Boolean if the select field should be disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * Boolean if the select field is required. This will update the label and placeholder to include a `*` suffix.
   */
  required: prop_types_default.a.bool,

  /**
   * Boolean if the select field is considered to be in an `error` state.
   *
   * @see {@link TextFields/TextField#error}
   */
  error: prop_types_default.a.bool,

  /**
   * An optional text to display when the text select field is in an error state.
   *
   * @see {@link TextFields/TextField#errorText}
   */
  errorText: prop_types_default.a.node,

  /**
   * An optional text to display below the select field to provide input help to the user.
   * This will only be displayed if the select field is not in an error state.
   *
   * @see {@link #helpOnFocus}
   * @see {@link TextFields/TextField#errorText}
   */
  helpText: prop_types_default.a.node,

  /**
   * Boolean if the `helpText` should only appear on focus.
   *
   * @see {@link #helpText}
   * @see {@link TextFields/TextField#helpOnFocus}
   */
  helpOnFocus: prop_types_default.a.bool,

  /**
   * An optional function to call when any element in the select field has been clicked.
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional function to call when the `keydown` event has been triggered anywhere in the
   * select field.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * An optional function to call when the select field's toggle has gained focus.
   */
  onFocus: prop_types_default.a.func,

  /**
   * An optional function to call when the select field's toggle has been blurred. This
   * will be triggered if the user hits the up or down arrow keys to traverse the list
   * of items.
   */
  onBlur: prop_types_default.a.func,

  /**
   * The icon to use to display the dropdown arrow.
   */
  dropdownIcon: prop_types_default.a.element,

  /**
   * Boolean if the select field is in a toolbar. This should automatically be injected by the `Toolbar`
   * component if being used as a `titleMenu` or one of the `actions`.
   *
   * @see {@link Toolbars/Toolbar#titleMenu}
   * @see {@link Toolbars/Toolbar#actions}
   */
  toolbar: prop_types_default.a.bool,

  /**
   * Boolean if the currently active item should be removed from the list of available `menuItems`.
   * If this is `undefined`, it will strip out the active one only when the
   * `position === SelectField.Positions.BELOW`.
   */
  stripActiveItem: prop_types_default.a.bool,

  /**
   * The transition name to use when a new value has been selected. By default, it will have the
   * new item _drop_ into the select field's input location.
   */
  transitionName: prop_types_default.a.string.isRequired,

  /**
   * The transition time to use when a new value has been selected. If this value is `0`, there
   * will be no transition.
   */
  transitionTime: prop_types_default.a.number.isRequired,

  /**
   * This is how the menu's `List` gets anchored to the select field.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  anchor: anchorShape,

  /**
   * This is the anchor to use when the `position` is set to `Autocomplete.Positions.BELOW`.
   *
   * @see {@link Helpers/Layover#belowAnchor}
   */
  belowAnchor: anchorShape,

  /**
   * This is the animation position for the list that appears.
   *
   * @see {@link Helpers/Layover#animationPosition}
   */
  position: positionShape,

  /**
   * This is how the menu's list will be "fixed" to the `toggle` component.
   *
   * @see {@link Helpers/Layover#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * Boolean if the menu's list should appear horizontally instead of vertically.
   */
  listInline: prop_types_default.a.bool,

  /**
   * The list's z-depth for applying box shadow. This should be a number from 0 to 5.
   */
  listZDepth: prop_types_default.a.number,

  /**
   * Boolean if the list should have its height restricted to the `$md-menu-mobile-max-height`/
   * `$md-menu-desktop-max-height` values.
   *
   * @see [md-menu-mobile-max-height](/components/menus?tab=1#variable-md-menu-mobile-max-height)
   * @see [md-menu-desktop-max-height](/components/menus?tab=1#variable-md-menu-desktop-max-height)
   */
  listHeightRestricted: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#xThreshold}
   */
  xThreshold: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#yThreshold}
   */
  yThreshold: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#closeOnOutsideClick}
   */
  closeOnOutsideClick: prop_types_default.a.bool,

  /**
   * An optional transition name to use for the list appearing/disappearing.
   *
   * @see {@link Menus/Menu#transitionName}
   */
  menuTransitionName: prop_types_default.a.string,

  /**
   * @see {@link Helpers/Layover#transitionEnterTimeout}
   */
  menuTransitionEnterTimeout: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#transitionLeaveTimeout}
   */
  menuTransitionLeaveTimeout: prop_types_default.a.number,

  /**
   * @see {@link Menus/Menu#block}
   */
  block: prop_types_default.a.bool,

  /**
   * @see {@link Menus/Menu#fullWidth}
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#centered}
   */
  centered: Menus_Menu.propTypes.centered,

  /**
   * @see {@link Helpers/Layover#sameWidth}
   */
  sameWidth: Menus_Menu.propTypes.sameWidth,

  /**
   * Since the `menuItems` get mapped into `ListItem`, this prop is used to remove
   * any unnecessary props from the `ListItem` itself. This is where you
   * would remove parts of your object such as `description` or `__metadata__`.
   */
  deleteKeys: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]))]),

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * Boolean if the menu logic should be simplified without any viewport logic and position
   * based on the relative position of the menu. This will most like require some additional
   * styles applied to the menu.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedMenu: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#minLeft}
   */
  minLeft: Menus_Menu.propTypes.minLeft,

  /**
   * @see {@link Helpers/Layover#minRight}
   */
  minRight: Menus_Menu.propTypes.minLeft,

  /**
   * @see {@link Helpers/Layover#minBottom}
   */
  minBottom: Menus_Menu.propTypes.minBottom,

  /**
   * @see {@link Helpers/Layover#fillViewportWidth}
   */
  fillViewportWidth: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#fillViewportHeight}
   */
  fillViewportHeight: prop_types_default.a.bool,

  /**
   * The direction that the underline should appear from.
   */
  lineDirection: prop_types_default.a.oneOf(['left', 'center', 'right']).isRequired,

  iconChildren: deprecated_default()(prop_types_default.a.node, 'Use `dropdownIcon` instead'),
  iconClassName: deprecated_default()(prop_types_default.a.string, 'Use `dropdownIcon` instead'),
  isOpen: deprecated_default()(prop_types_default.a.bool, 'Use `visible` instead'),
  defaultOpen: deprecated_default()(prop_types_default.a.bool, 'Use `defaultVisible` instead'),
  initiallyOpen: deprecated_default()(prop_types_default.a.bool, 'Use `defaultVisible` instead'),
  onMenuToggle: deprecated_default()(prop_types_default.a.func, 'Use `onVisibilityChange` instead'),
  stretchList: deprecated_default()(prop_types_default.a.bool, 'No longer valid after the changes to the `Menu` component. Possibly use `sameWidth` instead'),
  menuStyle: deprecated_default()(prop_types_default.a.object, 'Use `style` instead'),
  menuClassName: deprecated_default()(prop_types_default.a.string, 'Use `className` instead'),
  floatingLabel: deprecated_default()(prop_types_default.a.bool, 'A select field can only have floating labels now. Only provide the `label` prop'),
  noAutoAdjust: deprecated_default()(prop_types_default.a.bool, 'No longer valid to use since select fields are no longer text fields'),
  adjustMinWidth: deprecated_default()(prop_types_default.a.bool, 'No longer valid to use since select fields are no longer text fields')
};
SelectField_SelectField.defaultProps = {
  anchor: {
    x: SelectField_SelectField.HorizontalAnchors.INNER_LEFT,
    y: SelectField_SelectField.VerticalAnchors.OVERLAP
  },
  fixedTo: Menus_Menu.defaultProps.fixedTo,
  position: SelectField_SelectField.Positions.TOP_LEFT,
  itemLabel: 'label',
  itemValue: 'value',
  itemProps: 'getProps',
  dropdownIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'arrow_drop_down'
  ),
  lineDirection: 'left',
  menuItems: [],
  defaultValue: '',
  defaultVisible: false,
  keyboardMatchingTimeout: 1000,
  transitionName: 'md-drop',
  transitionTime: 300,
  repositionOnScroll: true,
  repositionOnResize: false
};

var SelectField_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._getActiveItemLabel = function (item, value, itemLabel, itemValue) {
    var v = _this2._getItemPart(item, itemLabel, itemValue);
    var label = _this2._getItemPart(item, itemLabel, itemValue, true);

    return v === value || v === parseFloat(value) ? label : '';
  };

  this._getActive = function (props, state) {
    var activeLabel = '';
    var activeIndex = -1;
    var value = getField(props, state, 'value');
    if (isValued(value)) {
      var menuItems = props.menuItems,
          itemLabel = props.itemLabel,
          itemValue = props.itemValue;


      menuItems.some(function (item, index) {
        activeLabel = _this2._getActiveItemLabel(item, value, itemLabel, itemValue);
        var found = isValued(activeLabel);
        if (found) {
          activeIndex = index;
        }

        return found;
      });
    }

    return { activeLabel: activeLabel, activeIndex: activeIndex };
  };

  this._attemptItemFocus = function (index) {
    if (index === -1) {
      return;
    }

    var item = _this2._items[index];
    if (item) {
      item.focus();
    }
  };

  this._setListItem = function (item) {
    if (!item) {
      return;
    }

    if (item.props.active) {
      _this2._activeItem = Object(react_dom["findDOMNode"])(item);
      item.focus();

      if (!_this2.state.listProps[ARIA_ACTIVE]) {
        var _extends2;

        _this2.setState({ listProps: SelectField_extends({}, _this2.state.listProps, (_extends2 = {}, _extends2[ARIA_ACTIVE] = _this2.props.id + '-options-active', _extends2)) });
      }
    }

    _this2._items.push(item);
  };

  this._scrollActiveIntoView = function (listRef) {
    if (listRef === null) {
      _this2._items = [];
      return;
    } else if (!_this2._activeItem) {
      return;
    }

    var list = Object(react_dom["findDOMNode"])(listRef);
    var offsetTop = _this2._activeItem.offsetTop;

    list.scrollTop = offsetTop > MOBILE_LIST_PADDING ? offsetTop : 0;
  };

  this._toggle = function (e) {
    var _props4 = _this2.props,
        isOpen = _props4.isOpen,
        onVisibilityChange = _props4.onVisibilityChange,
        onMenuToggle = _props4.onMenuToggle;

    var visible = !(typeof isOpen !== 'undefined' ? isOpen : getField(_this2.props, _this2.state, 'visible'));
    if (onMenuToggle || onVisibilityChange) {
      (onMenuToggle || onVisibilityChange)(visible, e);
    }

    var state = void 0;
    if (typeof isOpen === 'undefined' && typeof _this2.props.visible === 'undefined') {
      state = { visible: visible };
    }

    if (state) {
      _this2.setState(state);
    }
  };

  this._close = function (e) {
    if (_this2.props.onVisibilityChange) {
      _this2.props.onVisibilityChange(false, e);
    }

    if (e.type === 'keydown' && _this2._field) {
      _this2._field.focus();
    }

    var state = void 0;
    if (_this2.props.required && !getField(_this2.props, _this2.state, 'value')) {
      state = { error: true };
    }

    if (typeof _this2.props.visible === 'undefined') {
      state = state || {};
      state.visible = false;
    }

    if (state) {
      _this2.setState(state);
    }
  };

  this._handleClick = function (e) {
    if (_this2.props.onClick) {
      _this2.props.onClick(e);
    }

    var isOpen = _this2.props.isOpen;

    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(_this2.props, _this2.state, 'visible');
    if (visible && _this2._container) {
      var node = e.target;
      while (_this2._container.contains(node)) {
        if (node.dataset && typeof node.dataset.id !== 'undefined') {
          var _node$dataset = node.dataset,
              id = _node$dataset.id,
              value = _node$dataset.value;

          _this2._selectItem(parseInt(id, 10), value, e);
          return;
        }

        node = node.parentNode;
      }
    }
  };

  this._selectItem = function (dataIndex, dataValue, e) {
    var _props5 = _this2.props,
        required = _props5.required,
        menuItems = _props5.menuItems,
        itemLabel = _props5.itemLabel,
        itemValue = _props5.itemValue,
        onChange = _props5.onChange,
        id = _props5.id,
        name = _props5.name;

    var value = _this2._getItemPart(menuItems[dataIndex], itemLabel, itemValue);
    var prevValue = getField(_this2.props, _this2.state, 'value');
    if (prevValue !== value && onChange) {
      onChange(value, dataIndex, e, { id: id, name: name, value: value });
    }

    var state = SelectField_extends({}, _this2._getActive({ value: value, itemLabel: itemLabel, itemValue: itemValue, menuItems: menuItems }, {}), {
      error: !!required && !value && value !== 0
    });

    if (typeof _this2.props.value === 'undefined') {
      state.value = value;
    }

    _this2.setState(state);
  };

  this._handleFocus = function (e) {
    if (_this2.props.onFocus) {
      _this2.props.onFocus(e);
    }

    _this2.setState({ active: true });
  };

  this._handleBlur = function (e) {
    if (_this2.props.onBlur) {
      _this2.props.onBlur(e);
    }

    var error = _this2.state.error;
    var _props6 = _this2.props,
        isOpen = _props6.isOpen,
        required = _props6.required;

    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(_this2.props, _this2.state, 'visible');
    var value = getField(_this2.props, _this2.state, 'value');

    if (required && !visible) {
      error = !value;
    }

    _this2.setState({ active: false, error: error });
  };

  this._handleKeyDown = function (e) {
    var _props7 = _this2.props,
        isOpen = _props7.isOpen,
        onKeyDown = _props7.onKeyDown;

    if (onKeyDown) {
      onKeyDown(e);
    }

    var key = e.which || e.keyCode;
    var up = key === UP;
    var down = key === DOWN;
    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(_this2.props, _this2.state, 'visible');

    if (up || down) {
      e.preventDefault();

      if (!visible) {
        _this2._toggle(e);
        return;
      }

      _this2._advanceFocus(up);
    } else if (!visible && handleKeyboardAccessibility(e, _this2._toggle, true, true)) {
      return;
    } else if (visible && (key === ESC || key === TAB)) {
      if (_this2._field && key === ESC) {
        _this2._field.focus();
      }

      _this2._close(e);
      return;
    } else {
      _this2._selectItemByLetter(key, e);
    }
  };

  this._advanceFocus = function (decrement) {
    var _props8 = _this2.props,
        position = _props8.position,
        stripActiveItem = _props8.stripActiveItem;
    var activeIndex = _this2.state.activeIndex;


    var below = position === SelectField_SelectField.Positions.BELOW;
    var value = getField(_this2.props, _this2.state, 'value');
    var valued = isValued(value);
    var itemStripped = (typeof stripActiveItem !== 'undefined' ? stripActiveItem : below) && valued;

    // If the select field is positioned below and there is no value, need to increment the last index
    // by one since this select field removes the active item. Need to account for that here when there
    // is no value.
    var lastIndex = _this2._items.length - (itemStripped ? 0 : 1);
    if (decrement && activeIndex <= 0 || !decrement && activeIndex >= lastIndex) {
      return;
    }

    var nextIndex = Math.max(-1, Math.min(lastIndex, activeIndex + (decrement ? -1 : 1)));
    if (nextIndex === activeIndex) {
      return;
    }

    _this2._attemptItemFocus(nextIndex - (itemStripped ? 1 : 0));
    _this2.setState({ activeIndex: nextIndex });
  };

  this._selectItemByLetter = function (key, e) {
    var charCode = String.fromCharCode(key);
    var isLetter = charCode && charCode.match(/[A-Za-z0-9-_ ]/);
    var isKeypad = isBetween(key, KEYPAD_ZERO, KEYPAD_NINE);
    if (!isBetween(key, ZERO, NINE) && !isKeypad && !isLetter) {
      return;
    }

    var letter = isLetter ? charCode : String(key - (isKeypad ? KEYPAD_ZERO : ZERO));

    if (_this2._matchingTimeout) {
      clearTimeout(_this2._matchingTimeout);
    }

    _this2._matchingTimeout = setTimeout(function () {
      _this2._matchingTimeout = null;

      _this2.setState({ match: null, lastSearch: null });
    }, _this2.props.keyboardMatchingTimeout);

    _this2._selectFirstMatch(letter, e);
  };

  this._selectFirstMatch = function (letter, e) {
    var _props9 = _this2.props,
        menuItems = _props9.menuItems,
        itemLabel = _props9.itemLabel,
        itemValue = _props9.itemValue,
        isOpen = _props9.isOpen,
        onChange = _props9.onChange,
        id = _props9.id,
        name = _props9.name;
    var lastSearch = _this2.state.lastSearch;

    var match = -1;
    var search = ('' + (lastSearch || '') + letter).toUpperCase();
    menuItems.some(function (item, index) {
      if (item && (typeof item === 'undefined' ? 'undefined' : SelectField_typeof(item)) === 'object' && item.disabled) {
        return false;
      }

      var label = String(_this2._getItemPart(item, itemLabel, itemValue, true));
      if (label && label.toUpperCase().replace(/\s/g, '').indexOf(search) === 0) {
        match = index;
      }

      return match > -1;
    });

    var state = {
      match: match,
      lastSearch: search
    };

    if (match !== -1) {
      var activeItem = menuItems[match];
      state.activeLabel = _this2._getItemPart(activeItem, itemLabel, itemValue, true);
      state.activeIndex = match;

      var visible = typeof isOpen !== 'undefined' ? isOpen : getField(_this2.props, _this2.state, 'visible');
      if (visible) {
        if (state.match !== _this2.state.match) {
          _this2._attemptItemFocus(state.activeIndex);
        }
      } else {
        var value = _this2._getItemPart(activeItem, itemLabel, itemValue);
        var prevValue = getField(_this2.props, _this2.state, 'value');

        if (value !== prevValue && onChange) {
          onChange(value, match, e, { id: id, name: name, value: value });
        }

        if (typeof _this2.props.value === 'undefined') {
          state.value = value;
        }
      }
    }

    _this2.setState(state);
  };

  this._reduceItems = function (items, item, i) {
    if (item === null) {
      return items;
    } else if (react_default.a.isValidElement(item)) {
      items.push(item);
      return items;
    }

    var _props10 = _this2.props,
        getItemProps = _props10.getItemProps,
        id = _props10.id,
        itemLabel = _props10.itemLabel,
        itemProps = _props10.itemProps,
        itemValue = _props10.itemValue,
        position = _props10.position,
        stripActiveItem = _props10.stripActiveItem;

    var below = position === SelectField_SelectField.Positions.BELOW;
    var value = getField(_this2.props, _this2.state, 'value');

    var dataValue = _this2._getItemPart(item, itemLabel, itemValue);
    var primaryText = _this2._getItemPart(item, itemLabel, itemValue, true);

    var active = dataValue === value || dataValue === parseFloat(value);
    var stripped = (typeof stripActiveItem !== 'undefined' ? stripActiveItem : below) && active;
    if (!stripped) {
      var objectType = (typeof item === 'undefined' ? 'undefined' : SelectField_typeof(item)) === 'object';
      var props = objectType ? omit(item, _this2._deleteKeys) : {};
      var disabled = props.disabled || false;
      props.ref = disabled ? null : _this2._setListItem;
      props.id = active ? id + '-options-active' : null;
      props.active = active;
      props.tabIndex = -1;
      props.primaryText = primaryText;
      props.key = item.key || dataValue;
      props.role = 'option';
      props['data-id'] = disabled ? null : i;
      props['data-value'] = disabled ? null : dataValue;

      var getProps = objectType && item[itemProps] || getItemProps;
      if (typeof getProps === 'function') {
        Object.assign(props, getProps({
          index: i,
          active: active,
          disabled: disabled,
          itemValue: itemValue,
          value: value,
          props: props,
          item: item,
          field: _this2
        }));
      }

      items.push(react_default.a.createElement(Lists_ListItem, props));
    }

    return items;
  };
};

/* harmony default export */ var SelectFields_SelectField = (SelectField_SelectField);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/TablePagination.js
var TablePagination_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TablePagination_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TablePagination_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TablePagination_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TablePagination_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
















/**
 * The `TablePagination` component is used to generate the table footer that helps
 * pagination through a large dataset by limiting the number of rows per page.
 * The pagination will always be placed persistently at the bottom of the table
 * so that when a user scrolls to the right, they will always be able to use the
 * pagination.
 */

var TablePagination_TablePagination = function (_PureComponent) {
  TablePagination_inherits(TablePagination, _PureComponent);

  function TablePagination(props, context) {
    TablePagination_classCallCheck(this, TablePagination);

    var _this = TablePagination_possibleConstructorReturn(this, _PureComponent.call(this, props, context));

    TablePagination_initialiseProps.call(_this);

    var controlledPage = typeof props.page !== 'undefined';
    var controlledRowsPerPage = typeof props.rowsPerPage !== 'undefined';
    var rowsPerPage = controlledRowsPerPage ? props.rowsPerPage : props.defaultRowsPerPage;
    var page = controlledPage ? props.page : props.defaultPage;
    _this.state = {
      start: (page - 1) * rowsPerPage,
      controlsMarginLeft: 0
    };

    if (!controlledPage) {
      _this.state.page = page;
    }

    if (!controlledRowsPerPage) {
      _this.state.rowsPerPage = props.defaultRowsPerPage;
    }

    _this._table = null;
    _this._ticking = false;
    return _this;
  }

  TablePagination.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        rowsPerPage = _props.rowsPerPage,
        page = _props.page;

    if (page !== nextProps.page || rowsPerPage !== nextProps.rowsPerPage) {
      var rpp = getField(nextProps, this.state, 'rowsPerPage');
      var p = getField(nextProps, this.state, 'page');

      this.setState({ start: (p - 1) * rpp });
    }
  };

  TablePagination.prototype.render = function render() {
    var _state = this.state,
        controlsMarginLeft = _state.controlsMarginLeft,
        start = _state.start;

    var _props2 = this.props,
        className = _props2.className,
        selectFieldStyle = _props2.selectFieldStyle,
        selectFieldClassName = _props2.selectFieldClassName,
        selectFieldInputStyle = _props2.selectFieldInputStyle,
        selectFieldInputClassName = _props2.selectFieldInputClassName,
        rows = _props2.rows,
        rowsPerPageLabel = _props2.rowsPerPageLabel,
        rowsPerPageItems = _props2.rowsPerPageItems,
        incrementIcon = _props2.incrementIcon,
        decrementIcon = _props2.decrementIcon,
        simplifiedMenu = _props2.simplifiedMenu,
        incrementIconChildren = _props2.incrementIconChildren,
        incrementIconClassName = _props2.incrementIconClassName,
        decrementIconChildren = _props2.decrementIconChildren,
        decrementIconClassName = _props2.decrementIconClassName,
        propId = _props2.id,
        propIncrementId = _props2.incrementId,
        propDecrementId = _props2.decrementId,
        onPagination = _props2.onPagination,
        propRowsPerPage = _props2.rowsPerPage,
        propPage = _props2.page,
        defaultPage = _props2.defaultPage,
        defaultRowsPerPage = _props2.defaultRowsPerPage,
        props = TablePagination_objectWithoutProperties(_props2, ['className', 'selectFieldStyle', 'selectFieldClassName', 'selectFieldInputStyle', 'selectFieldInputClassName', 'rows', 'rowsPerPageLabel', 'rowsPerPageItems', 'incrementIcon', 'decrementIcon', 'simplifiedMenu', 'incrementIconChildren', 'incrementIconClassName', 'decrementIconChildren', 'decrementIconClassName', 'id', 'incrementId', 'decrementId', 'onPagination', 'rowsPerPage', 'page', 'defaultPage', 'defaultRowsPerPage']);

    var baseId = this.context.baseId;

    var rowsPerPage = getField(this.props, this.state, 'rowsPerPage');
    var _props3 = this.props,
        id = _props3.id,
        incrementId = _props3.incrementId,
        decrementId = _props3.decrementId;

    if (!id) {
      id = baseId + '-pagination';
    }

    if (!incrementId) {
      incrementId = id + '-increment-btn';
    }

    if (!decrementId) {
      decrementId = id + '-decrement-btn';
    }

    var pagination = start + 1 + '-' + Math.min(rows, start + rowsPerPage) + ' of ' + rows;
    return react_default.a.createElement(
      DataTables_TableFooter,
      TablePagination_extends({}, props, { className: classnames_default()('md-table-footer--pagination', className) }),
      react_default.a.createElement(Helpers_ResizeObserver, { watchWidth: true, component: 'tr', onResize: this._throttledPosition }),
      react_default.a.createElement(Helpers_ResizeObserver, { watchWidth: true, component: 'tr', target: this._table, onResize: this._throttledPosition }),
      react_default.a.createElement(
        'tr',
        null,
        react_default.a.createElement(
          DataTables_TableColumn,
          { colSpan: '100%' },
          react_default.a.createElement(
            'div',
            {
              ref: this._setControls,
              className: 'md-table-pagination md-table-pagination--controls md-text',
              style: { marginLeft: controlsMarginLeft }
            },
            react_default.a.createElement(
              'span',
              { className: 'md-table-pagination__label' },
              rowsPerPageLabel
            ),
            react_default.a.createElement(SelectFields_SelectField, {
              id: id,
              menuItems: rowsPerPageItems,
              position: SelectFields_SelectField.Positions.BELOW,
              style: selectFieldStyle,
              className: selectFieldClassName,
              inputStyle: selectFieldInputStyle,
              inputClassName: classnames_default()('md-select-field--pagination', selectFieldInputClassName),
              value: rowsPerPage,
              onChange: this._setRowsPerPage,
              simplifiedMenu: simplifiedMenu
            }),
            react_default.a.createElement(
              'span',
              { className: 'md-table-pagination--label' },
              pagination
            ),
            react_default.a.createElement(Buttons_Button, {
              id: decrementId,
              icon: true,
              onClick: this._decrement,
              disabled: start === 0,
              iconEl: getDeprecatedIcon(decrementIconClassName, decrementIconChildren, decrementIcon)
            }),
            react_default.a.createElement(Buttons_Button, {
              id: incrementId,
              icon: true,
              onClick: this._increment,
              disabled: start + rowsPerPage >= rows,
              iconEl: getDeprecatedIcon(incrementIconClassName, incrementIconChildren, incrementIcon)
            })
          ),
          react_default.a.createElement('div', { className: 'md-table-pagination' })
        )
      )
    );
  };

  return TablePagination;
}(react["PureComponent"]);

TablePagination_TablePagination.propTypes = {
  /**
   * An optional id to provide to the select field. If this is omitted, it will be
   * the `DataTable`'s `baseId` with '-pagination'.
   *
   * @see {@link DataTables/DataTable#baseId}
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the increment icon button. If this is omitted, it will be
   * the `id` with '-increment-btn'.
   *
   * @see {@link #id}
   */
  incrementId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the decrement icon button. If this is omitted, it will be
   * the `id` with '-decrement-btn'.
   *
   * @see {@link #id}
   */
  decrementId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply to the `tfoot` tag.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the `tfoot` tag.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the select field.
   *
   * @see {@link SelectFields/SelectField#style}
   */
  selectFieldStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the select field.
   *
   * @see {@link SelectFields/SelectField#className}
   */
  selectFieldClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the select field's input.
   *
   * @see {@link SelectFields/SelectField#inputStyle}
   */
  selectFieldInputStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the select field's input.
   *
   * @see {@link SelectFields/SelectField#inputClassName}
   */
  selectFieldInputClassName: prop_types_default.a.string,

  /**
   * Boolean if the select field should use the simplified menu logic.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedMenu: prop_types_default.a.bool,

  /**
   * A function to call when a user clicks the increment or decrement pagination
   * icon button. This function will be given the new start index and the number
   * or rows per page as well as the current page.
   *
   * ```js
   * onPagination(newStart, rowsPerPage, currentPage);
   * ```
   */
  onPagination: prop_types_default.a.func.isRequired,

  /**
   * The current value for the select field holding the number of rows per page.
   */
  rowsPerPage: prop_types_default.a.number,

  /**
   * The current page for the pagination. This will make the component controlled, so the only way to get pagination
   * is making sure you are updating this prop after the `onPagination` callback is called.
   *
   * Pages start from 1 instead of 0.
   */
  page: prop_types_default.a.number,

  /**
   * The default page to start from for the pagination. Pages start from 1 instead of 0.
   */
  defaultPage: prop_types_default.a.number.isRequired,

  /**
   * The default number of rows per page to display. This will be the value for the
   * `SelectField`.
   */
  defaultRowsPerPage: prop_types_default.a.number.isRequired,

  /**
   * The label to use for the rows per page `SelectField`.
   */
  rowsPerPageLabel: prop_types_default.a.node.isRequired,

  /**
   * A list of numbers for the amount of rows per page to display at a time.
   * This will be rendered into the `SelectField`.
   */
  rowsPerPageItems: prop_types_default.a.arrayOf(prop_types_default.a.number).isRequired,

  /**
   * The total number of rows that can be displayed. This is the unfiltered/non-subset
   * number of rows. This is used to help calculate the increment/decrement values to
   * display and determine if the user can increment/decrement again.
   */
  rows: prop_types_default.a.number.isRequired,

  /**
   * The icon to use for the increment icon button.
   */
  incrementIcon: prop_types_default.a.element,

  /**
   * The icon to use for the decrement icon button.
   */
  decrementIcon: prop_types_default.a.element,

  incrementIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `incrementIcon` prop instead'),
  incrementIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `incrementIcon` prop instead'),
  decrementIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `decrementIcon` prop instead'),
  decrementIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `decrementIcon` prop instead')
};
TablePagination_TablePagination.contextTypes = {
  baseId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  fixedFooter: prop_types_default.a.bool
};
TablePagination_TablePagination.defaultProps = {
  defaultPage: 1,
  defaultRowsPerPage: 10,
  rowsPerPageLabel: 'Rows per page:',
  rowsPerPageItems: [10, 20, 30, 40, 50, 100],
  incrementIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'keyboard_arrow_right'
  ),
  decrementIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'keyboard_arrow_left'
  ),
  simplifiedMenu: false
};

var TablePagination_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setControls = function (controls) {
    _this2._controls = controls;
    _this2._table = findTable(controls);

    if (_this2._table && _this2.context.fixedFooter) {
      _this2._table.addEventListener('scroll', _this2._throttledPosition);
    }
  };

  this._position = function () {
    if (_this2._table) {
      var fixedFooter = _this2.context.fixedFooter;
      var _table = _this2._table,
          offsetWidth = _table.offsetWidth,
          scrollLeft = _table.scrollLeft;


      var controlsMarginLeft = offsetWidth - _this2._controls.offsetWidth;
      if (fixedFooter) {
        controlsMarginLeft += scrollLeft;
      }

      _this2.setState({
        controlsMarginLeft: Math.max(24, controlsMarginLeft)
      });
    }
  };

  this._throttledPosition = function () {
    if (!_this2._ticking) {
      requestAnimationFrame(function () {
        _this2._ticking = false;
        _this2._position();
      });
    }

    _this2._ticking = true;
  };

  this._increment = function () {
    var _props4 = _this2.props,
        rows = _props4.rows,
        onPagination = _props4.onPagination;
    var start = _this2.state.start;

    var rowsPerPage = getField(_this2.props, _this2.state, 'rowsPerPage');
    var page = getField(_this2.props, _this2.state, 'page');

    // Only correct multiple of rows per page
    var max = rows - rows % rowsPerPage;

    var newStart = Math.min(start + rowsPerPage, max);
    var nextPage = page + 1;

    onPagination(newStart, rowsPerPage, nextPage);
    if (typeof _this2.props.page === 'undefined') {
      _this2.setState({ start: newStart, page: nextPage });
    }
  };

  this._decrement = function () {
    var start = _this2.state.start;

    var page = getField(_this2.props, _this2.state, 'page');
    var rowsPerPage = getField(_this2.props, _this2.state, 'rowsPerPage');
    var newStart = Math.max(0, start - rowsPerPage);
    var nextPage = page - 1;

    _this2.props.onPagination(newStart, rowsPerPage, nextPage);
    if (typeof _this2.props.page === 'undefined') {
      _this2.setState({ start: newStart, page: nextPage });
    }
  };

  this._setRowsPerPage = function (rowsPerPage) {
    var page = 1;
    var newStart = 0;
    _this2.props.onPagination(newStart, rowsPerPage, page);
    var nextState = void 0;
    if (typeof _this2.props.rowsPerPage === 'undefined') {
      nextState = { rowsPerPage: rowsPerPage };
    }

    if (typeof _this2.props.page === 'undefined') {
      nextState = nextState || {};
      nextState.start = newStart;
    }

    if (nextState) {
      _this2.setState(nextState);
    }
  };
};

/* harmony default export */ var DataTables_TablePagination = (TablePagination_TablePagination);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/EventUtils/isValidFocusKeypress.js
/** @module utils/EventUtils/isValidFocusKeypress */


/**
 * Checks if a keydown or keyup event's key was the TAB key or any additional valid
 * keys that were passed in.
 *
 * @param {Object} event - The event to check.
 * @param {Array.<number>=} additionalKeys - An optional array of additional key codes
 *    that are considered valid for a focus event.
 */
function isValidFocusKeypress(event, additionalKeys) {
  var key = event.which || event.keyCode;
  return key === TAB || additionalKeys && additionalKeys.indexOf(key) !== -1;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Helpers/FocusContainer.js
var FocusContainer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function FocusContainer_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function FocusContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FocusContainer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function FocusContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var BASE_FOCUSABLE_ELEMENTS = '[href],[tabindex]:not([tabindex="-1"]),input:not([disabled]):not([type="hidden"])';
var FOCUSABLE_QUERY = ['button', 'textarea', 'select'].reduce(function (queryString, element) {
  return queryString + ',' + element + ':not([disabled])';
}, BASE_FOCUSABLE_ELEMENTS);

/**
 * This component is used for keeping the focus within some container. When the container
 * is mounted and the `focusOnMount` prop is `true`, it will attempt to focus either:
 * - an element that matches `document.getElementById(this.props.initialFocus)`
 * - an element that matches `this._container.querySelector(this.props.initialFocus)`
 * - the first focusable element in it's children (if `this.props.initialFocus` is omitted)
 */

var FocusContainer_FocusContainer = function (_PureComponent) {
  FocusContainer_inherits(FocusContainer, _PureComponent);

  function FocusContainer() {
    var _temp, _this, _ret;

    FocusContainer_classCallCheck(this, FocusContainer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = FocusContainer_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._enableFocusTrap = function () {
      window.addEventListener('keydown', _this._handleKeyDown, true);
    }, _this._disableFocusTrap = function () {
      window.removeEventListener('keydown', _this._handleKeyDown, true);
    }, _this._attemptInitialFocus = function () {
      if (!_this._container) {
        return;
      }

      var initialFocus = _this.props.initialFocus;


      var toFocus = initialFocus ? document.getElementById(initialFocus) || _this._container.querySelector(initialFocus) : _this._focusables[0];

      var debugError = void 0;
      if (!toFocus && initialFocus) {
        debugError = ' The `initialFocus` did not match a document\'s `id` or was an invalid ';
        debugError += '`querySelector` for the container. `initialFocus`: `' + initialFocus + '`. ';
        debugError += 'If this was supposed to be an `id`, make sure to prefix with the `#` symbol.';
      }

      if (false) {}

      if (toFocus) {
        toFocus.focus();
      }
    }, _this._containFocus = function (containerRef) {
      if (containerRef === null) {
        _this._container = null;
        _this._disableFocusTrap();
        return;
      }

      var _this$props = _this.props,
          focusOnMount = _this$props.focusOnMount,
          containFocus = _this$props.containFocus;

      _this._container = Object(react_dom["findDOMNode"])(containerRef);
      _this._focusables = [].slice.call(_this._container.querySelectorAll(FOCUSABLE_QUERY));

      if (focusOnMount) {
        _this._attemptInitialFocus();
      }

      if (containFocus) {
        _this._enableFocusTrap();
      }
    }, _this._handleKeyDown = function (e) {
      _this._shifted = e.shiftKey;
      if (!isValidFocusKeypress(e, _this.props.additionalFocusKeys)) {
        return;
      } else if (_this._focusables.length === 1) {
        e.preventDefault();
        return;
      }

      var target = e.target,
          shiftKey = e.shiftKey;

      var _this$_focusables = _this._focusables,
          first = _this$_focusables[0],
          focusables = _this$_focusables.slice(1);

      var last = focusables[focusables.length - 1];

      if (shiftKey && target === first) {
        e.preventDefault();
        last.focus();
      } else if (!shiftKey && target === last) {
        e.preventDefault();
        first.focus();
      }
    }, _temp), FocusContainer_possibleConstructorReturn(_this, _ret);
  }

  FocusContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.containFocus === nextProps.containFocus) {
      return;
    }

    if (nextProps.containFocus) {
      this._enableFocusTrap();
      this._attemptInitialFocus();
    } else {
      this._disableFocusTrap();
    }
  };

  FocusContainer.prototype.componentDidUpdate = function componentDidUpdate() {
    if (this.props.containFocus && this._container) {
      this._focusables = [].slice.call(this._container.querySelectorAll(FOCUSABLE_QUERY));
    }
  };

  FocusContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.containFocus) {
      this._disableFocusTrap();
    }
  };

  /**
   * Manages the event listeners to contain the focus within some container.  When the container
   * ref is not null, the container has mounted and then attempts to focus an element inside
   * if the `focusOnMount` prop is `true`.
   */


  FocusContainer.prototype.render = function render() {
    var _props = this.props,
        Component = _props.component,
        initialFocus = _props.initialFocus,
        focusOnMount = _props.focusOnMount,
        containFocus = _props.containFocus,
        additionalFocusKeys = _props.additionalFocusKeys,
        props = FocusContainer_objectWithoutProperties(_props, ['component', 'initialFocus', 'focusOnMount', 'containFocus', 'additionalFocusKeys']);

    return react_default.a.createElement(Component, FocusContainer_extends({}, props, { ref: this._containFocus }));
  };

  return FocusContainer;
}(react["PureComponent"]);

FocusContainer_FocusContainer.propTypes = {
  /**
   * The component to render as. This can be a React DOM element or
   * a react Component.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The children to display.
   */
  children: prop_types_default.a.node,

  /**
   * An optional id string or a query selector string to use for the initial focus.
   * This will only be triggered if the `focusOnMount` prop is `true`. If this is
   * omitted and the `focusOnMount` prop is `true`, the first focusable element in the
   * container will be focused.
   *
   * Examples:
   *
   * ```js
   * initialFocus="#someAmazingId"
   * // or
   * initialFocus=".md-btn,.md-list-tile"
   * ```
   */
  initialFocus: prop_types_default.a.string,

  /**
   * Boolean if an element in the container should be focused when mounted.
   */
  focusOnMount: prop_types_default.a.bool,

  /**
   * An optional list of additional key codes to use for focus events.
   */
  additionalFocusKeys: prop_types_default.a.arrayOf(prop_types_default.a.number),

  /**
   * Boolean if the focus container should start or stop containing the focus within the container.
   * This is useful for changing the focus requirements after mount.
   */
  containFocus: prop_types_default.a.bool
};
FocusContainer_FocusContainer.defaultProps = {
  component: 'div',
  containFocus: true
};
/* harmony default export */ var Helpers_FocusContainer = (FocusContainer_FocusContainer);
// CONCATENATED MODULE: ../node_modules/react-md/es/Dialogs/DialogTitle.js
var DialogTitle_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function DialogTitle_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function DialogTitle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DialogTitle_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DialogTitle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var DialogTitle_DialogTitle = function (_PureComponent) {
  DialogTitle_inherits(DialogTitle, _PureComponent);

  function DialogTitle() {
    DialogTitle_classCallCheck(this, DialogTitle);

    return DialogTitle_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  DialogTitle.prototype.render = function render() {
    var _props = this.props,
        children = _props.children,
        className = _props.className,
        props = DialogTitle_objectWithoutProperties(_props, ['children', 'className']);

    if (!children) {
      return null;
    }

    return react_default.a.createElement(
      'h2',
      DialogTitle_extends({}, props, { className: classnames_default()('md-title md-title--dialog', className) }),
      children
    );
  };

  return DialogTitle;
}(react["PureComponent"]);

DialogTitle_DialogTitle.propTypes = {
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  className: prop_types_default.a.string,
  children: prop_types_default.a.node
};
/* harmony default export */ var Dialogs_DialogTitle = (DialogTitle_DialogTitle);
// CONCATENATED MODULE: ../node_modules/react-md/es/Dialogs/DialogFooter.js
var DialogFooter_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function DialogFooter_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function DialogFooter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DialogFooter_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DialogFooter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var FOOTER_PADDING = 8;

var DialogFooter_DialogFooter = function (_PureComponent) {
  DialogFooter_inherits(DialogFooter, _PureComponent);

  function DialogFooter() {
    var _temp, _this, _ret;

    DialogFooter_classCallCheck(this, DialogFooter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = DialogFooter_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { stacked: false }, _this._setContainer = function (container) {
      if (container !== null) {
        _this._container = container;
        var maxWidth = (_this._container.offsetWidth - FOOTER_PADDING * 3) / 2;

        var stacked = false;
        Array.prototype.slice.call(_this._container.querySelectorAll('.md-btn')).some(function (_ref) {
          var offsetWidth = _ref.offsetWidth;

          stacked = offsetWidth > maxWidth;
          return stacked;
        });

        _this.setState({ stacked: stacked });
      }
    }, _this._generateActions = function () {
      var actions = _this.props.actions;

      if (!actions) {
        return null;
      } else if (Array.isArray(actions)) {
        return actions.map(_this._toElement);
      }

      return _this._toElement(actions);
    }, _temp), DialogFooter_possibleConstructorReturn(_this, _ret);
  }

  DialogFooter.prototype._toElement = function _toElement(action, index) {
    if (Object(react["isValidElement"])(action)) {
      var button = react["Children"].only(action);

      return Object(react["cloneElement"])(action, {
        key: button.key || index,
        className: classnames_default()('md-btn--dialog', button.props.className)
      });
    }

    // Both label and children are valid for dialog actions

    var label = action.label,
        children = action.children,
        remaining = DialogFooter_objectWithoutProperties(action, ['label', 'children']);

    return react_default.a.createElement(
      Buttons_Button,
      DialogFooter_extends({
        key: index,
        flat: true
      }, remaining, {
        className: classnames_default()('md-btn--dialog', action.className)
      }),
      label || children
    );
  };

  DialogFooter.prototype.render = function render() {
    var _props = this.props,
        actions = _props.actions,
        className = _props.className,
        children = _props.children,
        propStacked = _props.stacked,
        props = DialogFooter_objectWithoutProperties(_props, ['actions', 'className', 'children', 'stacked']);

    if (!children && (!actions || Array.isArray(actions) && !actions.length)) {
      return null;
    }

    var stacked = this.props.stacked;

    var stackedDefined = typeof propStacked !== 'undefined';
    if (!stackedDefined) {
      stacked = this.state.stacked;
    }

    return react_default.a.createElement(
      'footer',
      DialogFooter_extends({}, props, {
        className: classnames_default()('md-dialog-footer', {
          'md-dialog-footer--inline': !stacked,
          'md-dialog-footer--stacked': stacked
        }, className),
        ref: !stackedDefined ? this._setContainer : null
      }),
      this._generateActions(),
      children
    );
  };

  return DialogFooter;
}(react["PureComponent"]);

DialogFooter_DialogFooter.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  children: prop_types_default.a.node,
  actions: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.object, prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.object]))]),
  stacked: prop_types_default.a.bool
};
/* harmony default export */ var Dialogs_DialogFooter = (DialogFooter_DialogFooter);
// CONCATENATED MODULE: ../node_modules/react-md/es/Dialogs/Dialog.js
var Dialog_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Dialog_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Dialog_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Dialog_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Dialog_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }














var DIFF_KEYS = ['style', 'height', 'width', 'contentStyle'];

/**
 * The `Dialog` is just a static component for creating dialogs. Dialogs
 * seemed like they could be used outside of the `DialogContainer` component,
 * so it was exposed as well. In *most* cases, you will still want to use
 * the `DialogContainer` component.
 */

var Dialog_Dialog = function (_PureComponent) {
  Dialog_inherits(Dialog, _PureComponent);

  function Dialog(props) {
    Dialog_classCallCheck(this, Dialog);

    var _this = Dialog_possibleConstructorReturn(this, _PureComponent.call(this));

    Dialog_initialiseProps.call(_this);

    var height = props.height,
        width = props.width;

    var styles = props.style;
    if (height || width) {
      styles = styles || {};
      styles = Dialog_extends({ height: height, width: width }, styles);
    }

    _this.state = {
      styles: styles,
      contentStyles: props.contentStyle,
      contentPadded: false
    };
    return _this;
  }

  Dialog.prototype.getChildContext = function getChildContext() {
    return { renderNode: this._renderNode };
  };

  Dialog.prototype.componentWillMount = function componentWillMount() {
    var _props = this.props,
        pageX = _props.pageX,
        pageY = _props.pageY;

    if (!pageX || !pageY) {
      return;
    }

    this.setState({ styles: this._getStyles(this.props) });
  };

  Dialog.prototype.componentDidMount = function componentDidMount() {
    if (this.props.onOpen) {
      this.props.onOpen();
    }
  };

  Dialog.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (DIFF_KEYS.some(function (key) {
      return nextProps[key] !== _this2.props[key];
    })) {
      this.setState({
        styles: this._getStyles(nextProps),
        contentStyles: Dialog_extends({}, this.state.contentStyles, nextProps.contentStyle)
      });
    }
  };

  Dialog.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onLeave) {
      this.props.onLeave();
    }
  };

  Dialog.prototype.render = function render() {
    var _state = this.state,
        contentPadded = _state.contentPadded,
        styles = _state.styles,
        contentStyles = _state.contentStyles;

    var _props2 = this.props,
        id = _props2.id,
        className = _props2.className,
        titleStyle = _props2.titleStyle,
        titleClassName = _props2.titleClassName,
        footerStyle = _props2.footerStyle,
        footerClassName = _props2.footerClassName,
        contentClassName = _props2.contentClassName,
        title = _props2.title,
        Content = _props2.contentComponent,
        contentProps = _props2.contentProps,
        actions = _props2.actions,
        children = _props2.children,
        fullPage = _props2.fullPage,
        centered = _props2.centered,
        autopadContent = _props2.autopadContent,
        paddedContent = _props2.paddedContent,
        autosizeContent = _props2.autosizeContent,
        stackedActions = _props2.stackedActions,
        style = _props2.style,
        contentStyle = _props2.contentStyle,
        pageX = _props2.pageX,
        pageY = _props2.pageY,
        containerX = _props2.containerX,
        containerY = _props2.containerY,
        onOpen = _props2.onOpen,
        onLeave = _props2.onLeave,
        height = _props2.height,
        width = _props2.width,
        props = Dialog_objectWithoutProperties(_props2, ['id', 'className', 'titleStyle', 'titleClassName', 'footerStyle', 'footerClassName', 'contentClassName', 'title', 'contentComponent', 'contentProps', 'actions', 'children', 'fullPage', 'centered', 'autopadContent', 'paddedContent', 'autosizeContent', 'stackedActions', 'style', 'contentStyle', 'pageX', 'pageY', 'containerX', 'containerY', 'onOpen', 'onLeave', 'height', 'width']);

    var labelledBy = this.props['aria-labelledby'];

    var titleId = id + '-title';
    if (!labelledBy && title) {
      labelledBy = titleId;
    }

    var padDefined = typeof paddedContent !== 'undefined';
    var dialogChildren = fullPage ? children : [react_default.a.createElement(
      Dialogs_DialogTitle,
      {
        key: 'title',
        id: titleId,
        style: titleStyle,
        className: titleClassName
      },
      title
    ), react_default.a.createElement(
      Content,
      Dialog_extends({
        ref: !padDefined && autopadContent ? this._setContent : null,
        key: 'content'
      }, contentProps, {
        style: contentStyles,
        className: classnames_default()('md-dialog-content', {
          'md-dialog-content--padded': padDefined ? paddedContent : contentPadded
        }, contentClassName)
      }),
      autosizeContent ? react_default.a.createElement(Helpers_ResizeObserver, { watchHeight: true, watchWidth: true, onResize: this._handleContentResize }) : null,
      children
    ), react_default.a.createElement(Dialogs_DialogFooter, {
      key: 'footer',
      style: footerStyle,
      className: footerClassName,
      actions: actions,
      stacked: stackedActions
    })];

    return react_default.a.createElement(
      Papers_Paper,
      Dialog_extends({}, props, {
        id: id,
        component: Helpers_FocusContainer,
        ref: this._setRenderNode,
        style: styles,
        className: classnames_default()('md-dialog', {
          'md-dialog--full-page': fullPage,
          'md-dialog--centered': centered
        }, className),
        role: 'dialog',
        'aria-labelledby': labelledBy
      }),
      dialogChildren
    );
  };

  return Dialog;
}(react["PureComponent"]);

Dialog_Dialog.propTypes = {
  /**
   * @see {@link Dialogs/DialogContainer#id}
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * @see {@link Dialogs/DialogContainer#aria-describedby}
   */
  'aria-describedby': oneRequiredForA11y(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]), 'title', 'aria-labelledby', 'aria-label'),

  /**
   * @see {@link Dialogs/DialogContainer#aria-labelledby}
   */
  'aria-labelledby': prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * @see {@link Dialogs/DialogContainer#aria-label}
   */
  'aria-label': prop_types_default.a.string,

  /**
   * An optional style to apply to the dialog.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the dialog.
   */
  className: prop_types_default.a.string,

  /**
   * An optional styke to apply to the title.
   */
  titleStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the title.
   */
  titleClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the footer. This is used when the `actions`
   * prop is defined.
   */
  footerStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the footer. This is used when the `actions`
   * prop is defined.
   */
  footerClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the dialog's content.
   */
  contentStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the dialog's content.
   */
  contentClassName: prop_types_default.a.string,

  /**
   * The component to render the content as. This is helpful if you would like to use
   * the CSSTransitionGroup. This really just saves a tiny bit of markup.
   *
   * ```js
   * <Dialog
   *   contentComponent={CSSTransitionGroup}
   *   contentProps={{
   *     transitionName: 'md-cross-fade',
   *     transitionLeave: false,
   *     transitionEnterTimeout: 150,
   *   }}
   * >
   *   {dynamicContent}
   * </Dialog>
   * ```
   */
  contentComponent: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * Any additional props to pass to the content component.
   */
  contentProps: prop_types_default.a.object,

  /**
   * An optional title to display in the dialog.
   */
  title: prop_types_default.a.node,

  /**
   * Any children to display in the content of the dialog.
   */
  children: prop_types_default.a.node,

  /**
   * A single action or a list of actions to display in the dialog. This can either be a list
   * of `FlatButton` props or `<Button flat {...props} />` elements.
   */
  actions: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.object, prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.object]))]),

  /**
   * @see {@link Helpers/FocusContainer#additionalFocusKeys}
   */
  additionalFocusKeys: Helpers_FocusContainer.propTypes.additionalFocusKeys,

  /**
   * @see {@link Helpers/FocusContainer#initialFocus}
   */
  initialFocus: Helpers_FocusContainer.propTypes.initialFocus,

  /**
   * @see {@link Helpers/FocusContainer#focusOnMount}
   */
  focusOnMount: Helpers_FocusContainer.propTypes.focusOnMount,

  /**
   * @see {@link Helpers/FocusContainer#containFocus}
   */
  containFocus: Helpers_FocusContainer.propTypes.containFocus,

  /**
   * An optional x coordinate on the page that caused a full page dialog
   * to be created. This is really just used for a `transformOrigin` style.
   */
  pageX: prop_types_default.a.number,

  /**
   * An optional y coordinate on the page that caused a full page dialog
   * to be created. This is really just used for a `transformOrigin` style.
   */
  pageY: prop_types_default.a.number,

  /**
   * An optional x scroll position of the container holding the dialog. This
   * is really just used for a `transformOrigin` style on full page dialogs.
   */
  containerX: prop_types_default.a.number,

  /**
   * An optional y scroll position of the container holding the dialog. This
   * is really just used for a `transformOrigin` style on full page dialogs.
   */
  containerY: prop_types_default.a.number,

  /**
   * Boolean if the dialog should be rendered as a full page dialog.
   */
  fullPage: prop_types_default.a.bool,

  /**
   * The zDepth to use for the dialog.
   */
  zDepth: prop_types_default.a.number.isRequired,

  /**
   * An optional function to call when the dialog has been opened. This is
   * really just used for the `DialogContainer`.
   */
  onOpen: prop_types_default.a.func,

  /**
   * An optional function to call when the dialog has been closed. This is
   * really just used for the `DialogContainer`.
   */
  onLeave: prop_types_default.a.func,

  /**
   * Boolean if the dialog should be centered in the page.
   */
  centered: prop_types_default.a.bool,

  /**
   * Boolean if the content should be padded. This will take precedence
   * over the `autopadContent` prop. So if this is defined, that value
   * will be used instead of any thing that was was calculated in this
   * component.
   *
   * @see {@link #autopadContent}
   */
  paddedContent: prop_types_default.a.bool,

  /**
   * Boolean if the dialog should automatically try to determine if the content
   * should be padded. It will be padded if the dialog does not contain a `List`.
   */
  autopadContent: prop_types_default.a.bool,

  /**
   * Boolean if the dialog content's size should automatically be resized to overflow
   * correctly when there is a lot of content. This will calculate and apply some `maxHeight`
   * to the `contentStyle`.
   */
  autosizeContent: prop_types_default.a.bool,

  /**
   * An optional height to apply to the dialog. This is used if it is easier to just apply height/width
   * with for specific dialogs instead of in CSS.
   *
   * **This prop should not be used if the `fullPage` prop is enabled.**
   *
   * @see {@link #fullPage}
   * @see {@link #width}
   */
  height: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional width to apply to the dialog. This is used if it is easier to just apply height/width
   * with for specific dialogs instead of in CSS.
   *
   * **This prop should not be used if the `fullPage` prop is enabled.**
   *
   * @see {@link #fullPage}
   * @see {@link #height}
   */
  width: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * Boolean if the actions should be stacked on top of each other. If this value is `undefined`, it will
   * automatically attempt to guess if the items should be stacked.
   */
  stackedActions: prop_types_default.a.bool
};
Dialog_Dialog.defaultProps = {
  autopadContent: true,
  autosizeContent: true,
  contentComponent: 'section',
  zDepth: 5
};
Dialog_Dialog.childContextTypes = {
  renderNode: prop_types_default.a.object
};

var Dialog_initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this._getStyles = function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this3.props,
        pageX = _ref.pageX,
        containerX = _ref.containerX,
        pageY = _ref.pageY,
        containerY = _ref.containerY,
        height = _ref.height,
        width = _ref.width,
        style = _ref.style;

    return Dialog_extends({
      height: typeof height !== 'undefined' ? height : null,
      width: typeof width !== 'undefined' ? width : null,
      transformOrigin: pageX || pageY ? pageX - containerX + 'px ' + (pageY - containerY) + 'px' : null
    }, style);
  };

  this._setRenderNode = function (dialog) {
    _this3._renderNode = Object(react_dom["findDOMNode"])(dialog);
  };

  this._setContent = function (content) {
    if (content !== null) {
      _this3._content = Object(react_dom["findDOMNode"])(content);
      var contentPadded = _this3._content.querySelectorAll('.md-list').length === 0;

      _this3.setState({ contentPadded: contentPadded });
    }
  };

  this._handleContentResize = function (_ref2) {
    var scrollHeight = _ref2.scrollHeight,
        content = _ref2.el;

    var maxHeight = content.style.maxHeight;
    var dialog = content.parentNode;
    content.style.maxHeight = 'none';
    var title = _this3.props.title ? dialog.querySelector('.md-title--dialog') : null;
    var footer = _this3.props.actions ? dialog.querySelector('.md-dialog-footer') : null;

    var totalHeight = dialog.offsetHeight - (title ? title.offsetHeight : 0) - (footer ? footer.offsetHeight : 0);
    content.style.maxHeight = maxHeight;
    var equalHeight = totalHeight === scrollHeight;
    if (equalHeight) {
      var currentHeight = _this3.state.contentStyles && _this3.state.contentStyles.maxHeight || null;
      if (currentHeight && currentHeight !== scrollHeight) {
        _this3.setState({ contentStyles: _this3.props.contentStyle });
      }
    } else {
      _this3.setState({ contentStyles: Dialog_extends({ maxHeight: totalHeight }, _this3.props.contentStyle) });
    }
  };
};

/* harmony default export */ var Dialogs_Dialog = (Dialog_Dialog);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/EditDialog.js
var EditDialog_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function EditDialog_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function EditDialog_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EditDialog_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function EditDialog_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }










var EditDialog_EditDialog = function (_PureComponent) {
  EditDialog_inherits(EditDialog, _PureComponent);

  function EditDialog() {
    EditDialog_classCallCheck(this, EditDialog);

    return EditDialog_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  EditDialog.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        dialogStyle = _props.dialogStyle,
        dialogClassName = _props.dialogClassName,
        dialogContentStyle = _props.dialogContentStyle,
        dialogContentClassName = _props.dialogContentClassName,
        textFieldId = _props.textFieldId,
        visible = _props.visible,
        header = _props.header,
        onOpen = _props.onOpen,
        children = _props.children,
        label = _props.label,
        title = _props.title,
        large = _props.large,
        actions = _props.actions,
        placeholder = _props.placeholder,
        dialogZDepth = _props.dialogZDepth,
        props = EditDialog_objectWithoutProperties(_props, ['id', 'dialogStyle', 'dialogClassName', 'dialogContentStyle', 'dialogContentClassName', 'textFieldId', 'visible', 'header', 'onOpen', 'children', 'label', 'title', 'large', 'actions', 'placeholder', 'dialogZDepth']);

    var field = react_default.a.createElement(
      Helpers_AccessibleFakeButton,
      {
        className: classnames_default()('md-edit-dialog__label', {
          'md-edit-dialog__header': header
        }, themeColors({ hint: placeholder || header })),
        noFocusOutline: visible,
        onClick: onOpen,
        onFocus: onOpen
      },
      label
    );

    return react_default.a.createElement(
      Helpers_Layover,
      EditDialog_extends({}, props, {
        id: id + '-layover',
        toggle: field,
        visible: visible,
        block: true,
        belowAnchor: null
      }),
      react_default.a.createElement(
        Dialogs_Dialog,
        {
          id: id,
          'aria-labelledby': !large ? textFieldId : undefined,
          style: dialogStyle,
          className: classnames_default()('md-edit-dialog', themeColors({ background: true, themeText: false }), dialogClassName),
          contentStyle: dialogContentStyle,
          contentClassName: classnames_default()('md-edit-dialog__content', dialogContentClassName),
          title: large ? title : null,
          focusOnMount: true,
          containFocus: !!large,
          paddedContent: false,
          actions: large ? actions : null,
          zDepth: dialogZDepth
        },
        children
      )
    );
  };

  return EditDialog;
}(react["PureComponent"]);

EditDialog_EditDialog.propTypes = {
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  textFieldId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  dialogStyle: prop_types_default.a.object,
  dialogClassName: prop_types_default.a.string,
  dialogContentStyle: prop_types_default.a.object,
  dialogContentClassName: prop_types_default.a.string,
  children: prop_types_default.a.node,
  onOpen: prop_types_default.a.func.isRequired,
  onClose: prop_types_default.a.func.isRequired,
  visible: prop_types_default.a.bool.isRequired,
  label: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  placeholder: prop_types_default.a.bool,
  title: prop_types_default.a.node,
  large: prop_types_default.a.bool,
  actions: Dialogs_Dialog.propTypes.actions,
  dialogZDepth: prop_types_default.a.number,
  header: prop_types_default.a.bool
};
/* harmony default export */ var DataTables_EditDialog = (EditDialog_EditDialog);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/findFixedTo.js
function findFixedTo(table) {
  if (table && table.firstChild.firstChild.classList.contains('md-data-table__scroll-wrapper')) {
    return {
      x: table,
      y: table.firstChild.firstChild
    };
  }

  return table;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/EditDialogColumn.js
var EditDialogColumn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function EditDialogColumn_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function EditDialogColumn_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EditDialogColumn_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function EditDialogColumn_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
























/**
 * The `EditDialogColumn` is used when there should be used when a table column's value
 * can be changed. It can either be displayed as a dialog or inline.
 *
 * All props that are not documented but provided will be passed on to the `TextField`
 * component.
 */

var EditDialogColumn_EditDialogColumn = function (_PureComponent) {
  EditDialogColumn_inherits(EditDialogColumn, _PureComponent);

  function EditDialogColumn(props) {
    EditDialogColumn_classCallCheck(this, EditDialogColumn);

    var _this = EditDialogColumn_possibleConstructorReturn(this, _PureComponent.call(this, props));

    EditDialogColumn_initialiseProps.call(_this);

    _this.state = {
      visible: props.defaultVisible,
      value: props.defaultValue,
      cancelValue: props.defaultValue,
      actions: _this._makeActions(props),
      cellIndex: undefined
    };
    return _this;
  }

  EditDialogColumn.prototype.componentDidMount = function componentDidMount() {
    this._column = Object(react_dom["findDOMNode"])(this);
    this._table = findTable(this._column);
    this._fixedTo = findFixedTo(this._table);

    // If a developer creates their own component to wrap the EditDialogColumn, the cellIndex prop
    // might not be defined if they don't pass ...props
    var cellIndex = this.props.cellIndex;

    if (!cellIndex && cellIndex !== 0) {
      var columns = [].slice.call(this._column.parentNode.querySelectorAll('th,td'));
      this.setState({ cellIndex: columns.indexOf(this._column) }); // eslint-disable-line react/no-did-mount-set-state
    }
  };

  EditDialogColumn.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        okLabel = _props.okLabel,
        okPrimary = _props.okPrimary,
        okSecondary = _props.okSecondary,
        okProps = _props.okProps,
        cancelLabel = _props.cancelLabel,
        cancelPrimary = _props.cancelPrimary,
        cancelSecondary = _props.cancelSecondary,
        cancelProps = _props.cancelProps;


    if (okLabel !== nextProps.okLabel || okPrimary !== nextProps.okPrimary || okSecondary !== nextProps.okSecondary || cancelLabel !== nextProps.cancelLabel || cancelPrimary !== nextProps.cancelPrimary || cancelSecondary !== nextProps.cancelSecondary || okProps !== nextProps.okProps || cancelProps !== nextProps.cancelProps) {
      this.setState({ actions: this._makeActions(nextProps) });
    }
  };

  EditDialogColumn.prototype.render = function render() {
    var rowId = this.context.rowId;

    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        layoverStyle = _props2.layoverStyle,
        layoverClassName = _props2.layoverClassName,
        dialogStyle = _props2.dialogStyle,
        dialogClassName = _props2.dialogClassName,
        dialogContentStyle = _props2.dialogContentStyle,
        dialogContentClassName = _props2.dialogContentClassName,
        dialogZDepth = _props2.dialogZDepth,
        textFieldStyle = _props2.textFieldStyle,
        textFieldClassName = _props2.textFieldClassName,
        inputClassName = _props2.inputClassName,
        large = _props2.large,
        title = _props2.title,
        inline = _props2.inline,
        inlineIcon = _props2.inlineIcon,
        maxLength = _props2.maxLength,
        label = _props2.label,
        placeholder = _props2.placeholder,
        header = _props2.header,
        anchor = _props2.anchor,
        belowAnchor = _props2.belowAnchor,
        fixedTo = _props2.fixedTo,
        animationPosition = _props2.animationPosition,
        xThreshold = _props2.xThreshold,
        yThreshold = _props2.yThreshold,
        centered = _props2.centered,
        sameWidth = _props2.sameWidth,
        repositionOnScroll = _props2.repositionOnScroll,
        repositionOnResize = _props2.repositionOnResize,
        transitionName = _props2.transitionName,
        transitionEnterTimeout = _props2.transitionEnterTimeout,
        transitionLeaveTimeout = _props2.transitionLeaveTimeout,
        tooltipLabel = _props2.tooltipLabel,
        tooltipDelay = _props2.tooltipDelay,
        tooltipPosition = _props2.tooltipPosition,
        onClick = _props2.onClick,
        onMouseDown = _props2.onMouseDown,
        onMouseUp = _props2.onMouseUp,
        onTouchStart = _props2.onTouchStart,
        onTouchEnd = _props2.onTouchEnd,
        onMouseEnter = _props2.onMouseEnter,
        onMouseOver = _props2.onMouseOver,
        onMouseLeave = _props2.onMouseLeave,
        onTouchMove = _props2.onTouchMove,
        simplifiedDialog = _props2.simplifiedDialog,
        minLeft = _props2.minLeft,
        minRight = _props2.minRight,
        minBottom = _props2.minBottom,
        noIcon = _props2.noIcon,
        inlineIconChildren = _props2.inlineIconChildren,
        inlineIconClassName = _props2.inlineIconClassName,
        propId = _props2.id,
        propDialogId = _props2.dialogId,
        propCellIndex = _props2.cellIndex,
        onOkClick = _props2.onOkClick,
        okLabel = _props2.okLabel,
        okPrimary = _props2.okPrimary,
        okSecondary = _props2.okSecondary,
        okProps = _props2.okProps,
        onCancelClick = _props2.onCancelClick,
        cancelLabel = _props2.cancelLabel,
        cancelPrimary = _props2.cancelPrimary,
        cancelSecondary = _props2.cancelSecondary,
        cancelProps = _props2.cancelProps,
        okOnOutsideClick = _props2.okOnOutsideClick,
        defaultValue = _props2.defaultValue,
        adjusted = _props2.adjusted,
        scrollIntoView = _props2.scrollIntoView,
        scrollIntoViewPadding = _props2.scrollIntoViewPadding,
        defaultVisible = _props2.defaultVisible,
        visibleOnFocus = _props2.visibleOnFocus,
        scrollThreshold = _props2.scrollThreshold,
        enforceMinWidth = _props2.enforceMinWidth,
        transitionDuration = _props2.transitionDuration,
        props = EditDialogColumn_objectWithoutProperties(_props2, ['style', 'className', 'layoverStyle', 'layoverClassName', 'dialogStyle', 'dialogClassName', 'dialogContentStyle', 'dialogContentClassName', 'dialogZDepth', 'textFieldStyle', 'textFieldClassName', 'inputClassName', 'large', 'title', 'inline', 'inlineIcon', 'maxLength', 'label', 'placeholder', 'header', 'anchor', 'belowAnchor', 'fixedTo', 'animationPosition', 'xThreshold', 'yThreshold', 'centered', 'sameWidth', 'repositionOnScroll', 'repositionOnResize', 'transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'tooltipLabel', 'tooltipDelay', 'tooltipPosition', 'onClick', 'onMouseDown', 'onMouseUp', 'onTouchStart', 'onTouchEnd', 'onMouseEnter', 'onMouseOver', 'onMouseLeave', 'onTouchMove', 'simplifiedDialog', 'minLeft', 'minRight', 'minBottom', 'noIcon', 'inlineIconChildren', 'inlineIconClassName', 'id', 'dialogId', 'cellIndex', 'onOkClick', 'okLabel', 'okPrimary', 'okSecondary', 'okProps', 'onCancelClick', 'cancelLabel', 'cancelPrimary', 'cancelSecondary', 'cancelProps', 'okOnOutsideClick', 'defaultValue', 'adjusted', 'scrollIntoView', 'scrollIntoViewPadding', 'defaultVisible', 'visibleOnFocus', 'scrollThreshold', 'enforceMinWidth', 'transitionDuration']);

    var _state = this.state,
        visible = _state.visible,
        actions = _state.actions;

    var value = getField(this.props, this.state, 'value');
    var cellIndex = getField(this.props, this.state, 'cellIndex');

    var _props3 = this.props,
        id = _props3.id,
        dialogId = _props3.dialogId;

    if (!dialogId) {
      dialogId = (id || rowId + '-' + cellIndex) + '-edit-dialog';
    }

    if (!id) {
      id = dialogId + '-field';
    }

    var inlineEditIcon = void 0;
    if (inline && !noIcon) {
      var icon = getDeprecatedIcon(inlineIconClassName, inlineIconChildren, inlineIcon);
      if (icon) {
        inlineEditIcon = react_default.a.cloneElement(icon, { key: 'edit-icon' });
      }
    }

    var numeric = props.type === 'number';
    var field = react_default.a.createElement(TextFields_TextField, EditDialogColumn_extends({}, props, {
      ref: this._setField,
      style: textFieldStyle,
      className: classnames_default()({ 'md-edit-dialog__blocked-field': inline }, textFieldClassName),
      inputClassName: classnames_default()({
        'md-edit-dialog__header': header && inline,
        'md-text-right': numeric
      }, themeColors({ hint: header && inline }), inputClassName),
      id: id,
      label: label,
      placeholder: placeholder,
      value: value,
      onFocus: this._handleFocus,
      onChange: this._handleChange,
      onKeyDown: this._handleKeyDown,
      block: inline,
      maxLength: visible ? maxLength : null,
      rightIcon: inlineEditIcon
    }));

    var children = void 0;
    if (inline) {
      children = field;
    } else {
      var dialogLabel = value || value === 0 ? value : placeholder || label;
      children = react_default.a.createElement(
        DataTables_EditDialog,
        {
          style: layoverStyle,
          className: layoverClassName,
          dialogStyle: dialogStyle,
          dialogClassName: dialogClassName,
          dialogContentStyle: dialogContentStyle,
          dialogContentClassName: dialogContentClassName,
          id: dialogId,
          textFieldId: id,
          visible: visible,
          onOpen: this._handleOpen,
          onClose: this._handleClose,
          label: dialogLabel,
          actions: actions,
          large: large,
          title: title,
          header: header,
          placeholder: dialogLabel === placeholder || dialogLabel === label,
          simplified: simplifiedDialog,
          anchor: anchor,
          belowAnchor: belowAnchor,
          animationPosition: animationPosition,
          xThreshold: xThreshold,
          yThreshold: yThreshold,
          centered: centered,
          sameWidth: sameWidth,
          minLeft: minLeft,
          minRight: minRight,
          minBottom: minBottom,
          fixedTo: typeof fixedTo !== 'undefined' ? fixedTo : this._fixedTo,
          dialogZDepth: dialogZDepth,
          repositionOnScroll: repositionOnScroll,
          repositionOnResize: repositionOnResize,
          transitionName: transitionName,
          transitionEnterTimeout: transitionEnterTimeout,
          transitionLeaveTimeout: transitionLeaveTimeout
        },
        field
      );
    }

    return react_default.a.createElement(
      DataTables_TableColumn,
      {
        style: style,
        numeric: numeric,
        className: classnames_default()('md-edit-dialog-column', className),
        header: header,
        adjusted: false,
        tooltipLabel: tooltipLabel,
        tooltipDelay: tooltipDelay,
        tooltipPosition: tooltipPosition,
        onClick: onClick,
        onMouseDown: onMouseDown,
        onMouseUp: onMouseUp,
        onTouchStart: onTouchStart,
        onTouchMove: onTouchMove,
        onMouseEnter: onMouseEnter,
        onMouseOver: onMouseOver,
        onMouseLeave: onMouseLeave,
        onTouchEnd: onTouchEnd
      },
      children
    );
  };

  return EditDialogColumn;
}(react["PureComponent"]);

EditDialogColumn_EditDialogColumn.VerticalAnchors = Helpers_Layover.VerticalAnchors;
EditDialogColumn_EditDialogColumn.HorizontalAnchors = Helpers_Layover.HorizontalAnchors;
EditDialogColumn_EditDialogColumn.Positions = Helpers_Layover.Positions;
EditDialogColumn_EditDialogColumn.propTypes = {
  /**
   * An optional id to use for the text field in the column. If this is omitted,
   * the id will be `${dialogId}-field`.
   *
   * @see {@link #dialogId}
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to use for the dialog that appears in the column. If this is omitted,
   * the id will be `${rowId}-${cellIndex}-edit-dialog-field`.
   */
  dialogId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * The optional style to apply to the edit dialog's column.
   */
  style: prop_types_default.a.object,

  /**
   * The optional className to apply to the edit dialog's column.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the dialog's surrounding `Layover` component.
   */
  layoverStyle: prop_types_default.a.object,

  /**
   * An optional className to the dialog's surrounding `Layover` component.
   */
  layoverClassName: prop_types_default.a.string,

  /**
   * The optional style to apply to the edit dialog.
   */
  dialogStyle: prop_types_default.a.object,

  /**
   * The optional className to apply to the edit dialog.
   */
  dialogClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the dialog's content area. This is the area
   * that holds the text field.
   */
  dialogContentStyle: prop_types_default.a.object,

  /**
   * An optional class name to apply to the dialog's content area. This is the area
   * that holds the text field.
   */
  dialogContentClassName: prop_types_default.a.string,

  /**
   * The zDepth to apply to the dialog when not inline.
   *
   * @see {@link Papers/Paper#zDepth}
   */
  dialogZDepth: prop_types_default.a.number.isRequired,

  /**
   * An optional style to apply to the text field.
   */
  textFieldStyle: prop_types_default.a.object,

  /**
   * An optional class name to apply to the text field.
   */
  textFieldClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the text field's input.
   */
  inputStyle: prop_types_default.a.object,

  /**
   * An optional class name to apply to the text field's input.
   */
  inputClassName: prop_types_default.a.string,

  /**
   * Boolean if the edit dialog is currently disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * Boolean if the text field should be editable inline instead of in a dialog.
   *
   * @see {@link #inlineIcon}
   */
  inline: prop_types_default.a.bool,

  /**
   * An optional icon to set for the inline edit dialog column. Setting this prop to null
   * will not render an icon.
   */
  inlineIcon: prop_types_default.a.element,

  /**
   * The default value to use for the text field.
   */
  defaultValue: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,

  /**
   * A value to use for the edit dialog text field. This will make the component controlled
   * so you will need to provide an `onChange` function.
   */
  value: controlled(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]), 'onChange', 'defaultValue'),

  /**
   * An optional function to call when the text field's value has changed. This is required
   * if the `value` prop has been defined.
   *
   * @see {@link TextFields/TextField#onChange}
   */
  onChange: prop_types_default.a.func,

  /**
   * An optional function to call when the text field gains focus.
   */
  onFocus: prop_types_default.a.func,

  /**
   * An optional function to call when the keydown event is triggered on the text field.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * An optional label for the text field. When displaying an `inline` edit dialog column,
   * the `placeholder` prop should be used instead. This is because the text field changes
   * to the `block` type when `inline`.
   *
   * @see {@link #inline}
   * @see {@link #placeholder}
   * @see {@link TextFields/TextField#block}
   */
  label: prop_types_default.a.node,

  /**
   * An optional placeholder for the text field.
   */
  placeholder: prop_types_default.a.string,

  /**
   * Boolean if the edit dialog should become a large dialog. When the dialog is large,
   * the `title` prop is required.
   *
   * A large dialog has a Title followed by the text field, and then a cancel and ok action
   * buttons below.
   */
  large: prop_types_default.a.bool,

  /**
   * The title to use for the large edit dialog. This prop is required if the `large` prop
   * is enabled.
   */
  title: prop_types_default.a.node,

  /**
   * An optional `maxLength` to apply to the text field.
   *
   * @see {@link TextFields/TextField#maxLength}
   */
  maxLength: prop_types_default.a.number,

  /**
   * An optional function to call when the "Ok" button has been clicked, the user presses enter
   * on * the text field or when the `okOnOutsideClick` prop has been enabled and the user clicks
   * somewhere on the page.
   *
   * The callback will include the current value and the click or keypress event.
   * ```js
   * onOkClick(value, event)
   * ```
   *
   * @see {@link #large}
   */
  onOkClick: prop_types_default.a.func,

  /**
   * The label to use for the "Ok" button in large dialogs.
   *
   * @see {@link #large}
   */
  okLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the "Ok" button in large dialogs should be styled with the primary color.
   * To get a `default` styled button, set both `okPrimary` and `okSecondary` (or omit `okSecondary`)
   * to `false`.
   *
   * @see {@link #large}
   * @see {@link #okSecondary}
   */
  okPrimary: prop_types_default.a.bool,

  /**
   * Boolean if the "Ok" button in large dialogs should be styled with the secondary color.
   *
   * @see {@link #large}
   * @see {@link #okPrimary}
   */
  okSecondary: prop_types_default.a.bool,

  /**
   * Any additional props to apply to the "Ok" button. This will override any of the other
   * button props.
   *
   * @see {@link #okLabel}
   * @see {@link #okPrimary}
   * @see {@link #okSecondary}
   */
  okProps: prop_types_default.a.object,

  /**
   * An optional function to call when the "Cancel" button has been clicked in large edit dialogs.
   * The callback will include the text field's value before any edits occurred and the click event.
   *
   * ```js
   * onCancelClick(previousValue, event)
   * ```
   *
   * @see {@link #large}
   */
  onCancelClick: prop_types_default.a.func,

  /**
   * The label to give to the "Cancel" button in large edit dialogs.
   *
   * @see {@link #large}
   */
  cancelLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the "Cancel" button in large dialogs should be styled with the primary color.
   * To get a `default` styled button, set both `cancelPrimary` and `cancelSecondary` (or
   * omit `cancelSecondary`) to `false`.
   *
   * @see {@link #large}
   * @see {@link #cancelSecondary}
   */
  cancelPrimary: prop_types_default.a.bool,

  /**
   * Boolean if the "Cancel" button in large dialogs should be styled with the secondary color.
   *
   * @see {@link #large}
   * @see {@link #cancelPrimary}
   */
  cancelSecondary: prop_types_default.a.bool,

  /**
   * Any additional props to apply to the "Cancel" button. This will override any of the other
   * button props.
   *
   * @see {@link #cancelLabel}
   * @see {@link #cancelPrimary}
   * @see {@link #cancelSecondary}
   */
  cancelProps: prop_types_default.a.object,

  /**
   * Boolean if the action for clicking somewhere on on the page while the dialog is open
   * saves the changes or cancels to the previous value before opening the dialog.
   *
   * @see {@link #onOkClick}
   * @see {@link #onCancelClick}
   */
  okOnOutsideClick: prop_types_default.a.bool,

  /**
   * An optional function to call when a user clicks out of the text field.
   */
  onOutsideClick: prop_types_default.a.func,

  /**
   * Boolean if the edit dialog should be closed if the user clicks somewhere else on the page
   * while the dialog is open.
   */
  closeOnOutsideClick: prop_types_default.a.bool,

  /**
   * Boolean if the Edit Dialog should be visible by default. This only applies when the `inline` prop
   * is not enabled.
   */
  defaultVisible: prop_types_default.a.bool,

  /**
   * Boolean if the edit dialog should automatically open when the text field is focused for non-inline
   * dialogs. This is enabled by default for backwards compatibility.
   */
  visibleOnFocus: prop_types_default.a.bool,

  /**
   * The type for the text field in the edit dialog.
   *
   * @see {@link TextFields/TextField#type}
   */
  type: prop_types_default.a.string,

  /**
   * This is how the dialog gets "anchored" to the table column.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  anchor: anchorShape,

  /**
   * This is the anchor to use when the `position` is set to `Autocomplete.Positions.BELOW`.
   *
   * @see {@link Helpers/Layover#belowAnchor}
   */
  belowAnchor: anchorShape,

  /**
   * This is the animation position to use for the dialog.
   *
   * @see {@link Helpers/Layover#animationPosition}
   */
  animationPosition: positionShape,

  /**
   * This is how the dialog should be fixed within the table. When this is omitted, it will
   * automatically use the responsive table as the fixture so that the dialog will close/adjust itself
   * to the scrolling of the table.
   *
   * @see {@link Helpers/Layover#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * @see {@link Helpers/Layover#xThreshold}
   */
  xThreshold: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#yThreshold}
   */
  yThreshold: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#centered}
   */
  centered: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#sameWidth}
   */
  sameWidth: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#transitionName}
   */
  transitionName: prop_types_default.a.string,

  /**
   * @see {@link Helpers/Layover#transitionEnterTimeout}
   */
  transitionEnterTimeout: prop_types_default.a.number,

  /**
   * @see {@link Helpers/Layover#transitionLeaveTimeout}
   */
  transitionLeaveTimeout: prop_types_default.a.number,

  /**
   * The optional tooltip to render on hover.
   */
  tooltipLabel: prop_types_default.a.node,

  /**
   * An optional delay to apply to the tooltip before it appears.
   */
  tooltipDelay: prop_types_default.a.number,

  /**
   * The position of the tooltip.
   */
  tooltipPosition: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * Boolean if the dialog logic should be simplified without any viewport logic and position
   * based on the relative position of the menu. This will most like require some additional
   * styles applied to the dialog.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedDialog: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#minLeft}
   */
  minLeft: Helpers_Layover.propTypes.minLeft,

  /**
   * @see {@link Helpers/Layover#minRight}
   */
  minRight: Helpers_Layover.propTypes.minLeft,

  /**
   * @see {@link Helpers/Layover#minBottom}
   */
  minBottom: Helpers_Layover.propTypes.minBottom,

  /**
   * Boolean if the edit dialog should attempt to scroll into view if the full
   * dialog can not be displayed in the viewport when it was toggled open.
   *
   * @see {@link #scrollIntoViewPadding}
   */
  scrollIntoView: prop_types_default.a.bool,

  /**
   * The amount of padding that should be applied when the cell is scrolled into view.
   * This will be applied to the left of the cell.
   */
  scrollIntoViewPadding: prop_types_default.a.number,

  /**
   * An optional function to call when the `click` event is triggered in the column.
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional function to call when the `mousedown` event is triggered in the column.
   */
  onMouseDown: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseup` event is triggered in the column.
   */
  onMouseUp: prop_types_default.a.func,

  /**
   * An optional function to call when the `touchstart` event is triggered in the column.
   */
  onTouchStart: prop_types_default.a.func,

  /**
   * An optional function to call when the `touchend` event is triggered in the column.
   */
  onTouchEnd: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseenter` event is triggered in the column.
   */
  onMouseEnter: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseover` event is triggered in the column.
   */
  onMouseOver: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseleave` event is triggered in the column.
   */
  onMouseLeave: prop_types_default.a.func,

  /**
   * An optional function to call when the `touchmove` event is triggered in the column.
   */
  onTouchMove: prop_types_default.a.func,

  /**
   * This is injected by the `TableRow` component.
   * @access private
   */
  header: prop_types_default.a.bool,

  /**
   * This is injected by the `TableRow` component and used to help generate the unique id for the text
   * field.
   *
   * @access private
   */
  cellIndex: prop_types_default.a.number,

  /**
   * @access private
   */
  adjusted: prop_types_default.a.bool,

  inlineIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `inlineIcon` prop instead'),
  inlineIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `inlineIcon` prop instead'),
  noIcon: deprecated_default()(prop_types_default.a.bool, 'Set the `inlineIcon` prop to `null` instead'),
  enforceMinWidth: deprecated_default()(prop_types_default.a.bool, 'The min width will always be enforced based on the `$md-edit-dialog-min-width` Sass variable'),
  scrollThreshold: deprecated_default()(prop_types_default.a.number, 'Use `xThreshold` and `yThreshold` instead'),
  transitionDuration: deprecated_default()(prop_types_default.a.number, 'use `transitionEnterTimeout` and `transitionLeaveTimeout` instead')
};
EditDialogColumn_EditDialogColumn.defaultProps = {
  type: 'text',
  defaultValue: '',
  okOnOutsideClick: true,
  inlineIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'edit'
  ),
  okLabel: 'Save',
  okPrimary: true,
  cancelLabel: 'Cancel',
  cancelPrimary: true,
  animationPosition: EditDialogColumn_EditDialogColumn.Positions.BELOW,
  dialogZDepth: 1,
  repositionOnScroll: true,
  repositionOnResize: false,
  scrollIntoView: true,
  scrollIntoViewPadding: 16,
  minLeft: 0,
  minRight: 0,
  minBottom: 0,
  visibleOnFocus: true,
  defaultVisible: false
};
EditDialogColumn_EditDialogColumn.contextTypes = {
  rowId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])
};

var EditDialogColumn_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setField = function (field) {
    _this2._field = field;
  };

  this._makeActions = function (props) {
    var okLabel = props.okLabel,
        okPrimary = props.okPrimary,
        okSecondary = props.okSecondary,
        okProps = props.okProps,
        cancelLabel = props.cancelLabel,
        cancelPrimary = props.cancelPrimary,
        cancelSecondary = props.cancelSecondary,
        cancelProps = props.cancelProps;


    return [EditDialogColumn_extends({
      key: 'cancel',
      children: cancelLabel,
      primary: cancelPrimary && !cancelSecondary,
      secondary: cancelSecondary
    }, cancelProps, {
      onClick: _this2._handleCancel
    }), EditDialogColumn_extends({
      key: 'ok',
      children: okLabel,
      primary: okPrimary && !okSecondary,
      secondary: okSecondary
    }, okProps, {
      onClick: _this2._handleOk
    })];
  };

  this._handleOpen = function (e) {
    if (_this2._skipNextOpen) {
      _this2._skipNextOpen = false;
    } else if (_this2.props.visibleOnFocus || !e || e.type !== 'focus') {
      var _props4 = _this2.props,
          scrollIntoView = _props4.scrollIntoView,
          scrollIntoViewPadding = _props4.scrollIntoViewPadding;

      if (scrollIntoView) {
        var vp = viewport(_this2._column);
        if (vp !== true && _this2._table && _this2._column && !_this2.props.inline) {
          _this2._table.scrollLeft = _this2._column.offsetLeft - scrollIntoViewPadding;
        }
      }

      _this2.setState({ visible: true, cancelValue: getField(_this2.props, _this2.state, 'value') });
    }
  };

  this._handleClose = function (e) {
    var _props5 = _this2.props,
        onOutsideClick = _props5.onOutsideClick,
        okOnOutsideClick = _props5.okOnOutsideClick;

    if (onOutsideClick) {
      onOutsideClick(e);
    }

    if (okOnOutsideClick) {
      _this2._handleOk(e);
    } else {
      _this2._handleCancel(e);
    }
  };

  this._handleChange = function (value, e) {
    if (_this2.props.onChange) {
      _this2.props.onChange(value, e);
    }

    if (typeof _this2.props.value === 'undefined') {
      _this2.setState({ value: value });
    }
  };

  this._handleFocus = function (e) {
    if (_this2.props.onFocus) {
      _this2.props.onFocus(e);
    }

    if (_this2.props.inline) {
      _this2.setState({ cancelValue: e.target.value });
    }
  };

  this._handleKeyDown = function (e) {
    var _props6 = _this2.props,
        onKeyDown = _props6.onKeyDown,
        okOnOutsideClick = _props6.okOnOutsideClick,
        large = _props6.large;

    if (onKeyDown) {
      onKeyDown(e);
    }

    var key = e.which || e.keyCode;
    if (key === ENTER) {
      _this2._handleOk(e);
    } else if (key === ESC) {
      _this2._handleCancel(e);
    } else if (key === TAB && !large) {
      // infinitely opens otherwise...
      _this2._skipNextOpen = e.shiftKey;

      if (okOnOutsideClick) {
        _this2._handleOk(e);
      } else {
        _this2._handleCancel(e);
      }
    }
  };

  this._handleOk = function (e) {
    if (_this2.props.onOkClick) {
      _this2.props.onOkClick(getField(_this2.props, _this2.state, 'value'), e);
    }

    _this2.setState({ visible: false });
  };

  this._handleCancel = function (e) {
    var value = _this2.state.cancelValue;
    if (_this2.props.onCancelClick) {
      _this2.props.onCancelClick(value, e);
    }

    var state = { visible: false };
    if (typeof _this2.props.value === 'undefined') {
      state.value = value;
    }

    _this2.setState(state);
  };
};

/* harmony default export */ var DataTables_EditDialogColumn = (EditDialogColumn_EditDialogColumn);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/withTableFixes.js
var withTableFixes_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function withTableFixes_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function withTableFixes_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function withTableFixes_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function withTableFixes_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











/**
 * This is a utility HOC to fix the components that use the `Menu` component behind the scenes. This will
 * correctly add the `id` and `fixedTo` props if they are omitted from the child component's props.
 *
 * If the id prop is omitted, it will default to the `${rowId}-${cellIndex}-${suffix}` and when the
 * `fixedTo` prop is omitted, it will automatically set it to the responsive table wrapper so that
 * it will stay in viewport as expected.
 *
 * This component also attempts to find the `cellIndex` prop if it is not correctly cloned into the
 * component.
 *
 * @param {function|Class} ComposedComponent - the component to compose with the tooltip functionality.
 * @param {String} suffix - the id suffix to apply.
 * @return {Class} the ComposedComponent with some fixes applied.
 */
function withTableFixes(ComposedComponent, suffix) {
  var _class, _temp2;

  return _temp2 = _class = function (_PureComponent) {
    withTableFixes_inherits(TableFixesComponent, _PureComponent);

    function TableFixesComponent() {
      var _temp, _this, _ret;

      withTableFixes_classCallCheck(this, TableFixesComponent);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = withTableFixes_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { cellIndex: undefined }, _this._fixedTo = null, _temp), withTableFixes_possibleConstructorReturn(_this, _ret);
    }

    TableFixesComponent.prototype.componentDidMount = function componentDidMount() {
      var _props = this.props,
          cellIndex = _props.cellIndex,
          fixedTo = _props.fixedTo,
          id = _props.id;

      var isIndexed = !!id || cellIndex === 0 || !!cellIndex;
      var isFixed = fixedTo === null || !!fixedTo;
      if (isIndexed && isFixed) {
        // all is good
        return;
      }

      var column = Object(react_dom["findDOMNode"])(this);
      var table = findTable(column);
      this._fixedTo = findFixedTo(table);

      // If a developer creates their own component to wrap the component that uses a menu, the cellIndex prop
      // might not be defined if they don't pass ...props
      if (!isIndexed) {
        var columns = [].slice.call(column.parentNode.querySelectorAll('th,td'));
        this.setState({ cellIndex: columns.indexOf(column) }); // eslint-disable-line react/no-did-mount-set-state
      } else if (this._fixedTo) {
        // need to apply the _fixedTo for the select field
        this.forceUpdate();
      }
    };

    TableFixesComponent.prototype.render = function render() {
      var rowId = this.context.rowId;

      var _props2 = this.props,
          propid = _props2.id,
          propFixedTo = _props2.fixedTo,
          propCellIndex = _props2.cellIndex,
          props = withTableFixes_objectWithoutProperties(_props2, ['id', 'fixedTo', 'cellIndex']);

      var id = this.props.id;

      var fixedTo = this._fixedTo === null || propFixedTo ? propFixedTo : this._fixedTo;
      var cellIndex = getField(this.props, this.state, 'cellIndex');
      if (!id) {
        id = rowId + '-' + cellIndex + '-' + suffix;
      }

      return react_default.a.createElement(ComposedComponent, withTableFixes_extends({}, props, { id: id, fixedTo: fixedTo }));
    };

    return TableFixesComponent;
  }(react["PureComponent"]), _class.Positions = ComposedComponent.Positions, _class.HorizontalAnchors = ComposedComponent.HorizontalAnchors, _class.VerticalAnchors = ComposedComponent.VerticalAnchors, _class.displayName = getDisplayName(ComposedComponent, 'TableFixes'), _class.propTypes = {
    id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
    cellIndex: prop_types_default.a.number,
    fixedTo: fixedToShape
  }, _class.contextTypes = {
    rowId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])
  }, _temp2;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/SelectFieldColumn.js
var SelectFieldColumn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function SelectFieldColumn_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SelectFieldColumn_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SelectFieldColumn_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SelectFieldColumn_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }












/**
 * The `SelectFieldColumn` component is just a simple wrapper between a `SelectField` and
 * the `TableColumn` components.
 *
 * All props that are on the `SelectField` are also available here (except the naming of style or className).
 * See the [SelectField](/components/select-fields?tab=1#select-field-proptypes) for remaining prop descriptions.
 */

var SelectFieldColumn_SelectFieldColumn = function (_PureComponent) {
  SelectFieldColumn_inherits(SelectFieldColumn, _PureComponent);

  function SelectFieldColumn() {
    SelectFieldColumn_classCallCheck(this, SelectFieldColumn);

    return SelectFieldColumn_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  SelectFieldColumn.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        menuStyle = _props.menuStyle,
        menuClassName = _props.menuClassName,
        header = _props.header,
        tooltipLabel = _props.tooltipLabel,
        tooltipDelay = _props.tooltipDelay,
        tooltipPosition = _props.tooltipPosition,
        adjusted = _props.adjusted,
        wrapperStyle = _props.wrapperStyle,
        wrapperClassName = _props.wrapperClassName,
        props = SelectFieldColumn_objectWithoutProperties(_props, ['style', 'className', 'menuStyle', 'menuClassName', 'header', 'tooltipLabel', 'tooltipDelay', 'tooltipPosition', 'adjusted', 'wrapperStyle', 'wrapperClassName']);

    return react_default.a.createElement(
      DataTables_TableColumn,
      {
        header: header,
        style: style,
        className: classnames_default()('md-select-field-column', className),
        adjusted: false,
        tooltipLabel: tooltipLabel,
        tooltipDelay: tooltipDelay,
        tooltipPosition: tooltipPosition
      },
      react_default.a.createElement(SelectFields_SelectField, SelectFieldColumn_extends({}, props, { style: menuStyle, className: menuClassName }))
    );
  };

  return SelectFieldColumn;
}(react["PureComponent"]);

SelectFieldColumn_SelectFieldColumn.VerticalAnchors = SelectFields_SelectField.VerticalAnchors;
SelectFieldColumn_SelectFieldColumn.HorizontalAnchors = SelectFields_SelectField.HorizontalAnchors;
SelectFieldColumn_SelectFieldColumn.Positions = SelectFields_SelectField.Positions;
SelectFieldColumn_SelectFieldColumn.propTypes = {
  /**
   * An optional id to use for the select field in the column. If this is omitted, it's value will be
   * `${rowId}-${cellIndex}-select-field`
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * This is the optional style to apply to the `TableColumn`.
   */
  style: prop_types_default.a.object,

  /**
   * This is the optional className to apply to the `TableColumn`.
   */
  className: prop_types_default.a.string,

  /**
   * The is the optional style to apply to the select field's menu container.
   *
   * @see {@link SelectFields/SelectField#style}
   */
  menuStyle: prop_types_default.a.object,

  /**
   * The is the optional class name to apply to the select field's menu container.
   *
   * @see {@link SelectFields/SelectField#className}
   */
  menuClassName: prop_types_default.a.string,

  /**
   * This is how the select field should be fixed within the table. When this is omitted,
   * it will automatically use the responsive table as the fixture so that the select field
   * will close/adjust itself to the scrolling of the table.
   *
   * @see {@link Helpers/Layover#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * Boolean if the select field should span the entire width of the column.
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * The position for the select field.
   *
   * @see {@link SelectFields/SelectField#position}
   */
  position: positionShape,

  /**
   * This is injected by the `TableRow` component.
   * @access private
   */
  header: prop_types_default.a.bool,

  /**
   * @access private
   */
  adjusted: prop_types_default.a.bool,

  /**
   * The optional tooltip to render on hover.
   *
   * @see {@link DataTables/TableColumn#tooltipLabel}
   */
  tooltipLabel: prop_types_default.a.string,

  /**
   * An optional delay to apply to the tooltip before it appears.
   *
   * @see {@link DataTables/TableColumn#tooltipDelay}
   */
  tooltipDelay: prop_types_default.a.number,

  /**
   * The position of the tooltip.
   *
   * @see {@link DataTables/TableColumn#tooltipPosition}
   */
  tooltipPosition: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * Boolean if the menu logic should be simplified without any viewport logic and position
   * based on the relative position of the menu. This will most like require some additional
   * styles applied to the menu.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedMenu: prop_types_default.a.bool,

  wrapperStyle: deprecated_default()(prop_types_default.a.object, 'There is no longer a wrapper'),
  wrapperClassName: deprecated_default()(prop_types_default.a.string, 'There is no longer a wrapper')
};
SelectFieldColumn_SelectFieldColumn.defaultProps = {
  position: SelectFieldColumn_SelectFieldColumn.Positions.BELOW,
  fullWidth: true,
  repositionOnScroll: true,
  repositionOnResize: false,
  simplifiedMenu: false
};


/* harmony default export */ var DataTables_SelectFieldColumn = (withTableFixes(SelectFieldColumn_SelectFieldColumn, 'select-field'));
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/mapToListParts.js
var mapToListParts_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function mapToListParts_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/** @module utils/mapToListParts */






/**
 * A utility function to convert any "item" into a valid React element that is used
 * within the `List` component.
 *
 * Use cases:
 * - is a valid React element -> item returned unmodified
 * - `number` or `string` -> `ListItem` with the item as the `primaryText`
 * - an `object` with a key `divider: true` -> a `Divider` component with the remaining
 *    keys applied as props.
 * - an `object` with a key `subheader: true` -> a `Subheader` component with the remianing
 *    keys applied as props. This one technically requires the `primaryText` key to be defined.
 * - an `object` -> all keys passed into the `ListItem` component.
 *
 * Examples:
 * ```js
 * mapToListParts('Hello') == <ListItem primaryText="Hello" />
 * mapToListParts(100)     == <ListItem primaryText={100} />
 * mapToListParts({ primaryText: 'Item' }) == <ListItem primaryText="Item" />
 * mapToListParts({ divider: true }) == <Divider />
 * mapToListParts({ subheader: true, primaryText: 'Subheader' }) == <Subheader primaryText="Subheader" />
 * ```
 *
 * @param {string|number|Object} item - the item to convert
 * @param {number|string=} index - the current index in the array (if used in an array)
 * @return {Object} a React element
 */
function mapToListParts(item, index) {
  if (typeof item === 'string' || typeof item === 'number') {
    return Object(react["createElement"])(Lists_ListItem, { key: item, primaryText: item });
  } else if (Object(react["isValidElement"])(item)) {
    return item;
  }

  var divider = item.divider,
      subheader = item.subheader,
      nestedItems = item.nestedItems,
      remainingProps = mapToListParts_objectWithoutProperties(item, ['divider', 'subheader', 'nestedItems']);

  var component = void 0;
  if (divider) {
    component = Dividers_Divider;
  } else if (subheader) {
    component = Subheaders_Subheader;
  } else {
    component = Lists_ListItem;
  }

  var props = mapToListParts_extends({}, remainingProps, { key: item.key || index });
  if (nestedItems) {
    props.nestedItems = nestedItems.map(mapToListParts);
  }

  return Object(react["createElement"])(component, props);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Menus/DropdownMenu.js
var DropdownMenu_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function DropdownMenu_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function DropdownMenu_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DropdownMenu_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DropdownMenu_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }












/**
 * The `DropdownMenu` is just a simple wrapper to the `Menu` component. The main differences
 * is that the `toggle` component will now be the children and the list of items to display
 * will be the `menuItems` prop.
 *
 * The dropdown menu is mostly used to control the state of the menu and render a single element
 * as the toggle.
 */

var DropdownMenu_DropdownMenu = function (_PureComponent) {
  DropdownMenu_inherits(DropdownMenu, _PureComponent);

  function DropdownMenu(props) {
    DropdownMenu_classCallCheck(this, DropdownMenu);

    var _this = DropdownMenu_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._handleClick = function (e) {
      var _this$props = _this.props,
          onVisibilityChange = _this$props.onVisibilityChange,
          children = _this$props.children;

      var visible = !getField(_this.props, _this.state, 'visible');
      if (onVisibilityChange) {
        onVisibilityChange(visible, e);
      }

      var toggle = react_default.a.Children.only(children);
      if (toggle.props.onClick) {
        toggle.props.onClick(e);
      }

      if (typeof _this.props.visible === 'undefined') {
        _this.setState({ visible: visible });
      }
    };

    _this._handleClose = function (e) {
      var onVisibilityChange = _this.props.onVisibilityChange;

      var visible = false;
      if (onVisibilityChange) {
        onVisibilityChange(visible, e);
      }

      if (typeof _this.props.visible === 'undefined') {
        _this.setState({ visible: visible });
      }
    };

    _this.state = {};
    if (typeof props.visible === 'undefined') {
      _this.state.visible = props.defaultVisible;
    }
    return _this;
  }

  DropdownMenu.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        listId = _props.listId,
        menuItems = _props.menuItems,
        propChildren = _props.children,
        simplifiedMenu = _props.simplifiedMenu,
        propVisible = _props.visible,
        onVisibilityChange = _props.onVisibilityChange,
        defaultVisible = _props.defaultVisible,
        props = DropdownMenu_objectWithoutProperties(_props, ['id', 'listId', 'menuItems', 'children', 'simplifiedMenu', 'visible', 'onVisibilityChange', 'defaultVisible']);

    var visible = getField(this.props, this.state, 'visible');

    var children = react_default.a.Children.only(propChildren);
    var toggle = react_default.a.cloneElement(children, {
      id: children.props.id || id + '-toggle',
      onClick: this._handleClick
    });

    var items = void 0;
    if (!Array.isArray(menuItems)) {
      items = mapToListParts(menuItems);
    } else {
      items = menuItems.map(mapToListParts);
    }

    return react_default.a.createElement(
      Menus_Menu,
      DropdownMenu_extends({}, props, {
        simplified: simplifiedMenu,
        id: id,
        listId: listId,
        toggle: toggle,
        visible: visible,
        onClose: this._handleClose
      }),
      items
    );
  };

  return DropdownMenu;
}(react["PureComponent"]);

DropdownMenu_DropdownMenu.Positions = Menus_Menu.Positions;
DropdownMenu_DropdownMenu.HorizontalAnchors = Menus_Menu.HorizontalAnchors;
DropdownMenu_DropdownMenu.VerticalAnchors = Menus_Menu.VerticalAnchors;
DropdownMenu_DropdownMenu.propTypes = {
  /**
   * An id to use for the menu. This is required for accessibility.
   *
   * @see {@link Menus/Menu#id}
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the menu's list.
   *
   * @see {@link Menus/Menu#listId}
   */
  listId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply to the menu.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the menu.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the list.
   */
  listStyle: prop_types_default.a.object,

  /**
   * An optional class name to apply to the list.
   */
  listClassName: prop_types_default.a.string,

  /**
   * Any additional props to provide to the list.
   *
   * @see {@link Menus/Menu#listProps}
   */
  listProps: prop_types_default.a.object,

  /**
   * The z-depth to use for the list.
   *
   * @see {@link Menus/Menu/listZDepth}
   */
  listZDepth: prop_types_default.a.number,

  /**
   * Boolean if the list should be displayed inline.
   *
   * @see {@link Lists/List#inline}
   */
  listInline: prop_types_default.a.bool,

  /**
   * Boolean if the list's height should be restricted.
   *
   * @see {@link Menus/Menu#listHeightRestricted}
   */
  listHeightRestricted: prop_types_default.a.bool,

  /**
   * Boolean if the menu's list is currently visible. If this is defined, it will
   * require the `onVisibilityChange` function to be defined since it will become
   * a controlled component.
   */
  visible: controlled(prop_types_default.a.bool, 'onVisibilityChange', 'defaultVisible'),

  /**
   * Boolean if the menu's list should be visible by default.
   */
  defaultVisible: prop_types_default.a.bool.isRequired,

  /**
   * An optional function to call when the button is clicked.
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional function to call when the visibility changes for the menu. The callback will
   * include the next visibility state and the event that triggered the change.
   *
   * ```js
   * onVisibilityChange(visible, event);
   * ```
   */
  onVisibilityChange: prop_types_default.a.func,

  /**
   * This is a 0 to many relationship of `ListItem` to display in the menu's `List`. If the type
   * of the item is a number or string, it will be passed to the `ListItem` as the `primaryText`.
   * If it is an object, it should be the shape of the `ListItem` props. If it is a node, it will
   * just be rendered in the `List`.
   *
   * @see {@link Lists/ListItem}
   * @see {@link Menus/Menu#children}
   */
  menuItems: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string, prop_types_default.a.object, prop_types_default.a.node, prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number, prop_types_default.a.object, prop_types_default.a.node]))]),

  /**
   * @see {@link Menus/Menu#toggle}
   */
  children: prop_types_default.a.element.isRequired,

  /**
   * The anchor position of the menu's list.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  anchor: anchorShape,

  /**
   * This is the anchor to use when the `position` is set to `Autocomplete.Positions.BELOW`.
   *
   * @see {@link Helpers/Layover#belowAnchor}
   */
  belowAnchor: anchorShape,

  /**
   * This is how the menu's list is fixed to the toggle.
   *
   * @see {@link Menus/Menu#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * This is the animation position for the menu's list.
   *
   * @see {@link Menus/Menu#position}
   */
  position: positionShape,

  /**
   * Boolean if the menu's list should gain the cascading styles.
   *
   * @see {@link Menus/Menu#cascading}
   */
  cascading: prop_types_default.a.bool,

  /**
   * The zDepth to use for the lists that appear in cascading menus.
   *
   * @see {@link Menus/Menu#cascadingZDepth}
   */
  cascadingZDepth: prop_types_default.a.number,

  /**
   * The anchor position for the cascading lists.
   *
   * @see {@link Menus/Menu#cascadingAnchor}
   */
  cascadingAnchor: anchorShape,

  /**
   * Boolean if the menu should display as a full width container. This will *not* update the button
   * to be full width as well.
   *
   * @see {@link Menus/Menu#fullWidth}
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * Boolean if the menu's container should display as `block` instead of `inline-block`.
   *
   * @see {@link Menus/Menu#block}
   */
  block: prop_types_default.a.bool,

  /**
   * Boolean if the list should appear centered related to the button.
   *
   * @see {@link Menus/Menu#centered}
   */
  centered: prop_types_default.a.bool,

  /**
   * Boolean if the menu's list should be the same width as the button.
   *
   * @see {@link Menus/Menu#sameWidth}
   */
  sameWidth: prop_types_default.a.bool,

  /**
   * @see {@link Menus/Menu#xThreshold}
   */
  xThreshold: prop_types_default.a.number,

  /**
   * @see {@link Menus/Menu#yThreshold}
   */
  yThreshold: prop_types_default.a.number,

  /**
   * Boolean if the menu's list should be closed when an element outside of the menu has been clicked.
   *
   * @see {@link Menus/Menu#closeOnOutsideClick}
   */
  closeOnOutsideClick: prop_types_default.a.bool,

  /**
   * The transition name to use for the menu's list visibility changes.
   *
   * @see {@link Menus/Menu#transitionName}
   */
  transitionName: prop_types_default.a.string,

  /**
   * The transition name to use when the menu's list gains visibility.
   *
   * @see {@link Menus/Menu#transitionEnterTimeout}
   */
  transitionEnterTimeout: prop_types_default.a.number,

  /**
   * The transition timeout to use when the menu's list loses visibility.
   *
   * @see {@link Menus/Menu#transitionLeaveTimeout}
   */
  transitionLeaveTimeout: prop_types_default.a.number,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * Boolean if the menu logic should be simplified without any viewport logic and position
   * based on the relative position of the menu. This will most like require some additional
   * styles applied to the menu.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedMenu: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#minLeft}
   */
  minLeft: Menus_Menu.propTypes.minLeft,

  /**
   * @see {@link Helpers/Layover#minRight}
   */
  minRight: Menus_Menu.propTypes.minLeft,

  /**
   * @see {@link Helpers/Layover#minBottom}
   */
  minBottom: Menus_Menu.propTypes.minBottom,

  /**
   * @see {@link Helpers/Layover#fillViewportWidth}
   */
  fillViewportWidth: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#fillViewportHeight}
   */
  fillViewportHeight: prop_types_default.a.bool
};
DropdownMenu_DropdownMenu.defaultProps = {
  defaultVisible: false,
  repositionOnScroll: true,
  repositionOnResize: false
};
/* harmony default export */ var Menus_DropdownMenu = (DropdownMenu_DropdownMenu);
// CONCATENATED MODULE: ../node_modules/react-md/es/Menus/MenuButton.js
var MenuButton_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function MenuButton_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function MenuButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MenuButton_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MenuButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }












/**
 * The `MenuButton` is a simple wrapper / combination of the `Button` and the `Menu`
 * components that can be uncontrolled.
 */

var MenuButton_MenuButton = function (_PureComponent) {
  MenuButton_inherits(MenuButton, _PureComponent);

  function MenuButton() {
    MenuButton_classCallCheck(this, MenuButton);

    return MenuButton_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  MenuButton.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        listId = _props.listId,
        buttonId = _props.buttonId,
        menuStyle = _props.menuStyle,
        menuClassName = _props.menuClassName,
        listStyle = _props.listStyle,
        listClassName = _props.listClassName,
        listProps = _props.listProps,
        listZDepth = _props.listZDepth,
        listInline = _props.listInline,
        listHeightRestricted = _props.listHeightRestricted,
        menuItems = _props.menuItems,
        buttonChildren = _props.buttonChildren,
        children = _props.children,
        anchor = _props.anchor,
        belowAnchor = _props.belowAnchor,
        fixedTo = _props.fixedTo,
        position = _props.position,
        cascading = _props.cascading,
        cascadingAnchor = _props.cascadingAnchor,
        cascadingZDepth = _props.cascadingZDepth,
        fullWidth = _props.fullWidth,
        block = _props.block,
        centered = _props.centered,
        sameWidth = _props.sameWidth,
        repositionOnScroll = _props.repositionOnScroll,
        repositionOnResize = _props.repositionOnResize,
        xThreshold = _props.xThreshold,
        yThreshold = _props.yThreshold,
        closeOnOutsideClick = _props.closeOnOutsideClick,
        transitionName = _props.transitionName,
        transitionEnterTimeout = _props.transitionEnterTimeout,
        transitionLeaveTimeout = _props.transitionLeaveTimeout,
        visible = _props.visible,
        defaultVisible = _props.defaultVisible,
        onVisibilityChange = _props.onVisibilityChange,
        simplifiedMenu = _props.simplifiedMenu,
        minLeft = _props.minLeft,
        minRight = _props.minRight,
        minBottom = _props.minBottom,
        fillViewportWidth = _props.fillViewportWidth,
        fillViewportHeight = _props.fillViewportHeight,
        onMenuClick = _props.onMenuClick,
        onMenuMouseDown = _props.onMenuMouseDown,
        onMenuMouseUp = _props.onMenuMouseUp,
        onMenuMouseEnter = _props.onMenuMouseEnter,
        onMenuMouseMove = _props.onMenuMouseMove,
        onMenuMouseLeave = _props.onMenuMouseLeave,
        onMenuTouchStart = _props.onMenuTouchStart,
        onMenuTouchMove = _props.onMenuTouchMove,
        onMenuTouchCancel = _props.onMenuTouchCancel,
        onMenuTouchEnd = _props.onMenuTouchEnd,
        onMenuFocus = _props.onMenuFocus,
        onMenuBlur = _props.onMenuBlur,
        onMenuKeyDown = _props.onMenuKeyDown,
        onMenuKeyUp = _props.onMenuKeyUp,
        isOpen = _props.isOpen,
        defaultOpen = _props.defaultOpen,
        onMenuToggle = _props.onMenuToggle,
        props = MenuButton_objectWithoutProperties(_props, ['id', 'listId', 'buttonId', 'menuStyle', 'menuClassName', 'listStyle', 'listClassName', 'listProps', 'listZDepth', 'listInline', 'listHeightRestricted', 'menuItems', 'buttonChildren', 'children', 'anchor', 'belowAnchor', 'fixedTo', 'position', 'cascading', 'cascadingAnchor', 'cascadingZDepth', 'fullWidth', 'block', 'centered', 'sameWidth', 'repositionOnScroll', 'repositionOnResize', 'xThreshold', 'yThreshold', 'closeOnOutsideClick', 'transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'visible', 'defaultVisible', 'onVisibilityChange', 'simplifiedMenu', 'minLeft', 'minRight', 'minBottom', 'fillViewportWidth', 'fillViewportHeight', 'onMenuClick', 'onMenuMouseDown', 'onMenuMouseUp', 'onMenuMouseEnter', 'onMenuMouseMove', 'onMenuMouseLeave', 'onMenuTouchStart', 'onMenuTouchMove', 'onMenuTouchCancel', 'onMenuTouchEnd', 'onMenuFocus', 'onMenuBlur', 'onMenuKeyDown', 'onMenuKeyUp', 'isOpen', 'defaultOpen', 'onMenuToggle']);

    var items = children;
    var toggleChildren = buttonChildren;
    if (typeof menuItems !== 'undefined') {
      toggleChildren = children;
      items = menuItems;
    }

    return react_default.a.createElement(
      Menus_DropdownMenu,
      {
        id: id,
        listId: listId,
        style: menuStyle,
        className: menuClassName,
        listStyle: listStyle,
        listClassName: listClassName,
        listProps: listProps,
        listInline: listInline,
        listZDepth: listZDepth,
        listHeightRestricted: listHeightRestricted,
        visible: typeof isOpen !== 'undefined' ? isOpen : visible,
        defaultVisible: typeof defaultOpen !== 'undefined' ? defaultOpen : defaultVisible,
        menuItems: items,
        simplifiedMenu: simplifiedMenu,
        anchor: anchor,
        belowAnchor: belowAnchor,
        fixedTo: fixedTo,
        position: position,
        cascading: cascading,
        cascadingAnchor: cascadingAnchor,
        cascadingZDepth: cascadingZDepth,
        fullWidth: fullWidth,
        block: block,
        centered: centered,
        sameWidth: sameWidth,
        minLeft: minLeft,
        minRight: minRight,
        minBottom: minBottom,
        fillViewportWidth: fillViewportWidth,
        fillViewportHeight: fillViewportHeight,
        repositionOnScroll: repositionOnScroll,
        repositionOnResize: repositionOnResize,
        xThreshold: xThreshold,
        yThreshold: yThreshold,
        closeOnOutsideClick: closeOnOutsideClick,
        transitionName: transitionName,
        transitionEnterTimeout: transitionEnterTimeout,
        transitionLeaveTimeout: transitionLeaveTimeout,
        onVisibilityChange: onMenuToggle || onVisibilityChange,
        onClick: onMenuClick,
        onMouseDown: onMenuMouseDown,
        onMouseUp: onMenuMouseUp,
        onMouseEnter: onMenuMouseEnter,
        onMouseMove: onMenuMouseMove,
        onMouseLeave: onMenuMouseLeave,
        onTouchStart: onMenuTouchStart,
        onTouchMove: onMenuTouchMove,
        onTouchCancel: onMenuTouchCancel,
        onTouchEnd: onMenuTouchEnd,
        onFocus: onMenuFocus,
        onBlur: onMenuBlur,
        onKeyDown: onMenuKeyDown,
        onKeyUp: onMenuKeyUp
      },
      react_default.a.createElement(
        Buttons_Button,
        MenuButton_extends({}, props, { id: buttonId }),
        toggleChildren
      )
    );
  };

  return MenuButton;
}(react["PureComponent"]);

MenuButton_MenuButton.Positions = Menus_DropdownMenu.Positions;
MenuButton_MenuButton.HorizontalAnchors = Menus_DropdownMenu.HorizontalAnchors;
MenuButton_MenuButton.VerticalAnchors = Menus_DropdownMenu.VerticalAnchors;
MenuButton_MenuButton.propTypes = {
  /**
   * An id to use for the menu button. This is required for accessibility.
   *
   * @see {@link Menus/Menu#id}
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the menu's list.
   *
   * @see {@link Menus/Menu#listId}
   */
  listId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the button. If this is omitted, the button will automatically
   * gain an id of `${id}-toggle`.
   */
  buttonId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply to the button.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the button.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the surrounding menu.
   */
  menuStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the surrounding menu.
   */
  menuClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the list.
   */
  listStyle: prop_types_default.a.object,

  /**
   * An optional class name to apply to the list.
   */
  listClassName: prop_types_default.a.string,

  /**
   * Any additional props to provide to the list.
   *
   * @see {@link Menus/Menu#listProps}
   */
  listProps: prop_types_default.a.object,

  /**
   * The z-depth to use for the list.
   *
   * @see {@link Menus/Menu/listZDepth}
   */
  listZDepth: prop_types_default.a.number,

  /**
   * Boolean if the list should be displayed inline.
   *
   * @see {@link Lists/List#inline}
   */
  listInline: prop_types_default.a.bool,

  /**
   * Boolean if the list's height should be restricted.
   *
   * @see {@link Menus/Menu#listHeightRestricted}
   */
  listHeightRestricted: prop_types_default.a.bool,

  /**
   * Boolean if the menu's list is currently visible. If this is defined, it will
   * require the `onVisibilityChange` function to be defined since it will become
   * a controlled component.
   */
  visible: controlled(prop_types_default.a.bool, 'onVisibilityChange', 'defaultVisible'),

  /**
   * Boolean if the menu's list should be visible by default.
   */
  defaultVisible: prop_types_default.a.bool.isRequired,

  /**
   * An optional function to call when the button is clicked.
   *
   * @see {@link #onMenuClick}
   */
  onClick: prop_types_default.a.func,

  /**
   * An optional function to call when the `mousedown` event is triggered by the button.
   *
   * @see {@link #onMenuMouseDown}
   */
  onMouseDown: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseup` event is triggered by the button.
   *
   * @see {@link #onMenuMouseUp}
   */
  onMouseUp: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseenter` event is triggered by the button.
   *
   * @see {@link #onMenuMouseEnter}
   */
  onMouseEnter: prop_types_default.a.func,

  /**
   * An optional function to call when the `mousemove` event is triggered by the button.
   *
   * @see {@link #onMenuMouseMove}
   */
  onMouseMove: prop_types_default.a.func,

  /**
   * An optional function to call when the `mouseleave` event is triggered by the button.
   *
   * @see {@link #onMenuMouseLeave}
   */
  onMouseLeave: prop_types_default.a.func,

  /**
   * An optional function to call when the `touchstart` event is triggered by the button.
   *
   * @see {@link #onMenuTouchStart}
   */
  onTouchStart: prop_types_default.a.func,

  /**
   * An optional function to call when the `touchmove` event is triggered by the button.
   *
   * @see {@link #onMenuTouchMove}
   */
  onTouchMove: prop_types_default.a.func,

  /**
   * An optional function to call when the `touchend` event is triggered by the button.
   *
   * @see {@link #onMenuTouchEnd}
   */
  onTouchEnd: prop_types_default.a.func,

  /**
   * An optional function to call when the `touchcancel` event is triggered by the button.
   *
   * @see {@link #onMenuTouchCancel}
   */
  onTouchCancel: prop_types_default.a.func,

  /**
   * An optional function to call when the `focus` event is triggered by the button.
   *
   * @see {@link #onMenuFocus}
   */
  onFocus: prop_types_default.a.func,

  /**
   * An optional function to call when the `blur` event is triggered by the button.
   *
   * @see {@link #onMenuBlur}
   */
  onBlur: prop_types_default.a.func,

  /**
   * An optional function to call when the `keydown` event is triggered by the button.
   *
   * @see {@link #onMenuKeyDown}
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * An optional function to call when the `keyup` event is triggered by the button.
   *
   * @see {@link #onMenuKeyUp}
   */
  onKeyUp: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the entire `MenuButton` is clicked. This can be triggered
   * by clicking the button or any list item that appears in the menu list.
   *
   * @see {@link #onClick}
   */
  onMenuClick: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `mousedown` event.
   *
   * @see {@link #onMouseDown}
   */
  onMenuMouseDown: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `mouseup` event.
   *
   * @see {@link #onMouseUp}
   */
  onMenuMouseUp: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `mouseenter` event.
   *
   * @see {@link #onMouseEnter}
   */
  onMenuMouseEnter: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `mousemove` event.
   *
   * @see {@link #onMouseMove}
   */
  onMenuMouseMove: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `mouseleave` event.
   *
   * @see {@link #onMouseLeave}
   */
  onMenuMouseLeave: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `touchstart` event.
   *
   * @see {@link @onTouchStart}
   */
  onMenuTouchStart: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `touchmove` event.
   *
   * @see {@link @onTouchMove}
   */
  onMenuTouchMove: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `touchend` event.
   *
   * @see {@link @onTouchEnd}
   */
  onMenuTouchEnd: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `touchcancel` event.
   *
   * @see {@link @onTouchCancel}
   */
  onMenuTouchCancel: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `focus` event.
   *
   * @see {@link #onFocus}
   */
  onMenuFocus: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `blur` event.
   *
   * @see {@link #onBlur}
   */
  onMenuBlur: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `keydown` event.
   *
   * @see {@link #onKeyDown}
   */
  onMenuKeyDown: prop_types_default.a.func,

  /**
   * An optional function to call when any element in the `MenuButton` triggers the `keyup` event.
   *
   * @see {@link #onKeyUp}
   */
  onMenuKeyUp: prop_types_default.a.func,

  /**
   * An optional function to call when the visibility changes for the menu. The callback will
   * include the next visibility state and the event that triggered the change.
   *
   * ```js
   * onVisibilityChange(visible, event);
   * ```
   */
  onVisibilityChange: prop_types_default.a.func,

  /**
   * This is a 0 to many relationship of `ListItem` to display in the menu's `List`. If the type
   * of the item is a number or string, it will be passed to the `ListItem` as the `primaryText`.
   * If it is an object, it should be the shape of the `ListItem` props. If it is a node, it will
   * just be rendered in the `List`.
   *
   * @see {@link Lists/ListItem}
   * @see {@link Menus/Menu#children}
   */
  menuItems: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string, prop_types_default.a.object, prop_types_default.a.node, prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number, prop_types_default.a.object, prop_types_default.a.node]))]),

  /**
   * This should be the children to use in the `Button` that gets created as the menu's toggle.
   *
   * @see {@link Buttons/Button}
   * @see {@link Menus/Menu#toggle}
   */
  children: prop_types_default.a.node,

  /**
   * The anchor position of the menu's list.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  anchor: anchorShape,

  /**
   * This is the anchor to use when the `position` is set to `Autocomplete.Positions.BELOW`.
   *
   * @see {@link Helpers/Layover#belowAnchor}
   */
  belowAnchor: anchorShape,

  /**
   * This is how the menu's list is fixed to the toggle.
   *
   * @see {@link Menus/Menu#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * This is the animation position for the menu's list.
   *
   * @see {@link Menus/Menu#position}
   */
  position: positionShape,

  /**
   * Boolean if the menu's list should gain the cascading styles.
   *
   * @see {@link Menus/Menu#cascading}
   */
  cascading: prop_types_default.a.bool,

  /**
   * The zDepth to use for the lists that appear in cascading menus.
   *
   * @see {@link Menus/Menu#cascadingZDepth}
   */
  cascadingZDepth: prop_types_default.a.number,

  /**
   * The anchor position for the cascading lists.
   *
   * @see {@link Menus/Menu#cascadingAnchor}
   */
  cascadingAnchor: anchorShape,

  /**
   * Boolean if the menu should display as a full width container. This will *not* update the button
   * to be full width as well.
   *
   * @see {@link Menus/Menu#fullWidth}
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * Boolean if the menu's container should display as `block` instead of `inline-block`.
   *
   * @see {@link Menus/Menu#block}
   */
  block: prop_types_default.a.bool,

  /**
   * Boolean if the list should appear centered related to the button.
   *
   * @see {@link Menus/Menu#centered}
   */
  centered: prop_types_default.a.bool,

  /**
   * Boolean if the menu's list should be the same width as the button.
   *
   * @see {@link Menus/Menu#sameWidth}
   */
  sameWidth: prop_types_default.a.bool,

  /**
   * @see {@link Menus/Menu#xThreshold}
   */
  xThreshold: prop_types_default.a.number,

  /**
   * @see {@link Menus/Menu#yThreshold}
   */
  yThreshold: prop_types_default.a.number,

  /**
   * Boolean if the menu's list should be closed when an element outside of the menu has been clicked.
   *
   * @see {@link Menus/Menu#closeOnOutsideClick}
   */
  closeOnOutsideClick: prop_types_default.a.bool,

  /**
   * The transition name to use for the menu's list visibility changes.
   *
   * @see {@link Menus/Menu#transitionName}
   */
  transitionName: prop_types_default.a.string,

  /**
   * The transition name to use when the menu's list gains visibility.
   *
   * @see {@link Menus/Menu#transitionEnterTimeout}
   */
  transitionEnterTimeout: prop_types_default.a.number,

  /**
   * The transition timeout to use when the menu's list loses visibility.
   *
   * @see {@link Menus/Menu#transitionLeaveTimeout}
   */
  transitionLeaveTimeout: prop_types_default.a.number,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * Boolean if the menu logic should be simplified without any viewport logic and position
   * based on the relative position of the menu. This will most like require some additional
   * styles applied to the menu.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedMenu: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#minLeft}
   */
  minLeft: Menus_DropdownMenu.propTypes.minLeft,

  /**
   * @see {@link Helpers/Layover#minRight}
   */
  minRight: Menus_DropdownMenu.propTypes.minLeft,

  /**
   * @see {@link Helpers/Layover#minBottom}
   */
  minBottom: Menus_DropdownMenu.propTypes.minBottom,

  /**
   * @see {@link Helpers/Layover#fillViewportWidth}
   */
  fillViewportWidth: prop_types_default.a.bool,

  /**
   * @see {@link Helpers/Layover#fillViewportHeight}
   */
  fillViewportHeight: prop_types_default.a.bool,

  buttonChildren: deprecated_default()(prop_types_default.a.node, 'To build a button, put any elements in the `children`. The `ListItem` have been moved to the `menuItems` prop'),
  onMenuToggle: deprecated_default()(prop_types_default.a.bool, 'Use `onVisibilityChange` instead'),
  isOpen: deprecated_default()(prop_types_default.a.bool, 'Use `visible` instead'),
  defaultOpen: deprecated_default()(prop_types_default.a.bool, 'Use `defaultVisible` instead')
};
MenuButton_MenuButton.defaultProps = {
  defaultVisible: false,
  repositionOnScroll: true,
  repositionOnResize: false
};
/* harmony default export */ var Menus_MenuButton = (MenuButton_MenuButton);
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/MenuButtonColumn.js
var MenuButtonColumn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function MenuButtonColumn_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function MenuButtonColumn_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MenuButtonColumn_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MenuButtonColumn_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









var MenuButtonColumn_MenuButtonColumn = function (_PureComponent) {
  MenuButtonColumn_inherits(MenuButtonColumn, _PureComponent);

  function MenuButtonColumn() {
    MenuButtonColumn_classCallCheck(this, MenuButtonColumn);

    return MenuButtonColumn_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  MenuButtonColumn.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        menuStyle = _props.menuStyle,
        menuClassName = _props.menuClassName,
        header = _props.header,
        adjusted = _props.adjusted,
        tooltipLabel = _props.tooltipLabel,
        tooltipDelay = _props.tooltipDelay,
        tooltipPosition = _props.tooltipPosition,
        props = MenuButtonColumn_objectWithoutProperties(_props, ['style', 'className', 'menuStyle', 'menuClassName', 'header', 'adjusted', 'tooltipLabel', 'tooltipDelay', 'tooltipPosition']);

    return react_default.a.createElement(
      DataTables_TableColumn,
      {
        style: style,
        className: className,
        header: header,
        adjusted: adjusted,
        tooltipLabel: tooltipLabel,
        tooltipDelay: tooltipDelay,
        tooltipPosition: tooltipPosition
      },
      react_default.a.createElement(Menus_MenuButton, MenuButtonColumn_extends({}, props, { style: menuStyle, className: menuClassName }))
    );
  };

  return MenuButtonColumn;
}(react["PureComponent"]);

MenuButtonColumn_MenuButtonColumn.Positions = Menus_MenuButton.Positions;
MenuButtonColumn_MenuButtonColumn.HorizontalAnchors = Menus_MenuButton.HorizontalAnchors;
MenuButtonColumn_MenuButtonColumn.VerticalAnchors = Menus_MenuButton.VerticalAnchors;
MenuButtonColumn_MenuButtonColumn.propTypes = {
  /**
   * An optional id to use for the menu button in the column. If this is omitted, it's value will be
   * `${rowId}-${cellIndex}-menu-button`
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * This is the optional style to apply to the `TableColumn`.
   */
  style: prop_types_default.a.object,

  /**
   * This is the optional className to apply to the `TableColumn`.
   */
  className: prop_types_default.a.string,

  /**
   * The is the optional style to apply to the menu button's menu container.
   *
   * @see {@link Menus/MenuButton#style}
   */
  menuStyle: prop_types_default.a.object,

  /**
   * The is the optional class name to apply to the menu button's menu container.
   *
   * @see {@link Menus/MenuButton#className}
   */
  menuClassName: prop_types_default.a.string,

  /**
   * This is how the select field should be fixed within the table. When this is omitted,
   * it will automatically use the responsive table as the fixture so that the select field
   * will close/adjust itself to the scrolling of the table.
   *
   * @see {@link Helpers/Layover#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * The optional tooltip to render on hover.
   *
   * @see {@link DataTables/TableColumn#tooltipLabel}
   */
  tooltipLabel: prop_types_default.a.string,

  /**
   * An optional delay to apply to the tooltip before it appears.
   *
   * @see {@link DataTables/TableColumn#tooltipDelay}
   */
  tooltipDelay: prop_types_default.a.number,

  /**
   * The position of the tooltip.
   *
   * @see {@link DataTables/TableColumn#tooltipPosition}
   */
  tooltipPosition: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * Boolean if the menu logic should be simplified without any viewport logic and position
   * based on the relative position of the menu. This will most like require some additional
   * styles applied to the menu.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedMenu: prop_types_default.a.bool,

  /**
   * This is injected by the `TableRow` component.
   * @access private
   */
  header: prop_types_default.a.bool,

  /**
   * @access private
   */
  adjusted: prop_types_default.a.bool
};
MenuButtonColumn_MenuButtonColumn.defaultProps = {
  simplifiedMenu: false
};


/* harmony default export */ var DataTables_MenuButtonColumn = (withTableFixes(MenuButtonColumn_MenuButtonColumn, 'menu-button'));
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/DropdownMenuColumn.js
var DropdownMenuColumn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function DropdownMenuColumn_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function DropdownMenuColumn_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DropdownMenuColumn_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DropdownMenuColumn_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









var DropdownMenuColumn_DropdownMenuColumn = function (_PureComponent) {
  DropdownMenuColumn_inherits(DropdownMenuColumn, _PureComponent);

  function DropdownMenuColumn() {
    DropdownMenuColumn_classCallCheck(this, DropdownMenuColumn);

    return DropdownMenuColumn_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  DropdownMenuColumn.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        menuStyle = _props.menuStyle,
        menuClassName = _props.menuClassName,
        header = _props.header,
        adjusted = _props.adjusted,
        tooltipLabel = _props.tooltipLabel,
        tooltipDelay = _props.tooltipDelay,
        tooltipPosition = _props.tooltipPosition,
        props = DropdownMenuColumn_objectWithoutProperties(_props, ['style', 'className', 'menuStyle', 'menuClassName', 'header', 'adjusted', 'tooltipLabel', 'tooltipDelay', 'tooltipPosition']);

    return react_default.a.createElement(
      DataTables_TableColumn,
      {
        style: style,
        className: className,
        header: header,
        adjusted: adjusted,
        tooltipLabel: tooltipLabel,
        tooltipDelay: tooltipDelay,
        tooltipPosition: tooltipPosition
      },
      react_default.a.createElement(Menus_DropdownMenu, DropdownMenuColumn_extends({}, props, { style: menuStyle, className: menuClassName }))
    );
  };

  return DropdownMenuColumn;
}(react["PureComponent"]);

DropdownMenuColumn_DropdownMenuColumn.Positions = Menus_DropdownMenu.Positions;
DropdownMenuColumn_DropdownMenuColumn.HorizontalAnchors = Menus_DropdownMenu.HorizontalAnchors;
DropdownMenuColumn_DropdownMenuColumn.VerticalAnchors = Menus_DropdownMenu.VerticalAnchors;
DropdownMenuColumn_DropdownMenuColumn.propTypes = {
  /**
   * An optional id to use for the menu button in the column. If this is omitted, it's value will be
   * `${rowId}-${cellIndex}-menu-button`
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * This is the optional style to apply to the `TableColumn`.
   */
  style: prop_types_default.a.object,

  /**
   * This is the optional className to apply to the `TableColumn`.
   */
  className: prop_types_default.a.string,

  /**
   * The is the optional style to apply to the menu button's menu container.
   *
   * @see {@link Menus/DropdownMenu#style}
   */
  menuStyle: prop_types_default.a.object,

  /**
   * The is the optional class name to apply to the menu button's menu container.
   *
   * @see {@link Menus/DropdownMenu#className}
   */
  menuClassName: prop_types_default.a.string,

  /**
   * This is how the select field should be fixed within the table. When this is omitted,
   * it will automatically use the responsive table as the fixture so that the select field
   * will close/adjust itself to the scrolling of the table.
   *
   * @see {@link Helpers/Layover#fixedTo}
   */
  fixedTo: fixedToShape,

  /**
   * The optional tooltip to render on hover.
   *
   * @see {@link DataTables/TableColumn#tooltipLabel}
   */
  tooltipLabel: prop_types_default.a.string,

  /**
   * An optional delay to apply to the tooltip before it appears.
   *
   * @see {@link DataTables/TableColumn#tooltipDelay}
   */
  tooltipDelay: prop_types_default.a.number,

  /**
   * The position of the tooltip.
   *
   * @see {@link DataTables/TableColumn#tooltipPosition}
   */
  tooltipPosition: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: prop_types_default.a.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: prop_types_default.a.bool,

  /**
   * Boolean if the menu logic should be simplified without any viewport logic and position
   * based on the relative position of the menu. This will most like require some additional
   * styles applied to the menu.
   *
   * @see {@link Helpers/Layover#simplified}
   */
  simplifiedMenu: prop_types_default.a.bool,

  /**
   * This is injected by the `TableRow` component.
   * @access private
   */
  header: prop_types_default.a.bool,

  /**
   * @access private
   */
  adjusted: prop_types_default.a.bool
};
DropdownMenuColumn_DropdownMenuColumn.defaultProps = {
  simplifiedMenu: false
};


/* harmony default export */ var DataTables_DropdownMenuColumn = (withTableFixes(DropdownMenuColumn_DropdownMenuColumn, 'menu-button'));
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/PropTypes/oneRequired.js
/** @module utils/PropTypes/oneRequired */

/**
 * A simple prop type validation that makes sure that at least this prop or one of the
 * other defined prop names are defined for a component.
 *
 * @param {function} validator - The PropType validator for the current prop.
 * @param {...String} otherPropNames - A single or list of prop names that could be defined
 * @return {Error} a prop type validation error or null.
 */
function oneRequired(validator) {
  for (var _len = arguments.length, otherPropNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    otherPropNames[_key - 1] = arguments[_key];
  }

  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;
    var allPropNames = [propFullNameSafe].concat(otherPropNames);

    for (var _len2 = arguments.length, args = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      args[_key2 - 5] = arguments[_key2];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (!err && !allPropNames.filter(function (pn) {
      return typeof props[pn] !== 'undefined';
    }).length) {
      err = new Error('One of the following props are required for the ' + componentNameSafe + ' component. ' + ('`' + allPropNames.join('`, `') + '`.'));
    }

    return err;
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/DataTables/TableCardHeader.js
var TableCardHeader_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TableCardHeader_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TableCardHeader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TableCardHeader_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TableCardHeader_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











/**
 * The `TableCardHeader` is used when contextual actions should appear when
 * a user selects a row.
 */

var TableCardHeader_TableCardHeader = function (_PureComponent) {
  TableCardHeader_inherits(TableCardHeader, _PureComponent);

  function TableCardHeader(props) {
    TableCardHeader_classCallCheck(this, TableCardHeader);

    var _this = TableCardHeader_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = { animating: false };
    return _this;
  }

  TableCardHeader.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    var visible = this.props.visible;
    var nVisible = nextProps.visible,
        transitionEnterTimeout = nextProps.transitionEnterTimeout,
        transitionLeaveTimeout = nextProps.transitionLeaveTimeout;

    var timeout = !nVisible ? transitionLeaveTimeout : transitionEnterTimeout;
    if (visible !== nVisible) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }

      this._timeout = setTimeout(function () {
        _this2._timeout = setTimeout(function () {
          _this2._timeout = null;
          _this2.setState({ animating: false });
        }, timeout);
      }, CSSTransitionGroupTick);

      if (!this.state.animating) {
        this.setState({ animating: true });
      }
    }
  };

  TableCardHeader.prototype._cloneCellRight = function _cloneCellRight(noAdjust, children) {
    if (noAdjust || !children) {
      return children;
    }

    return react["Children"].map(react["Children"].toArray(children), function (child, i) {
      if (i === 0) {
        return Object(react["cloneElement"])(child, { className: classnames_default()('md-cell--right', child.props.className) });
      }

      return child;
    });
  };

  TableCardHeader.prototype._cloneLeftChildren = function _cloneLeftChildren(noClone, children) {
    if (noClone || !children) {
      return children;
    }

    return react["Children"].map(react["Children"].toArray(children), function (child) {
      return Object(react["cloneElement"])(child, {
        className: classnames_default()('md-btn--dialog', child.props.className)
      });
    });
  };

  TableCardHeader.prototype.render = function render() {
    var animating = this.state.animating;

    var _props = this.props,
        style = _props.style,
        className = _props.className,
        title = _props.title,
        titleId = _props.titleId,
        actions = _props.actions,
        contextualTitleId = _props.contextualTitleId,
        contextualChildren = _props.contextualChildren,
        noActionsAdjust = _props.noActionsAdjust,
        noChildrenAdjust = _props.noChildrenAdjust,
        noLeftChildrenClone = _props.noLeftChildrenClone,
        visible = _props.visible,
        propChildren = _props.children,
        propLeftChildren = _props.leftChildren,
        propContextualTitle = _props.contextualTitle,
        props = TableCardHeader_objectWithoutProperties(_props, ['style', 'className', 'title', 'titleId', 'actions', 'contextualTitleId', 'contextualChildren', 'noActionsAdjust', 'noChildrenAdjust', 'noLeftChildrenClone', 'visible', 'children', 'leftChildren', 'contextualTitle']);

    var _props2 = this.props,
        children = _props2.children,
        leftChildren = _props2.leftChildren,
        contextualTitle = _props2.contextualTitle;

    children = this._cloneCellRight(noChildrenAdjust, children);
    leftChildren = this._cloneLeftChildren(noLeftChildrenClone, leftChildren);

    if (title) {
      children = react_default.a.createElement(
        'div',
        { className: 'md-card-title', key: 'main-title' },
        react_default.a.createElement(Cards_CardTitleBlock, { id: titleId, title: title }),
        children
      );
    } else if (leftChildren) {
      leftChildren = react["Children"].toArray(leftChildren);

      if (children) {
        children = leftChildren.concat(react["Children"].toArray(children));
      } else {
        children = leftChildren;
      }
    }

    if (contextualTitle) {
      contextualTitle = react_default.a.createElement(
        'h2',
        {
          id: contextualTitleId,
          className: 'md-card-title--title md-card-title--title-contextual',
          tabIndex: contextualTitleId ? -1 : null
        },
        contextualTitle
      );
    }

    var contextualHeader = react_default.a.createElement(
      'div',
      { key: 'contextual-header', className: 'md-card-title md-card-title--contextual' },
      contextualTitle,
      contextualChildren,
      this._cloneCellRight(noActionsAdjust, actions)
    );

    var mergedStyles = style;
    if (animating) {
      mergedStyles = Object.assign({}, style, { overflow: 'hidden' });
    }

    return react_default.a.createElement(
      CSSTransitionGroup_default.a,
      TableCardHeader_extends({}, props, {
        style: mergedStyles,
        className: classnames_default()('md-table-card-header', {
          'md-table-card-header--no-title': !title
        }, className)
      }),
      children,
      visible ? contextualHeader : null
    );
  };

  return TableCardHeader;
}(react["PureComponent"]);

TableCardHeader_TableCardHeader.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The component to render as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * The transition name to use when the contextual header appears.
   */
  transitionName: prop_types_default.a.string.isRequired,

  /**
   * The transition time to use when the contextual header appears.
   */
  transitionEnterTimeout: prop_types_default.a.number.isRequired,

  /**
   * The transition time to use when the contextual header disappears.
   */
  transitionLeaveTimeout: prop_types_default.a.number.isRequired,

  /**
   * An optional title to display. It is invalid to have both `title` and `leftChildren`
   * defined as only one will be used.
   */
  title: oneRequired(prop_types_default.a.node, 'leftChildren', 'children'),

  /**
   * An optional id to provide to the title.
   */
  titleId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional title to display in the contextual header. This will get wrapped in an `h2`
   * tag and additional styles applied.
   */
  contextualTitle: prop_types_default.a.node,

  /**
   * An optional id to provide to the contextual title.
   */
  contextualTitleId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * Any additional children to display in the contextual header. This will be displayed after
   * the optional `contextualTile` and before the `actions`.
   */
  contextualChildren: prop_types_default.a.node,

  /**
   * An optional button or list of buttons to display instead of a title.
   */
  leftChildren: invalidIf(prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.arrayOf(prop_types_default.a.element)]), 'title'),

  /**
   * An additional children to display after the `title` or `leftChildren` prop.
   * This is _normally_ a list of icon button or menu button.
   */
  children: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.arrayOf(prop_types_default.a.element)]),

  /**
   * An optional button/menu button or a list of button/menu button to display in the
   * contextual header once the user has selected a row or multiple rows.
   */
  actions: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.arrayOf(prop_types_default.a.element)]),

  /**
   * Boolean if the `actions` prop should not have each element cloned with additional
   * class names.
   */
  noActionsAdjust: prop_types_default.a.bool,

  /**
   * Boolean if the `children` prop should not have each element cloned with additional
   * class names.
   */
  noChildrenAdjust: prop_types_default.a.bool,

  /**
   * Boolean if the `leftChildren` prop should not have each element cloned with additional
   * class names.
   */
  noLeftChildrenClone: prop_types_default.a.bool,

  /**
   * Boolean if the contextual header is currently visible.
   */
  visible: prop_types_default.a.bool.isRequired
};
TableCardHeader_TableCardHeader.defaultProps = {
  component: 'header',
  transitionName: 'md-drop-down',
  transitionEnterTimeout: 150,
  transitionLeaveTimeout: 150
};
/* harmony default export */ var DataTables_TableCardHeader = (TableCardHeader_TableCardHeader);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/toggleScroll.js
/** @module utils/toggleScroll */


/**
 * A utility function for toggling the overflow visibility on an element. This will either target
 * the given `selector`, or the `body` tag to set a `className`.
 *
 * If the `visible` param is `undefined`, the className will be toggled.
 * If the `visible` param is `true`, the className will be added.
 * If the `visible` param is `false`, the className will be removed.
 *
 *
 * > This depends on the `classList` attribute on elements.
 *
 * @param {bool=} visible - An optional boolean to determine how the `className` will be applied.
 * @param {string|Object=} selector - An optional query selector string to use to select an element.
 * @param {string=} className - The className to apply. Defaults to 'md-overflow-hidden'
 */
function toggleScroll(scrollable, selector) {
  var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'md-no-scroll';

  var queryable = !selector || typeof selector === 'string';
  var el = void 0;
  if (queryable) {
    el = selector ? document.querySelector(selector) : document.querySelector('html');
  } else {
    el = selector;
  }

  if (!el) {
    return;
  }

  if (typeof scrollable === 'undefined') {
    scrollable = !el.classList.contains(className);
  }

  if (scrollable && !el.classList.contains(className)) {
    el.style.top = '-' + (queryable ? getPagePosition('y') : el.scrollTop) + 'px';
    el.classList.add(className);
  } else if (!scrollable && el.classList.contains(className)) {
    var scrollTop = Math.abs(parseInt(el.style.top, 10));
    el.classList.remove(className);
    el.style.top = null;

    if (!selector) {
      window.scrollTo(0, scrollTop);
    } else {
      el.scrollTop = scrollTop;
    }
  }
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Dialogs/DialogContainer.js
var DialogContainer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function DialogContainer_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function DialogContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DialogContainer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DialogContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

















/**
 * The `DialogContainer` component is used for dynamically creating the `Dialog` with
 * transitions.
 */

var DialogContainer_DialogContainer = function (_PureComponent) {
  DialogContainer_inherits(DialogContainer, _PureComponent);

  function DialogContainer(props) {
    DialogContainer_classCallCheck(this, DialogContainer);

    var _this = DialogContainer_possibleConstructorReturn(this, _PureComponent.call(this, props));

    DialogContainer_initialiseProps.call(_this);

    var visible = typeof props.isOpen !== 'undefined' ? props.isOpen : props.visible;
    var dialogVisible = visible && !props.defaultVisibleTransitionable;

    _this.state = {
      active: visible && !props.fullPage,
      portalVisible: visible,
      dialogVisible: dialogVisible
    };
    return _this;
  }
  /* eslint-disable max-len */


  DialogContainer.prototype.componentDidMount = function componentDidMount() {
    if (!this.props.isOpen && !this.props.visible) {
      return;
    }

    this._mountDialog(this.props);
  };

  DialogContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var visible = typeof nextProps.isOpen !== 'undefined' ? nextProps.isOpen : nextProps.visible;
    if (this.props.isOpen === visible || this.props.visible === visible) {
      return;
    }

    var el = getField(this.props, this.context, 'renderNode') || window;
    var pageX = el.scrollX,
        pageY = el.scrollY;

    if (typeof el.scrollTop !== 'undefined' && typeof el.scrollLeft !== 'undefined') {
      pageX = el.scrollLeft;
      pageY = el.scrollTop;
    } else if (typeof el.scrollY !== 'undefined' && typeof el.scrollX !== 'undefined') {
      pageX = el.scrollX;
      pageY = el.scrollY;
    }

    this._pageX = pageX;
    this._pageY = pageY;

    if (this._inTimeout) {
      clearTimeout(this._inTimeout);
      this._inTimeout = null;
    }

    if (visible) {
      this._activeElement = document.activeElement;
      this._mountPortal(nextProps);
    } else {
      this.setState({ dialogVisible: false, active: false });
    }
  };

  DialogContainer.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _props = this.props,
        visible = _props.visible,
        closeOnEsc = _props.closeOnEsc,
        modal = _props.modal;

    var escapable = !modal && closeOnEsc;
    var prevEscapable = !prevProps.modal && prevProps.closeOnEsc;

    // Only going to support visible here since it was not implemented before.
    if (visible === prevProps.visible && escapable === prevEscapable) {
      return;
    }

    var add = false;
    var remove = false;

    if (escapable !== prevEscapable) {
      add = visible && escapable;
      remove = !visible || prevEscapable && !escapable;
    } else if (escapable) {
      add = visible;
      remove = !visible;
    }

    if (add) {
      window.addEventListener('keydown', this._handleEscClose);
    } else if (remove) {
      window.removeEventListener('keydown', this._handleEscClose);
    }
  };

  DialogContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.isOpen || this.props.visible) {
      toggleScroll(false);
    }

    if (this.props.visible && this.props.closeOnEsc && !this.props.modal) {
      window.removeEventListener('keydown', this._handleEscClose);
    }

    if (this._inTimeout) {
      clearTimeout(this._inTimeout);
    }
  };

  DialogContainer.prototype.render = function render() {
    var _state = this.state,
        active = _state.active,
        dialogVisible = _state.dialogVisible,
        portalVisible = _state.portalVisible;

    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        dialogStyle = _props2.dialogStyle,
        dialogClassName = _props2.dialogClassName,
        modal = _props2.modal,
        fullPage = _props2.fullPage,
        component = _props2.component,
        transitionEnterTimeout = _props2.transitionEnterTimeout,
        transitionLeaveTimeout = _props2.transitionLeaveTimeout,
        lastChild = _props2.lastChild,
        portal = _props2.portal,
        propVisible = _props2.visible,
        propRenderNode = _props2.renderNode,
        closeOnEsc = _props2.closeOnEsc,
        onShow = _props2.onShow,
        onHide = _props2.onHide,
        disableScrollLocking = _props2.disableScrollLocking,
        defaultVisibleTransitionable = _props2.defaultVisibleTransitionable,
        close = _props2.close,
        isOpen = _props2.isOpen,
        actionLeft = _props2.actionLeft,
        actionRight = _props2.actionRight,
        transitionName = _props2.transitionName,
        transitionEnter = _props2.transitionEnter,
        transitionLeave = _props2.transitionLeave,
        props = DialogContainer_objectWithoutProperties(_props2, ['style', 'className', 'dialogStyle', 'dialogClassName', 'modal', 'fullPage', 'component', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'lastChild', 'portal', 'visible', 'renderNode', 'closeOnEsc', 'onShow', 'onHide', 'disableScrollLocking', 'defaultVisibleTransitionable', 'close', 'isOpen', 'actionLeft', 'actionRight', 'transitionName', 'transitionEnter', 'transitionLeave']);

    var renderNode = getField(this.props, this.context, 'renderNode');
    var dialog = react_default.a.createElement(Dialogs_Dialog, DialogContainer_extends({
      key: 'dialog',
      style: dialogStyle,
      className: classnames_default()('md-background--card', dialogClassName),
      ref: this._handleDialogMounting,
      centered: !fullPage,
      fullPage: fullPage
    }, props, {
      containerX: this._pageX,
      containerY: this._pageY,
      onLeave: this._unmountPortal
    }));

    var container = react_default.a.createElement(
      CSSTransitionGroup_default.a,
      {
        component: component,
        ref: this._setContainer,
        style: style,
        className: classnames_default()('md-dialog-container', {
          'md-overlay': !fullPage,
          'md-overlay--active': !fullPage && active && propVisible,
          'md-pointer--hover': !fullPage && !modal && propVisible
        }, className),
        transitionName: 'md-dialog--' + (fullPage ? 'full-page' : 'centered'),
        transitionEnterTimeout: transitionEnterTimeout,
        transitionLeaveTimeout: transitionLeaveTimeout,
        tabIndex: -1,
        onClick: this._handleClick
      },
      dialogVisible ? dialog : null
    );

    if (!portal) {
      return portalVisible ? container : null;
    }

    return react_default.a.createElement(
      Helpers_Portal,
      { visible: portalVisible, renderNode: renderNode, lastChild: lastChild },
      container
    );
  };

  return DialogContainer;
}(react["PureComponent"]);

DialogContainer_DialogContainer.propTypes = {
  /**
   * An id to use for the `Dialog` once it has been opened. This is used for the
   * [dialog role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_dialog_role).
   * This is used to generate an `id` for the `title` prop when it has been defined.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),
  /* eslint-enable max-len */

  /**
   * An optional accessibility prop to use when the `Dialog` is opened. This should be an id
   * pointing to some text that describes the content of the dialog. For accessibility
   * reasons, one of the following props must be defined:
   * - `title`
   * - `aria-describedby`
   * - `aria-labelledby`
   * - `aria-label`
   *
   * An example usage:
   *
   * ```js
   * <Dialog id="accessible-example" visible aria-describedby="accessible-content">
   *   <p id="accessible-content">This is some content that describes the dialog.</p>
   * </Dialog>
   * ```
   */
  'aria-describedby': oneRequiredForA11y(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]), 'title', 'aria-labelledby', 'aria-label'),

  /**
   * An optional accessibility prop to use when the `title` prop is not given. This should be
   * an id pointing to a `h` tag that labels the dialog.
   *
   * An example usage:
   *
   * ```js
   * <Dialog visible id="accessible-example" aria-labelledby="accessible-dialog-label">
   *   <h2 id="accessible-dialog-label">Some Accessible Dialog</h2>
   * </Dialog>
   * ```
   */
  'aria-labelledby': prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional accessibility prop to use when the `title` and `aria-labelledby` props are
   * not defined. This should be a string that describes what is in the `Dialog`.
   *
   * An example usage:
   *
   * ```js
   * <Dialog visible id="accessible-example" aria-label="Some Accessible Dialog">
   *   <p>Lorem Ipsum</p>
   * </Dialog>
   * ```
   */
  'aria-label': prop_types_default.a.string,

  /**
   * An optional style to apply to the dialog's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the dialog's container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the dialog itself when the `visible` prop is `true`.
   */
  dialogStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the dialog itself when the `visible` prop is `true`.
   */
  dialogClassName: prop_types_default.a.string,

  /**
   * An optional styke to apply to the title.
   */
  titleStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the title.
   */
  titleClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the footer. This is used when the `actions`
   * prop is defined.
   */
  footerStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the footer. This is used when the `actions`
   * prop is defined.
   */
  footerClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the dialog's content.
   */
  contentStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the dialog's content.
   */
  contentClassName: prop_types_default.a.string,

  /**
   * The component to render the dialog's container in.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * The component to render the dialog's content in.
   */
  contentComponent: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * The content to display in the dialog once open.
   */
  children: prop_types_default.a.node,

  /**
   * A single action or a list of actions to display in the dialog. This can either be a list
   * of `FlatButton` props or `<Button flat {...props} />` elements.
   */
  actions: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.object, prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.object]))]),

  /**
   * Boolean if the `Dialog` is current visible.
   */
  visible: prop_types_default.a.bool.isRequired,

  /**
   * An optional function to call when the `visible` prop is changed from `false` to `true`.
   */
  onShow: prop_types_default.a.func,

  /**
   * A function to call that will close the dialog. This is required when the `modal` and `fullPage`
   * props are not `true`.
   */
  onHide: function onHide(props, propName) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var validator = prop_types_default.a.func;
    if (!props.modal && !props.fullPage) {
      validator = validator.isRequired;
    }

    return validator.apply(undefined, [props, propName].concat(args));
  },

  /**
   * Boolean if the dialog should behave like a modal. This means that the dialog can only
   * be closed by clicking on an action instead of also clicking on the overlay.
   */
  modal: prop_types_default.a.bool,

  /**
   * Boolean if the dialog should be displayed as a full page dialog.
   */
  fullPage: function fullPage(props, propName, componentName) {
    for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      args[_key2 - 3] = arguments[_key2];
    }

    var componentNameSafe = componentName || '<<anonymous>>';
    var err = prop_types_default.a.bool.apply(prop_types_default.a, [props, propName, componentName].concat(args));

    if (!err && props[propName] && typeof props.title !== 'undefined') {
      err = new Error('You provided a `title` ' + location + ' to the `' + componentNameSafe + '` when `fullPage` ' + 'has been set to true. A title for a full page dialog should be rendered as a child instead.');
    }

    return err;
  },

  /**
   * An optional pageX location to use when rendering a full page dialog. This is used to set the location
   * the dialog should appear from.
   */
  pageX: prop_types_default.a.number,

  /**
   * An optional pageY location to use when rendering a full page dialog. This is used to set the location
   * the dialog should appear from.
   */
  pageY: prop_types_default.a.number,

  /**
   * @see {@link Helpers/FocusContainer#additionalFocusKeys}
   */
  additionalFocusKeys: Dialogs_Dialog.propTypes.additionalFocusKeys,

  /**
   * @see {@link Helpers/FocusContainer#initialFocus}
   */
  initialFocus: Dialogs_Dialog.propTypes.initialFocus,

  /**
   * @see {@link Helpers/FocusContainer#focusOnMount}
   */
  focusOnMount: Dialogs_Dialog.propTypes.focusOnMount,

  /**
   * @see {@link Helpers/FocusContainer#containFocus}
   */
  containFocus: Dialogs_Dialog.propTypes.containFocus,

  /**
   * The transition enter timeout for the dialog.
   */
  transitionEnterTimeout: prop_types_default.a.number.isRequired,

  /**
   * The transition leave timeout for the dialog.
   */
  transitionLeaveTimeout: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the dialog should be closable by pressing the escape key.
   * This will always be considered `false` of the `modal` props is `true`.
   */
  closeOnEsc: prop_types_default.a.bool,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the dialog.
   *
   * @see {@link Helpers/Portal}
   */
  portal: prop_types_default.a.bool,

  /**
   * Since the `Dialog` uses the `Portal` component, you can pass an optional HTML Node to render
   * the dialog in instead of the `document.body`.
   */
  renderNode: prop_types_default.a.object,

  /**
   * Boolean if the dialog should be rendered as the last child in the `renderNode` or `body` instead
   * of as the first.
   */
  lastChild: prop_types_default.a.bool,

  /**
   * An optional title for the dialog.
   */
  title: prop_types_default.a.node,

  /**
   * Boolean if the dialog should animate into view if it is constructed with `visible` enabled.
   *
   * This basically means that if the `Dialog` has `visible` enabled on initial page load, does it animate?
   * In some cases, it can also mean if the `Dialog` is added to the render tree with `visible` enabled,
   * does it animate?
   */
  defaultVisibleTransitionable: prop_types_default.a.bool,

  /**
   * Boolean if the Dialog should no longer try to prevent the parent container from scrolling while visible.
   * In most cases, this will attempt to prevent the main window scrolling. If this dialog is nested in another
   * dialog, it will attempt to prevent the parent dialog from scrolling.
   */
  disableScrollLocking: prop_types_default.a.bool,

  /**
   * Boolean if the dialog should automatically try to determine if the content
   * should be padded. It will be padded if the dialog does not contain a `List`.
   */
  autopadContent: prop_types_default.a.bool,

  /**
   * Boolean if the dialog content's size should automatically be resized to overflow
   * correctly when there is a lot of content. This will calculate and apply some `maxHeight`
   * to the `contentStyle`.
   */
  autosizeContent: prop_types_default.a.bool,

  /**
   * An optional height to apply to the dialog. This is used if it is easier to just apply height/width
   * with for specific dialogs instead of in CSS.
   *
   * **This prop should not be used if the `fullPage` prop is enabled.**
   *
   * @see {@link #fullPage}
   * @see {@link #width}
   */
  height: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional width to apply to the dialog. This is used if it is easier to just apply height/width
   * with for specific dialogs instead of in CSS.
   *
   * **This prop should not be used if the `fullPage` prop is enabled.**
   *
   * @see {@link #fullPage}
   * @see {@link #height}
   */
  width: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * Boolean if the actions should be stacked on top of each other. If this value is `undefined`, it will
   * automatically attempt to guess if the items should be stacked.
   */
  stackedActions: prop_types_default.a.bool,

  isOpen: deprecated_default()(prop_types_default.a.bool, 'Use `visible` instead'),
  transitionName: deprecated_default()(prop_types_default.a.string, 'The transition name will be managed by the component'),
  transitionEnter: deprecated_default()(prop_types_default.a.bool, 'The transition will always be enforced'),
  transitionLeave: deprecated_default()(prop_types_default.a.bool, 'The transition will always be enforced'),
  actionLeft: deprecated_default()(prop_types_default.a.node, 'Use the `fullPage` prop instead'),
  actionRight: deprecated_default()(prop_types_default.a.node, 'Use the `fullPage` prop instead'),
  close: deprecated_default()(prop_types_default.a.func, 'Use `onHide` instead')
};
DialogContainer_DialogContainer.defaultProps = {
  autopadContent: true,
  autosizeContent: true,
  component: 'span',
  closeOnEsc: true,
  contentComponent: 'section',
  focusOnMount: true,
  transitionEnterTimeout: 300,
  transitionLeaveTimeout: 300,
  defaultVisibleTransitionable: false
};
DialogContainer_DialogContainer.contextTypes = {
  renderNode: prop_types_default.a.object
};

var DialogContainer_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setContainer = function (container) {
    if (container !== null) {
      _this2._container = Object(react_dom["findDOMNode"])(container);
    }
  };

  this._handleEscClose = function (e) {
    if ((e.which || e.keyCode) === ESC) {
      (_this2.props.onHide || _this2.props.close)(e);
    }
  };

  this._mountPortal = function (props) {
    _this2._mountDialog(props);
    _this2.setState({ portalVisible: true });
  };

  this._mountDialog = function (props) {
    var fullPage = props.fullPage,
        onShow = props.onShow;

    _this2._inTimeout = setTimeout(function () {
      _this2._inTimeout = fullPage ? null : setTimeout(function () {
        _this2._inTimeout = null;
        _this2.setState({ active: true });
      }, CSSTransitionGroupTick);
      _this2.setState({ dialogVisible: true }, onShow);
    }, CSSTransitionGroupTick);
  };

  this._unmountPortal = function () {
    _this2.setState({ portalVisible: false });
  };

  this._handleClick = function (e) {
    var visible = typeof _this2.props.isOpen !== 'undefined' ? _this2.props.isOpen : _this2.props.visible;
    if (_this2.props.modal || !visible || e.target !== _this2._container) {
      return;
    }

    (_this2.props.onHide || _this2.props.close)(e);
  };

  this._handleDialogMounting = function (dialog) {
    var disableScrollLocking = _this2.props.disableScrollLocking;

    if (dialog === null) {
      if (_this2._activeElement && _this2._activeElement.focus) {
        _this2._activeElement.focus();
      }

      if (!disableScrollLocking) {
        toggleScroll(false, _this2.scrollEl);
      }

      _this2._activeElement = null;
    } else {
      var container = document.getElementById(_this2.props.id);
      if (!container || disableScrollLocking) {
        return;
      }

      var el = getField(_this2.props, _this2.context, 'renderNode');
      var node = container.parentNode;
      while (node && node.classList && !el) {
        if (node.classList.contains('md-dialog')) {
          el = node;
        }

        node = node.parentNode;
      }

      _this2.scrollEl = el;
      toggleScroll(true, el);
    }
  };
};

/* harmony default export */ var Dialogs_DialogContainer = (DialogContainer_DialogContainer);
// CONCATENATED MODULE: ../node_modules/react-md/es/constants/media.js
var MOBILE_MIN_WIDTH = 320;
var TABLET_MIN_WIDTH = 768;
var DESKTOP_MIN_WIDTH = 1025;
// CONCATENATED MODULE: ../node_modules/react-md/es/Drawers/Overlay.js
function Overlay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Overlay_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Overlay_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var Overlay_Overlay = function (_PureComponent) {
  Overlay_inherits(Overlay, _PureComponent);

  function Overlay() {
    Overlay_classCallCheck(this, Overlay);

    return Overlay_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Overlay.prototype.getChildContext = function getChildContext() {
    // Always want the overlay to render in a separate subtree until 1.1.0
    return { isInPortal: false };
  };

  Overlay.prototype.render = function render() {
    var _props = this.props,
        active = _props.active,
        visible = _props.visible,
        renderNode = _props.renderNode,
        onClick = _props.onClick,
        style = _props.style,
        className = _props.className;

    return react_default.a.createElement(
      Helpers_Portal,
      { visible: visible, renderNode: renderNode },
      react_default.a.createElement('div', {
        style: style,
        className: classnames_default()('md-overlay md-overlay--drawer md-pointer--hover', {
          'md-overlay--active': active
        }, className),
        onClick: onClick
      })
    );
  };

  return Overlay;
}(react["PureComponent"]);

Overlay_Overlay.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  active: prop_types_default.a.bool,
  visible: prop_types_default.a.bool.isRequired,
  renderNode: prop_types_default.a.object,
  onClick: prop_types_default.a.func
};
Overlay_Overlay.childContextTypes = {
  isInPortal: prop_types_default.a.bool
};
/* harmony default export */ var Drawers_Overlay = (Overlay_Overlay);
// CONCATENATED MODULE: ../node_modules/react-md/es/Drawers/DrawerTypes.js
/** @module Drawers/DrawerTypes */

/**
 * An enum for all the different type of drawers.
 *
 * @readonly
 * @enum {string}
 */
var DrawerTypes = {
  // Permanent drawers
  /**
   * This is the default drawer type. It will always be on the screen and takes
   * up the entire height. This is very helpful for main navigation on desktops
   * when you do not need an expandable workspace.
   */
  FULL_HEIGHT: 'full-height',

  /**
   * This drawer type will always be on the screen, but it will appear under the
   * main toolbar.
   */
  CLIPPED: 'clipped',

  /**
   * This drawer type will always be on the screen, but it will appear under the
   * main toolbar and have a transparent background. This is useful if you want
   * a persistent drawer on desktop screens, but do not want the main focus to be
   * the drawer.
   */
  FLOATING: 'floating',

  // Persistent drawers
  /**
   * A persistent drawer changes between being hidden and being fixed on the page like
   * a permanent drawer. When it is visible, it will take up the same amount of room
   * as a permanent drawer, and will not go away until closed.
   *
   * This drawer type is helpful when you need to have a dynamic workspace size.
   */
  PERSISTENT: 'persistent',

  /**
   * This is a modification of the persistent drawer. It will behave as the persistent drawer
   * but it will always have a "mini" drawer visible. This is helpful when you want to have
   * a dynamic workspace size and keep certain actions available at all times.
   */
  PERSISTENT_MINI: 'persistent-mini',

  // Temporary
  /**
   * A temporary drawer will not be visible by default. When it is visible, it will overlay
   * the page to get the main focus on the drawer. When the user touches the overlay or
   * one of the navigation items, the drawer will be closed. The overlay can be disabled on
   * desktop and tablets.
   */
  TEMPORARY: 'temporary',

  /**
   * This is a modification of the temporary drawer. It will behave like a temporary drawer,
   * but it will always have a "mini" drawer visible. Just like the `PERSISTENT_MINI` drawer
   * type, this is useful when certain actions should be available at all times but additional
   * actions are available when the drawer is visible.
   */
  TEMPORARY_MINI: 'temporary-mini'
};

/* harmony default export */ var Drawers_DrawerTypes = (DrawerTypes);
// CONCATENATED MODULE: ../node_modules/react-md/es/Drawers/isType.js

var FULL_HEIGHT = Drawers_DrawerTypes.FULL_HEIGHT,
    CLIPPED = Drawers_DrawerTypes.CLIPPED,
    FLOATING = Drawers_DrawerTypes.FLOATING,
    PERSISTENT = Drawers_DrawerTypes.PERSISTENT,
    PERSISTENT_MINI = Drawers_DrawerTypes.PERSISTENT_MINI,
    TEMPORARY = Drawers_DrawerTypes.TEMPORARY,
    TEMPORARY_MINI = Drawers_DrawerTypes.TEMPORARY_MINI;


function isTemporary(type) {
  return [TEMPORARY, TEMPORARY_MINI].indexOf(type) !== -1;
}

function isPersistent(type) {
  return [PERSISTENT, PERSISTENT_MINI].indexOf(type) !== -1;
}

function isPermanent(type) {
  return [FULL_HEIGHT, CLIPPED, FLOATING].indexOf(type) !== -1;
}

function isMini(type) {
  return [PERSISTENT_MINI, TEMPORARY_MINI].indexOf(type) !== -1;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Drawers/Drawer.js
var Drawer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Drawer_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Drawer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Drawer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Drawer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




















var oneOfDrawerTypes = prop_types_default.a.oneOf([Drawers_DrawerTypes.FULL_HEIGHT, Drawers_DrawerTypes.CLIPPED, Drawers_DrawerTypes.FLOATING, Drawers_DrawerTypes.PERSISTENT, Drawers_DrawerTypes.PERSISTENT_MINI, Drawers_DrawerTypes.TEMPORARY, Drawers_DrawerTypes.TEMPORARY_MINI]);

/**
 * The `Drawer` component is used for having a sliding panel of content or navigation
 * that appears from the side of a screen.
 *
 * If the `Drawer` uses any of the `_MINI` drawer types, you will need to also create another
 * `Drawer` that is not `_MINI`. Transitioning the `width` on mobile devices is very sluggish,
 * and it isn't much more work to create another drawer.
 */

var Drawer_Drawer = function (_PureComponent) {
  Drawer_inherits(Drawer, _PureComponent);

  /**
   * Determines the current media and returns an object containing matches for `mobile`, `tablet`, `desktop`,
   * and the current drawer type. This expects a `props` object of the drawer.
   *
   * If this is used server side, it will default to only matching mobile.
   *
   * @param {Object=} props - The current drawer's prop shape to extract the mobile, tablet,
   *    and desktop type/min widths. This defaults to the drawer's default props.
   * @return {Object} an object containing the media matches and the current type to use for the drawer.
   */
  Drawer.getCurrentMedia = function getCurrentMedia() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Drawer.defaultProps;
    var mobileMinWidth = props.mobileMinWidth,
        tabletMinWidth = props.tabletMinWidth,
        desktopMinWidth = props.desktopMinWidth,
        mobileType = props.mobileType,
        tabletType = props.tabletType,
        desktopType = props.desktopType,
        constantType = props.constantType;

    if (typeof window === 'undefined') {
      var _type = constantType && props.type ? props.type : mobileType;
      return { mobile: true, tablet: false, desktop: false, type: _type };
    }

    var mobile = Drawer.matchesMedia(mobileMinWidth, tabletMinWidth - 1);
    var tablet = Drawer.matchesMedia(tabletMinWidth, desktopMinWidth);
    var desktop = Drawer.matchesMedia(desktopMinWidth);

    var type = void 0;
    if (constantType && props.type && isTemporary(props.type)) {
      type = props.type;
    } else if (desktop) {
      type = desktopType;
    } else if (tablet) {
      type = tabletType;
    } else {
      type = mobileType;
    }

    return { type: type, mobile: mobile, tablet: tablet, desktop: desktop };
  };

  /**
   * Simply does a `window.matchMedia(query)` where the query gets defined as a min width
   * and optional max width.
   *
   * @param {number} min - The min width for the media query.
   * @param {number=} max - An optional max width to include for the media query.
   * @return {boolean} true if the media matches.
   */


  Drawer.matchesMedia = function matchesMedia(min, max) {
    var media = 'screen and (min-width: ' + min + 'px)';
    if (max) {
      media += ' and (max-width: ' + max + 'px)';
    }

    return window.matchMedia(media).matches;
  };

  function Drawer(props) {
    Drawer_classCallCheck(this, Drawer);

    var _this = Drawer_possibleConstructorReturn(this, _PureComponent.call(this, props));

    Drawer_initialiseProps.call(_this);

    var defaultVisible = props.defaultVisible,
        defaultMedia = props.defaultMedia,
        overlay = props.overlay;


    _this.state = {
      mobile: defaultMedia === 'mobile',
      tablet: defaultMedia === 'tablet',
      desktop: defaultMedia === 'desktop',
      animating: false,
      overlayActive: false,
      drawerActive: false
    };

    if (typeof props.type === 'undefined') {
      _this.state.type = props[defaultMedia + 'Type'];
    }

    var type = getField(props, _this.state, 'type');
    _this._initialFix = true;

    if (typeof props.visible === 'undefined') {
      var _visible = isPermanent(type) || isMini(type);
      if (!_visible && typeof defaultVisible !== 'undefined') {
        _visible = defaultVisible;
      }

      _this.state.visible = _visible;
    }

    var visible = getField(props, _this.state, 'visible');

    _this.state.overlayActive = (typeof overlay !== 'undefined' ? overlay : isTemporary(type) && !_this.state.desktop) && visible;
    _this.state.drawerActive = visible;
    return _this;
  }

  Drawer.prototype.componentWillMount = function componentWillMount() {
    if (typeof window !== 'undefined') {
      this._updateType(this.props);
    }
  };

  Drawer.prototype.componentDidMount = function componentDidMount() {
    if (!isMini(getField(this.props, this.state, 'type'))) {
      window.addEventListener('resize', this._updateMedia);
    }
  };

  Drawer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        mobileMinWidth = _props.mobileMinWidth,
        mobileType = _props.mobileType,
        tabletMinWidth = _props.tabletMinWidth,
        tabletType = _props.tabletType,
        desktopMinWidth = _props.desktopMinWidth,
        desktopType = _props.desktopType;


    if (nextProps.mobileMinWidth !== mobileMinWidth || nextProps.mobileType !== mobileType || nextProps.tabletMinWidth !== tabletMinWidth || nextProps.tabletType !== tabletType || nextProps.desktopMinWidth !== desktopMinWidth || nextProps.desktopType !== desktopType) {
      this._updateType(nextProps);
    }

    var visible = nextProps.visible,
        transitionDuration = nextProps.transitionDuration,
        overlay = nextProps.overlay;

    if (this.props.visible === nextProps.visible) {
      return;
    }

    var type = getField(nextProps, this.state, 'type');
    this._animate(visible, type, transitionDuration, overlay, this.state.desktop);
  };

  Drawer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    if (this._closeTimeout) {
      clearTimeout(this._closeTimeout);
    }

    window.removeEventListener('resize', this._updateMedia);
  };

  Drawer.prototype.render = function render() {
    var _cn;

    var _state = this.state,
        overlayActive = _state.overlayActive,
        drawerActive = _state.drawerActive,
        animating = _state.animating;

    var _props2 = this.props,
        id = _props2.id,
        style = _props2.style,
        className = _props2.className,
        navStyle = _props2.navStyle,
        navClassName = _props2.navClassName,
        component = _props2.component,
        navItems = _props2.navItems,
        header = _props2.header,
        children = _props2.children,
        inline = _props2.inline,
        position = _props2.position,
        overlay = _props2.overlay,
        clickableDesktopOverlay = _props2.clickableDesktopOverlay,
        lastChild = _props2.lastChild,
        portal = _props2.portal,
        overlayStyle = _props2.overlayStyle,
        overlayClassName = _props2.overlayClassName,
        propType = _props2.type,
        propVisible = _props2.visible,
        propRenderNode = _props2.renderNode,
        propNavItemsId = _props2.navItemsId,
        propZDepth = _props2.zDepth,
        constantType = _props2.constantType,
        defaultVisible = _props2.defaultVisible,
        defaultMedia = _props2.defaultMedia,
        mobileType = _props2.mobileType,
        mobileMinWidth = _props2.mobileMinWidth,
        tabletType = _props2.tabletType,
        tabletMinWidth = _props2.tabletMinWidth,
        desktopType = _props2.desktopType,
        desktopMinWidth = _props2.desktopMinWidth,
        transitionDuration = _props2.transitionDuration,
        onMediaTypeChange = _props2.onMediaTypeChange,
        onVisibilityChange = _props2.onVisibilityChange,
        autoclose = _props2.autoclose,
        autocloseAfterInk = _props2.autocloseAfterInk,
        onVisibilityToggle = _props2.onVisibilityToggle,
        closeOnNavItemClick = _props2.closeOnNavItemClick,
        props = Drawer_objectWithoutProperties(_props2, ['id', 'style', 'className', 'navStyle', 'navClassName', 'component', 'navItems', 'header', 'children', 'inline', 'position', 'overlay', 'clickableDesktopOverlay', 'lastChild', 'portal', 'overlayStyle', 'overlayClassName', 'type', 'visible', 'renderNode', 'navItemsId', 'zDepth', 'constantType', 'defaultVisible', 'defaultMedia', 'mobileType', 'mobileMinWidth', 'tabletType', 'tabletMinWidth', 'desktopType', 'desktopMinWidth', 'transitionDuration', 'onMediaTypeChange', 'onVisibilityChange', 'autoclose', 'autocloseAfterInk', 'onVisibilityToggle', 'closeOnNavItemClick']);

    var _props3 = this.props,
        navItemsId = _props3.navItemsId,
        zDepth = _props3.zDepth;

    if (!navItemsId && id) {
      navItemsId = id + '-nav-items';
    }

    var desktop = this.state.desktop;

    var renderNode = getField(this.props, this.context, 'renderNode');
    var type = getField(this.props, this.state, 'type');
    var visible = getField(this.props, this.state, 'visible');
    var mini = isMini(type);
    var temporary = isTemporary(type);
    var floating = Drawers_DrawerTypes.FLOATING === type;
    var permanent = isPermanent(type);

    var Component = void 0;
    if (component) {
      Component = component;
    } else if (navItems) {
      Component = 'nav';
    } else {
      Component = 'aside';
    }

    var navigation = void 0;
    if (navItems) {
      navigation = react_default.a.createElement(
        Lists_List,
        {
          ref: this._setNavigation,
          key: 'navigation',
          id: navItemsId,
          style: navStyle,
          className: classnames_default()('md-list--drawer', {
            'md-toolbar-relative': mini && !visible,
            'md-background': floating
          }, navClassName),
          onClick: this._handleNavClick
        },
        navItems.map(mapToListParts)
      );
    }

    if (typeof zDepth === 'undefined') {
      zDepth = 1;
      if (floating || inline) {
        zDepth = 0;
      } else if (!mini && temporary) {
        zDepth = 5;
      }
    }

    var overlayVisible = overlay;
    if (typeof overlayVisible !== 'boolean') {
      overlayVisible = temporary && !mini && (!desktop || clickableDesktopOverlay) && (animating || visible);
    }

    var drawer = react_default.a.createElement(
      Papers_Paper,
      Drawer_extends({}, props, {
        id: id,
        key: 'drawer',
        component: Component,
        zDepth: zDepth,
        raiseOnHover: false,
        style: style,
        className: classnames_default()('md-drawer', (_cn = {}, _cn['md-drawer--' + position] = !inline, _cn['md-drawer--fixed'] = !inline, _cn['md-drawer--inline'] = inline, _cn['md-drawer--active'] = mini || drawerActive, _cn['md-drawer--mini'] = mini, _cn['md-transition--deceleration'] = !mini && !permanent && visible, _cn['md-transition--acceleration'] = !mini && !permanent && !visible, _cn['md-background'] = inline || floating, _cn['md-background--card'] = !floating && !inline, _cn), className)
      }),
      header,
      navigation,
      children,
      react_default.a.createElement(Drawers_Overlay, {
        style: overlayStyle,
        className: overlayClassName,
        active: overlayActive,
        onClick: this._closeDrawer,
        visible: overlayVisible,
        renderNode: renderNode
      })
    );

    if (inline || permanent) {
      return drawer;
    } else if (!portal) {
      return mini || animating || visible ? drawer : null;
    }

    return react_default.a.createElement(
      Helpers_Portal,
      { visible: animating || visible, renderNode: renderNode, lastChild: lastChild },
      drawer
    );
  };

  return Drawer;
}(react["PureComponent"]);

Drawer_Drawer.DrawerTypes = Drawers_DrawerTypes;
Drawer_Drawer.propTypes = {
  /**
   * An optional id to provide to the drawer. This is generally a good idea to provide if
   * there are any `navItems` defined.
   *
   * @see {@link #navItemsId}
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the navItems list. If this is omitted and the `id` prop is
   * defined, it will be defaulted to `${id}-nav-items`.
   */
  navItemsId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the `List` surrounding the `navItems`.
   */
  navStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the `List` surrounding the `navItems`.
   */
  navClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the overlay.
   */
  overlayStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the overlay.
   */
  overlayClassName: prop_types_default.a.string,

  /**
   * An optional component to render the drawer in. When this prop is undefined, the drawer
   * will be rendered as a `nav` if the `navItems` prop is defined, otherwise an `aside`.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.element]),

  /**
   * An optional list of navigation items to display in the drawer. This list can either contain
   * a valid child component for a `List` or an object used to create a `Divider`, `Subheader`,
   * or `ListItem`.
   *
   * - To create a divider in the list, set a `divider` key to `true`. Any other keys will be
   * passed to the `Divider` component.
   * - To create a subheader in the list, set the `subheader` key to `true`. Any other keys will
   * be passed to the `Subheader` component.
   * - To create a list item, just create an object with any normal `ListItem` props.
   */
  navItems: prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.shape({
    divider: prop_types_default.a.bool,
    subheader: prop_types_default.a.bool,
    primaryText: prop_types_default.a.node
  })])),

  /**
   * Boolean if a temporary drawer should close when a nav item is clicked.
   */
  autoclose: prop_types_default.a.bool,

  /**
   * An optional header to display. This _should_ normally be a toolbar.
   */
  header: prop_types_default.a.node,

  /**
   * Any additional children to display after the `header` and `navItems`.
   */
  children: prop_types_default.a.node,

  /**
   * The drawer type to use when the current device matches the mobile
   * media query.
   */
  mobileType: prop_types_default.a.oneOf([Drawer_Drawer.DrawerTypes.TEMPORARY, Drawer_Drawer.DrawerTypes.TEMPORARY_MINI]).isRequired,

  /**
   * The min-width to use for the mobile media query.
   */
  mobileMinWidth: prop_types_default.a.number.isRequired,

  /**
   * The drawer type to use when the current device matches the tablet
   * media query.
   */
  tabletType: oneOfDrawerTypes.isRequired,

  /**
   * The min-width to use for the tablet media query.
   */
  tabletMinWidth: prop_types_default.a.number.isRequired,

  /**
   * The drawer type to use when the current device matches the desktop media
   * query.
   */
  desktopType: oneOfDrawerTypes.isRequired,

  /**
   * The min-width for a desktop screen.
   */
  desktopMinWidth: prop_types_default.a.number.isRequired,

  /**
   * An optional type to enforce across all media sizes. Since `mobile` devices are
   * included, you are required to manually specify when the `type` should be `temporary`.
   *
   * When the `type` is not one of the `temporary` types, the `onMediaTypeChange` prop
   * must be provided.
   */
  type: function type(props, propName, component) {
    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      others[_key - 3] = arguments[_key];
    }

    var type = props[propName];
    if (isTemporary(type)) {
      return oneOfDrawerTypes.apply(undefined, [props, propName, component].concat(others));
    }

    var err = oneOfDrawerTypes.apply(undefined, [props, propName, component].concat(others));
    if (!err && typeof type !== 'undefined' && !isMini(type) && typeof props.onMediaTypeChange === 'undefined') {
      err = new Error('You provided a `' + propName + '` prop to the ' + component + ' without the `onMediaTypeChange` ' + ('handler. The `onMediaTypeChange` prop must be specified when the `' + propName + '` is not ') + 'one of the `temporary` types.');
    }

    return err;
  },

  /**
   * An optional function to call when the drawer's type changes when the screen resizes.
   * The callback will include the new `type` that should be used for the screen size,
   * and an object containing the media matches for `mobile`, `tablet`, and `desktop`.
   *
   * ```js
   * this.props.onMediaTypeChange(Drawer.DrawerTypes.TEMPORARY, {
   *   mobile: true,
   *   tablet: false,
   *   desktop: false,
   * });
   * ```
   */
  onMediaTypeChange: prop_types_default.a.func,

  /**
   * The default drawer type to display on initial render. The drawer will automatically
   * adjust itself to the correct media once it has mounted. This prop is really only useful
   * for server side rendering.
   */
  defaultMedia: prop_types_default.a.oneOf(['mobile', 'tablet', 'desktop']).isRequired,

  /**
   * Boolean if there should be a visible overlay when the drawer is visible. The default behavior
   * is to only include a visible overlay when the `type` is `TEMPORARY` or `TEMPORARY_MINI` and
   * the device is not a desktop.
   *
   * Definining this variable as `true` or `false` will override any default behavior. This means that
   * if this is enabled for a full-height drawer, an overlay will still be created.
   */
  overlay: prop_types_default.a.bool,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the drawer. The overlay that appears for temporary type drawers will still appear in the
   * separate subtree.
   *
   * @see {@link Helpers/Portal}
   */
  portal: prop_types_default.a.bool,

  /**
   * An optional DOM Node to render the drawer into. The default is to render as
   * the first child in the `body`.
   *
   * > This prop will not be used when the drawer is of the permanent type or `inline` is specified
   * since the `Portal` component will not be used.
   */
  renderNode: prop_types_default.a.object,

  /**
   * Boolean if the drawer should be rendered as the last child instead of the first child
   * in the `renderNode` or `body`.
   *
   * > This prop will not be used when the drawer is of the permanent type or `inline` is specified
   * since the `Portal` component will not be used.
   */
  lastChild: prop_types_default.a.bool,

  /**
   * Boolean if the drawer is visible by default. If this is omitted, the drawer will be visible
   * if the current drawer type is NOT `Drawer.DrawerTypes.TEMPORARY` or `Drawer.DrawerTypes.TEMPORARY_MINI`.
   *
   * This basically means that if you are using the default configuration, a mobile device's drawer
   * will be hidden while tablets and desktops will be visible.
   */
  defaultVisible: prop_types_default.a.bool,

  /**
   * Boolean if the drawer is visible. This will force the component to define the `onVisibilityChange`
   * prop as well as manually updating the drawer's visibility.
   */
  visible: controlled(prop_types_default.a.bool, 'onVisibilityChange', 'defaultVisible'),

  /**
   * An optional function to call when the visibility of the drawer is changed. The function will
   * be called with the new visibility state.
   *
   * ```js
   * onVisibilityChange(!currentlyVisible);
   * ```
   */
  onVisibilityChange: prop_types_default.a.func,

  /**
   * The drawer's position on the page when it is not `inline`. When the drawer's position is `left`,
   * the width will be `calc(100vw - 56px)` on mobile devices and `$md-drawer-desktop-width` on desktops.
   *
   * When the position is `right`, the width will be `100vw` for mobile devices and scaling to the drawer's
   * children width on desktops.
   */
  position: prop_types_default.a.oneOf(['left', 'right']).isRequired,

  /**
   * Boolean if the drawer should be displayed inline instead of fixed to the page. When this prop
   * is enabled, the `position` prop will not be used.
   */
  inline: prop_types_default.a.bool,

  /**
   * The `$md-drawer-transition-time` value from sass.
   */
  transitionDuration: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the temporary drawer's overlay should be created on desktop screens. This is really used so that
   * the drawer will close when a user clicks anywhere on the page except in the drawer.
   */
  clickableDesktopOverlay: prop_types_default.a.bool,

  /**
   * Boolean if the `autoclose` feature should wait for the ink transition to finish before automatically
   * closing the drawer. This will add a `300ms` delay. If this is `false`, there will only be a `17ms` delay.
   *
   * > The delay is required so that any event listeners will still be correctly invoked when an item is clicked.
   */
  autocloseAfterInk: prop_types_default.a.bool,

  /**
   * Boolean if the `type` prop should be constant across all media sizes. This is only valid if the `type` is
   * one of the temporary types.
   *
   * This will basically mean that when attempting to do a media adjustment, it will use the `type` prop instead of
   * `mobileType`, `tabletType`, and `desktopType` to determine the next drawer type.
   */
  constantType: prop_types_default.a.bool.isRequired,

  /**
   * An optional zDepth to apply to the drawer. If this is omitted, the value will be set as follows:
   * - floating || inline = 1
   * - temporary = 5
   * - all others = 1
   *
   * @see {@link Papers/Paper#zDepth}
   */
  zDepth: prop_types_default.a.number,

  closeOnNavItemClick: deprecated_default()(prop_types_default.a.bool, 'Use `autoclose` instead'),
  onVisibilityToggle: deprecated_default()(prop_types_default.a.func, 'Use `onVisibilityChange` instead')
};
Drawer_Drawer.defaultProps = {
  defaultMedia: 'mobile',
  mobileType: Drawer_Drawer.DrawerTypes.TEMPORARY,
  mobileMinWidth: MOBILE_MIN_WIDTH,
  tabletType: Drawer_Drawer.DrawerTypes.PERSISTENT,
  tabletMinWidth: TABLET_MIN_WIDTH,
  desktopType: Drawer_Drawer.DrawerTypes.FULL_HEIGHT,
  desktopMinWidth: DESKTOP_MIN_WIDTH,
  position: 'left',
  transitionDuration: 300,
  autoclose: true,
  clickableDesktopOverlay: true,
  constantType: true
};
Drawer_Drawer.contextTypes = {
  renderNode: prop_types_default.a.object
};

var Drawer_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._updateType = function (props) {
    var onMediaTypeChange = props.onMediaTypeChange,
        overlay = props.overlay,
        transitionDuration = props.transitionDuration;


    var onVisibilityChange = props.onVisibilityToggle || props.onVisibilityChange;

    var state = Drawer_Drawer.getCurrentMedia(props);
    var diffType = getField(props, _this2.state, 'type') !== state.type;
    var diffMedia = state.mobile !== _this2.state.mobile || state.tablet !== _this2.state.tablet || state.desktop !== _this2.state.desktop;

    if (onMediaTypeChange && (diffType || diffMedia)) {
      onMediaTypeChange(state.type, { mobile: state.mobile, tablet: state.tablet, desktop: state.desktop });
    }

    if (diffType) {
      var visible = isPermanent(state.type);
      if (_this2._initialFix) {
        if (props.defaultVisible) {
          visible = props.defaultVisible;
        } else if (props.visible) {
          visible = props.visible;
        }
      }

      var prevVisible = getField(props, _this2.state, 'visible');
      if (onVisibilityChange && visible !== prevVisible) {
        onVisibilityChange(visible);
      }

      if (typeof props.visible === 'undefined') {
        state.visible = visible;
        _this2._animate(visible, state.type, transitionDuration, overlay, state.desktop);
      }
    } else if (_this2._initialFix && diffMedia) {
      state.overlayActive = (typeof overlay !== 'undefined' ? overlay : isTemporary(state.type) && !state.desktop) && getField(props, _this2.state, 'visible');
    }

    if (typeof props.type !== 'undefined') {
      var _state2 = state,
          type = _state2.type,
          realState = Drawer_objectWithoutProperties(_state2, ['type']); // eslint-disable-line no-unused-vars


      state = realState;
    }

    _this2._initialFix = false;
    _this2.setState(state);
  };

  this._updateMedia = function () {
    _this2._updateType(_this2.props);
  };

  this._animate = function (visible, type, timeout, overlay, desktop) {
    if (_this2._timeout) {
      clearTimeout(_this2._timeout);
    }

    if (visible) {
      _this2._timeout = setTimeout(function () {
        _this2._timeout = null;

        _this2.setState({
          overlayActive: overlay || isTemporary(type) && !desktop,
          drawerActive: true,
          animating: true
        });
      }, CSSTransitionGroupTick);
    } else {
      _this2._timeout = setTimeout(function () {
        _this2._timeout = null;

        _this2.setState({ animating: false });
      }, timeout);
      _this2.setState({ animating: true, overlayActive: false, drawerActive: false });
    }
  };

  this._setNavigation = function (navigation) {
    _this2._navigation = Object(react_dom["findDOMNode"])(navigation);
  };

  this._handleNavClick = function (e) {
    var _props4 = _this2.props,
        closeOnNavItemClick = _props4.closeOnNavItemClick,
        autoclose = _props4.autoclose,
        autocloseAfterInk = _props4.autocloseAfterInk;

    var enabled = typeof closeOnNavItemClick !== 'undefined' ? closeOnNavItemClick : autoclose;
    if (!enabled || !isTemporary(getField(_this2.props, _this2.state, 'type'))) {
      return;
    }

    var target = e.target;

    while (target && _this2._navigation.contains(target)) {
      if (target.classList.contains('md-list-tile')) {
        // Clicked a nav item that has a nested list
        if (target.getAttribute('aria-expanded') !== null) {
          return;
        }

        _this2._closeTimeout = setTimeout(function () {
          _this2._closeTimeout = null;

          _this2._closeDrawer(e);
        }, autocloseAfterInk ? 300 : CSSTransitionGroupTick);
        return;
      }

      target = target.parentNode;
    }
  };

  this._closeDrawer = function () {
    var _props5 = _this2.props,
        onVisibilityChange = _props5.onVisibilityChange,
        onVisibilityToggle = _props5.onVisibilityToggle,
        transitionDuration = _props5.transitionDuration,
        overlay = _props5.overlay;

    var callback = onVisibilityToggle || onVisibilityChange;
    if (callback) {
      callback(false);
    }

    if (typeof _this2.props.visible === 'undefined') {
      _this2.setState({ visible: false });
      _this2._animate(false, getField(_this2.props, _this2.state, 'type'), transitionDuration, overlay, _this2.state.desktop);
    }
  };
};

/* harmony default export */ var Drawers_Drawer = (Drawer_Drawer);
// CONCATENATED MODULE: ../node_modules/react-md/es/ExpansionPanels/PanelContent.js
var PanelContent_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function PanelContent_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PanelContent_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function PanelContent_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The `PanelContent` component is for displaying the expanded content
 * for an `ExpansionPanel`. It will display any children in a `md-panel-content`
 * container followed by a `Divider` and the `PanelControls` .
 */

var PanelContent_PanelContent = function (_PureComponent) {
  PanelContent_inherits(PanelContent, _PureComponent);

  function PanelContent() {
    PanelContent_classCallCheck(this, PanelContent);

    return PanelContent_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  PanelContent.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        footerStyle = _props.footerStyle,
        footerClassName = _props.footerClassName,
        contentStyle = _props.contentStyle,
        className = _props.className,
        children = _props.children,
        onSave = _props.onSave,
        onCancel = _props.onCancel,
        saveProps = _props.saveProps,
        saveType = _props.saveType,
        saveLabel = _props.saveLabel,
        savePrimary = _props.savePrimary,
        saveSecondary = _props.saveSecondary,
        cancelProps = _props.cancelProps,
        cancelType = _props.cancelType,
        cancelLabel = _props.cancelLabel,
        cancelPrimary = _props.cancelPrimary,
        cancelSecondary = _props.cancelSecondary,
        footer = _props.footer,
        footerChildren = _props.footerChildren;


    var actions = [PanelContent_extends({
      type: cancelType,
      label: cancelLabel,
      primary: cancelPrimary,
      secondary: cancelSecondary
    }, cancelProps, {
      onClick: onCancel
    }), PanelContent_extends({
      type: saveType,
      label: saveLabel,
      primary: savePrimary,
      secondary: saveSecondary
    }, saveProps, {
      onClick: onSave
    })];

    var actionFooter = null;
    if (typeof footer === 'undefined') {
      actionFooter = react_default.a.createElement(
        Dialogs_DialogFooter,
        {
          actions: actions,
          style: footerStyle,
          className: classnames_default()('md-divider-border md-divider-border--top', footerClassName)
        },
        footerChildren
      );
    } else if (footer !== null) {
      actionFooter = footer;
    }

    return react_default.a.createElement(
      'div',
      { style: style },
      react_default.a.createElement(
        'div',
        { className: classnames_default()('md-panel-content', className), style: contentStyle },
        children
      ),
      actionFooter
    );
  };

  return PanelContent;
}(react["PureComponent"]);

PanelContent_PanelContent.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  footerStyle: prop_types_default.a.object,
  footerClassName: prop_types_default.a.string,
  contentStyle: prop_types_default.a.object,
  children: prop_types_default.a.node,
  onSave: prop_types_default.a.func.isRequired,
  onCancel: prop_types_default.a.func.isRequired,
  saveProps: prop_types_default.a.object,
  saveType: prop_types_default.a.string,
  saveLabel: prop_types_default.a.node.isRequired,
  savePrimary: prop_types_default.a.bool,
  saveSecondary: prop_types_default.a.bool,
  cancelProps: prop_types_default.a.object,
  cancelType: prop_types_default.a.string,
  cancelLabel: prop_types_default.a.node.isRequired,
  cancelPrimary: prop_types_default.a.bool,
  cancelSecondary: prop_types_default.a.bool,
  footer: prop_types_default.a.node,
  footerChildren: prop_types_default.a.node
};
/* harmony default export */ var ExpansionPanels_PanelContent = (PanelContent_PanelContent);
// CONCATENATED MODULE: ../node_modules/react-md/es/ExpansionPanels/ExpansionPanel.js
var ExpansionPanel_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function ExpansionPanel_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ExpansionPanel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ExpansionPanel_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ExpansionPanel_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }


















var LABEL_FONT_SIZE = 15;
var LINE_HEIGHT = 1.42857;
var SINGLE_LINE_HEIGHT = LABEL_FONT_SIZE * LINE_HEIGHT;

/**
 * The `ExpansionPanel` component needs to be used with the `ExpansionList`
 * component. The only reason is that the `ExpansionPanel` should really
 * be rendered as a table, but it was a bit hard to have a single component
 * dynamically rendering another row when expanded. It couldn't be in the
 * same row since the expanded content might not have the same columns.
 */

var ExpansionPanel_ExpansionPanel = function (_PureComponent) {
  ExpansionPanel_inherits(ExpansionPanel, _PureComponent);

  function ExpansionPanel(props, context) {
    ExpansionPanel_classCallCheck(this, ExpansionPanel);

    var _this = ExpansionPanel_possibleConstructorReturn(this, _PureComponent.call(this, props, context));

    _this._determineIfTwoLine = function () {
      var twoLine = false;
      Array.prototype.slice.call(Object(react_dom["findDOMNode"])(_this).querySelectorAll('.md-panel-column')).some(function (el) {
        return twoLine = el.offsetHeight > SINGLE_LINE_HEIGHT;
      });

      _this.setState({ twoLine: twoLine });
    };

    _this._handleClick = function () {
      var expanded = !_this._isExpanded(_this.props, _this.state);
      if (_this.props.onExpandToggle) {
        _this.props.onExpandToggle(expanded);
      }

      if (typeof _this.props.expanded === 'undefined') {
        _this.setState({ expanded: expanded });
      }
    };

    _this._handleSave = function (e) {
      var _this$props = _this.props,
          onSave = _this$props.onSave,
          onExpandToggle = _this$props.onExpandToggle,
          closeOnSave = _this$props.closeOnSave;

      if (onSave) {
        onSave(e);
      }

      if (closeOnSave) {
        if (onExpandToggle) {
          onExpandToggle(false);
        }

        if (typeof _this.props.expanded === 'undefined') {
          _this.setState({ expanded: false });
        }
      }
    };

    _this._handleCancel = function (e) {
      var _this$props2 = _this.props,
          onCancel = _this$props2.onCancel,
          onExpandToggle = _this$props2.onExpandToggle,
          closeOnCancel = _this$props2.closeOnCancel;

      if (onCancel) {
        onCancel(e);
      }

      if (closeOnCancel) {
        if (onExpandToggle) {
          onExpandToggle(false);
        }

        if (typeof _this.props.expanded === 'undefined') {
          _this.setState({ expanded: false });
        }
      }
    };

    _this.state = {
      received: false,
      twoLine: false
    };

    if (typeof props.expanded === 'undefined') {
      _this.state.expanded = props.defaultExpanded;
    }
    return _this;
  }

  ExpansionPanel.prototype.componentDidMount = function componentDidMount() {
    this._determineIfTwoLine();
  };

  ExpansionPanel.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (false) {}
  };

  ExpansionPanel.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.label === prevProps.label && this.props.secondaryLabel === prevProps.secondaryLabel) {
      return;
    }

    this._determineIfTwoLine();
  };

  ExpansionPanel.prototype._isExpanded = function _isExpanded(props, state) {
    return typeof props.expanded === 'undefined' ? state.expanded : props.expanded;
  };

  ExpansionPanel.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        label = _props.label,
        secondaryLabel = _props.secondaryLabel,
        expandedSecondaryLabel = _props.expandedSecondaryLabel,
        children = _props.children,
        focused = _props.focused,
        columnWidths = _props.columnWidths,
        saveType = _props.saveType,
        saveLabel = _props.saveLabel,
        savePrimary = _props.savePrimary,
        saveSecondary = _props.saveSecondary,
        saveProps = _props.saveProps,
        cancelType = _props.cancelType,
        cancelLabel = _props.cancelLabel,
        cancelPrimary = _props.cancelPrimary,
        cancelSecondary = _props.cancelSecondary,
        cancelProps = _props.cancelProps,
        headerStyle = _props.headerStyle,
        headerClassName = _props.headerClassName,
        contentStyle = _props.contentStyle,
        contentClassName = _props.contentClassName,
        tabIndex = _props.tabIndex,
        overflown = _props.overflown,
        footer = _props.footer,
        footerChildren = _props.footerChildren,
        footerStyle = _props.footerStyle,
        footerClassName = _props.footerClassName,
        expandIconChildren = _props.expandIconChildren,
        expandIconClassName = _props.expandIconClassName,
        propAnimateContent = _props.animateContent,
        propExpanded = _props.expanded,
        propExpanderIcon = _props.expanderIcon,
        defaultExpanded = _props.defaultExpanded,
        closeOnSave = _props.closeOnSave,
        closeOnCancel = _props.closeOnCancel,
        onSave = _props.onSave,
        onCancel = _props.onCancel,
        onExpandToggle = _props.onExpandToggle,
        props = ExpansionPanel_objectWithoutProperties(_props, ['className', 'label', 'secondaryLabel', 'expandedSecondaryLabel', 'children', 'focused', 'columnWidths', 'saveType', 'saveLabel', 'savePrimary', 'saveSecondary', 'saveProps', 'cancelType', 'cancelLabel', 'cancelPrimary', 'cancelSecondary', 'cancelProps', 'headerStyle', 'headerClassName', 'contentStyle', 'contentClassName', 'tabIndex', 'overflown', 'footer', 'footerChildren', 'footerStyle', 'footerClassName', 'expandIconChildren', 'expandIconClassName', 'animateContent', 'expanded', 'expanderIcon', 'defaultExpanded', 'closeOnSave', 'closeOnCancel', 'onSave', 'onCancel', 'onExpandToggle']);

    var twoLine = this.state.twoLine;

    var expanded = this._isExpanded(this.props, this.state);
    var animateContent = getField(this.props, this.context, 'animateContent');

    var columns = react["Children"].map(expanded && expandedSecondaryLabel || secondaryLabel, function (panelLabel, i) {
      var _ref;

      return react_default.a.createElement(
        'div',
        {
          style: (_ref = {}, _ref['' + (overflown ? 'width' : 'minWidth')] = columnWidths[i + 1], _ref),
          className: classnames_default()('md-panel-column', {
            'md-panel-column--overflown': overflown
          }, themeColors({ text: true }))
        },
        panelLabel
      );
    });

    if (!Array.isArray(columns)) {
      columns = [columns];
    }

    columns.unshift(react_default.a.createElement(
      'div',
      {
        key: 'main-label',
        style: { minWidth: columnWidths[0] },
        className: classnames_default()('md-panel-column', themeColors({ text: true }))
      },
      label
    ));

    var expanderIcon = getDeprecatedIcon(expandIconClassName, expandIconChildren, this.props.expanderIcon);
    expanderIcon = react_default.a.Children.only(expanderIcon);
    expanderIcon = react_default.a.cloneElement(expanderIcon, {
      className: getCollapserStyles({
        flipped: expanded
      }, 'md-expansion-panel__collapser md-cell--right', expanderIcon.props.className)
    });

    return react_default.a.createElement(
      Papers_Paper,
      ExpansionPanel_extends({}, props, {
        className: classnames_default()('md-expansion-panel', {
          'md-expansion-panel--expanded': expanded
        }, className),
        'aria-expanded': expanded
      }),
      react_default.a.createElement(
        Helpers_AccessibleFakeButton,
        {
          onClick: this._handleClick,
          style: headerStyle,
          className: classnames_default()('md-panel-header', {
            'md-panel-header--expanded': expanded || twoLine,
            'md-panel-header--focused': focused
          }, headerClassName),
          tabIndex: tabIndex
        },
        columns,
        expanderIcon
      ),
      react_default.a.createElement(
        Helpers_Collapse,
        { collapsed: !expanded, animate: animateContent },
        react_default.a.createElement(
          ExpansionPanels_PanelContent,
          {
            style: contentStyle,
            className: contentClassName,
            footerStyle: footerStyle,
            footerClassName: footerClassName,
            onSave: this._handleSave,
            onCancel: this._handleCancel,
            saveType: saveType,
            saveLabel: saveLabel,
            savePrimary: savePrimary,
            saveSecondary: saveSecondary,
            saveProps: saveProps,
            cancelType: cancelType,
            cancelLabel: cancelLabel,
            cancelPrimary: cancelPrimary,
            cancelSecondary: cancelSecondary,
            cancelProps: cancelProps,
            footer: footer,
            footerChildren: footerChildren
          },
          children
        )
      )
    );
  };

  return ExpansionPanel;
}(react["PureComponent"]);

ExpansionPanel_ExpansionPanel.propTypes = {
  /**
   * An optional style to apply to the panel.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the panel.
   */
  className: prop_types_default.a.string,

  /**
   * An options style to apply to the panel's header content. This is the
   * section that toggles the children to be visible and label columns.
   */
  headerStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the panel's header content. This is the
   * section that toggles the children to be visible and label columns.
   */
  headerClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the element surrounding the children when expanded.
   */
  contentStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the element surrounding the children when expanded.
   */
  contentClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the footer when the `footer` prop is `undefined`.
   *
   * @see {@link #footer}
   */
  footerStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the footer when the `footer` prop is `undefined`.
   *
   * @see {@link #footer}
   */
  footerClassName: prop_types_default.a.string,

  /**
   * The main label to display in the unexpanded panel.
   */
  label: prop_types_default.a.node.isRequired,

  /**
   * Any additional columns to display after the main label. If this is a `list`
   * instead of a singular item, they will each be formatted as a column.
   */
  secondaryLabel: prop_types_default.a.node,

  /**
   * Any additional columns to display after the main label when the panel is
   * expanded. If this is omitted, the default `secondaryLabel` will be displayed
   * instead.
   */
  expandedSecondaryLabel: prop_types_default.a.node,

  /**
   * The component to render the panel as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * The content to display once the panel is toggled open.
   */
  children: prop_types_default.a.node,

  /**
   * A boolean if the panel is currently expanded. This will force the component
   * to be controlled and require's the `onExpandToggle` function to be defined.
   */
  expanded: controlled(prop_types_default.a.bool, 'onExpandToggle', 'defaultExpanded'),

  /**
   * Boolean if an uncontrolled panel should be expanded by default.
   */
  defaultExpanded: prop_types_default.a.bool.isRequired,

  /**
   * The icon to display for expanding the expansion panel.
   */
  expanderIcon: prop_types_default.a.element,

  /**
   * Boolean if the `ExpansionPanel` is currently tab focused. This is injected
   * and managed by the `ExpansionList` component. Do not set yourself.
   */
  focused: prop_types_default.a.bool.isRequired,

  /**
   * A list of min-widths to apply to each column in the panel header. This is injected
   * and managed by the `ExpansionList` component. Do not set yourself.
   */
  columnWidths: prop_types_default.a.arrayOf(prop_types_default.a.number).isRequired,

  /**
   * Boolean if the panel has too much content so that it overflowns. This is injected
   * and managed by the `ExpansionList` component. Do not set yourself.
   *
   * When this is active, it will truncate all columns except for the main label and the
   * toggle icon.
   */
  overflown: prop_types_default.a.bool,

  /**
   * A function to call when the expansion panel's expanded state is toggled.
   * The callback for this function will include the new expanded state.
   *
   * `onExpandToggle(expanded)`
   */
  onExpandToggle: prop_types_default.a.func,

  /**
   * An optional function to call when the Save button is clicked on the expanded panel.
   */
  onSave: prop_types_default.a.func,

  /**
   * An optional function to call when the Cancel button is clicked on the expanded panel.
   */
  onCancel: prop_types_default.a.func,

  /**
   * Boolean if the panel should close when the Save button is clicked.
   */
  closeOnSave: prop_types_default.a.bool,

  /**
   * Boolean if the panel should close when the Cancel button is clicked.
   */
  closeOnCancel: prop_types_default.a.bool,

  /**
   * An optional button type to apply to the Save button. This will get
   * passed to the `FlatButton`.
   */
  saveType: prop_types_default.a.oneOf(['button', 'submit', 'reset']),

  /**
   * The label for the Save button.
   */
  saveLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the Save button should be styled with the primary color.
   */
  savePrimary: prop_types_default.a.bool,

  /**
   * Boolean if the Save button should be styled with the secondary color,
   */
  saveSecondary: prop_types_default.a.bool,

  /**
   * Any additional props to provide/override for the save button in the
   * footer of the panel.
   */
  saveProps: prop_types_default.a.object,

  /**
   * An optional button type to apply to the Cancel button. This will get
   * passed to the `FlatButton`.
   */
  cancelType: prop_types_default.a.oneOf(['button', 'submit', 'reset']),

  /**
   * The label for the Cancel button.
   */
  cancelLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the Cancel button should be styled with the primary color,
   */
  cancelPrimary: prop_types_default.a.bool,

  /**
   * Boolean if the Cancel button should be styled with the secondary color,
   */
  cancelSecondary: prop_types_default.a.bool,

  /**
   * Any additional props to provide/override for the cancel button in the
   * footer of the panel.
   */
  cancelProps: prop_types_default.a.object,

  /**
   * The tab index for the panel's header. This allows keyboard navigation.
   */
  tabIndex: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the panel's content should animate when the content's visibility changes. This
   * can also be toggled from the `ExpansionList` component if all `ExpansionPanel` in the list
   * should not animate. This only affects the height transition.
   *
   * > The default value is really `true` since it gets passed down to the `Collapse` component.
   */
  animateContent: prop_types_default.a.bool,

  /**
   * This prop controls the footer for the expansion panel. If this prop is `undefined`, it will
   * go with the default behavior of generating the save and cancel buttons with the save and cancel
   * props.
   *
   * If this value is `null`, there will be no footer created.
   *
   * Finally, if this prop is defined as any renderable item, it will be displayed in place of the
   * footer.
   *
   * @see {@link #footerChildren}
   */
  footer: prop_types_default.a.node,

  /**
   * Any additional children that should be displayed in the footer of the panel. These children
   * will be placed after the action buttons.
   */
  footerChildren: prop_types_default.a.node,
  expandIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `expanderIcon` instead'),
  expandIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `expanderIcon` instead')
};
ExpansionPanel_ExpansionPanel.defaultProps = {
  defaultExpanded: false,
  expanderIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'keyboard_arrow_down'
  ),
  component: 'li',
  saveLabel: 'Save',
  cancelLabel: 'Cancel',
  savePrimary: true,
  tabIndex: 0,
  closeOnSave: true,
  closeOnCancel: true,
  focused: false,
  columnWidths: []
};
ExpansionPanel_ExpansionPanel.contextTypes = {
  animateContent: prop_types_default.a.bool
};
/* harmony default export */ var ExpansionPanels_ExpansionPanel = (ExpansionPanel_ExpansionPanel);
// CONCATENATED MODULE: ../node_modules/react-md/es/ExpansionPanels/ExpansionList.js
var ExpansionList_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function ExpansionList_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ExpansionList_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ExpansionList_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ExpansionList_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }










/**
 * The `ExpansionList` component is a wrapper for the `ExpansionPanel` that helps
 * determine which `ExpansionPanel` currently has tab focus and adjusts the column
 * sizes in the header of the `ExpansionPanel`.
 *
 * The `ExpansionList` and `ExpansionPanel` components should have probably been
 * implemented as a `table` instead of a `ul || ol` since it is more column based,
 * but it would complicate the API to have dynamic row generation for the expanded
 * panels. The expanded panels _might_ not follow the same column widths as their labels
 * so a singular row with a div for expanded content might not work correctly.
 */

var ExpansionList_ExpansionList = function (_PureComponent) {
  ExpansionList_inherits(ExpansionList, _PureComponent);

  function ExpansionList() {
    var _temp, _this, _ret;

    ExpansionList_classCallCheck(this, ExpansionList);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = ExpansionList_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { columnWidths: [], focusedIndex: -1, overflown: false }, _this._setContainer = function (container) {
      if (container !== null) {
        _this._container = Object(react_dom["findDOMNode"])(container);
        window.addEventListener('keyup', _this._determineTabFocus);

        _this._width = _this._container.offsetWidth;
        _this._calcColumnWidths();
      }
    }, _this._determineTabFocus = function (e) {
      if ((e.which || e.keyCode) === TAB) {
        var panels = Array.prototype.slice.call(Object(react_dom["findDOMNode"])(_this).querySelectorAll('.md-panel-header'));
        _this.setState({ focusedIndex: panels.indexOf(e.target) });
      }
    }, _this._removeFocus = function () {
      _this.setState({ focusedIndex: -1 });
    }, _this._isOverflown = function (widths) {
      if (!_this._container) {
        return false;
      }

      var panel = _this._container.querySelector('.md-panel-header');
      if (!panel) {
        return false;
      }

      var collapser = _this._container.querySelector('.md-expansion-panel__collapser');
      var collapserWidth = collapser ? collapser.offsetWidth : 0;
      var styles = window.getComputedStyle(panel);
      var maxWidth = panel.offsetWidth - parseFloat(styles.paddingLeft) - parseFloat(styles.paddingRight) - collapserWidth;

      var totalWidth = widths.reduce(function (total, w) {
        return total + w;
      }, 0);
      return totalWidth > maxWidth;
    }, _this._getColumnWidths = function () {
      if (!_this._container) {
        return _this.state.columnWidths;
      }

      return [].slice.call(_this._container.querySelectorAll('.md-panel-header')).reduce(function (maxes, row) {
        var columns = row.querySelectorAll('.md-panel-column');
        for (var i = 0; i < columns.length; i++) {
          var col = columns[i];
          // Need to reset the widths if it has already been calculated to get a more accurate measurement.
          var _col$style = col.style,
              width = _col$style.width,
              minWidth = _col$style.minWidth;

          col.style.width = 'auto';
          col.style.minWidth = 'auto';

          // Only need to include the offsetWidth of the column because the child will really
          // determine the width of the column. Since it has already been defined at this point,
          // no additional work needs to be done.
          maxes[i] = Math.max(col.offsetWidth, maxes[i] || 0);
          col.style.width = width;
          col.style.minWidth = minWidth;
        }

        return maxes;
      }, [0]);
    }, _this._calcColumnWidths = function () {
      var columnWidths = _this.state.columnWidths;

      var nextWidths = _this._getColumnWidths();
      var overflown = _this._isOverflown(nextWidths);
      if (_this.state.overflown !== overflown || columnWidths.length !== nextWidths.length || nextWidths.some(function (w, i) {
        return w !== columnWidths[i];
      })) {
        _this.setState({ columnWidths: nextWidths, overflown: overflown });
      }
    }, _this._handleResize = function (_ref) {
      var width = _ref.width;
      var recalculateThreshold = _this.props.recalculateThreshold;

      if (_this._width !== width && Math.abs(width - _this._width) >= recalculateThreshold) {
        _this._width = width;
        _this._calcColumnWidths();
      }
    }, _temp), ExpansionList_possibleConstructorReturn(_this, _ret);
  }

  ExpansionList.prototype.getChildContext = function getChildContext() {
    var animateContent = this.props.animateContent;

    return { animateContent: animateContent };
  };

  ExpansionList.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.children !== nextProps.children) {
      this._calcColumnWidths();
    }
  };

  ExpansionList.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var focusedIndex = this.state.focusedIndex;

    if (prevState.focusedIndex === focusedIndex || prevState.focusedIndex > -1 && focusedIndex > -1) {
      return;
    }

    handleWindowClickListeners(this._removeFocus, this.state.focusedIndex !== -1);
  };

  ExpansionList.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.state.focusedIndex === -1) {
      handleWindowClickListeners(this._removeFocus, false);
    }

    window.removeEventListener('keyup', this._determineTabFocus);
  };

  /**
   * Since this should really be rendered as a table, need to calculate the max width for each _column_
   * on the panel's header and apply that as a min width for the other panels.
   */


  ExpansionList.prototype.render = function render() {
    var _state = this.state,
        columnWidths = _state.columnWidths,
        focusedIndex = _state.focusedIndex,
        overflown = _state.overflown;

    var _props = this.props,
        children = _props.children,
        className = _props.className,
        Component = _props.component,
        animateContent = _props.animateContent,
        recalculateThreshold = _props.recalculateThreshold,
        props = ExpansionList_objectWithoutProperties(_props, ['children', 'className', 'component', 'animateContent', 'recalculateThreshold']);

    var panels = react["Children"].map(children, function (child, i) {
      return Object(react["cloneElement"])(child, {
        key: child.key || i,
        overflown: overflown,
        columnWidths: columnWidths,
        focused: focusedIndex === i
      });
    });
    return react_default.a.createElement(
      Component,
      ExpansionList_extends({}, props, {
        ref: this._setContainer,
        className: classnames_default()('md-expansion-panel-list', className)
      }),
      react_default.a.createElement(Helpers_ResizeObserver, { watchWidth: true, onResize: this._handleResize }),
      panels
    );
  };

  return ExpansionList;
}(react["PureComponent"]);

ExpansionList_ExpansionList.propTypes = {
  /**
   * An optional style object to apply to the list.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the list.
   */
  className: prop_types_default.a.string,

  /**
   * The children should be a list or singular `ExpansionPanel` component
   * to render with some additional props injected.
   */
  children: prop_types_default.a.node,

  /**
   * The component to render the list as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * Boolean if all the expansion panels in the list should animate when their content's visibility
   * changes. This is just a quicker way to disable all animations instead of having to toggle it off
   * on each panel.
   *
   * > The default value is really `true` since it gets passed down to the `Collapse` component.
   */
  animateContent: prop_types_default.a.bool,

  /**
   * The threshold that should be used for when the list should recalculate the positioning of all
   * the columns. This will only compare the difference between updates.
   * So if the size changes from 80 -> 120 -> 160 -> 140. It will only update on the third resize (160)
   */
  recalculateThreshold: prop_types_default.a.number.isRequired
};
ExpansionList_ExpansionList.defaultProps = {
  component: 'ul',
  recalculateThreshold: 80
};
ExpansionList_ExpansionList.childContextTypes = {
  animateContent: prop_types_default.a.bool
};
/* harmony default export */ var ExpansionPanels_ExpansionList = (ExpansionList_ExpansionList);
// CONCATENATED MODULE: ../node_modules/react-md/es/FileInputs/FileInput.js
var FileInput_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function FileInput_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function FileInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FileInput_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function FileInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }














/**
 * The `FileInput` component is used as simple styling for the `<input type="file" />`.
 * It will style the input as a raised button by default.
 */

var FileInput_FileInput = function (_PureComponent) {
  FileInput_inherits(FileInput, _PureComponent);

  function FileInput() {
    var _temp, _this, _ret;

    FileInput_classCallCheck(this, FileInput);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = FileInput_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { hover: false, pressed: false }, _this._handleChange = function (e) {
      var _this$props = _this.props,
          multiple = _this$props.multiple,
          onChange = _this$props.onChange;
      var files = e.target.files;

      if (onChange) {
        if (!multiple) {
          onChange(files[0] || null, e);
        } else {
          onChange(Array.prototype.slice.call(files), e);
        }
      }
    }, _this._blur = function () {
      if (_this.props.disabled) {
        return;
      }

      if (_this._timeout) {
        _this._attemptedBlur = true;
      } else {
        _this.setState({ pressed: false });
      }
    }, _this._handleMouseUp = function (e) {
      if (_this.props.onMouseUp) {
        _this.props.onMouseUp(e);
      }

      _this._blur();
    }, _this._handleMouseDown = function (e) {
      if (_this.props.onMouseDown) {
        _this.props.onMouseDown(e);
      }

      if (!_this.props.disabled) {
        _this.setState({ pressed: true });
      }
    }, _this._handleTouchStart = function (e) {
      if (_this.props.onTouchStart) {
        _this.props.onTouchStart(e);
      }

      if (!_this.props.disabled) {
        _this.setState({ pressed: true });
      }
    }, _this._handleTouchEnd = function (e) {
      if (_this.props.onTouchEnd) {
        _this.props.onTouchEnd(e);
      }

      _this._blur();
      captureNextEvent('mouseover');
    }, _this._handleKeyUp = function (e) {
      if (_this.props.onKeyUp) {
        _this.props.onKeyUp(e);
      }

      if ((e.which || e.keyCode) === TAB) {
        window.addEventListener('click', _this._blur);
        _this.setState({ pressed: true });
      }
    }, _this._handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }

      var key = e.which || e.keyCode;

      if (key === TAB) {
        window.removeEventListener('click', _this._blur);
        _this.setState({ pressed: false });
      } else if (key === SPACE || key === ENTER) {
        e.preventDefault();
        e.target.click();
      }
    }, _this._handleMouseOver = function (e) {
      if (_this.props.onMouseOver) {
        _this.props.onMouseOver(e);
      }

      if (!_this.props.disabled) {
        _this.setState({ hover: true });
      }
    }, _this._handleMouseLeave = function (e) {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave(e);
      }

      if (!_this.props.disabled) {
        _this.setState({ hover: false });
      }
    }, _temp), FileInput_possibleConstructorReturn(_this, _ret);
  }

  FileInput.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.disabled && !nextProps.disabled && this.state.hover) {
      this.setState({ hover: false });
    }
  };

  FileInput.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {
    var _this2 = this;

    // I honestly don't remember why this was implemented, but it was copied from the Button
    // component
    if (!this.state.pressed && nextState.pressed) {
      this._timeout = setTimeout(function () {
        _this2._timeout = null;
        if (_this2._attemptedBlur) {
          _this2._attemptedBlur = false;

          _this2.setState({ pressed: false });
        }
      }, 450);
    }
  };

  FileInput.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    window.removeEventListener('click', this._blur);
  };

  FileInput.prototype.render = function render() {
    var _state = this.state,
        hover = _state.hover,
        pressed = _state.pressed;

    var _props = this.props,
        style = _props.style,
        className = _props.className,
        labelStyle = _props.labelStyle,
        labelClassName = _props.labelClassName,
        label = _props.label,
        primary = _props.primary,
        secondary = _props.secondary,
        flat = _props.flat,
        id = _props.id,
        name = _props.name,
        iconBefore = _props.iconBefore,
        disabled = _props.disabled,
        accept = _props.accept,
        multiple = _props.multiple,
        swapTheming = _props.swapTheming,
        allowDuplicates = _props.allowDuplicates,
        capture = _props.capture,
        iconChildren = _props.iconChildren,
        iconClassName = _props.iconClassName,
        propIcon = _props.icon,
        onChange = _props.onChange,
        onKeyUp = _props.onKeyUp,
        onKeyDown = _props.onKeyDown,
        onMouseUp = _props.onMouseUp,
        onMouseDown = _props.onMouseDown,
        onMouseOver = _props.onMouseOver,
        onMouseLeave = _props.onMouseLeave,
        onTouchStart = _props.onTouchStart,
        onTouchEnd = _props.onTouchEnd,
        propValue = _props.value,
        props = FileInput_objectWithoutProperties(_props, ['style', 'className', 'labelStyle', 'labelClassName', 'label', 'primary', 'secondary', 'flat', 'id', 'name', 'iconBefore', 'disabled', 'accept', 'multiple', 'swapTheming', 'allowDuplicates', 'capture', 'iconChildren', 'iconClassName', 'icon', 'onChange', 'onKeyUp', 'onKeyDown', 'onMouseUp', 'onMouseDown', 'onMouseOver', 'onMouseLeave', 'onTouchStart', 'onTouchEnd', 'value']);

    var icon = this.props.icon;

    if (iconClassName || iconChildren) {
      icon = react_default.a.createElement(
        FontIcons_FontIcon,
        { iconClassName: iconClassName },
        iconChildren
      );
    }

    var labelChildren = label;
    if (icon) {
      icon = react_default.a.cloneElement(icon, { inherit: true });
      labelChildren = react_default.a.createElement(
        Helpers_IconSeparator,
        { label: label, iconBefore: iconBefore },
        icon
      );
    }

    var value = void 0;
    if (allowDuplicates) {
      value = '';
    }

    return react_default.a.createElement(
      'div',
      FileInput_extends({}, props, {
        style: style,
        className: classnames_default()('md-inline-block md-file-input-container', className)
      }),
      react_default.a.createElement(
        AccessibleFakeInkedButton,
        {
          component: 'label',
          htmlFor: id,
          disabled: disabled,
          onTouchStart: this._handleTouchStart,
          onTouchEnd: this._handleTouchEnd,
          onMouseDown: this._handleMouseDown,
          onMouseUp: this._handleMouseUp,
          onKeyDown: this._handleKeyDown,
          onKeyUp: this._handleKeyUp,
          onMouseOver: this._handleMouseOver,
          onMouseLeave: this._handleMouseLeave,
          style: labelStyle,
          className: getBtnStyles({
            flat: flat,
            raised: !flat,
            disabled: disabled,
            primary: primary,
            secondary: secondary,
            hover: hover,
            swapTheming: swapTheming,
            pressed: pressed
          }, labelClassName)
        },
        labelChildren
      ),
      react_default.a.createElement('input', {
        id: id,
        name: name,
        accept: accept,
        type: 'file',
        multiple: multiple,
        disabled: disabled,
        'aria-hidden': 'true',
        className: 'md-file-input',
        onChange: this._handleChange,
        value: value,
        tabIndex: -1,
        capture: capture
      })
    );
  };

  return FileInput;
}(react["PureComponent"]);

FileInput_FileInput.propTypes = {
  /**
   * The id for the text field. This is required for a11y and to get the `input type="file"` to
   * open.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])),

  /**
   * An optional name to provide to the input.
   */
  name: prop_types_default.a.string,

  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the label.
   */
  labelStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the label.
   */
  labelClassName: prop_types_default.a.string,

  /**
   * Boolean if the `FileInput` should be styled with the primary color.
   */
  primary: prop_types_default.a.bool,

  /**
   * Boolean if the `FileInput` should be styled with the secondary color.
   */
  secondary: prop_types_default.a.bool,

  /**
   * Boolean if the `FileInput` should be styled as a flat button instead of a
   * raised button.
   */
  flat: prop_types_default.a.bool,

  /**
   * Boolean if the theming should be swapped from text to background or vice-versa.
   *
   * @see {@link Buttons/Button#swapTheming}
   */
  swapTheming: prop_types_default.a.bool,

  /**
   * This should be a comma separated list of Media Types that the `FileInput` can
   * accept. If this prop is left blank, any file will be accepted.
   *
   * The values can either be:
   * - A file extension
   * - audio/*
   * - video/*
   * - image/*
   * - any valid [IANA Media Type](http://www.iana.org/assignments/media-types/media-types.xhtml)
   *
   * > NOTE: IE does not enforce this.
   */
  accept: prop_types_default.a.string,

  /**
   * Boolean if the same file is allowed to be uploaded multiple times. This will basically make the
   * `value` of the file input always blank.
   */
  allowDuplicates: prop_types_default.a.bool,

  /**
   * Boolean if multiple files will be accepted.
   */
  multiple: prop_types_default.a.bool,

  /**
   * A label to display on the `FileInput`. This will be used with the `AccessibleFakeInkedButton` component to
   * create a `<label>` for the `<input type="file">`.
   */
  label: prop_types_default.a.node,

  /**
   * Boolean if the icons should appear before the label.
   */
  iconBefore: prop_types_default.a.bool,

  /**
   * An optional icon to display with the file download. This can be a `FontIcon` or an `SVGIcon`.
   */
  icon: prop_types_default.a.element,

  /**
   * A function to call when the value of the input changes. This will
   * be triggered when the user selects a new file or cancels the new file selection.
   *
   * This function will be given the new [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)
   * as an array and the change event. If this is not a multiple file input, only the
   * newly selected File will be given instead of a list of one file. Since this is an
   * `input` tag, the user will not be able to select the same file multiple times unless
   * you manually clear the input's value.
   *
   * > NOTE: If the user hits cancel, null will be given for a single file input.
   *
   * ```js
   * onChange(files, e);
   * ```
   */
  onChange: prop_types_default.a.func,

  /**
   * This prop tells mobile browsers that the input would prefer the user to get the image/video from
   * the camera instead of using the file browser. This will be completely ignored by desktop browsers.
   *
   * Providing `'user'` will select the front facing camera while `'environment'` will select the rear facing
   * camera.
   *
   * @see https://developers.google.com/web/fundamentals/media/capturing-images/
   */
  capture: prop_types_default.a.oneOf(['user', 'environment']),

  /**
   * Boolean if the `FileInput` is currently disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * An optional function to call when they keyup event is triggered on the file input's label.
   */
  onKeyUp: prop_types_default.a.func,

  /**
   * An optional function to call when they keydown event is triggered on the file input's label.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * An optional function to call when they mouseup event is triggered on the file input's label.
   */
  onMouseUp: prop_types_default.a.func,

  /**
   * An optional function to call when they mousedown event is triggered on the file input's label.
   */
  onMouseDown: prop_types_default.a.func,

  /**
   * An optional function to call when they mouseover event is triggered on the file input's label.
   */
  onMouseOver: prop_types_default.a.func,

  /**
   * An optional function to call when they mouseleave event is triggered on the file input's label.
   */
  onMouseLeave: prop_types_default.a.func,

  /**
   * An optional function to call when they touchend event is triggered on the file input's label.
   */
  onTouchEnd: prop_types_default.a.func,

  /**
   * An optional function to call when they touchstart event is triggered on the file input's label.
   */
  onTouchStart: prop_types_default.a.func,

  iconChildren: deprecated_default()(prop_types_default.a.node, 'Use `icon` instead'),
  iconClassName: deprecated_default()(prop_types_default.a.string, 'Use `icon` instead'),
  value: deprecated_default()(prop_types_default.a.string, 'There should\'t be a reason to set the value manually. Check out {@link #allowDuplicates} instead')
};
FileInput_FileInput.defaultProps = {
  label: 'Select a file',
  icon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'file_upload'
  ),
  allowDuplicates: false
};
/* harmony default export */ var FileInputs_FileInput = (FileInput_FileInput);
// CONCATENATED MODULE: ../node_modules/react-md/es/FileInputs/FileUpload.js
var FileUpload_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function FileUpload_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function FileUpload_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FileUpload_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function FileUpload_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









/**
 * The `FileUpload` component is used to upload files locally This is a wrapper of the `FileInput` component
 * with some additional functionality so any props that are undocumented on `FileUpload` but are present
 * on `FileInput` are correctly provided. If you want to upload files to a server, use
 * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)
 * by attaching the `File`.
 *
 * Quick example:
 *
 * ```js
 * function upload(file) {
 *   fetch('/api/images', {
 *     method: 'POST',
 *     body: new FormData().append('file', file),
 *   });
 * }
 * ```
 *
 * An upload can be aborted by calling the `abort(file || fileName)` function. If
 * the file or fileName are omitted, it will *attempt* to abort the current
 * file that is uploading. Unreliable for multi-select.
 *
 * ```js
 * <FileUpload ref="upload" />
 * <Button raised onClick={() => this.refs.upload.abort()} label="Abort! Abort!" />
 * ```
 */

var FileUpload_FileUpload = function (_PureComponent) {
  FileUpload_inherits(FileUpload, _PureComponent);

  function FileUpload() {
    var _temp, _this, _ret;

    FileUpload_classCallCheck(this, FileUpload);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = FileUpload_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = {}, _this.abort = function (file) {
      var fileName = file;
      if (!file) {
        // Attempt to remove first file added...
        fileName = Object.keys(_this.state)[0];
      } else if (typeof file.name === 'string') {
        fileName = file.name;
      }

      var reader = _this.state[fileName];
      if (reader) {
        reader.abort();
        Object(react_dom["findDOMNode"])(_this).querySelector('.md-file-input').value = '';

        _this.setState(omit(_this.state, [fileName]));
      }
    }, _this._uploadFile = function (file) {
      var _this$props = _this.props,
          onAbort = _this$props.onAbort,
          onError = _this$props.onError,
          onLoad = _this$props.onLoad,
          onLoadStart = _this$props.onLoadStart,
          onLoadEnd = _this$props.onLoadEnd,
          onProgress = _this$props.onProgress,
          readAs = _this$props.readAs;
      var name = file.name,
          type = file.type;


      var fr = new FileReader();
      if (onError) {
        fr.onerror = function (e) {
          onError(file, e.target.error, e);
        };
      }

      if (onAbort) {
        fr.onabort = function (e) {
          onAbort(file, e);
        };
      }

      if (onLoadStart) {
        fr.onloadstart = function (e) {
          onLoadStart(file, e);
        };
      }

      if (onLoadEnd) {
        fr.onloadend = function (e) {
          onLoadEnd(file, e);
        };
      }

      fr.onload = function (e) {
        if (onLoad) {
          onLoad(file, e.target.result, e);
        }

        _this.setState(omit(_this.state, [name]));
      };

      if (onProgress) {
        fr.onprogress = function (e) {
          if (e.lengthComputable) {
            onProgress(file, e.loaded / e.total * 100, e);
          }
        };
      }

      if (readAs) {
        if (typeof readAs === 'function') {
          readAs(type, file, fr);
        } else {
          fr['readAs' + readAs](file);
        }
      } else if (type.match(/image|video|audio|application\/pdf/) || name.match(/\.mkv$/)) {
        fr.readAsDataURL(file);
      } else if (type.match(/application\/json/)) {
        fr.readAsText(file);
      } else if (type.match(/application|model|multipart/) || name.match(/(w|e)ar$/)) {
        fr.readAsArrayBuffer(file);
      } else {
        fr.readAsText(file);
      }

      return fr;
    }, _this._handleUpload = function (fileList, e) {
      if (_this.props.onChange) {
        _this.props.onChange(fileList, e);
      }

      if (!fileList) {
        return;
      }
      var _this$props2 = _this.props,
          maxSize = _this$props2.maxSize,
          onSizeError = _this$props2.onSizeError;

      var files = Array.isArray(fileList) ? fileList : [fileList];

      var errorFiles = [];
      if (maxSize) {
        errorFiles = files.filter(function (file) {
          return file.size > maxSize;
        });
        files = files.filter(function (file) {
          return file.size <= maxSize;
        });
      }

      if (errorFiles.length) {
        onSizeError(errorFiles);
      }

      if (!files.length) {
        return;
      }

      var nextState = {};
      files.forEach(function (file) {
        var fileReader = _this._uploadFile(file);
        nextState[file.name] = fileReader;
      });

      _this.setState(nextState);
    }, _temp), FileUpload_possibleConstructorReturn(_this, _ret);
  }

  /**
   * Attempts to abort the upload of a file. This function takes an optional `file` or `fileName`
   * as it's parameter. If the parameter is omitted, it attempts to abort the first file that was
   * added. If the `onAbort` function was given, it will be called as well.
   *
   * @param {Object|string} file - The file or the file name to use to find the
   *     correct `FileReader`.
   */


  FileUpload.prototype.render = function render() {
    var _props = this.props,
        maxSize = _props.maxSize,
        readAs = _props.readAs,
        onLoad = _props.onLoad,
        onLoadStart = _props.onLoadStart,
        onLoadEnd = _props.onLoadEnd,
        onProgress = _props.onProgress,
        onAbort = _props.onAbort,
        onError = _props.onError,
        onSizeError = _props.onSizeError,
        props = FileUpload_objectWithoutProperties(_props, ['maxSize', 'readAs', 'onLoad', 'onLoadStart', 'onLoadEnd', 'onProgress', 'onAbort', 'onError', 'onSizeError']);

    return react_default.a.createElement(FileInputs_FileInput, FileUpload_extends({}, props, { onChange: this._handleUpload }));
  };

  return FileUpload;
}(react["PureComponent"]);

FileUpload_FileUpload.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the label.
   */
  labelStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the label.
   */
  labelClassName: prop_types_default.a.string,

  /**
   * Boolean if the `FileInput` should be styled with the primary color.
   */
  primary: prop_types_default.a.bool,

  /**
   * Boolean if the `FileInput` should be styled with the secondary color.
   */
  secondary: prop_types_default.a.bool,

  /**
   * Boolean if the `FileInput` should be styled as a flat button instead of a
   * raised button.
   */
  flat: prop_types_default.a.bool,

  /**
   * This should be a comma separated list of Media Types that the `FileInput` can
   * accept. If this prop is left blank, any file will be accepted.
   *
   * The values can either be:
   * - A file extension
   * - audio/*
   * - video/*
   * - image/*
   * - any valid [IANA Media Type](http://www.iana.org/assignments/media-types/media-types.xhtml)
   */
  accept: prop_types_default.a.string,

  /**
   * Boolean if multiple files will be accepted.
   */
  multiple: prop_types_default.a.bool,

  /**
   * A label to display on the `FileInput`.
   */
  label: prop_types_default.a.node,

  /**
   * The icon children to use for the upload icon.
   */
  iconChildren: prop_types_default.a.node,

  /**
   * The icon className to use for the upload icon.
   */
  iconClassName: prop_types_default.a.string,

  /**
   * An optional max size for the file. If the file is greater than
   * this limit, the file will not be uploaded.
   */
  maxSize: prop_types_default.a.number,

  /**
   * A required function to call when the `maxSize` prop is set. It will
   * be given a list of files that were too big.
   */
  onSizeError: function onSizeError(props, propName, component) {
    for (var _len2 = arguments.length, others = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      others[_key2 - 3] = arguments[_key2];
    }

    if (typeof props.maxSize === 'number') {
      var _PropTypes$func;

      return (_PropTypes$func = prop_types_default.a.func).isRequired.apply(_PropTypes$func, [props, propName, component].concat(others));
    }

    return null;
  },

  /**
   * You can force the `FileReader` to read the file as a specific type
   * if you do not trust the *amazing* regex I have for choosing the correct
   * one.
   *
   * ```js
   * if(type.match(/image|video|audio/)) {
   *   fr.readAsDataURL(file);
   * } else if(type.match(/application|model|multipart/)) {
   *   fr.readAsArrayBuffer(file);
   * } else {
   *   fr.readAsText(file);
   * }
   * ```
   *
   * > `.yml` and `.js` both are considered `application`, so it definitely fails there.
   *
   * If this prop is a function, you will be given the file's type, the file object, and
   * the file reader. You will then need to call `fileReader.readAsYOUR_CORRECT_TYPE(file)`.
   */
  readAs: prop_types_default.a.oneOfType([prop_types_default.a.oneOf(['DataURL', 'ArrayBuffer', 'Text']), prop_types_default.a.func]),

  /**
   * An optional function to call when the `FileUpload` aborts. The current
   * file and the abort event are given. This might not be the most useful
   * function to use since you will need to manually call abort yourself anyways.
   */
  onAbort: prop_types_default.a.func,

  /**
   * An optional function to call when the `FileUpload` errors. The current
   * file, the error, and the error event are given.
   *
   * ```js
   * onError(file, event.target.error, event);
   * ```
   */
  onError: prop_types_default.a.func,

  /**
   * An optional function to call when the `FileUpload` loads. The current
   * file, the load result, and the load event are given.
   *
   * ```js
   * onLoad(file, event.target.result, event);
   * ```
   *
   * The load result will either be:
   * - a data URL
   * - a plain text string
   * - an array buffer
   *
   * depending on what type the file is.
   */
  onLoad: prop_types_default.a.func,

  /**
   * An optional function to call when the `FileUpload` starts loading. The current
   * file and the load start event are given.
   */
  onLoadStart: prop_types_default.a.func,

  /**
   * An optional function to call when the `FileUpload` finishes loading. The
   * current file and the load end event are given.
   */
  onLoadEnd: prop_types_default.a.func,

  /**
   * An optional function to call when the `FileUpload` progress. The current
   * file, upload progress, and the progress event are given. The progress
   * will be a number between 0 and 100 that has not been rounded.
   *
   * ```js
   * onProgress(file, progress, event);
   * ```
   */
  onProgress: prop_types_default.a.func,

  /**
   * Boolean if the same file is allowed to be uploaded multiple times. This will basically make the
   * `value` of the file input always blank.
   */
  allowDuplicates: prop_types_default.a.bool,

  /**
   * An optional function to call when a file selects or unselects a file.
   * This will be called before any local uploading occurs.
   *
   * ```js
   * onChange(file(s) || null, event);
   * ```
   */
  onChange: prop_types_default.a.func,

  /**
   * This prop tells mobile browsers that the input would prefer the user to get the image/video from
   * the camera instead of using the file browser. This will be completely ignored by desktop browsers.
   *
   * Providing `'user'` will select the front facing camera while `'environment'` will select the rear facing
   * camera.
   *
   * @see https://developers.google.com/web/fundamentals/media/capturing-images/
   */
  capture: prop_types_default.a.oneOf(['user', 'environment']),
  value: deprecated_default()(prop_types_default.a.string, 'There should\'t be a reason to set the value manually. Check out {@link #allowDuplicates} instead')
};
/* harmony default export */ var FileInputs_FileUpload = (FileUpload_FileUpload);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/bem.js
var bem_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** @module utils/bem */


/**
 * A utility function to apply BEM class names to an element.
 *
 * ### Examples:
 * ```js
 * bem('class') === 'class'
 * bem('block', 'element') === 'block__element'
 * bem('block', 'element', 'sub-element') === 'block__element__sub-element'
 * bem('block', { 'mod-1': true, 'mod-2': false }) === 'block block--mod-1'
 * bem('block', 'element', { 'mod-1': false, 'mod-2': true }) === 'block__element block__element--mod-2'
 * bem('block', 'element', {
 *   'mod-1': false,
 *   'mod-2': true,
 * }, 'other', 'class-names') === 'block__element block__element--mod-2 other class-names'
 * ```
 *
 * @param {...String} blocks - 1 to many blocks to use. These names will be joined
 *    with underscores.
 * @param {Object=} modifiers - Any conditional modifiers to apply to the blocks. Each
 *    key in this object will be applied as a `--suffix` to the blocks ONLY when
 *    their value is true-ish.
 * @param {...String} others - Any additional class names to apply.
 * @return {String} the bem-formatted className string.
 */
function bem() {
  var base = [];
  var modifiers = null;
  var remaining = -1;

  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  args.some(function (arg, i) {
    if (arg) {
      var type = typeof arg === 'undefined' ? 'undefined' : bem_typeof(arg);
      if (type === 'number' || type === 'string') {
        base.push(arg);
      } else if (type === 'object') {
        modifiers = arg;
        remaining = i + 1;
      }
    }
    return modifiers;
  });

  var element = base.join('__');
  if (modifiers) {
    modifiers = Object.keys(modifiers).reduce(function (obj, key) {
      obj[element + '--' + key] = modifiers[key];
      return obj;
    }, {});
  }
  var classes = remaining > -1 ? args.slice(remaining) : null;
  return classnames_default()(element, modifiers, classes).trim();
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Grids/Grid.js
var Grid_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Grid_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Grid_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Grid_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Grid_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var Grid_DIFF_KEYS = ['className', 'stacked', 'container', 'noSpacing', 'gutter', 'spacing'];

var Grid_Grid = function (_PureComponent) {
  Grid_inherits(Grid, _PureComponent);

  /**
   * A utility function to get the grid's className based on the Grid's props. This is
   * used behind the scenes to merge and create the className for the grid.
   *
   * ### Example:
   * ```js
   * <div className={Grid.getClassName()}>A base grid</div>
   * <div className={Grid.getClassName({ stacked: true })}>A stacked Grid</div>
   * ```
   *
   * @param {Object=} props - This should be an object of the `Grid`'s props. It
   *    will extract the needed keys and generate the className.
   * @return {String} the full className to use for the grid
   */
  Grid.getClassName = function getClassName() {
    var _bem;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var className = props.className,
        stacked = props.stacked,
        noSpacing = props.noSpacing,
        gutter = props.gutter,
        spacing = props.spacing,
        container = props.container;

    return bem('md-grid', (_bem = {
      'stacked': stacked,
      'no-spacing': noSpacing
    }, _bem[gutter + '-' + spacing] = isValued(gutter) && isValued(spacing), _bem[container] = container, _bem), className);
  };

  function Grid(props) {
    Grid_classCallCheck(this, Grid);

    var _this = Grid_possibleConstructorReturn(this, _PureComponent.call(this));

    _this.state = { className: Grid.getClassName(props) };
    return _this;
  }

  Grid.prototype.componentWillMount = function componentWillMount() {
    this.setState({ className: Grid.getClassName(this.props) });
  };

  Grid.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (Grid_DIFF_KEYS.some(function (key) {
      return _this2.props[key] !== nextProps[key];
    })) {
      this.setState({ className: Grid.getClassName(nextProps) });
    }
  };

  Grid.prototype.render = function render() {
    var className = this.state.className;

    var _props = this.props,
        style = _props.style,
        Component = _props.component,
        children = _props.children,
        propClassName = _props.className,
        container = _props.container,
        stacked = _props.stacked,
        noSpacing = _props.noSpacing,
        gutter = _props.gutter,
        spacing = _props.spacing,
        props = Grid_objectWithoutProperties(_props, ['style', 'component', 'children', 'className', 'container', 'stacked', 'noSpacing', 'gutter', 'spacing']);

    if (typeof children === 'function') {
      return children({ style: style, className: className });
    }

    return react_default.a.createElement(
      Component,
      Grid_extends({}, props, { style: style, className: className }),
      children
    );
  };

  return Grid;
}(react["PureComponent"]);

Grid_Grid.propTypes = {
  /**
   * An optional style to apply to the Grid component. This will only be applied
   * if the `children` prop is not a callback function.
   *
   * @see {@link #children}
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the Grid component. This will only be applied
   * if the `children` prop is not a callback function.
   *
   * @see {@link #children}
   */
  className: prop_types_default.a.string,

  /**
   * The component to render the Grid as. This should probably not be used as much
   * as the `children` callback function.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]),

  /**
   * The children can either be renderable React elements or a callback function
   * that accepts the style and className props to apply so that the styles can
   * be manually added to whichever component.
   */
  children: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.node]),

  /**
   * An optional container name to apply to the Grid. This should be the same name as provided
   * to the [react-md-make-grid-container](/components/grids?tab=2#mixin-react-md-make-grid-container) mixin.
   */
  container: prop_types_default.a.string,

  /**
   * Boolean if the grid should be placed vertically instead of horizontally.
   */
  stacked: prop_types_default.a.bool,

  /**
   * Boolean if all the gutters and spacing should be removed from the grid.
   */
  noSpacing: prop_types_default.a.bool,

  /**
   * When the [react-md-make-custom-grid](/components/grids?tab=2#mixin-react-md-make-custom-grid) mixin
   * is used, you can use the `gutter` and `spacing` props on the `Grid` to apply the correct className
   */
  gutter: prop_types_default.a.number,

  /**
   * When the [react-md-make-custom-grid](/components/grids?tab=2#mixin-react-md-make-custom-grid) mixin
   * is used, you can use the `gutter` and `spacing` props on the `Grid` to apply the correct className
   */
  spacing: prop_types_default.a.number
};
Grid_Grid.defaultProps = {
  component: 'div',
  stacked: false,
  noSpacing: false
};
/* harmony default export */ var Grids_Grid = (Grid_Grid);
// CONCATENATED MODULE: ../node_modules/react-md/es/Grids/Cell.js
var Cell_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Cell_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Cell_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Cell_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Cell_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var Cell_DIFF_KEYS = ['className', 'align', 'position', 'size', 'offset', 'order', 'phoneSize', 'phoneOrder', 'phoneOffset', 'phoneHidden', 'tabletSize', 'tabletOrder', 'tabletOffset', 'tabletHidden', 'desktopSize', 'desktopOrder', 'desktopOffset', 'desktopHidden'];

var Cell_Cell = function (_PureComponent) {
  Cell_inherits(Cell, _PureComponent);

  /**
   * A utility function to get the cell's className based on the Cell's props. This is
   * used behind the scenes to merge and create the className for the cell.
   *
   * ### Example:
   * ```js
   * <div className={Cell.getClassName()}>A simple cell</div>
   * <div className={Cell.getClassName({ size: 1 })}>A cell with size 1</div>
   * ```
   *
   * @param {Object=} props - This should be an object of the `Cell`'s props. It
   *    will extract the needed keys and generate the className.
   * @return {String} the full className to use for the cell
   */
  Cell.getClassName = function getClassName() {
    var _bem;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var className = props.className,
        align = props.align,
        position = props.position,
        size = props.size,
        order = props.order,
        offset = props.offset,
        phoneSize = props.phoneSize,
        phoneOrder = props.phoneOrder,
        phoneOffset = props.phoneOffset,
        phoneHidden = props.phoneHidden,
        tabletSize = props.tabletSize,
        tabletOrder = props.tabletOrder,
        tabletOffset = props.tabletOffset,
        tabletHidden = props.tabletHidden,
        desktopSize = props.desktopSize,
        desktopOrder = props.desktopOrder,
        desktopOffset = props.desktopOffset,
        desktopHidden = props.desktopHidden;


    return bem('md-cell', (_bem = {}, _bem[align] = align, _bem[position] = position, _bem[size] = size, _bem['order-' + order] = order, _bem[offset + '-offset'] = offset, _bem[phoneSize + '-phone'] = phoneSize, _bem['order-' + phoneOrder + '-phone'] = phoneOrder, _bem[phoneOffset + '-phone-offset'] = phoneOffset, _bem['phone-hidden'] = phoneHidden, _bem[tabletSize + '-tablet'] = tabletSize, _bem['order-' + tabletOrder + '-tablet'] = tabletOrder, _bem[tabletOffset + '-tablet-offset'] = tabletOffset, _bem['tablet-hidden'] = tabletHidden, _bem[desktopSize + '-desktop'] = desktopSize, _bem['order-' + desktopOrder + '-desktop'] = desktopOrder, _bem[desktopOffset + '-desktop-offset'] = desktopOffset, _bem['desktop-hidden'] = desktopHidden, _bem), className);
  };

  function Cell(props) {
    Cell_classCallCheck(this, Cell);

    var _this = Cell_possibleConstructorReturn(this, _PureComponent.call(this));

    _this.state = { className: Cell.getClassName(props) };
    return _this;
  }

  Cell.prototype.componentWillMount = function componentWillMount() {
    this.setState({ className: Cell.getClassName(this.props) });
  };

  Cell.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (Cell_DIFF_KEYS.some(function (key) {
      return _this2.props[key] !== nextProps[key];
    })) {
      this.setState({ className: Cell.getClassName(nextProps) });
    }
  };

  Cell.prototype.render = function render() {
    var className = this.state.className;

    var _props = this.props,
        style = _props.style,
        Component = _props.component,
        children = _props.children,
        propClassName = _props.className,
        align = _props.align,
        position = _props.position,
        size = _props.size,
        offset = _props.offset,
        order = _props.order,
        phoneSize = _props.phoneSize,
        phoneOrder = _props.phoneOrder,
        phoneOffset = _props.phoneOffset,
        phoneHidden = _props.phoneHidden,
        tabletSize = _props.tabletSize,
        tabletOrder = _props.tabletOrder,
        tabletOffset = _props.tabletOffset,
        tabletHidden = _props.tabletHidden,
        desktopSize = _props.desktopSize,
        desktopOrder = _props.desktopOrder,
        desktopOffset = _props.desktopOffset,
        desktopHidden = _props.desktopHidden,
        props = Cell_objectWithoutProperties(_props, ['style', 'component', 'children', 'className', 'align', 'position', 'size', 'offset', 'order', 'phoneSize', 'phoneOrder', 'phoneOffset', 'phoneHidden', 'tabletSize', 'tabletOrder', 'tabletOffset', 'tabletHidden', 'desktopSize', 'desktopOrder', 'desktopOffset', 'desktopHidden']);

    if (typeof children === 'function') {
      return children({ style: style, className: className });
    }

    return react_default.a.createElement(
      Component,
      Cell_extends({}, props, { style: style, className: className }),
      children
    );
  };

  return Cell;
}(react["PureComponent"]);

Cell_Cell.propTypes = {
  /**
   * An optional style to apply to the Cell component. This will only be applied
   * if the `children` prop is not a callback function.
   *
   * @see {@link #children}
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the Cell component. This will only be applied
   * if the `children` prop is not a callback function.
   *
   * @see {@link #children}
   */
  className: prop_types_default.a.string,

  /**
   * The component to render the Cell as. This should probably not be used as much
   * as the `children` callback function.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]),

  /**
   * The children can either be renderable React elements or a callback function
   * that accepts the style and className props to apply so that the styles can
   * be manually added to whichever component.
   */
  children: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.node]),

  /**
   * An optional cell alignment to apply. When the `Grid` is not `stacked`,
   * this will apply to vertical alignment within each "row" of the grid.
   *
   * Alignments:
   * - `top` - This will align to the top of the row
   * - `middle` - This will align to the middle of the row
   * - `bottom` - This will align to the bottom of the row
   * - `stretch` - This will make the cell stretch to fill all the available space
   *   in the row.
   *
   * @see {@link #position}
   */
  align: prop_types_default.a.oneOf(['top', 'middle', 'bottom', 'stretch']),

  /**
   * An optional cell position to apply. When the `Grid` is not `stacked`,
   * this will apply to horizontal alignment within each "row" of the grid.
   *
   * Positions:
   * - `center` - This will align the cell to be within the center of the row. This really
   *    just applies `margin-left: auto; margin-right: auto`.
   * - `right` - This will align the cell to the end of the row. This really just applies `margin-left: auto`.
   *
   * @see {@link #align}
   */
  position: prop_types_default.a.oneOf(['center', 'right']),

  /**
   * An optional size to apply to the cell. This sizing will be applied across all media sizes.
   * If the size is greater than the number of columns allowed for the media size, it will just
   * span the entire width.
   */
  size: prop_types_default.a.number,

  /**
   * An optional order to apply to the cell. This order will be applied across all media sizes.
   */
  order: prop_types_default.a.number,

  /**
   * An optional offset to apply to the cell. This will add spacing to the left of the cell.
   */
  offset: prop_types_default.a.number,

  /**
   * An optional size to apply to the cell only on phones.
   */
  phoneSize: prop_types_default.a.number,

  /**
   * An optional order to apply to the cell only on phones.
   */
  phoneOrder: prop_types_default.a.number,

  /**
   * An optional offset to apply to the cell only on phones.
   */
  phoneOffset: prop_types_default.a.number,

  /**
   * Boolean if the cell should be hidden on phones only.
   */
  phoneHidden: prop_types_default.a.bool,

  /**
   * An optional size to apply to the cell only on tablets.
   */
  tabletSize: prop_types_default.a.number,

  /**
   * An optional order to apply to the cell only on tablets.
   */
  tabletOrder: prop_types_default.a.number,

  /**
   * An optional offset to apply to the cell only on tablets.
   */
  tabletOffset: prop_types_default.a.number,

  /**
   * Boolean if the cell should be hidden on tablets only.
   */
  tabletHidden: prop_types_default.a.bool,

  /**
   * An optional size to apply to the cell only on desktops.
   */
  desktopSize: prop_types_default.a.number,

  /**
   * An optional order to apply to the cell only on desktops.
   */
  desktopOrder: prop_types_default.a.number,

  /**
   * An optional offset to apply to the cell only on desktops.
   */
  desktopOffset: prop_types_default.a.number,

  /**
   * Boolean if the cell should be hidden on desktops only.
   */
  desktopHidden: prop_types_default.a.bool
};
Cell_Cell.defaultProps = {
  component: 'div',
  phoneHidden: false,
  tabletHidden: false,
  desktopHidden: false
};
/* harmony default export */ var Grids_Cell = (Cell_Cell);
// CONCATENATED MODULE: ../node_modules/react-md/es/Grids/GridList.js
var GridList_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function GridList_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function GridList_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GridList_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function GridList_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var GridList_DIFF_KEYS = ['className', 'cellClassName', 'stacked', 'container', 'noSpacing', 'gutter', 'spacing', 'align', 'position', 'size', 'offset', 'order', 'phoneSize', 'phoneOrder', 'phoneOffset', 'phoneHidden', 'tabletSize', 'tabletOrder', 'tabletOffset', 'tabletHidden', 'desktopSize', 'desktopOrder', 'desktopOffset', 'desktopHidden'];

var GridList_GridList = function (_PureComponent) {
  GridList_inherits(GridList, _PureComponent);

  /**
   * A utility function to get the grid's className based on the `Grid`'s and `Cell`'s
   * props. This is * used behind the scenes to merge and create the className for the grid.
   *
   * ### Example:
   * ```js
   * const { className, cellClassName } = GridList.getClassNames();
   * const { className, cellClassName } = GridList.getClassNames({ size: 1, container: 'custom' });
   * ```
   *
   * @param {Object=} props - This should be an object of the `Grid`'s props. It
   *    will extract the needed keys and generate the classNames.
   * @return {Object} an object containing the `className` and `cellClassName` attributes.
   */
  GridList.getClassNames = function getClassNames() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var className = props.className,
        cellClassName = props.cellClassName,
        remaining = GridList_objectWithoutProperties(props, ['className', 'cellClassName']);

    return {
      className: Grids_Grid.getClassName(GridList_extends({ className: className }, remaining)),
      cellClassName: Grids_Cell.getClassName(GridList_extends({ className: cellClassName }, remaining))
    };
  };

  function GridList(props) {
    GridList_classCallCheck(this, GridList);

    var _this = GridList_possibleConstructorReturn(this, _PureComponent.call(this));

    _this.state = GridList.getClassNames(props);
    return _this;
  }

  GridList.prototype.componentWillMount = function componentWillMount() {
    this.setState(GridList.getClassNames(this.props));
  };

  GridList.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (GridList_DIFF_KEYS.some(function (key) {
      return _this2.props[key] !== nextProps[key];
    })) {
      this.setState(GridList.getClassNames(nextProps));
    }
  };

  GridList.prototype.render = function render() {
    var _state = this.state,
        className = _state.className,
        cellClassName = _state.cellClassName;

    var _props = this.props,
        style = _props.style,
        cellStyle = _props.cellStyle,
        Component = _props.component,
        children = _props.children,
        propClassName = _props.className,
        propCellClassName = _props.cellClassName,
        container = _props.container,
        noSpacing = _props.noSpacing,
        stacked = _props.stacked,
        gutter = _props.gutter,
        spacing = _props.spacing,
        align = _props.align,
        position = _props.position,
        size = _props.size,
        offset = _props.offset,
        order = _props.order,
        phoneSize = _props.phoneSize,
        phoneOrder = _props.phoneOrder,
        phoneOffset = _props.phoneOffset,
        phoneHidden = _props.phoneHidden,
        tabletSize = _props.tabletSize,
        tabletOrder = _props.tabletOrder,
        tabletOffset = _props.tabletOffset,
        tabletHidden = _props.tabletHidden,
        desktopSize = _props.desktopSize,
        desktopOrder = _props.desktopOrder,
        desktopOffset = _props.desktopOffset,
        desktopHidden = _props.desktopHidden,
        props = GridList_objectWithoutProperties(_props, ['style', 'cellStyle', 'component', 'children', 'className', 'cellClassName', 'container', 'noSpacing', 'stacked', 'gutter', 'spacing', 'align', 'position', 'size', 'offset', 'order', 'phoneSize', 'phoneOrder', 'phoneOffset', 'phoneHidden', 'tabletSize', 'tabletOrder', 'tabletOffset', 'tabletHidden', 'desktopSize', 'desktopOrder', 'desktopOffset', 'desktopHidden']);

    if (typeof children === 'function') {
      return children({ style: style, className: className, cellStyle: cellStyle, cellClassName: cellClassName });
    }

    return react_default.a.createElement(
      Component,
      GridList_extends({}, props, { style: style, className: className }),
      react_default.a.Children.map(children, function (child) {
        if (!child) {
          return child;
        }

        var childStyle = child.props.style;
        if (cellStyle) {
          childStyle = childStyle ? GridList_extends({}, cellStyle, childStyle) : cellStyle;
        }

        return react_default.a.cloneElement(child, {
          style: childStyle,
          className: classnames_default()(child.props.className, cellClassName)
        });
      })
    );
  };

  return GridList;
}(react["PureComponent"]);

GridList_GridList.propTypes = {
  /**
   * An optional style to apply to the Grid component. This will only be applied
   * if the `children` prop is not a callback function.
   *
   * @see {@link #children}
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the Grid component. This will only be applied
   * if the `children` prop is not a callback function.
   *
   * @see {@link #children}
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to each child. This will only be applied
   * if the `children` prop is not a callback function.
   *
   * @see {@link #children}
   */
  cellStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to each child. This will only be applied
   * if the `children` prop is not a callback function.
   *
   * @see {@link #children}
   */
  cellClassName: prop_types_default.a.string,

  /**
   * The component to render the Cell as. This should probably not be used as much
   * as the `children` callback function.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]),

  /**
   * The children can either be renderable React elements or a callback function
   * that accepts the style and className props to apply so that the styles can
   * be manually added to whichever component.
   */
  children: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.node]),

  /**
   * An optional container name to apply to the Grid. This should be the same name as provided
   * to the [react-md-make-grid-container](/components/grids?tab=2#mixin-react-md-make-grid-container) mixin.
   */
  container: prop_types_default.a.string,

  /**
   * Boolean if the grid should be placed vertically instead of horizontally.
   */
  stacked: prop_types_default.a.bool,

  /**
   * Boolean if all the gutters and spacing should be removed from the grid.
   */
  noSpacing: prop_types_default.a.bool,

  /**
   * When the [react-md-make-custom-grid](/components/grids?tab=2#mixin-react-md-make-custom-grid) mixin
   * is used, you can use the `gutter` and `spacing` props on the `Grid` to apply the correct className
   */
  gutter: prop_types_default.a.number,

  /**
   * When the [react-md-make-custom-grid](/components/grids?tab=2#mixin-react-md-make-custom-grid) mixin
   * is used, you can use the `gutter` and `spacing` props on the `Grid` to apply the correct className
   */
  spacing: prop_types_default.a.number,

  /**
   * An optional cell alignment to apply. When the `Grid` is not `stacked`,
   * this will apply to vertical alignment within each "row" of the grid.
   *
   * Alignments:
   * - `top` - This will align to the top of the row
   * - `middle` - This will align to the middle of the row
   * - `bottom` - This will align to the bottom of the row
   * - `stretch` - This will make the cell stretch to fill all the available space
   *   in the row.
   *
   * @see {@link #position}
   */
  align: prop_types_default.a.oneOf(['top', 'middle', 'bottom', 'stretch']),

  /**
   * An optional cell position to apply. When the `Grid` is not `stacked`,
   * this will apply to horizontal alignment within each "row" of the grid.
   *
   * Positions:
   * - `center` - This will align the cell to be within the center of the row. This really
   *    just applies `margin-left: auto; margin-right: auto`.
   * - `right` - This will align the cell to the end of the row. This really just applies `margin-left: auto`.
   *
   * @see {@link #align}
   */
  position: prop_types_default.a.oneOf(['center', 'right']),

  /**
   * An optional size to apply to the cell. This sizing will be applied across all media sizes.
   * If the size is greater than the number of columns allowed for the media size, it will just
   * span the entire width.
   */
  size: prop_types_default.a.number,

  /**
   * An optional order to apply to the cell. This order will be applied across all media sizes.
   */
  order: prop_types_default.a.number,

  /**
   * An optional offset to apply to the cell. This will add spacing to the left of the cell.
   */
  offset: prop_types_default.a.number,

  /**
   * An optional size to apply to the cell only on phones.
   */
  phoneSize: prop_types_default.a.number,

  /**
   * An optional order to apply to the cell only on phones.
   */
  phoneOrder: prop_types_default.a.number,

  /**
   * An optional offset to apply to the cell only on phones.
   */
  phoneOffset: prop_types_default.a.number,

  /**
   * Boolean if the cell should be hidden on phones only.
   */
  phoneHidden: prop_types_default.a.bool,

  /**
   * An optional size to apply to the cell only on tablets.
   */
  tabletSize: prop_types_default.a.number,

  /**
   * An optional order to apply to the cell only on tablets.
   */
  tabletOrder: prop_types_default.a.number,

  /**
   * An optional offset to apply to the cell only on tablets.
   */
  tabletOffset: prop_types_default.a.number,

  /**
   * Boolean if the cell should be hidden on tablets only.
   */
  tabletHidden: prop_types_default.a.bool,

  /**
   * An optional size to apply to the cell only on desktops.
   */
  desktopSize: prop_types_default.a.number,

  /**
   * An optional order to apply to the cell only on desktops.
   */
  desktopOrder: prop_types_default.a.number,

  /**
   * An optional offset to apply to the cell only on desktops.
   */
  desktopOffset: prop_types_default.a.number,

  /**
   * Boolean if the cell should be hidden on desktops only.
   */
  desktopHidden: prop_types_default.a.bool
};
GridList_GridList.defaultProps = {
  component: 'div',
  stacked: false,
  noSpacing: false,
  phoneHidden: false,
  tabletHidden: false,
  desktopHidden: false
};
/* harmony default export */ var Grids_GridList = (GridList_GridList);
// CONCATENATED MODULE: ../node_modules/react-md/es/Lists/ListItemControl.js
var ListItemControl_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function ListItemControl_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ListItemControl_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ListItemControl_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ListItemControl_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









var ListItemControl_ListItemControl = function (_PureComponent) {
  ListItemControl_inherits(ListItemControl, _PureComponent);

  function ListItemControl() {
    ListItemControl_classCallCheck(this, ListItemControl);

    return ListItemControl_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  ListItemControl.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        tileStyle = _props.tileStyle,
        tileClassName = _props.tileClassName,
        primaryAction = _props.primaryAction,
        secondaryAction = _props.secondaryAction,
        primaryText = _props.primaryText,
        secondaryText = _props.secondaryText,
        threeLines = _props.threeLines,
        leftIcon = _props.leftIcon,
        leftAvatar = _props.leftAvatar,
        rightIcon = _props.rightIcon,
        rightAvatar = _props.rightAvatar,
        props = ListItemControl_objectWithoutProperties(_props, ['className', 'tileStyle', 'tileClassName', 'primaryAction', 'secondaryAction', 'primaryText', 'secondaryText', 'threeLines', 'leftIcon', 'leftAvatar', 'rightIcon', 'rightAvatar']);

    var control = react["Children"].only(primaryAction || secondaryAction);
    var text = react_default.a.createElement(Lists_ListItemText, {
      key: 'text',
      primaryText: control.props.label || primaryText,
      secondaryText: secondaryText,
      className: classnames_default()({
        'md-tile-content--left-icon': leftIcon,
        'md-tile-content--left-avatar': leftAvatar,
        'md-tile-content--left-button': primaryAction,
        'md-tile-content--right-padding': primaryAction
      })
    });
    control = Object(react["cloneElement"])(control, {
      className: classnames_default()('md-list-control', {
        'md-list-control--right': secondaryAction
      }, control.props.className),
      label: text
    });

    var leftNode = react_default.a.createElement(Lists_TileAddon, {
      key: 'left-addon',
      icon: leftIcon,
      avatar: leftAvatar
    });

    var rightNode = react_default.a.createElement(Lists_TileAddon, {
      key: 'right-addon',
      icon: rightIcon,
      avatar: rightAvatar
    });

    var icond = !!leftIcon || !!rightIcon;
    var avatard = !!leftAvatar || !!rightAvatar;

    return react_default.a.createElement(
      'li',
      ListItemControl_extends({}, props, { className: classnames_default()('md-list-item', className) }),
      react_default.a.createElement(
        'div',
        {
          style: tileStyle,
          className: classnames_default()('md-list-tile', {
            'md-list-tile--icon': !secondaryText && icond && !avatard,
            'md-list-tile--avatar': !secondaryText && avatard,
            'md-list-tile--two-lines': secondaryText && !threeLines,
            'md-list-tile--three-lines': secondaryText && threeLines,
            'md-list-tile--control-left': primaryAction,
            'md-list-tile--control-right': secondaryAction
          }, themeColors({ text: true }), tileClassName)
        },
        leftNode,
        control,
        rightNode
      )
    );
  };

  return ListItemControl;
}(react["PureComponent"]);

ListItemControl_ListItemControl.propTypes = {
  /**
   * An optional style to apply to the `.md-list-item`.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the `.md-list-item`.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the `.md-list-tile`.
   */
  tileStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the `.md-list-tile`.
   */
  tileClassName: prop_types_default.a.string,

  /**
   * The primary text to display in the `ListItemControl`. The `primaryAction` or
   * `secondaryAction` will end up getting the `label` prop injected into it with
   * a combination of the `primaryText` and `secondaryText`. If the `primaryAction`
   * or `secondaryAction` already have a label prop, the `label` prop will be used
   * as the `primaryText`.
   */
  primaryText: prop_types_default.a.node,

  /**
   * An optional secondary text that can be displayed in the label of the `primaryAction`
   * or `secondaryAction`.
   */
  secondaryText: prop_types_default.a.node,

  /**
   * Boolean if the primary and secondary text will span three lines.
   */
  threeLines: prop_types_default.a.bool,

  /**
   * The primary action of the `ListItemControl`. This _should_ normally
   * be a type of `SelectionControl`
   */
  primaryAction: prop_types_default.a.element,

  /**
   * The secondary action of the `ListItemControl`. This _should_ normally
   * be a type of `SelectionControl`. If it is a selection control,
   * make sure to add the `labelBefore` prop to get correct positioning.
   */
  secondaryAction: prop_types_default.a.element,

  /**
   * An optional `FontIcon` to display to the left of the action.
   */
  leftIcon: prop_types_default.a.node,

  /**
   * An optional `Avatar` to display to the left of the action.
   */
  leftAvatar: prop_types_default.a.node,

  /**
   * An optional `FontIcon` to display to the right of the action.
   */
  rightIcon: prop_types_default.a.node,

  /**
   * An optional `FontIcon` to display to the right of the action.
   */
  rightAvatar: prop_types_default.a.node,

  /**
   * Defines the number of items in the list. This is only required when all items in the
   * list are not present in the DOM.
   *
   * @see https://www.w3.org/TR/wai-aria/states_and_properties#aria-setsize
   */
  'aria-setsize': prop_types_default.a.number,

  /**
   * Defines the items position in the list. This is only required when all items in the list
   * are not present in the DOM. The custom validation just requires this prop if the `aria-setsize`
   * prop is defined as a helpful reminder.
   *
   * @see https://www.w3.org/TR/wai-aria/states_and_properties#aria-posinset
   */
  'aria-posinset': function ariaPosinset(props, propName) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var validator = prop_types_default.a.number;
    if (typeof props['aria-setsize'] !== 'undefined') {
      validator = validator.isRequired;
    }

    return validator.apply(undefined, [props, propName].concat(args));
  }
};
/* harmony default export */ var Lists_ListItemControl = (ListItemControl_ListItemControl);
// CONCATENATED MODULE: ../node_modules/react-md/es/Media/Media.js
var Media_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Media_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Media_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Media_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Media_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





function validateAspectRatio(props, propName, component) {
  var _PropTypes$string;

  var value = props[propName];

  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  var err = (_PropTypes$string = prop_types_default.a.string).isRequired.apply(_PropTypes$string, [props, propName, component].concat(args));
  if (!err && value.split('-').length !== 2) {
    err = new Error('Your provided an `' + propName + '` prop to the ' + component + ' that is not a valid ' + ('aspect ratio `' + value + '`. This should be in the form of \'{width}-{height}\'.'));
  }

  return err;
}

/**
 * The `Media` component is used to display images, iframes, ...media. Who'da thunk?
 */

var Media_Media = function (_PureComponent) {
  Media_inherits(Media, _PureComponent);

  function Media() {
    Media_classCallCheck(this, Media);

    return Media_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Media.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        Component = _props.component,
        className = _props.className,
        children = _props.children,
        forceAspect = _props.forceAspect,
        aspectRatio = _props.aspectRatio,
        expandable = _props.expandable,
        props = Media_objectWithoutProperties(_props, ['component', 'className', 'children', 'forceAspect', 'aspectRatio', 'expandable']);

    return react_default.a.createElement(
      Component,
      Media_extends({}, props, {
        className: classnames_default()('md-media', (_cn = {}, _cn['md-media--' + aspectRatio] = forceAspect, _cn), className)
      }),
      children
    );
  };

  return Media;
}(react["PureComponent"]);

Media_Media.propTypes = {
  /**
   * An optional className to apply to the card media component.
   */
  className: prop_types_default.a.string,

  /**
   * Any media to display.
   */
  children: prop_types_default.a.node,

  /**
   * Boolean if the aspect ratio should be forced.
   */
  forceAspect: prop_types_default.a.bool,

  /**
   * The aspect ratio to use.
   */
  aspectRatio: validateAspectRatio,

  /**
   * Boolean if this component should be expandable when there is a `CardExpander`
   * above it in the `Card`.
   */
  expandable: prop_types_default.a.bool,

  /**
   * The component to render the card media as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired
};
Media_Media.defaultProps = {
  forceAspect: true,
  aspectRatio: '16-9',
  component: 'section'
};
/* harmony default export */ var es_Media_Media = (Media_Media);
// CONCATENATED MODULE: ../node_modules/react-md/es/Media/MediaOverlay.js
var MediaOverlay_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function MediaOverlay_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function MediaOverlay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MediaOverlay_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MediaOverlay_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The `MediaOverlay` component is just a very simple wrapper that adds the
 * `.md-media-overlay` class name to a div. The overlay will be positioned
 * at the bottom of the `Media` by default.
 */

var MediaOverlay_MediaOverlay = function (_PureComponent) {
  MediaOverlay_inherits(MediaOverlay, _PureComponent);

  function MediaOverlay() {
    MediaOverlay_classCallCheck(this, MediaOverlay);

    return MediaOverlay_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  MediaOverlay.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        Component = _props.component,
        props = MediaOverlay_objectWithoutProperties(_props, ['className', 'component']);

    return react_default.a.createElement(Component, MediaOverlay_extends({ className: classnames_default()('md-media-overlay', className) }, props));
  };

  return MediaOverlay;
}(react["PureComponent"]);

MediaOverlay_MediaOverlay.propTypes = {
  /**
   * An optional style to apply to the overlay.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the overlay.
   */
  className: prop_types_default.a.string,

  /**
   * Any children to display in the overlay. This is _normally_ a `CardTitle` component
   * or some buttons.
   */
  children: prop_types_default.a.node,

  /**
   * The component to be rendered as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired
};
MediaOverlay_MediaOverlay.defaultProps = {
  component: 'div'
};
/* harmony default export */ var Media_MediaOverlay = (MediaOverlay_MediaOverlay);
// CONCATENATED MODULE: ../node_modules/react-md/es/Toolbars/ToolbarTitle.js
var ToolbarTitle_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function ToolbarTitle_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ToolbarTitle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ToolbarTitle_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ToolbarTitle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var ToolbarTitle_ToolbarTitle = function (_PureComponent) {
  ToolbarTitle_inherits(ToolbarTitle, _PureComponent);

  function ToolbarTitle() {
    ToolbarTitle_classCallCheck(this, ToolbarTitle);

    return ToolbarTitle_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  ToolbarTitle.prototype.render = function render() {
    var _props = this.props,
        title = _props.title,
        className = _props.className,
        prominent = _props.prominent,
        offset = _props.offset,
        props = ToolbarTitle_objectWithoutProperties(_props, ['title', 'className', 'prominent', 'offset']);

    if (!title) {
      return null;
    }

    var fullClassName = classnames_default()('md-title md-title--toolbar', {
      'md-title--toolbar-prominent': prominent,
      'md-title--toolbar-offset': offset
    }, className);

    if (Object(react["isValidElement"])(title)) {
      var titleEl = react["Children"].only(title);
      return Object(react["cloneElement"])(title, ToolbarTitle_extends({}, props, {
        id: titleEl.props.id || props.id,
        className: classnames_default()(fullClassName, titleEl.props.className)
      }));
    }

    return react_default.a.createElement(
      'h2',
      ToolbarTitle_extends({}, props, {
        className: fullClassName
      }),
      title
    );
  };

  return ToolbarTitle;
}(react["PureComponent"]);

ToolbarTitle_ToolbarTitle.propTypes = {
  className: prop_types_default.a.string,
  prominent: prop_types_default.a.bool,
  offset: prop_types_default.a.bool,
  title: prop_types_default.a.node
};
/* harmony default export */ var Toolbars_ToolbarTitle = (ToolbarTitle_ToolbarTitle);
// CONCATENATED MODULE: ../node_modules/react-md/es/Toolbars/Toolbar.js
var Toolbar_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Toolbar_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Toolbar_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Toolbar_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Toolbar_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











var Toolbar_Toolbar = function (_PureComponent) {
  Toolbar_inherits(Toolbar, _PureComponent);

  function Toolbar() {
    Toolbar_classCallCheck(this, Toolbar);

    return Toolbar_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Toolbar.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        component = _props.component,
        titleStyle = _props.titleStyle,
        titleClassName = _props.titleClassName,
        prominentTitle = _props.prominentTitle,
        themed = _props.themed,
        singleColor = _props.singleColor,
        actions = _props.actions,
        fixed = _props.fixed,
        children = _props.children,
        inset = _props.inset,
        titleId = _props.titleId,
        propNav = _props.nav,
        propTitle = _props.title,
        propTitleMenu = _props.titleMenu,
        propZDepth = _props.zDepth,
        propColored = _props.colored,
        propProminent = _props.prominent,
        containerStyle = _props.containerStyle,
        containerClassName = _props.containerClassName,
        actionLeft = _props.actionLeft,
        actionsRight = _props.actionsRight,
        primary = _props.primary,
        secondary = _props.secondary,
        props = Toolbar_objectWithoutProperties(_props, ['style', 'className', 'component', 'titleStyle', 'titleClassName', 'prominentTitle', 'themed', 'singleColor', 'actions', 'fixed', 'children', 'inset', 'titleId', 'nav', 'title', 'titleMenu', 'zDepth', 'colored', 'prominent', 'containerStyle', 'containerClassName', 'actionLeft', 'actionsRight', 'primary', 'secondary']);

    var _props2 = this.props,
        colored = _props2.colored,
        title = _props2.title,
        titleMenu = _props2.titleMenu,
        nav = _props2.nav,
        prominent = _props2.prominent,
        zDepth = _props2.zDepth;


    colored = colored || primary || secondary;
    prominent = prominent || prominentTitle;

    title = react_default.a.createElement(Toolbars_ToolbarTitle, {
      key: 'title',
      style: titleStyle,
      className: titleClassName,
      prominent: prominentTitle,
      offset: prominentTitle,
      id: typeof titleId === 'undefined' && props.id ? props.id + '-title' : titleId,
      title: title
    });

    if (nav || actionLeft) {
      var navEl = react["Children"].only(nav || actionLeft);
      nav = Object(react["cloneElement"])(nav, {
        className: classnames_default()('md-btn--toolbar md-toolbar--action-left', navEl.props.className)
      });
    }

    var rightActions = void 0;
    if (actions || actionsRight) {
      rightActions = react["Children"].map(react["Children"].toArray(actions || actionsRight), function (action) {
        return Object(react["cloneElement"])(action, {
          className: classnames_default()('md-btn--toolbar', action.props.className)
        });
      });

      rightActions = react_default.a.createElement(
        'div',
        { key: 'actions', className: 'md-cell--right md-toolbar--action-right' },
        rightActions
      );
    }

    if (titleMenu) {
      titleMenu = react["Children"].only(titleMenu);
      titleMenu = Object(react["cloneElement"])(titleMenu, {
        className: classnames_default()('md-title md-title--toolbar md-select-field--toolbar', {
          'md-title--toolbar-offset': prominentTitle,
          'md-title--toolbar-prominent': prominentTitle
        }, titleMenu.props.className),
        position: titleMenu.props.position || 'tl',
        toolbar: true
      });
    }

    if (typeof zDepth !== 'number') {
      zDepth = fixed ? 2 : 0;
    }

    return react_default.a.createElement(
      Papers_Paper,
      Toolbar_extends({}, props, {
        component: component,
        zDepth: zDepth,
        style: style,
        className: classnames_default()('md-toolbar', {
          'md-background--primary': colored,
          'md-toolbar--themed': themed,
          'md-toolbar--text-white': singleColor && colored,
          'md-toolbar--prominent': prominent,
          'md-toolbar--fixed': fixed,
          'md-toolbar--inset': inset
        }, className)
      }),
      nav,
      title,
      titleMenu,
      children,
      rightActions
    );
  };

  return Toolbar;
}(react["PureComponent"]);

Toolbar_Toolbar.propTypes = {
  /**
   * An optional id to provide to the toolbar. If this is specified and the `titleId` is not, the title
   * will gain an id of `${id}-title`. This will not be applied to the `titleMenu`.
   *
   * @see {@link #titleId}
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply to the toolbar.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the toolbar,
   */
  className: prop_types_default.a.string,

  /*
   * An optional style to apply to the `h2` surrounding the `title` prop.
   */
  titleStyle: prop_types_default.a.object,

  /*
   * An optional className to apply to the `h2` surrounding the `title` prop.
   */
  titleClassName: prop_types_default.a.string,

  /**
   * Boolean if the toolbar should more prominent. This will double the height of the toolbar.
   */
  prominent: prop_types_default.a.bool,

  /**
   * Boolean if the toolbar's title should be more prominent. This will move the title to the
   * second line of the toolbar. This only works when the `prominent` prop is true as well.
   */
  prominentTitle: prop_types_default.a.bool,

  /**
   * The current title of the page to show in the toolbar. It is invalid to specify both a
   * `title` and a `titleMenu`. Only one should be given.
   */
  title: invalidIf(prop_types_default.a.node, 'titleMenu'),

  /**
   * An optional id to give the main title in the toolbar. This will not be applied to the
   * `titleMenu`.
   */
  titleId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional title menu to display instead of the title. This should be a `SelectField` component.
   * It is cloned with some additional props, so if the `SelectField` is separated into a separate
   * component, the following props must be passed to get the correct styling: `className`, `block`,
   * `paddedBlock`, `position`.
   */
  titleMenu: prop_types_default.a.element,

  /**
   * This prop is used for rendering an optional navigation button to the left of the `title`
   * or the `titleMenu` component. This needs to be an icon `Button` because some additional props
   * are cloned into it.
   */
  nav: prop_types_default.a.element,

  /**
   * Any additional actions to display to the right of the title. This should be a list or a single
   * `Button` to display. The buttons get cloned with an additional className for toolbar styling.
   */
  actions: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.arrayOf(prop_types_default.a.element)]),

  /**
   * Any children to display in the toolbar. This will be displayed between the optional title and
   * actions.
   */
  children: prop_types_default.a.node,

  /**
   * Boolean if the toolbar should be fixed to the top of the page. This will add some additional box shadow.
   */
  fixed: prop_types_default.a.bool,

  /**
   * Boolean if the nav, actions, and title should share the same color. For a `colored` or dark `themed`
   * toolbar, they will all be colored white. For a transparent or light `themed` toolbar, the colors will
   * be the `rgba(0, 0, 0, .87)`. Setting this to false will only style the title to the specific color
   * stated above.
   */
  singleColor: prop_types_default.a.bool,

  /**
   * Boolean if the toolbar should be colored based off the current theme. This will either style the background
   * to be fairly white, or fairly black. You can not specify both `themed` and `colored`.
   */
  themed: prop_types_default.a.bool,

  /**
   * Boolean if the toolbar should be colored with the `$md-primary-color`.
   */
  colored: invalidIf(prop_types_default.a.bool, 'themed'),

  /**
   * The component to render the toolbar as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * Boolean if the toolbar is inset in the page. This will just add some margin around
   * it.
   */
  inset: prop_types_default.a.bool,

  /**
   * An optional zDepth to enforce for the toolbar. This should be a number between 0 and 5.
   * If this is omitted, the toolbar will gain a zDepth of 2 when `fixed`.
   */
  zDepth: between(prop_types_default.a.number, 0, 5),
  containerStyle: deprecated_default()(prop_types_default.a.object, 'The `container` no longer exists in the `Toolbar`. Use the `style` prop instead'),
  containerClassName: deprecated_default()(prop_types_default.a.string, 'The `container` no longer exists in the `Toolbar`. Use the `className` prop instead'),
  primary: deprecated_default()(prop_types_default.a.bool, 'Use the `colored` prop instead'),
  secondary: deprecated_default()(prop_types_default.a.bool, 'Toolbars can no longer be themed to the secondary color. Use the `colored` prop instead'),
  actionLeft: deprecated_default()(prop_types_default.a.element, 'Use the `nav` prop instead'),
  actionsRight: deprecated_default()(prop_types_default.a.node, 'Use the `menu` prop and/or the `actions` prop instead')
};
Toolbar_Toolbar.defaultProps = {
  singleColor: true,
  component: 'header'
};
/* harmony default export */ var Toolbars_Toolbar = (Toolbar_Toolbar);
// CONCATENATED MODULE: ../node_modules/react-md/es/NavigationDrawers/JumpToContentLink.js
var JumpToContentLink_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function JumpToContentLink_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function JumpToContentLink_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function JumpToContentLink_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function JumpToContentLink_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * This is an accessibility only component that should be used in the `NavigationDrawer`
 * component. It allows keyboard users to quickly jump to the main content.
 *
 * This component relies on the `contextTypes` of the `NavigationDrawer` to work. If this is going
 * to be used outside of that component, you will need to specify an `id` and `label` contextType
 * to pass to this component.
 */

var JumpToContentLink_JumpToContentLink = function (_PureComponent) {
  JumpToContentLink_inherits(JumpToContentLink, _PureComponent);

  function JumpToContentLink() {
    var _temp, _this, _ret;

    JumpToContentLink_classCallCheck(this, JumpToContentLink);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = JumpToContentLink_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._handleClick = function (e) {
      if (_this.props.onClick) {
        _this.props.onClick(e);
      }

      document.getElementById(_this.context.id).focus();
    }, _temp), JumpToContentLink_possibleConstructorReturn(_this, _ret);
  }

  JumpToContentLink.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        props = JumpToContentLink_objectWithoutProperties(_props, ['className']);

    var _context = this.context,
        id = _context.id,
        label = _context.label;

    return react_default.a.createElement(
      'a',
      JumpToContentLink_extends({}, props, {
        id: 'jump-to-' + id,
        href: '#' + id,
        onClick: this._handleClick,
        className: classnames_default()('md-content-jump', className)
      }),
      label
    );
  };

  return JumpToContentLink;
}(react["PureComponent"]);

JumpToContentLink_JumpToContentLink.propTypes = {
  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * An optional function to call when the linked is clicked.
   */
  onClick: prop_types_default.a.func
};
JumpToContentLink_JumpToContentLink.contextTypes = {
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  label: prop_types_default.a.node.isRequired
};
/* harmony default export */ var NavigationDrawers_JumpToContentLink = (JumpToContentLink_JumpToContentLink);
// CONCATENATED MODULE: ../node_modules/react-md/es/NavigationDrawers/CloseButton.js
var CloseButton_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function CloseButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CloseButton_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CloseButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * A button used to close the persistent navigation drawer. The button will
 * be generated based on the `NavigationDrawer`'s `contextTypes`.
 *
 * This component is really only used if you are using a `persistent` drawer and you
 * manually created the `drawerHeader` for the `NavigationDrawer`.
 */

var CloseButton_CloseButton = function (_PureComponent) {
  CloseButton_inherits(CloseButton, _PureComponent);

  function CloseButton() {
    var _temp, _this, _ret;

    CloseButton_classCallCheck(this, CloseButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = CloseButton_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._handleClick = function (e) {
      if (_this.props.onClick) {
        _this.props.onClick(e);
      }

      if (_this.context.onCloseClick) {
        _this.context.onCloseClick(e);
      }
    }, _temp), CloseButton_possibleConstructorReturn(_this, _ret);
  }

  CloseButton.prototype.render = function render() {
    var closeIcon = this.context.closeIcon;


    return react_default.a.createElement(Buttons_Button, CloseButton_extends({}, this.props, {
      icon: true,
      key: 'close',
      onClick: this._handleClick,
      iconEl: closeIcon
    }));
  };

  return CloseButton;
}(react["PureComponent"]);

CloseButton_CloseButton.propTypes = {
  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * An optional additional function to call when the `click` event is triggered.
   */
  onClick: prop_types_default.a.func
};
CloseButton_CloseButton.contextTypes = {
  closeIcon: prop_types_default.a.element,
  onCloseClick: prop_types_default.a.func
};
/* harmony default export */ var NavigationDrawers_CloseButton = (CloseButton_CloseButton);
// CONCATENATED MODULE: ../node_modules/react-md/es/NavigationDrawers/MiniListItem.js
var MiniListItem_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function MiniListItem_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function MiniListItem_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MiniListItem_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MiniListItem_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var MiniListItem_MiniListItem = function (_PureComponent) {
  MiniListItem_inherits(MiniListItem, _PureComponent);

  function MiniListItem() {
    var _temp, _this, _ret;

    MiniListItem_classCallCheck(this, MiniListItem);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = MiniListItem_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { active: false }, _this._handleMouseOver = function (e) {
      if (_this.props.onMouseOver) {
        _this.props.onMouseOver(e);
      }

      if (!_this.props.disabled) {
        _this.setState({ active: true });
      }
    }, _this._handleMouseLeave = function (e) {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave(e);
      }

      if (!_this.props.disabled) {
        _this.setState({ active: false });
      }
    }, _this._handleTouchStart = function (e) {
      if (_this.props.onTouchStart) {
        _this.props.onTouchStart(e);
      }

      _this._touched = true;

      _this.setState({ active: true, touchedAt: Date.now() });
    }, _this._handleTouchEnd = function (e) {
      if (_this.props.onTouchEnd) {
        _this.props.onTouchEnd(e);
      }

      var time = Date.now() - _this.state.touchedAt;
      _this._touchTimeout = setTimeout(function () {
        _this._touchTimeout = null;

        _this.setState({ active: false });
      }, time > 450 ? 0 : 450 - time);
    }, _temp), MiniListItem_possibleConstructorReturn(_this, _ret);
  }

  MiniListItem.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._touchTimeout) {
      clearTimeout(this._touchTimeout);
    }
  };

  MiniListItem.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        tileStyle = _props.tileStyle,
        tileClassName = _props.tileClassName,
        leftIcon = _props.leftIcon,
        leftAvatar = _props.leftAvatar,
        active = _props.active,
        activeClassName = _props.activeClassName,
        ItemComponent = _props.itemComponent,
        primaryText = _props.primaryText,
        secondaryText = _props.secondaryText,
        rightIcon = _props.rightIcon,
        rightAvatar = _props.rightAvatar,
        threeLines = _props.threeLines,
        children = _props.children,
        defaultOpen = _props.defaultOpen,
        isOpen = _props.isOpen,
        inset = _props.inset,
        nestedItems = _props.nestedItems,
        animateNestedItems = _props.animateNestedItems,
        expanderIcon = _props.expanderIcon,
        expanderIconChildren = _props.expanderIconChildren,
        expanderIconClassName = _props.expanderIconClassName,
        props = MiniListItem_objectWithoutProperties(_props, ['style', 'className', 'tileStyle', 'tileClassName', 'leftIcon', 'leftAvatar', 'active', 'activeClassName', 'itemComponent', 'primaryText', 'secondaryText', 'rightIcon', 'rightAvatar', 'threeLines', 'children', 'defaultOpen', 'isOpen', 'inset', 'nestedItems', 'animateNestedItems', 'expanderIcon', 'expanderIconChildren', 'expanderIconClassName']);

    return react_default.a.createElement(
      ItemComponent,
      { style: style, className: className },
      react_default.a.createElement(
        AccessibleFakeInkedButton,
        MiniListItem_extends({}, props, {
          style: tileStyle,
          className: classnames_default()('md-list-tile md-list-tile--icon md-list-tile--mini', {
            'md-list-tile--active': this.state.active && !this._touched
          }, tileClassName),
          onMouseOver: this._handleMouseOver,
          onMouseLeave: this._handleMouseLeave,
          onTouchStart: this._handleTouchStart,
          onTouchEnd: this._handleTouchEnd
        }),
        react_default.a.createElement(Lists_TileAddon, {
          active: active,
          activeClassName: activeClassName,
          icon: leftIcon,
          avatar: leftAvatar
        })
      )
    );
  };

  return MiniListItem;
}(react["PureComponent"]);

MiniListItem_MiniListItem.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  tileStyle: prop_types_default.a.object,
  tileClassName: prop_types_default.a.string,
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),
  active: prop_types_default.a.bool,
  activeClassName: prop_types_default.a.string,
  leftIcon: prop_types_default.a.node,
  leftAvatar: prop_types_default.a.node,
  disabled: prop_types_default.a.bool,
  onTouchStart: prop_types_default.a.func,
  onTouchEnd: prop_types_default.a.func,
  onMouseOver: prop_types_default.a.func,
  onMouseLeave: prop_types_default.a.func,
  defaultOpen: prop_types_default.a.bool,
  itemComponent: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired
};
MiniListItem_MiniListItem.defaultProps = {
  activeClassName: 'md-text--theme-primary',
  component: 'div',
  itemComponent: 'li'
};
/* harmony default export */ var NavigationDrawers_MiniListItem = (MiniListItem_MiniListItem);
// CONCATENATED MODULE: ../node_modules/react-md/es/NavigationDrawers/NavigationDrawer.js
var NavigationDrawer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function NavigationDrawer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function NavigationDrawer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function NavigationDrawer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function NavigationDrawer_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }


















var NavigationDrawer_DrawerTypes = Drawers_Drawer.DrawerTypes;






function getNonMiniType(type) {
  var pMini = NavigationDrawer_DrawerTypes.PERSISTENT_MINI,
      tMini = NavigationDrawer_DrawerTypes.TEMPORARY_MINI;

  if ([pMini, tMini].indexOf(type) === -1) {
    return type;
  }

  return pMini === type ? NavigationDrawer_DrawerTypes.PERSISTENT : NavigationDrawer_DrawerTypes.TEMPORARY;
}

function toMiniListItem(item, index) {
  if (Object(react["isValidElement"])(item)) {
    return item;
  }

  var divider = item.divider,
      subheader = item.subheader,
      key = item.key,
      itemProps = NavigationDrawer_objectWithoutProperties(item, ['divider', 'subheader', 'key']);

  if (divider || subheader) {
    return null;
  }

  return react_default.a.createElement(NavigationDrawers_MiniListItem, NavigationDrawer_extends({ key: key || index }, itemProps));
}

/**
 * The `NavigationDrawer` is used when you want a full layout configuration. It is a combination
 * of the `Toolbar` component and the `Drawer` component. Any props that are not specifically
 * listed below will be provided to the `Drawer` component. So if there are props on the `Drawer`
 * that are not listed here, they will be passed along.
 *
 * The main benefit of using this component is that it will manage adding respective offset
 * classes automatically for you to the content and the drawer. It will also manage using
 * a mini drawer type for you.
 */

var NavigationDrawer_NavigationDrawer = function (_PureComponent) {
  NavigationDrawer_inherits(NavigationDrawer, _PureComponent);

  /**
   * Determines the current media and returns an object containing matches for `mobile`, `tablet`, `desktop`,
   * and the current drawer type. This expects a `props` object of the drawer.
   *
   * If this is used server side, it will default to only matching mobile.
   *
   * @param {Object=} props - The current drawer's prop shape to extract the mobile, tablet, and desktop type/min
   *    widths. This defaults to the drawer's default props.
   * @return {Object} an object containing the media matches and the current type to use for the drawer.
   */
  NavigationDrawer.getCurrentMedia = function getCurrentMedia() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NavigationDrawer.defaultProps;

    var mobileType = props.mobileDrawerType,
        tabletType = props.tabletDrawerType,
        desktopType = props.desktopDrawerType,
        constantType = props.constantDrawerType,
        others = NavigationDrawer_objectWithoutProperties(props, ['mobileDrawerType', 'tabletDrawerType', 'desktopDrawerType', 'constantDrawerType']);

    return Drawers_Drawer.getCurrentMedia(NavigationDrawer_extends({ mobileType: mobileType, tabletType: tabletType, desktopType: desktopType, constantType: constantType }, others));
  };

  function NavigationDrawer(props) {
    NavigationDrawer_classCallCheck(this, NavigationDrawer);

    var _this = NavigationDrawer_possibleConstructorReturn(this, _PureComponent.call(this, props));

    NavigationDrawer_initialiseProps.call(_this);

    var defaultMedia = props.defaultMedia,
        defaultVisible = props.defaultVisible,
        initialDrawerType = props.initialDrawerType;


    _this.state = {
      mobile: initialDrawerType || defaultMedia === 'mobile',
      tablet: initialDrawerType || defaultMedia === 'tablet',
      desktop: initialDrawerType || defaultMedia === 'desktop'
    };

    if (typeof props.drawerType === 'undefined') {
      _this.state.drawerType = props[(initialDrawerType || defaultMedia) + 'DrawerType'];
    }

    var type = getField(props, _this.state, 'drawerType');

    if (typeof props.visible === 'undefined') {
      // The logic for determining the visibility is handled by the created mini drawer
      _this.state.visible = isPermanent(type);
      if (!_this.state.visible && typeof defaultVisible !== 'undefined') {
        _this.state.visible = defaultVisible;
      }
    }
    return _this;
  }

  NavigationDrawer.prototype.getChildContext = function getChildContext() {
    var _props = this.props,
        persistentIcon = _props.persistentIcon,
        id = _props.contentId,
        label = _props.jumpLabel,
        persistentIconChildren = _props.persistentIconChildren,
        persistentIconClassName = _props.persistentIconClassName,
        closeIconChildren = _props.closeIconChildren,
        closeIconClassName = _props.closeIconClassName;


    return {
      id: id,
      label: label,
      closeIcon: getDeprecatedIcon(closeIconClassName || persistentIconClassName, closeIconChildren || persistentIconChildren, persistentIcon),
      onCloseClick: this._toggleVisibility,
      renderNode: this.context.renderNode
    };
  };

  NavigationDrawer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var visible = getField(this.props, this.state, 'visible');
    var nVisible = getField(nextProps, this.state, 'visible');
    if (visible !== nVisible) {
      this._animate(nextProps);
    }
  };

  NavigationDrawer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  NavigationDrawer.prototype.render = function render() {
    var _props2 = this.props,
        id = _props2.id,
        style = _props2.style,
        className = _props2.className,
        toolbarStyle = _props2.toolbarStyle,
        toolbarClassName = _props2.toolbarClassName,
        drawerStyle = _props2.drawerStyle,
        drawerClassName = _props2.drawerClassName,
        contentStyle = _props2.contentStyle,
        contentClassName = _props2.contentClassName,
        Content = _props2.contentComponent,
        miniDrawerStyle = _props2.miniDrawerStyle,
        miniDrawerClassName = _props2.miniDrawerClassName,
        miniNavStyle = _props2.miniNavStyle,
        miniNavClassName = _props2.miniNavClassName,
        miniDrawerId = _props2.miniDrawerId,
        miniNavItemsId = _props2.miniNavItemsId,
        navItems = _props2.navItems,
        children = _props2.children,
        drawerId = _props2.drawerId,
        drawerTitle = _props2.drawerTitle,
        drawerZDepth = _props2.drawerZDepth,
        drawerChildren = _props2.drawerChildren,
        drawerHeaderChildren = _props2.drawerHeaderChildren,
        drawerTransitionDuration = _props2.drawerTransitionDuration,
        toolbarId = _props2.toolbarId,
        toolbarTitle = _props2.toolbarTitle,
        toolbarTitleMenu = _props2.toolbarTitleMenu,
        toolbarTitleStyle = _props2.toolbarTitleStyle,
        toolbarTitleClassName = _props2.toolbarTitleClassName,
        toolbarActions = _props2.toolbarActions,
        toolbarProminent = _props2.toolbarProminent,
        toolbarProminentTitle = _props2.toolbarProminentTitle,
        toolbarThemeType = _props2.toolbarThemeType,
        toolbarSingleColor = _props2.toolbarSingleColor,
        toolbarChildren = _props2.toolbarChildren,
        toolbarZDepth = _props2.toolbarZDepth,
        mobileType = _props2.mobileDrawerType,
        tabletType = _props2.tabletDrawerType,
        desktopType = _props2.desktopDrawerType,
        transitionName = _props2.transitionName,
        transitionEnterTimeout = _props2.transitionEnterTimeout,
        transitionLeaveTimeout = _props2.transitionLeaveTimeout,
        extractMini = _props2.extractMini,
        miniDrawerHeader = _props2.miniDrawerHeader,
        miniDrawerChildren = _props2.miniDrawerChildren,
        footer = _props2.footer,
        includeDrawerHeader = _props2.includeDrawerHeader,
        contentId = _props2.contentId,
        contentProps = _props2.contentProps,
        constantDrawerType = _props2.constantDrawerType,
        temporaryIcon = _props2.temporaryIcon,
        temporaryIconChildren = _props2.temporaryIconChildren,
        temporaryIconClassName = _props2.temporaryIconClassName,
        menuIconChildren = _props2.menuIconChildren,
        menuIconClassName = _props2.menuIconClassName,
        propDrawerType = _props2.drawerType,
        propDrawerHeader = _props2.drawerHeader,
        propRenderNode = _props2.renderNode,
        jumpLabel = _props2.jumpLabel,
        persistentIcon = _props2.persistentIcon,
        onDrawerChange = _props2.onDrawerChange,
        closeIconChildren = _props2.closeIconChildren,
        closeIconClassName = _props2.closeIconClassName,
        persistentIconChildren = _props2.persistentIconChildren,
        persistentIconClassName = _props2.persistentIconClassName,
        props = NavigationDrawer_objectWithoutProperties(_props2, ['id', 'style', 'className', 'toolbarStyle', 'toolbarClassName', 'drawerStyle', 'drawerClassName', 'contentStyle', 'contentClassName', 'contentComponent', 'miniDrawerStyle', 'miniDrawerClassName', 'miniNavStyle', 'miniNavClassName', 'miniDrawerId', 'miniNavItemsId', 'navItems', 'children', 'drawerId', 'drawerTitle', 'drawerZDepth', 'drawerChildren', 'drawerHeaderChildren', 'drawerTransitionDuration', 'toolbarId', 'toolbarTitle', 'toolbarTitleMenu', 'toolbarTitleStyle', 'toolbarTitleClassName', 'toolbarActions', 'toolbarProminent', 'toolbarProminentTitle', 'toolbarThemeType', 'toolbarSingleColor', 'toolbarChildren', 'toolbarZDepth', 'mobileDrawerType', 'tabletDrawerType', 'desktopDrawerType', 'transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'extractMini', 'miniDrawerHeader', 'miniDrawerChildren', 'footer', 'includeDrawerHeader', 'contentId', 'contentProps', 'constantDrawerType', 'temporaryIcon', 'temporaryIconChildren', 'temporaryIconClassName', 'menuIconChildren', 'menuIconClassName', 'drawerType', 'drawerHeader', 'renderNode', 'jumpLabel', 'persistentIcon', 'onDrawerChange', 'closeIconChildren', 'closeIconClassName', 'persistentIconChildren', 'persistentIconClassName']);

    var drawerHeader = this.props.drawerHeader;
    var _state = this.state,
        desktop = _state.desktop,
        tablet = _state.tablet,
        contentActive = _state.contentActive;


    var drawerType = getField(this.props, this.state, 'drawerType');
    var visible = getField(this.props, this.state, 'visible');
    var renderNode = getField(this.props, this.context, 'renderNode');
    var mini = isMini(drawerType);
    var temporary = isTemporary(drawerType);
    var persistent = isPersistent(drawerType);
    var clipped = drawerType === NavigationDrawer_DrawerTypes.CLIPPED;
    var floating = drawerType === NavigationDrawer_DrawerTypes.FLOATING;

    var offset = desktop || tablet ? !temporary && visible : visible;
    var toolbarRelative = classnames_default()({
      'md-toolbar-relative': !toolbarProminent && !toolbarProminentTitle,
      'md-toolbar-relative--prominent': toolbarProminent || toolbarProminentTitle
    });

    var nav = void 0;
    if (temporary || persistent) {
      nav = react_default.a.createElement(Buttons_Button, {
        key: 'nav',
        onClick: this._toggleVisibility,
        disabled: persistent && visible,
        icon: true,
        iconEl: getDeprecatedIcon(menuIconClassName || temporaryIconClassName, menuIconChildren || temporaryIconChildren, temporaryIcon)
      });
    }

    var closeButton = void 0;
    if (persistent) {
      closeButton = react_default.a.createElement(NavigationDrawers_CloseButton, null);
    }

    if (!drawerHeader && includeDrawerHeader) {
      var _cn;

      drawerHeader = react_default.a.createElement(
        Toolbars_Toolbar,
        {
          key: 'drawer-header',
          title: drawerTitle,
          actions: visible && nav ? closeButton : null,
          className: classnames_default()('md-divider-border md-divider-border--bottom', (_cn = {}, _cn[toolbarRelative] = clipped || floating, _cn))
        },
        drawerHeaderChildren,
        react_default.a.createElement(NavigationDrawers_JumpToContentLink, null)
      );
    }
    var miniDrawer = void 0;
    if (mini) {
      var miniList = void 0;
      if (extractMini) {
        miniList = react_default.a.createElement(
          Lists_List,
          {
            id: miniNavItemsId,
            key: 'mini-nav-items',
            style: miniNavStyle,
            className: classnames_default()(miniNavClassName, toolbarRelative)
          },
          navItems.map(toMiniListItem)
        );
      }

      miniDrawer = react_default.a.createElement(
        Drawers_Drawer,
        {
          id: miniDrawerId,
          key: 'mini-drawer',
          type: drawerType,
          renderNode: renderNode,
          'aria-hidden': visible,
          style: miniDrawerStyle,
          className: miniDrawerClassName
        },
        miniDrawerHeader,
        miniList,
        miniDrawerChildren
      );
    }

    var desktopOffset = !clipped && !floating && offset;

    return react_default.a.createElement(
      'div',
      { id: id, style: style, className: className },
      react_default.a.createElement(
        Toolbars_Toolbar,
        {
          id: toolbarId,
          colored: toolbarThemeType === 'colored',
          themed: toolbarThemeType === 'themed',
          singleColor: toolbarSingleColor,
          style: toolbarStyle,
          className: classnames_default()({
            'md-toolbar--over-drawer': clipped || floating || mini && !visible
          }, toolbarClassName),
          title: toolbarTitle,
          titleMenu: toolbarTitleMenu,
          prominent: toolbarProminent,
          prominentTitle: toolbarProminentTitle,
          titleStyle: toolbarTitleStyle,
          titleClassName: classnames_default()({
            'md-title--drawer-active': contentActive,
            'md-transition--deceleration': offset && visible,
            'md-transition--acceleration': offset && !visible,
            'md-title--permanent-offset': desktopOffset && isPermanent(drawerType),
            'md-title--persistent-offset': desktopOffset && persistent
          }, toolbarTitleClassName),
          nav: nav,
          actions: toolbarActions,
          fixed: true,
          zDepth: toolbarZDepth
        },
        toolbarChildren
      ),
      miniDrawer,
      react_default.a.createElement(
        Drawers_Drawer,
        NavigationDrawer_extends({}, props, {
          id: drawerId,
          constantType: constantDrawerType,
          transitionDuration: drawerTransitionDuration,
          header: drawerHeader,
          style: drawerStyle,
          className: drawerClassName,
          navItems: navItems,
          renderNode: renderNode,
          mobileType: mobileType,
          tabletType: tabletType,
          desktopType: desktopType,
          type: getNonMiniType(drawerType),
          visible: visible,
          zDepth: drawerZDepth,
          onVisibilityChange: this._handleVisibility,
          onMediaTypeChange: this._handleTypeChange
        }),
        drawerChildren
      ),
      react_default.a.createElement(
        CSSTransitionGroup_default.a,
        NavigationDrawer_extends({}, contentProps, {
          id: contentId,
          component: Content,
          transitionName: transitionName,
          transitionEnter: !!transitionEnterTimeout,
          transitionEnterTimeout: transitionEnterTimeout,
          transitionLeave: !!transitionLeaveTimeout,
          transitionLeaveTimeout: transitionLeaveTimeout,
          tabIndex: -1,
          style: contentStyle,
          className: classnames_default()('md-navigation-drawer-content', {
            'md-navigation-drawer-content--active': contentActive,
            'md-navigation-drawer-content--inactive': !visible,
            'md-navigation-drawer-content--prominent-offset': toolbarProminent || toolbarProminentTitle,
            'md-transition--deceleration': visible,
            'md-transition--acceleration': !visible,
            'md-drawer-relative': offset,
            'md-drawer-relative--mini': mini && (!visible || temporary)
          }, toolbarRelative, contentClassName)
        }),
        children
      ),
      footer
    );
  };

  return NavigationDrawer;
}(react["PureComponent"]);

NavigationDrawer_NavigationDrawer.DrawerType = { // deprecated
  /* eslint-disable no-console */
  _warned: false,
  _msg: 'Invalid use of `NavigationDrawer.DrawerType.{{TYPE}}`. The `NavigationDrawer.DrawerType` ' + 'has been deprecated and will be removed in the next major release. Please use the ' + '`NavigationDrawer.DrawerTypes.{{TYPE}}` instead.',

  get FULL_HEIGHT() {
    if (!this._warned) {
      console.error(this._msg.replace(/{{TYPE}}/g, 'FULL_HEIGHT'));
    }
    this._warned = true;

    return NavigationDrawer_DrawerTypes.FULL_HEIGHT;
  },

  get CLIPPED() {
    if (!this._warned) {
      console.error(this._msg.replace(/{{TYPE}}/g, 'CLIPPED'));
    }
    this._warned = true;

    return NavigationDrawer_DrawerTypes.CLIPPED;
  },

  get FLOATING() {
    if (!this._warned) {
      console.error(this._msg.replace(/{{TYPE}}/g, 'FLOATING'));
    }
    this._warned = true;

    return NavigationDrawer_DrawerTypes.FLOATING;
  },

  get PERSISTENT() {
    if (!this._warned) {
      console.error(this._msg.replace(/{{TYPE}}/g, 'PERSISTENT'));
    }
    this._warned = true;

    return NavigationDrawer_DrawerTypes.PERSISTENT;
  },

  get PERSISTENT_MINI() {
    if (!this._warned) {
      console.error(this._msg.replace(/{{TYPE}}/g, 'PERSISTENT_MINI'));
    }
    this._warned = true;

    return NavigationDrawer_DrawerTypes.PERSISTENT_MINI;
  },

  get TEMPORARY() {
    if (!this._warned) {
      console.error(this._msg.replace(/{{TYPE}}/g, 'TEMPORARY'));
    }
    this._warned = true;

    return NavigationDrawer_DrawerTypes.TEMPORARY;
  },

  get TEMPORARY_MINI() {
    if (!this._warned) {
      console.error(this._msg.replace(/{{TYPE}}/g, 'TEMPORARY_MINI'));
    }
    this._warned = true;

    return NavigationDrawer_DrawerTypes.TEMPORARY_MINI;
  }
};
NavigationDrawer_NavigationDrawer.DrawerTypes = NavigationDrawer_DrawerTypes;
NavigationDrawer_NavigationDrawer.propTypes = {
  /**
   * An optional id to provide to the entire div wrapper.
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the drawer. This is generally a good idea to provide if
   * there are any `navItems` defined.
   *
   * @see {@link #navItemsId}
   * @see {@link #miniDrawerId}
   */
  drawerId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the navItems list. If this is omitted and the `drawerId` prop is
   * defined, it will be defaulted to `${drawerId}-nav-items`.
   *
   * @see {@link #drawerId}
   * @see {@link Drawer#navItemsId}
   */
  navItemsId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to apply to mini drawer that gets created when the `drawerType` is set to
   * one of the mini types.
   *
   * @see {@link #drawerId}
   * @see {@link #miniNavItemsId}
   */
  miniDrawerId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to apply to mini drawer's navigation list that gets created when the `drawerType`
   * is set to one of the mini types.
   *
   * @see {@link #navItemsId}
   * @see {@link #miniDrawerId}
   */
  miniNavItemsId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional id to provide to the main toolbar.
   */
  toolbarId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An id to give the main content. A hidden link is created in the main drawer's header that links to the main
   * content. This is used for keyboard only users to jump the navigation and jump straight to the content.
   *
   * If you provide your own `drawerHeader`, it is suggested to include the link yourself.
   */
  contentId: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * An optional style to apply to the surrounding container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the surrounding container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the main toolbar.
   */
  toolbarStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the toolbar.
   */
  toolbarClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the main toolbar's title.
   */
  toolbarTitleStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the main toolbar's title.
   */
  toolbarTitleClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the drawer.
   */
  drawerStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the drawer.
   */
  drawerClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the `List` surrounding the `navItems`.
   */
  navStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the `List` surrounding the `navItems`.
   */
  navClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the mini drawer that gets created when the `drawerType` is set
   * to one of the mini types.
   *
   * @see {@link #miniDrawerClassName}
   * @see {@link #miniNavStyle}
   * @see {@link #miniNavClassName}
   */
  miniDrawerStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the mini drawer that gets created when the `drawerType` is set
   * to one of the mini types.
   *
   * @see {@link #miniDrawerStyle}
   * @see {@link #miniNavStyle}
   * @see {@link #miniNavClassName}
   */
  miniDrawerClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the mini drawer's navigation list when the `drawerType` is set
   * to one of the mini types.
   *
   * @see {@link #miniDrawerStyle}
   * @see {@link #miniDrawerClassName}
   * @see {@link #miniNavClassName}
   */
  miniNavStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the mini drawer's navigation list when the `drawerType` is set
   * to one of the mini types.
   *
   * @see {@link #miniDrawerStyle}
   * @see {@link #miniDrawerClassName}
   * @see {@link #miniNavStyle}
   */
  miniNavClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the content. This is the container surrounding whatever
   * `children` are passed in.
   */
  contentStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the content. This is the container surrounding whatever
   * `children` are passed in.
   */
  contentClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the overlay.
   */
  overlayStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the overlay.
   */
  overlayClassName: prop_types_default.a.string,

  /**
   * The children to display in the main content.
   */
  children: prop_types_default.a.node,

  /**
   * Boolean if the `drawerHeader` component should be built if the `drawerHeader` prop is not
   * passed in.
   */
  includeDrawerHeader: prop_types_default.a.bool,

  /**
   * An optional header to display in the drawer. This will normally be the `Toolbar` component
   * or any other type of header. You can either use this prop with the `CloseButton` component
   * when displaying a persistent drawer, or use the `drawerTitle` and `drawerHeaderChildren` prop
   * to build a toolbar.
   */
  drawerHeader: prop_types_default.a.node,

  /**
   * An optional title to use for the drawer's header toolbar. If the `drawerHeader` prop is defined,
   * this is invalid.
   */
  drawerTitle: invalidIf(prop_types_default.a.node, 'drawerHeader'),

  /**
   * An optional zDepth to apply to the drawer. If this is omitted, the value will be set as follows:
   * - floating || inline = 1
   * - temporary = 5
   * - all others = 1
   *
   * @see {@link Papers/Paper#zDepth}
   */
  drawerZDepth: prop_types_default.a.number,

  /**
   * Any additional children to display after the `drawerHeader` and `navItems` list in the drawer.
   */
  drawerChildren: prop_types_default.a.node,

  /**
   * Any additional children to display in the drawer's header `Toolbar`. If the `drawerHeader` prop is defined,
   * this is invalid.
   */
  drawerHeaderChildren: invalidIf(prop_types_default.a.node, 'drawerHeader'),

  /**
   * The position for the drawer to be displayed.
   */
  position: prop_types_default.a.oneOf(['left', 'right']).isRequired,

  /**
   * An optional list of elements or props to use to build a navigational list in the drawer.
   * When the item is an object of props, it will build a `ListItem` component unless a key of
   * `divider` or `subheader` is set to true. It will then create the Divider or Subheader component
   * with any other remaining keys.
   */
  navItems: prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.shape({
    divider: prop_types_default.a.bool,
    subheader: prop_types_default.a.bool,
    primaryText: prop_types_default.a.node
  })])),

  /**
   * The drawer type to use for mobile devices.
   */
  mobileDrawerType: prop_types_default.a.oneOf([NavigationDrawer_DrawerTypes.TEMPORARY, NavigationDrawer_DrawerTypes.TEMPORARY_MINI]).isRequired,

  /**
   * The drawer type to use for tablets.
   */
  tabletDrawerType: prop_types_default.a.oneOf([NavigationDrawer_DrawerTypes.FULL_HEIGHT, NavigationDrawer_DrawerTypes.CLIPPED, NavigationDrawer_DrawerTypes.FLOATING, NavigationDrawer_DrawerTypes.PERSISTENT, NavigationDrawer_DrawerTypes.PERSISTENT_MINI, NavigationDrawer_DrawerTypes.TEMPORARY, NavigationDrawer_DrawerTypes.TEMPORARY_MINI]).isRequired,

  /**
   * The drawer type to use for desktop displays.
   */
  desktopDrawerType: prop_types_default.a.oneOf([NavigationDrawer_DrawerTypes.FULL_HEIGHT, NavigationDrawer_DrawerTypes.CLIPPED, NavigationDrawer_DrawerTypes.FLOATING, NavigationDrawer_DrawerTypes.PERSISTENT, NavigationDrawer_DrawerTypes.PERSISTENT_MINI, NavigationDrawer_DrawerTypes.TEMPORARY, NavigationDrawer_DrawerTypes.TEMPORARY_MINI]).isRequired,

  /**
   * An optional drawer type to enforce on all screen sizes. If the drawer type is not
   * `temporary`, you are required to define the `onMediaTypeChange` prop to handle switching
   * to temporary when the media matches a mobile device.
   * ```
   */
  drawerType: prop_types_default.a.oneOf([NavigationDrawer_DrawerTypes.FULL_HEIGHT, NavigationDrawer_DrawerTypes.CLIPPED, NavigationDrawer_DrawerTypes.FLOATING, NavigationDrawer_DrawerTypes.PERSISTENT, NavigationDrawer_DrawerTypes.PERSISTENT_MINI, NavigationDrawer_DrawerTypes.TEMPORARY, NavigationDrawer_DrawerTypes.TEMPORARY_MINI]),

  /**
   * The default media match for the drawer. This will be what is displayed on first render.
   * The component will adjust itself to the current media after it has mounted, but this
   * is mostly used for server side rendering.
   */
  defaultMedia: prop_types_default.a.oneOf(['mobile', 'tablet', 'desktop']),

  /**
   * The min width to use for a mobile media query. This prop should match the `md-mobile-min-width`
   * variable.
   *
   * The media query for a mobile device will be:
   *
   * ```js
   * window.matchMedia(
   *   `screen and (min-width: ${mobileMinWidth}px) and (max-width: ${tabletMinWidth - 1}px`
   * ).matches;
   * ```
   */
  mobileMinWidth: prop_types_default.a.number.isRequired,

  /**
   * The min width to use for a tablet media query. This prop should match the `md-tablet-min-width`
   * variable.
   *
   * The media query for a tablet device will be:
   *
   * ```js
   * window.matchMedia(
   *   `screen and (min-width: ${tabletMinWidth}px) and (max-width: ${desktopWidth - 1}px`
   * ).matches;
   * ```
   */
  tabletMinWidth: prop_types_default.a.number.isRequired,

  /**
   * The min width to use for a desktop media query. This prop should match the `md-desktop-min-width`
   * variable.
   *
   * The media query for a tablet device will be:
   *
   * ```js
   * window.matchMedia(`screen and (min-width: ${tabletMinWidth}px)`).matches;
   * ```
   */
  desktopMinWidth: prop_types_default.a.number.isRequired,

  /**
   * An optional function to call when the type of the drawer changes because of the
   * new media queries. The callback will include the newly selected drawer type
   * and an object containing the media matches of `mobile`, `tablet`, and `desktop`.
   *
   * ```js
   * this.props.onMediaTypeChange(NavigationDrawer.DrawerTypes.TEMPORARY, {
   *   mobile: true,
   *   tablet: false,
   *   desktop: false,
   * });
   * ```
   */
  onMediaTypeChange: prop_types_default.a.func,

  /**
   * Boolean if the temporary or persistent drawers are visible by default.
   */
  defaultVisible: prop_types_default.a.bool,

  /**
   * Boolean if the temporary or persistent drawers are visible. If this is defined,
   * it will make the component controlled and require the `onVisibilityChange` prop
   * to be defined.
   */
  visible: controlled(prop_types_default.a.bool, 'onVisibilityChange', 'defaultVisible'),

  /**
   * An optional function to call when the visibility of the drawer changes. The callback
   * will include the new visibility.
   *
   * ```js
   * onVisibilityChange(false);
   * ```
   */
  onVisibilityChange: prop_types_default.a.func,

  /**
   * A boolean if the mini drawer's list should be generated from the `navItems` prop. When building
   * the list, it will extract the `leftIcon` or `leftAvatar` from the `navItem` and then create a
   * mini `ListItem` containing only that icon or image. Any other event listeners will also be applied.
   *
   *
   * @see {@link #miniDrawerHeader}
   * @see {@link #miniDrawerChildren}
   */
  extractMini: prop_types_default.a.bool,

  /**
   * An optional header to display in the mini drawer. This will be displayed above the optional
   * mini nav list that get generated if the `extractMini` prop is `true` and the `miniDrawerChildren`.
   *
   * @see {@link #extractMini}
   */
  miniDrawerHeader: prop_types_default.a.node,

  /**
   * Any additional children to display in the mini drawer. This will be displayed after the `miniDrawerHeader`
   * and the optional mini nav list that gets generated if the `extractMini` prop is `true`.
   *
   * @see {@link #extractMini}
   */
  miniDrawerChildren: prop_types_default.a.node,

  /**
   * Boolean if the drawer should automatically close after a nav item has been clicked for `temporary` drawers.
   */
  autoclose: prop_types_default.a.bool,

  /**
   * An optional title to display in the main toolbar. Either the `toolbarTitle` or the `toolbarTitleMenu`
   * may be defined, not both.
   */
  toolbarTitle: invalidIf(prop_types_default.a.node, 'toolbarTitleMenu'),

  /**
   * An optional select field menu to display in the main toolbar. Either the `toolbarTitle` or the `toolbarTitleMenu`
   * may be defined, not both.
   */
  toolbarTitleMenu: prop_types_default.a.element,

  /**
   * The theme style for the main toolbar.
   *
   * @see {@link Toolbars/Toolbar}
   */
  toolbarThemeType: prop_types_default.a.oneOf(['default', 'colored', 'themed']).isRequired,

  /**
   * Boolean if the toolbar's nav, actions, and title should share the same color.
   */
  toolbarSingleColor: prop_types_default.a.bool,

  /**
   * A boolean if the toolbar should be prominent.
   */
  toolbarProminent: prop_types_default.a.bool,

  /**
   * A boolean if the toolbar's title should be prominent.
   */
  toolbarProminentTitle: prop_types_default.a.bool,

  /**
   * A list of elements or a single element to display to the right of the
   * toolbar's nav, title, and children.
   *
   * @see {@link Toolbars/Toolbar#actions}
   */
  toolbarActions: Toolbars_Toolbar.propTypes.actions,

  /**
   * Any children to display in the toolbar. This will be displayed between the optional title and
   * actions.
   */
  toolbarChildren: Toolbars_Toolbar.propTypes.children,

  /**
   * An optional zDepth to apply to the toolbar.
   *
   * @see {@link Toolbars/Toolbar#zDepth}
   */
  toolbarZDepth: prop_types_default.a.number,

  /**
   * The component to render the content in.
   */
  contentComponent: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * An optional footer display after the main content.
   */
  footer: prop_types_default.a.node,

  /**
   * The icon to use to render the button that will toggle the visibility of the
   * navigation drawer for `temporary` and `persistent` drawers. This is normally a
   * hamburger menu.
   */
  temporaryIcon: prop_types_default.a.element,

  /**
   * The icon to use to render the button that appears on a persistent drawer's open
   * header. This is used to create the `CloseButton` for drawers. When a persistent
   * drawer is closed, the `temporaryIcon` will be used to create a button to open the drawer.
   *
   * If the `drawerHeader` prop is defined, you will have to either include the `CloseButton`
   * in your header manually, or create your own controlled button to close the drawer.
   */
  persistentIcon: prop_types_default.a.element,

  /**
   * The transition name to use when the page's content changes. If you want to disable
   * transitions, set both the `transitionEnterTimeout` and `transitionLeaveTimeout` props
   * to a false-ish value. (`null`, `undefined`, or `0`).
   */
  transitionName: prop_types_default.a.string.isRequired,

  /**
   * The transition enter timeout when the page's content changes. If you want to disable
   * the enter transition, set this to a false-ish value (`null`, `undefined`, or `0`).
   */
  transitionEnterTimeout: prop_types_default.a.number,

  /**
   * The transition leave timeout when the page's content changes. If you want to disable
   * the leave transition, set this to a false-ish value (`null`, `undefined`, or `0`).
   */
  transitionLeaveTimeout: prop_types_default.a.number,

  /**
   * The transition duration for the drawer when sliding in and out of view.
   */
  drawerTransitionDuration: prop_types_default.a.number.isRequired,

  /**
   * Any additional props to provide to the main content. This will be applied before any of the generated props,
   * so this should not include `style`, `className`, or `component`.
   */
  contentProps: prop_types_default.a.object,

  /**
   * The label to use for a keyboard accessibility link that jumps all the navigation and allows a user to focus
   * the main content. This is created in the drawer's header.
   */
  jumpLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the drawer. The overlay that appears for temporary type drawers will still appear in the
   * separate subtree.
   *
   * @see {@link Helpers/Portal}
   */
  portal: prop_types_default.a.bool,

  /**
   * An optional DOM Node to render the drawer into. The default is to render as
   * the first child in the `body`.
   *
   * > This prop will not be used when the drawer is of the permanent type or `inline` is specified
   * since the `Portal` component will not be used.
   */
  renderNode: prop_types_default.a.object,

  /**
   * Boolean if the drawer should be rendered as the last child instead of the first child
   * in the `renderNode` or `body`.
   *
   * > This prop will not be used when the drawer is of the permanent type or `inline` is specified
   * since the `Portal` component will not be used.
   */
  lastChild: prop_types_default.a.bool,

  /**
   * Boolean if the `drawerType` should remain constant across all media. This is really only valid
   * if the `drawerType` is one of the temporary types.
   */
  constantDrawerType: prop_types_default.a.bool,

  menuIconChildren: deprecated_default()(prop_types_default.a.node, 'Use `temporaryIcon` instead'),
  menuIconClassName: deprecated_default()(prop_types_default.a.string, 'Use `temporaryIcon` instead'),
  closeIconChildren: deprecated_default()(prop_types_default.a.node, 'Use `persistentIcon` instead'),
  closeIconClassName: deprecated_default()(prop_types_default.a.string, 'Use `persistentIcon` instead'),
  temporaryIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `temporaryIcon` instead'),
  temporaryIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `temporaryIcon` instead'),
  persistentIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `persistentIcon` instead'),
  persistentIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `persistentIcon` prop instead'),
  onDrawerChange: deprecated_default()(prop_types_default.a.func, 'Use `onVisibilityChange` or `onMediaTypeChange` instead'),
  onVisibilityToggle: deprecated_default()(prop_types_default.a.func, 'Use `onVisibilityChange` instead'),
  contentTransitionName: deprecated_default()(prop_types_default.a.string, 'Use `transitionName` instead'),
  contentTransitionEnterTimeout: deprecated_default()(prop_types_default.a.number, 'Use `transtionEnterTimeout` instead'),
  contentTransitionLeaveTimeout: deprecated_default()(prop_types_default.a.number, 'Use `transtionLeaveTimeout` instead'),
  initialDrawerType: deprecated_default()(prop_types_default.a.oneOf(['mobile', 'tablet', 'desktop']), 'Use `defaultMedia` instead')
};
NavigationDrawer_NavigationDrawer.contextTypes = {
  renderNode: prop_types_default.a.object
};
NavigationDrawer_NavigationDrawer.childContextTypes = {
  closeIcon: prop_types_default.a.element,
  onCloseClick: prop_types_default.a.func,
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  label: prop_types_default.a.node.isRequired,
  renderNode: prop_types_default.a.object
};
NavigationDrawer_NavigationDrawer.defaultProps = {
  autoclose: Drawers_Drawer.defaultProps.autoclose,
  contentId: 'main-content',
  // Defaults to false since it keeps the state of the drawerType in sync and makes the Drawer
  // controlled. On initial mount without any defaultMedia updates, it would always be considered
  // temporary
  constantDrawerType: false,
  jumpLabel: 'Jump to content',
  extractMini: true,
  position: Drawers_Drawer.defaultProps.position,
  defaultMedia: Drawers_Drawer.defaultProps.defaultMedia,
  mobileDrawerType: Drawers_Drawer.defaultProps.mobileType,
  tabletDrawerType: Drawers_Drawer.defaultProps.tabletType,
  desktopDrawerType: Drawers_Drawer.defaultProps.desktopType,
  mobileMinWidth: Drawers_Drawer.defaultProps.mobileMinWidth,
  tabletMinWidth: Drawers_Drawer.defaultProps.tabletMinWidth,
  desktopMinWidth: Drawers_Drawer.defaultProps.desktopMinWidth,
  includeDrawerHeader: true,
  contentComponent: 'main',
  temporaryIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'menu'
  ),
  toolbarThemeType: 'colored',
  persistentIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'arrow_back'
  ),
  transitionName: 'md-cross-fade',
  transitionEnterTimeout: 300,
  drawerTransitionDuration: Drawers_Drawer.defaultProps.transitionDuration
};

var NavigationDrawer_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._animate = function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this2.props;
    var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this2.state;

    if (isTemporary(getField(props, state, 'drawerType'))) {
      return;
    }

    if (_this2._timeout) {
      clearTimeout(_this2._timeout);
    }

    _this2._timeout = setTimeout(function () {
      _this2.setState({ contentActive: false });
    }, props.drawerTransitionDuration);

    _this2.setState({ contentActive: true });
  };

  this._toggleVisibility = function (e) {
    var _props3 = _this2.props,
        onVisibilityToggle = _props3.onVisibilityToggle,
        onVisibilityChange = _props3.onVisibilityChange,
        onDrawerChange = _props3.onDrawerChange;

    var visible = !getField(_this2.props, _this2.state, 'visible');
    var callback = onVisibilityChange || onVisibilityToggle || onDrawerChange;
    if (callback) {
      callback(visible, e);
    }

    if (typeof _this2.props.visible === 'undefined') {
      _this2.setState({ visible: visible });
      _this2._animate(_this2.props);
    }
  };

  this._handleVisibility = function (visible) {
    var _props4 = _this2.props,
        onVisibilityToggle = _props4.onVisibilityToggle,
        onVisibilityChange = _props4.onVisibilityChange,
        onDrawerChange = _props4.onDrawerChange;

    var callback = onVisibilityChange || onVisibilityToggle || onDrawerChange;
    if (callback) {
      callback(visible);
    }

    if (typeof _this2.props.visible === 'undefined') {
      _this2.setState({ visible: visible });
      _this2._animate(_this2.props);
    }
  };

  this._handleTypeChange = function (drawerType, mediaState) {
    var onMediaTypeChange = _this2.props.onMediaTypeChange;

    var state = mediaState;
    if (onMediaTypeChange) {
      onMediaTypeChange(drawerType, mediaState);
    }

    if (typeof _this2.props.drawerType === 'undefined') {
      state = NavigationDrawer_extends({}, mediaState, { drawerType: drawerType });
    }

    _this2.setState(state);
  };
};

/* harmony default export */ var NavigationDrawers_NavigationDrawer = (NavigationDrawer_NavigationDrawer);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/isValidDate.js
/**
 * Checks if a variable provided is defined and a correctly formatted date.
 *
 * Examples:
 * - isValidDate(null) -> false
 * - isValidDate('') -> false
 * - isValidDate(new Date('23--33')) - false (malformed date)
 * - isValidDate(new Date()) -> true
 *
 * @param d - Any value that should be checked if it is a valid date
 * @return {boolean} true if it is a valid date.
 */
function isValidDate(d) {
  // just checking if getTime is a function is ridiculously quicker than instanceof Date
  // and _seems_ safe enough
  return !!d && typeof d.getTime === 'function' && d.getTime() === d.getTime();
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/addDay.js


/**
 * Adds the specified number of days to a provided date. If the date
 * is null, an invalid formatted date, or not a Date instance, null
 * will be returned instead.
 *
 * @param {Date} date - The date to update
 * @param {number} amount - The number of days to add. This can be positive
 *    or negative.
 * @return {Date} a new date with the number of days added or null.
 */
function addDay(date, amount) {
  if (!isValidDate(date)) {
    return null;
  }

  var d = new Date(date);
  d.setDate(d.getDate() + amount);
  return d;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/getLastDay.js


/**
 * Gets the last day in a month as a new Date.
 *
 * @param {Date} date - The date to get the last date in a month for
 * @return {Date} the last day in the month as a date object or null.
 */
function getLastDay(date) {
  if (!isValidDate(date)) {
    return null;
  }

  return new Date(date.getFullYear(), date.getMonth() + 1, 0);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/getDaysInMonth.js


/**
 * Gets the number of days in a month for the provided date.
 *
 * @param {Date} date - The date to get the number of days for
 * @return {number} the number of days in the month or -1 if it is false-ish
 *    or an invalid date object.
 */
function getDaysInMonth(date) {
  var day = getLastDay(date);
  return day === null ? -1 : day.getDate();
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/addMonth.js



/**
 * Adds the specified number of months to a provided date. If the date
 * is null, an invalid formatted date, or not a Date instance, null
 * will be returned instead.
 *
 * When a new month is returned, it will make sure that the date matches
 * the date in the old month if possible, if the new month does not have
 * include the new date, the `newMonthDate` will be used instead.
 *
 * @param {Date} date - The date to update
 * @param {number} amount - The number of months to add. This can be positive
 *    or negative.
 * @param {number=1} newMonthDate - An optional date to set in the new month
 *    if the new month does not have the old date.
 * @return {Date} a new date with the number of days added or null.
 */
function addMonth(date, amount, newMonthDate) {
  if (!isValidDate(date)) {
    return null;
  } else if (amount === 0) {
    return new Date(date);
  }

  if (!newMonthDate) {
    // 0 is invalid for this case
    newMonthDate = date.getDate();
  }

  var d = new Date(date);
  d.setDate(1); // reset to first day to prevent month overflows
  d.setMonth(d.getMonth() + amount);

  if (newMonthDate !== 1 && newMonthDate <= getDaysInMonth(d)) {
    // set the date back to the correct day if it still exists within the month
    d.setDate(newMonthDate);
  }

  return d;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/addYear.js


/**
 * Adds the specified number of years to a provided date. If the date
 * is null, an invalid formatted date, or not a Date instance, null
 * will be returned instead.
 *
 * @param {Date} date - The date to update
 * @param {number} amount - The number of years to add. This can be positive
 *    or negative.
 * @return {Date} a new date with the number of years added or null.
 */
function addYear(date, amount) {
  if (!isValidDate(date)) {
    return null;
  }

  var d = new Date(date);
  d.setFullYear(d.getFullYear() + amount);

  return d;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/addDate.js




/**
 * Adds a given amount to a date.
 *
 * @param {Date} date - The date to add
 * @param {number} amount - The amount to add
 * @param {string} part - The date part to add to. ['D', 'M', 'Y']
 * @param {number=1} newMonthDate - An optional date to set in the new month
 *    if the new month does not have the old date. This only applies to month
 *    addition.
 * @return a new Date with the part added or the date if the part is not valid.
 */
function addDate(date, amount, part, newMonthDate) {
  switch (part) {
    case 'D':
      return addDay(date, amount);
    case 'M':
      return addMonth(date, amount, newMonthDate);
    case 'Y':
      return addYear(date, amount);
    default:
      return date;
  }
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/isSameYear.js


/**
 * Checks if two dates are part of the same year.
 *
 * @param {Date} d1 - The first date to compare.
 * @param {Date} d2 - The second date to compare.
 * @param {boolean=false} bothNullValue - boolean for what should be returned if
 *  both values are null.
 * @return {boolean} true if both the dates are defined and part of the same year or
 *  if both values are null it will return the `bothNullValue`.
 */
function isSameYear(d1, d2) {
  var bothNullValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!d1 && !d2) {
    return bothNullValue;
  } else if (!isValidDate(d1) || !isValidDate(d2)) {
    return false;
  }

  return d1.getFullYear() === d2.getFullYear();
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/isSameMonth.js


/**
 * Checks if two dates are part of the same month. This will also
 * make sure the dates are part of the same year.
 *
 * @param {Date} d1 - The first date to compare.
 * @param {Date} d2 - The second date to compare.
 * @param {boolean=false} bothNullValue - boolean for what should be returned if
 *  both values are null.
 * @return {boolean} true if both the dates are defined and part of the same year and month
 *  or if both values are null it will return the `bothNullValue`
 */
function isSameMonth(d1, d2) {
  var bothNullValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!d1 && !d2) {
    return bothNullValue;
  }

  return isSameYear(d1, d2, bothNullValue) && d1.getMonth() === d2.getMonth();
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/isSameDay.js


/**
 * Checks if two dates are part of the same date. This will also
 * make sure the dates are part of the same year and month.
 *
 * @param {Date} d1 - The first date to compare.
 * @param {Date} d2 - The second date to compare.
 * @param {boolean=false} bothNullValue - boolean for what should be returned if
 *  both values are null.
 * @return {boolean} true if both the dates are defined and part of the same year, month, and day
 *  or if both values are null it will return the `bothNullValue`.
 */
function isSameDay(d1, d2) {
  var bothNullValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!d1 && !d2) {
    return bothNullValue;
  }

  return isSameMonth(d1, d2, bothNullValue) && d1.getDate() === d2.getDate();
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/DateUtils/DateTimeFormat.js
function DateTimeFormat_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @module utils/DateUtils/DateTimeFormat */

/**
 * A _really_ terrible DateTimeFormat mock if it is not available in
 * the browser or node version.
 */
var DateTimeFormat_DateTimeFormat = function () {
  if (typeof Intl !== 'undefined' && typeof Intl.DateTimeFormat !== 'undefined') {
    return Intl.DateTimeFormat;
  }

  // Very bad 'mock' of Intl.DateTimeFormat
  return function () {
    // eslint-disable-line no-shadow
    function DateTimeFormat(locales, formatOptions) {
      DateTimeFormat_classCallCheck(this, DateTimeFormat);

      this.locales = locales;
      this.options = formatOptions;
    }

    DateTimeFormat.prototype.format = function format(date) {
      return date.toLocaleString();
    };

    return DateTimeFormat;
  }();
}();

/* harmony default export */ var DateUtils_DateTimeFormat = (DateTimeFormat_DateTimeFormat);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/PickerControl.js
var PickerControl_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function PickerControl_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function PickerControl_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PickerControl_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function PickerControl_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The `PickerControl` component is the button that goes in the header
 * of a `Picker` component. It is used to switch the view of the `Picker`
 * from state to state.
 *
 * For example, this is the year and date views for the `DatePicker`.
 */

var PickerControl_PickerControl = function (_PureComponent) {
  PickerControl_inherits(PickerControl, _PureComponent);

  function PickerControl() {
    PickerControl_classCallCheck(this, PickerControl);

    return PickerControl_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  PickerControl.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        active = _props.active,
        props = PickerControl_objectWithoutProperties(_props, ['className', 'active']);

    return react_default.a.createElement('button', PickerControl_extends({}, props, {
      type: 'button',
      className: classnames_default()('md-btn md-pointer--hover md-picker-control md-picker-text', {
        'md-picker-text--active': active
      }, className)
    }));
  };

  return PickerControl;
}(react["PureComponent"]);

PickerControl_PickerControl.propTypes = {
  className: prop_types_default.a.string,
  active: prop_types_default.a.bool.isRequired,
  onClick: prop_types_default.a.func.isRequired,
  children: prop_types_default.a.node.isRequired
};
/* harmony default export */ var Pickers_PickerControl = (PickerControl_PickerControl);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/DatePickerHeader.js
function DatePickerHeader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DatePickerHeader_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DatePickerHeader_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable new-cap */






/**
 * The `DatePickerHeader` component is the component that holds the
 * current year and the current date. It allows the user to switch
 * between calendar and year picker mode.
 */

var DatePickerHeader_DatePickerHeader = function (_PureComponent) {
  DatePickerHeader_inherits(DatePickerHeader, _PureComponent);

  function DatePickerHeader(props) {
    DatePickerHeader_classCallCheck(this, DatePickerHeader);

    var _this = DatePickerHeader_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._selectYear = function (e) {
      _this.props.changeCalendarMode('year', e);
    };

    _this._selectCalendar = function (e) {
      _this.props.changeCalendarMode('calendar', e);
    };

    _this.state = _this._getFormattedDate(props);
    return _this;
  }

  DatePickerHeader.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        DateTimeFormat = _props.DateTimeFormat,
        locales = _props.locales,
        calendarTempDate = _props.calendarTempDate,
        changeCalendarMode = _props.changeCalendarMode;

    if (DateTimeFormat !== nextProps.DateTimeFormat || locales !== nextProps.locales || calendarTempDate !== nextProps.calendarTempDate || changeCalendarMode !== nextProps.changeCalendarMode) {
      this.setState(this._getFormattedDate(nextProps));
    }
  };

  DatePickerHeader.prototype._getFormattedDate = function _getFormattedDate(_ref) {
    var DateTimeFormat = _ref.DateTimeFormat,
        locales = _ref.locales,
        calendarTempDate = _ref.calendarTempDate;

    return {
      year: DateTimeFormat(locales, { year: 'numeric' }).format(calendarTempDate),
      weekday: DateTimeFormat(locales, { weekday: 'short' }).format(calendarTempDate),
      date: DateTimeFormat(locales, { month: 'short', day: '2-digit' }).format(calendarTempDate)
    };
  };

  DatePickerHeader.prototype.render = function render() {
    var _state = this.state,
        year = _state.year,
        weekday = _state.weekday,
        date = _state.date;
    var _props2 = this.props,
        calendarMode = _props2.calendarMode,
        className = _props2.className;

    var isYearMode = calendarMode === 'year';
    return react_default.a.createElement(
      'header',
      { className: classnames_default()('md-picker-header', className) },
      react_default.a.createElement(
        Pickers_PickerControl,
        {
          onClick: this._selectYear,
          active: isYearMode,
          'aria-expanded': isYearMode
        },
        react_default.a.createElement(
          'h6',
          { className: 'md-subheading-1' },
          year
        )
      ),
      react_default.a.createElement(
        Pickers_PickerControl,
        { onClick: this._selectCalendar, active: calendarMode === 'calendar' },
        react_default.a.createElement(
          'h4',
          { className: 'md-display-1' },
          weekday + ',',
          '\xA0'
        ),
        react_default.a.createElement(
          'h4',
          { className: 'md-display-1' },
          date
        )
      )
    );
  };

  return DatePickerHeader;
}(react["PureComponent"]);

DatePickerHeader_DatePickerHeader.propTypes = {
  className: prop_types_default.a.string,
  DateTimeFormat: prop_types_default.a.func.isRequired,
  locales: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]).isRequired,
  calendarTempDate: prop_types_default.a.instanceOf(Date).isRequired,
  calendarMode: prop_types_default.a.oneOf(['calendar', 'year']).isRequired,
  changeCalendarMode: prop_types_default.a.func.isRequired
};
/* harmony default export */ var Pickers_DatePickerHeader = (DatePickerHeader_DatePickerHeader);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/chunk.js
/** @module utils/omit */

/**
 * This should hopefully be very similar to lodash's chunk function. It will
 * take an array and split it into chunks of the given size. Any remainder will
 * be in the last chunk.
 *
 * @param {Array} arr - the array to split into chunks
 * @param {integer} size - the desired length of each chunk
 * @return {Array} - the chunked array
 */
function chunk(arr, size) {
  if (!arr) {
    return [];
  }
  return arr.reduce(function (chunks, item, index) {
    return index % size === 0 ? [].concat(chunks, [arr.slice(index, index + size)]) : chunks;
  }, []);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/stripTime.js


/**
 * Removes all the time parts (hours, minutes, seconds, milliseconds) from a date.
 * The hour of the stripped time is set to 1 by default to help with cross-browser
 * date implementations and how hour 0 sometimes is the previous day.
 *
 * @param {Date} date the date to strip
 * @param {number=0} hours - the fake hours to set for the stripped time date.
 * @return a new Date with the time stripped.
 */
function stripTime(date) {
  var hours = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (!isValidDate(date)) {
    return null;
  }

  var d = new Date(date);
  d.setHours(hours, 0, 0, 0);

  return d;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/toDayOfWeek.js


/**
 * Takes in a date and returns a new date at the specified day of week.
 *
 * Examples:
 * // to Sunday
 * - toDayOfWeek(new Date(2018, 0, 1), 0) == new Date(2017, 11, 31)
 *
 * // to Monday
 * - toDayOfWeek(new Date(2018, 0, 1), 1) == new Date(2018, 0, 1)
 *
 * @param {Date} date - The date to convert to a day of week
 * @param {number=0} dow - The day of the week to convert to
 * @return {Date} the new date set at the day of week or null if the
 *    date is invalid or false-ish.
 */
function toDayOfWeek(date) {
  var dow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (!isValidDate(date)) {
    return null;
  }

  var d = new Date(date);
  var day = date.getDay();
  var diff = d.getDate() - day + dow;
  return new Date(d.setDate(diff));
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/CalendarDate.js
var CalendarDate_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function CalendarDate_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CalendarDate_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CalendarDate_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * This component renders a selectable date in the `CalendarMonth` component.
 */

var CalendarDate_CalendarDate = function (_PureComponent) {
  CalendarDate_inherits(CalendarDate, _PureComponent);

  function CalendarDate(props) {
    CalendarDate_classCallCheck(this, CalendarDate);

    var _this = CalendarDate_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setFocus = function (btn) {
      if (btn && _this.props.active) {
        btn.focus();
      }
    };

    _this._handleClick = function (e) {
      _this.props.onClick(new Date(_this.props.date), e);
    };

    _this._setActive = function () {
      if (!_this.props.disabled) {
        _this.setState({ desktopActive: true });
      }
    };

    _this._setInactive = function () {
      if (!_this.props.disabled) {
        _this.setState({ desktopActive: false });
      }
    };

    _this.state = CalendarDate_extends({}, _this._getFormattedDate(props), { desktopActive: false });
    return _this;
  }

  CalendarDate.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        DateTimeFormat = _props.DateTimeFormat,
        locales = _props.locales,
        date = _props.date;

    if (DateTimeFormat !== nextProps.DateTimeFormat || locales !== nextProps.locales || date !== nextProps.date) {
      this.setState(this._getFormattedDate(nextProps));
    }
  };

  CalendarDate.prototype._getFormattedDate = function _getFormattedDate(_ref) {
    var DateTimeFormat = _ref.DateTimeFormat,
        locales = _ref.locales,
        date = _ref.date;

    return {
      date: new DateTimeFormat(locales, { day: 'numeric' }).format(date)
    };
  };

  CalendarDate.prototype.render = function render() {
    var _state = this.state,
        date = _state.date,
        desktopActive = _state.desktopActive;
    var _props2 = this.props,
        disabled = _props2.disabled,
        active = _props2.active,
        today = _props2.today,
        className = _props2.className;


    var fullyActive = today && !active && !desktopActive;
    return react_default.a.createElement(
      'div',
      {
        role: 'gridcell',
        className: 'md-calendar-date',
        style: { display: 'inline-block' }
      },
      react_default.a.createElement(
        'button',
        {
          type: 'button',
          ref: this._setFocus,
          onFocus: this._setActive,
          onBlur: this._setInactive,
          onMouseOver: this._setActive,
          onMouseLeave: this._setInactive,
          className: classnames_default()('md-calendar-date--btn', {
            'md-calendar-date--btn-active': active || desktopActive,
            'md-pointer--hover': !disabled
          }, themeColors({ disabled: disabled, primary: fullyActive }), 'md-btn', className),
          onClick: this._handleClick,
          disabled: disabled
        },
        react_default.a.createElement(
          'span',
          {
            className: classnames_default()('md-calendar-date--date', {
              'md-picker-text--active': active || desktopActive,
              'md-font-bold': fullyActive
            })
          },
          date
        )
      )
    );
  };

  return CalendarDate;
}(react["PureComponent"]);

CalendarDate_CalendarDate.propTypes = {
  className: prop_types_default.a.string,
  date: prop_types_default.a.instanceOf(Date).isRequired,
  DateTimeFormat: prop_types_default.a.func.isRequired,
  locales: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]).isRequired,
  disabled: prop_types_default.a.bool,
  onClick: prop_types_default.a.func.isRequired,
  active: prop_types_default.a.bool,
  today: prop_types_default.a.bool
};
/* harmony default export */ var Pickers_CalendarDate = (CalendarDate_CalendarDate);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/CalendarMonth.js
var CalendarMonth_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function CalendarMonth_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function CalendarMonth_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CalendarMonth_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CalendarMonth_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }













/**
 * This component renders a month for the calendar view of the `DatePicker`.
 */

var CalendarMonth_CalendarMonth = function (_PureComponent) {
  CalendarMonth_inherits(CalendarMonth, _PureComponent);

  function CalendarMonth() {
    CalendarMonth_classCallCheck(this, CalendarMonth);

    return CalendarMonth_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  CalendarMonth.prototype.render = function render() {
    var _props = this.props,
        calendarDate = _props.calendarDate,
        calendarTempDate = _props.calendarTempDate,
        onCalendarDateClick = _props.onCalendarDateClick,
        minDate = _props.minDate,
        maxDate = _props.maxDate,
        DateTimeFormat = _props.DateTimeFormat,
        locales = _props.locales,
        className = _props.className,
        firstDayOfWeek = _props.firstDayOfWeek,
        disableWeekEnds = _props.disableWeekEnds,
        dateClassName = _props.dateClassName,
        showAllDays = _props.showAllDays,
        outerDateClassName = _props.outerDateClassName,
        disableOuterDates = _props.disableOuterDates,
        props = CalendarMonth_objectWithoutProperties(_props, ['calendarDate', 'calendarTempDate', 'onCalendarDateClick', 'minDate', 'maxDate', 'DateTimeFormat', 'locales', 'className', 'firstDayOfWeek', 'disableWeekEnds', 'dateClassName', 'showAllDays', 'outerDateClassName', 'disableOuterDates']);

    var days = [];
    var firstDay = stripTime(calendarDate);
    firstDay.setDate(1);
    var lastDay = getLastDay(calendarDate);
    var currentDate = toDayOfWeek(firstDay, 0);
    var endDate = toDayOfWeek(lastDay, 6);
    var activeDateTime = stripTime(calendarTempDate).getTime();
    var todayTime = new Date().getTime();

    if (firstDayOfWeek) {
      currentDate = addDate(currentDate, firstDayOfWeek > firstDay.getDay() ? firstDayOfWeek - 7 : firstDayOfWeek, 'D');
      endDate = addDate(endDate, firstDayOfWeek > lastDay.getDay() ? firstDayOfWeek - 7 : firstDayOfWeek, 'D');
    }

    while (currentDate <= endDate) {
      var key = currentDate.getMonth() + '-' + currentDate.getDate();
      var currentMonth = currentDate.getMonth() === calendarDate.getMonth();

      var date = void 0;
      if (currentMonth || showAllDays) {
        var _cn;

        var time = currentDate.getTime();
        var isMinDateDisabled = minDate && minDate.getTime() > time;
        var isMaxDateDisabled = maxDate && maxDate.getTime() < time;
        var isWeekendDisabled = disableWeekEnds && (currentDate.getDay() === 0 || currentDate.getDay() === 6);
        var disabled = !currentMonth && disableOuterDates || isMinDateDisabled || isMaxDateDisabled || isWeekendDisabled;

        date = react_default.a.createElement(Pickers_CalendarDate, {
          key: key,
          className: classnames_default()(dateClassName, (_cn = {}, _cn[outerDateClassName] = !currentMonth && outerDateClassName, _cn)),
          today: time === todayTime,
          active: time === activeDateTime,
          disabled: disabled,
          onClick: onCalendarDateClick,
          date: currentDate,
          DateTimeFormat: DateTimeFormat,
          locales: locales
        });
      } else {
        date = react_default.a.createElement('div', { key: key, className: 'md-calendar-date', role: 'gridcell' });
      }

      days.push(date);
      currentDate = addDate(currentDate, 1, 'D');
    }

    var weeks = chunk(days, 7);

    return react_default.a.createElement(
      'div',
      CalendarMonth_extends({ role: 'grid', className: classnames_default()('md-calendar-month', className) }, props),
      weeks.map(function (week, i) {
        return react_default.a.createElement(
          'div',
          { key: i, role: 'row' },
          week
        );
      })
    );
  };

  return CalendarMonth;
}(react["PureComponent"]);

CalendarMonth_CalendarMonth.propTypes = {
  /**
   * A className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The current selected date of the calendar. This is
   * the date after hitting the Ok button or `value` || `defaultValue`.
   */
  calendarDate: prop_types_default.a.instanceOf(Date).isRequired,

  /**
   * The current selected date of the calendar before verifying
   * the new date.
   */
  calendarTempDate: prop_types_default.a.instanceOf(Date).isRequired,

  /**
   * An optional min date for the calendar. This will disable any
   * dates that come before this date in the month.
   */
  minDate: prop_types_default.a.instanceOf(Date),

  /**
   * An optional max date for the calendar. This will disable any
   * dates that come after this date in the month.
   */
  maxDate: prop_types_default.a.instanceOf(Date),

  /**
   * A function to call that will select a new date.
   */
  onCalendarDateClick: prop_types_default.a.func.isRequired,

  /**
   * The first day of week: 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
   */
  firstDayOfWeek: prop_types_default.a.oneOf([0, 1, 2, 3, 4, 5, 6]),

  /**
   * True if weekends are to be greyed out.
   */
  disableWeekEnds: prop_types_default.a.bool,

  /**
   * An optional className to apply to a date.
   */
  dateClassName: prop_types_default.a.string,

  /**
   * True if dates from adjacent months should be shown.
   */
  showAllDays: prop_types_default.a.bool,
  disableOuterDates: prop_types_default.a.bool,

  /**
   * An optional className to apply to a date from an adjacent month.
   */
  outerDateClassName: prop_types_default.a.string,
  DateTimeFormat: prop_types_default.a.func.isRequired,
  locales: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]).isRequired
};
CalendarMonth_CalendarMonth.defaultProps = {
  firstDayOfWeek: 0
};
/* harmony default export */ var Pickers_CalendarMonth = (CalendarMonth_CalendarMonth);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/dates/isMonthBefore.js


/**
 * Checks if a date is the month before another date without time
 *
 * @param {Date} date the date to check if it is before the other
 * @param {Date} toCompare the date to compare to
 * @return true if the date is before the other date's first day of month.
 */
function isMonthBefore(date, toCompare) {
  if (!isValidDate(date) || !isValidDate(toCompare)) {
    return false;
  }

  var d1 = new Date(date.getFullYear(), date.getMonth(), 1);
  var d2 = new Date(toCompare.getFullYear(), toCompare.getMonth() - 1, 1);
  return d1 > d2;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/CalendarHeader.js
function CalendarHeader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CalendarHeader_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CalendarHeader_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











/**
 * This component renders the controls for a `DatePicker`'s Calendar.
 * This will render a next and previous month button along with the
 * current month/year. It also renders the abbreviiations for the days
 * of the week.
 */

var CalendarHeader_CalendarHeader = function (_PureComponent) {
  CalendarHeader_inherits(CalendarHeader, _PureComponent);

  function CalendarHeader(props) {
    CalendarHeader_classCallCheck(this, CalendarHeader);

    var _this = CalendarHeader_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = _this._createState(props);
    return _this;
  }

  CalendarHeader.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        DateTimeFormat = _props.DateTimeFormat,
        locales = _props.locales,
        date = _props.date;

    if (DateTimeFormat !== nextProps.DateTimeFormat || locales !== nextProps.locales || date !== nextProps.date) {
      this.setState(this._createState(nextProps));
    }
  };

  CalendarHeader.prototype._createState = function _createState() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props,
        DateTimeFormat = _ref.DateTimeFormat,
        locales = _ref.locales,
        date = _ref.date,
        firstDayOfWeek = _ref.firstDayOfWeek,
        titleFormat = _ref.titleFormat,
        weekdayClassName = _ref.weekdayClassName,
        weekdayFormat = _ref.weekdayFormat;

    var firstDay = toDayOfWeek(date, firstDayOfWeek);
    var formatter = new DateTimeFormat(locales, { weekday: weekdayFormat });
    var dows = [];
    for (var i = 0; i < 7; i++) {
      var dow = formatter.format(addDate(firstDay, i, 'D'));
      dows.push(react_default.a.createElement(
        'h4',
        {
          key: i,
          className: classnames_default()('md-calendar-date md-calendar-dow', themeColors({ disabled: true }), weekdayClassName)
        },
        dow
      ));
    }

    return {
      dows: dows,
      title: new DateTimeFormat(locales, titleFormat).format(date)
    };
  };

  CalendarHeader.prototype.render = function render() {
    var _state = this.state,
        dows = _state.dows,
        title = _state.title;
    var _props2 = this.props,
        date = _props2.date,
        minDate = _props2.minDate,
        maxDate = _props2.maxDate,
        onPreviousClick = _props2.onPreviousClick,
        previousIcon = _props2.previousIcon,
        onNextClick = _props2.onNextClick,
        nextIcon = _props2.nextIcon,
        titleClassName = _props2.titleClassName;


    var isPreviousDisabled = isMonthBefore(minDate, date);
    var isNextDisabled = isMonthBefore(date, maxDate);
    return react_default.a.createElement(
      'header',
      { className: 'md-calendar-header' },
      react_default.a.createElement(
        'div',
        { className: 'md-calendar-controls' },
        react_default.a.createElement(Buttons_Button, {
          icon: true,
          onClick: onPreviousClick,
          disabled: isPreviousDisabled,
          className: 'md-calendar-control',
          iconEl: previousIcon
        }),
        react_default.a.createElement(
          'h4',
          { className: classnames_default()('md-title', titleClassName) },
          title
        ),
        react_default.a.createElement(Buttons_Button, {
          icon: true,
          onClick: onNextClick,
          disabled: isNextDisabled,
          className: 'md-calendar-control',
          iconEl: nextIcon
        })
      ),
      react_default.a.createElement(
        'div',
        { className: 'md-calendar-dows' },
        dows
      )
    );
  };

  return CalendarHeader;
}(react["PureComponent"]);

CalendarHeader_CalendarHeader.propTypes = {
  className: prop_types_default.a.string,
  children: prop_types_default.a.node,
  date: prop_types_default.a.instanceOf(Date).isRequired,
  minDate: prop_types_default.a.instanceOf(Date),
  maxDate: prop_types_default.a.instanceOf(Date),
  previousIcon: prop_types_default.a.element,
  onPreviousClick: prop_types_default.a.func.isRequired,
  nextIcon: prop_types_default.a.node,
  onNextClick: prop_types_default.a.func.isRequired,
  DateTimeFormat: prop_types_default.a.func.isRequired,
  locales: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]).isRequired,
  /**
   * The first day of week: 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
   */
  firstDayOfWeek: prop_types_default.a.oneOf([0, 1, 2, 3, 4, 5, 6]),
  /**
   * An optional className to apply to the title.
   */
  titleClassName: prop_types_default.a.string,
  /**
   * The DateTimeFormat options to apply to format the title.
   */
  titleFormat: prop_types_default.a.shape({
    era: prop_types_default.a.oneOf(['narrow', 'short', 'long']),
    year: prop_types_default.a.oneOf(['numeric', '2-digit']),
    month: prop_types_default.a.oneOf(['numeric', '2-digit', 'narrow', 'short', 'long'])
  }),
  /**
   * An optional className to apply to a weekday.
   */
  weekdayClassName: prop_types_default.a.string,
  /**
   * The DateTimeFormat option to apply to format a weekday.
   */
  weekdayFormat: prop_types_default.a.oneOf(['narrow', 'short', 'long'])
};
CalendarHeader_CalendarHeader.defaultProps = {
  firstDayOfWeek: 0,
  titleFormat: { month: 'long', year: 'numeric' },
  weekdayFormat: 'narrow'
};
/* harmony default export */ var Pickers_CalendarHeader = (CalendarHeader_CalendarHeader);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/DatePickerCalendar.js
function DatePickerCalendar_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DatePickerCalendar_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DatePickerCalendar_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var DatePickerCalendar_DatePickerCalendar = function (_PureComponent) {
  DatePickerCalendar_inherits(DatePickerCalendar, _PureComponent);

  function DatePickerCalendar() {
    DatePickerCalendar_classCallCheck(this, DatePickerCalendar);

    return DatePickerCalendar_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  DatePickerCalendar.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        previousIcon = _props.previousIcon,
        onPreviousClick = _props.onPreviousClick,
        nextIcon = _props.nextIcon,
        onNextClick = _props.onNextClick,
        calendarDate = _props.calendarDate,
        calendarTempDate = _props.calendarTempDate,
        onCalendarDateClick = _props.onCalendarDateClick,
        DateTimeFormat = _props.DateTimeFormat,
        locales = _props.locales,
        minDate = _props.minDate,
        maxDate = _props.maxDate,
        firstDayOfWeek = _props.firstDayOfWeek,
        disableWeekEnds = _props.disableWeekEnds,
        showAllDays = _props.showAllDays,
        disableOuterDates = _props.disableOuterDates,
        dateClassName = _props.dateClassName,
        outerDateClassName = _props.outerDateClassName,
        titleClassName = _props.titleClassName,
        titleFormat = _props.titleFormat,
        weekdayClassName = _props.weekdayClassName,
        weekdayFormat = _props.weekdayFormat;


    return react_default.a.createElement(
      'section',
      { className: classnames_default()('md-picker-content md-picker-content--calendar', className) },
      react_default.a.createElement(Pickers_CalendarHeader, {
        date: calendarDate,
        minDate: minDate,
        maxDate: maxDate,
        DateTimeFormat: DateTimeFormat,
        locales: locales,
        onPreviousClick: onPreviousClick,
        previousIcon: previousIcon,
        onNextClick: onNextClick,
        nextIcon: nextIcon,
        firstDayOfWeek: firstDayOfWeek,
        titleClassName: titleClassName,
        titleFormat: titleFormat,
        weekdayClassName: weekdayClassName,
        weekdayFormat: weekdayFormat
      }),
      react_default.a.createElement(Pickers_CalendarMonth, {
        key: new DateTimeFormat(locales).format(calendarDate),
        calendarDate: calendarDate,
        calendarTempDate: calendarTempDate,
        onCalendarDateClick: onCalendarDateClick,
        minDate: minDate,
        maxDate: maxDate,
        DateTimeFormat: DateTimeFormat,
        locales: locales,
        firstDayOfWeek: firstDayOfWeek,
        disableWeekEnds: disableWeekEnds,
        showAllDays: showAllDays,
        disableOuterDates: disableOuterDates,
        dateClassName: dateClassName,
        outerDateClassName: outerDateClassName
      })
    );
  };

  return DatePickerCalendar;
}(react["PureComponent"]);

DatePickerCalendar_DatePickerCalendar.propTypes = {
  className: prop_types_default.a.string,
  previousIcon: prop_types_default.a.element,
  onPreviousClick: prop_types_default.a.func.isRequired,
  nextIcon: prop_types_default.a.element,
  onNextClick: prop_types_default.a.func.isRequired,
  onCalendarDateClick: prop_types_default.a.func.isRequired,
  calendarDate: prop_types_default.a.instanceOf(Date).isRequired,
  calendarTempDate: prop_types_default.a.instanceOf(Date).isRequired,
  DateTimeFormat: prop_types_default.a.func.isRequired,
  locales: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]).isRequired,
  minDate: prop_types_default.a.instanceOf(Date),
  maxDate: prop_types_default.a.instanceOf(Date),

  /**
   * The first day of week: 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
   */
  firstDayOfWeek: prop_types_default.a.oneOf([0, 1, 2, 3, 4, 5, 6]),

  /**
   * True if weekends are to be greyed out.
   */
  disableWeekEnds: prop_types_default.a.bool,

  /**
   * True if dates from adjacent months should be shown.
   */
  showAllDays: prop_types_default.a.bool,
  disableOuterDates: prop_types_default.a.bool,

  /**
   * An optional className to apply to a date in calendar.
   */
  dateClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to a date from an adjacent month.
   */
  outerDateClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the title in calendar header.
   */
  titleClassName: prop_types_default.a.string,

  /**
   * The DateTimeFormat options to apply to format the title in calendar header.
   */
  titleFormat: prop_types_default.a.shape({
    era: prop_types_default.a.oneOf(['narrow', 'short', 'long']),
    year: prop_types_default.a.oneOf(['numeric', '2-digit']),
    month: prop_types_default.a.oneOf(['numeric', '2-digit', 'narrow', 'short', 'long'])
  }),

  /**
   * An optional className to apply to a weekday in calendar header.
   */
  weekdayClassName: prop_types_default.a.string,

  /**
   * The DateTimeFormat option to apply to format a weekday in calendar header.
   */
  weekdayFormat: prop_types_default.a.oneOf(['narrow', 'short', 'long'])
};
/* harmony default export */ var Pickers_DatePickerCalendar = (DatePickerCalendar_DatePickerCalendar);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/Year.js
function Year_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Year_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Year_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * This is a component for rendering a year in the Date Picker's Year picker
 * list.
 */

var Year_Year = function (_PureComponent) {
  Year_inherits(Year, _PureComponent);

  function Year() {
    var _temp, _this, _ret;

    Year_classCallCheck(this, Year);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Year_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { desktopActive: false }, _this._setActiveFocus = function (btn) {
      if (btn && _this.props.active) {
        btn.focus();
      }
    }, _this._setActive = function () {
      _this.setState({ desktopActive: true });
    }, _this._setInactive = function () {
      _this.setState({ desktopActive: false });
    }, _this._handleClick = function (e) {
      _this.props.onClick(_this.props.year, e);
    }, _temp), Year_possibleConstructorReturn(_this, _ret);
  }

  Year.prototype.render = function render() {
    var desktopActive = this.state.desktopActive;
    var _props = this.props,
        active = _props.active,
        className = _props.className,
        year = _props.year;

    return react_default.a.createElement(
      'button',
      {
        type: 'button',
        ref: this._setActiveFocus,
        className: classnames_default()('md-year', { 'md-year--active': active }, themeColors({
          text: !active && !desktopActive,
          primary: active || desktopActive
        }), 'md-btn md-pointer--hover md-full-width', className),
        onClick: this._handleClick
      },
      year
    );
  };

  return Year;
}(react["PureComponent"]);

Year_Year.propTypes = {
  className: prop_types_default.a.string,
  active: prop_types_default.a.bool.isRequired,
  onClick: prop_types_default.a.func.isRequired,
  year: prop_types_default.a.number.isRequired
};
/* harmony default export */ var Pickers_Year = (Year_Year);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/YearPicker.js
function YearPicker_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function YearPicker_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function YearPicker_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The `YearPicker` component is the Year view in a `DatePicker`. This
 * will display a list of years to select from within the given range.
 */

var YearPicker_YearPicker = function (_PureComponent) {
  YearPicker_inherits(YearPicker, _PureComponent);

  function YearPicker(props) {
    YearPicker_classCallCheck(this, YearPicker);

    var _this = YearPicker_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = _this._getYearRange(props);
    return _this;
  }

  YearPicker.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.yearsDisplayed !== nextProps.yearsDisplayed) {
      this.setState(this._getFullYear(nextProps));
    }
  };

  /**
   * Gets the current start and end years for the year picker.
   *
   * @param {Object} props - The current props to extract the year range from.
   * @return {Object} an object containign the start and end years
   */


  YearPicker.prototype._getYearRange = function _getYearRange(_ref) {
    var minDate = _ref.minDate,
        maxDate = _ref.maxDate,
        yearsDisplayed = _ref.yearsDisplayed,
        calendarTempDate = _ref.calendarTempDate;

    var year = calendarTempDate.getFullYear();
    var range = !minDate && !maxDate ? parseInt(yearsDisplayed / 2, 10) : yearsDisplayed;

    var startYear = void 0;
    var endYear = void 0;
    if (minDate && maxDate) {
      startYear = minDate.getFullYear();
      endYear = maxDate.getFullYear();
    } else if (!minDate && !maxDate) {
      startYear = year - range;
      endYear = year + range;
      if (yearsDisplayed % 2 === 0) {
        endYear -= 1;
      }
    } else if (!maxDate) {
      startYear = minDate.getFullYear();
      endYear = startYear + yearsDisplayed - 1;
    } else {
      endYear = maxDate.getFullYear();
      startYear = endYear - yearsDisplayed + 1;
    }

    return { startYear: startYear, endYear: endYear };
  };

  YearPicker.prototype._setContainer = function _setContainer(container) {
    if (container === null) {
      return;
    }

    var offsetHeight = container.offsetHeight,
        offsetWidth = container.offsetWidth;

    var _container$querySelec = container.querySelector('.md-year--active'),
        top = _container$querySelec.offsetTop,
        height = _container$querySelec.offsetHeight;

    // Portrait seems to be 3/4 of the way while landscape is about 1/2


    if (offsetHeight > offsetWidth) {
      container.scrollTop = top - offsetHeight * 3 / 4;
    } else {
      container.scrollTop = top - offsetHeight / 2 + height / 2;
    }
  };

  YearPicker.prototype.render = function render() {
    var _state = this.state,
        startYear = _state.startYear,
        endYear = _state.endYear;


    var currentYear = this.props.calendarTempDate.getFullYear();
    var years = [];
    for (var year = startYear; year <= endYear; year++) {
      years.push(react_default.a.createElement(Pickers_Year, {
        key: year,
        year: year,
        active: year === currentYear,
        onClick: this.props.onCalendarYearClick
      }));
    }

    return react_default.a.createElement(
      'section',
      {
        className: classnames_default()('md-picker-content md-picker-content--year', this.props.className),
        ref: this._setContainer
      },
      react_default.a.createElement(
        'ol',
        { className: 'md-years' },
        years
      )
    );
  };

  return YearPicker;
}(react["PureComponent"]);

YearPicker_YearPicker.propTypes = {
  className: prop_types_default.a.string,
  calendarTempDate: prop_types_default.a.instanceOf(Date).isRequired,
  onCalendarYearClick: prop_types_default.a.func.isRequired,
  yearsDisplayed: prop_types_default.a.number.isRequired,
  minDate: prop_types_default.a.instanceOf(Date),
  maxDate: prop_types_default.a.instanceOf(Date)
};
/* harmony default export */ var Pickers_YearPicker = (YearPicker_YearPicker);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/DatePicker.js
var DatePicker_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function DatePicker_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function DatePicker_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DatePicker_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DatePicker_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }










var DatePicker_DatePicker = function (_PureComponent) {
  DatePicker_inherits(DatePicker, _PureComponent);

  function DatePicker() {
    DatePicker_classCallCheck(this, DatePicker);

    return DatePicker_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  DatePicker.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        okLabel = _props.okLabel,
        okPrimary = _props.okPrimary,
        onOkClick = _props.onOkClick,
        cancelLabel = _props.cancelLabel,
        cancelPrimary = _props.cancelPrimary,
        onCancelClick = _props.onCancelClick,
        DateTimeFormat = _props.DateTimeFormat,
        locales = _props.locales,
        calendarTempDate = _props.calendarTempDate,
        calendarMode = _props.calendarMode,
        changeCalendarMode = _props.changeCalendarMode,
        style = _props.style,
        className = _props.className,
        inline = _props.inline,
        icon = _props.icon,
        displayMode = _props.displayMode,
        firstDayOfWeek = _props.firstDayOfWeek,
        disableWeekEnds = _props.disableWeekEnds,
        showAllDays = _props.showAllDays,
        disableOuterDates = _props.disableOuterDates,
        headerClassName = _props.headerClassName,
        contentClassName = _props.contentClassName,
        footerClassName = _props.footerClassName,
        calendarClassName = _props.calendarClassName,
        yearPickerClassName = _props.yearPickerClassName,
        calendarDateClassName = _props.calendarDateClassName,
        calendarOuterDateClassName = _props.calendarOuterDateClassName,
        calendarTitleClassName = _props.calendarTitleClassName,
        calendarTitleFormat = _props.calendarTitleFormat,
        calendarWeekdayClassName = _props.calendarWeekdayClassName,
        calendarWeekdayFormat = _props.calendarWeekdayFormat,
        props = DatePicker_objectWithoutProperties(_props, ['okLabel', 'okPrimary', 'onOkClick', 'cancelLabel', 'cancelPrimary', 'onCancelClick', 'DateTimeFormat', 'locales', 'calendarTempDate', 'calendarMode', 'changeCalendarMode', 'style', 'className', 'inline', 'icon', 'displayMode', 'firstDayOfWeek', 'disableWeekEnds', 'showAllDays', 'disableOuterDates', 'headerClassName', 'contentClassName', 'footerClassName', 'calendarClassName', 'yearPickerClassName', 'calendarDateClassName', 'calendarOuterDateClassName', 'calendarTitleClassName', 'calendarTitleFormat', 'calendarWeekdayClassName', 'calendarWeekdayFormat']);

    var picker = void 0;
    if (calendarMode === 'calendar') {
      picker = react_default.a.createElement(Pickers_DatePickerCalendar, DatePicker_extends({}, props, {
        key: 'calendar',
        className: calendarClassName,
        calendarTempDate: calendarTempDate,
        DateTimeFormat: DateTimeFormat,
        locales: locales,
        firstDayOfWeek: firstDayOfWeek,
        disableWeekEnds: disableWeekEnds,
        showAllDays: showAllDays,
        disableOuterDates: disableOuterDates,
        dateClassName: calendarDateClassName,
        outerDateClassName: calendarOuterDateClassName,
        titleClassName: calendarTitleClassName,
        titleFormat: calendarTitleFormat,
        weekdayClassName: calendarWeekdayClassName,
        weekdayFormat: calendarWeekdayFormat
      }));
    } else {
      picker = react_default.a.createElement(Pickers_YearPicker, DatePicker_extends({}, props, {
        key: 'year',
        className: yearPickerClassName,
        calendarTempDate: calendarTempDate,
        DateTimeFormat: DateTimeFormat,
        locales: locales
      }));
    }

    var actions = [{
      key: 'cancel',
      onClick: onCancelClick,
      primary: cancelPrimary,
      secondary: !cancelPrimary,
      label: cancelLabel
    }, {
      key: 'ok',
      onClick: onOkClick,
      primary: okPrimary,
      secondary: !okPrimary,
      label: okLabel
    }];

    return react_default.a.createElement(
      'div',
      {
        style: style,
        className: classnames_default()('md-picker md-picker--date', (_cn = {}, _cn['md-picker--' + displayMode] = displayMode, _cn['md-picker--inline'] = inline, _cn['md-picker--inline-icon'] = inline && icon, _cn), className)
      },
      react_default.a.createElement(Pickers_DatePickerHeader, {
        className: headerClassName,
        DateTimeFormat: DateTimeFormat,
        locales: locales,
        calendarTempDate: calendarTempDate,
        calendarMode: calendarMode,
        changeCalendarMode: changeCalendarMode
      }),
      react_default.a.createElement(
        'div',
        { className: classnames_default()('md-picker-content-container', contentClassName) },
        picker,
        react_default.a.createElement(Dialogs_DialogFooter, {
          className: footerClassName,
          actions: actions
        })
      )
    );
  };

  return DatePicker;
}(react["PureComponent"]);

DatePicker_DatePicker.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  okLabel: prop_types_default.a.node.isRequired,
  okPrimary: prop_types_default.a.bool.isRequired,
  onOkClick: prop_types_default.a.func.isRequired,
  cancelLabel: prop_types_default.a.node.isRequired,
  cancelPrimary: prop_types_default.a.bool.isRequired,
  onCancelClick: prop_types_default.a.func.isRequired,
  DateTimeFormat: prop_types_default.a.func.isRequired,
  locales: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]).isRequired,
  calendarDate: prop_types_default.a.instanceOf(Date).isRequired,
  calendarTempDate: prop_types_default.a.instanceOf(Date).isRequired,
  calendarMode: prop_types_default.a.oneOf(['calendar', 'year']).isRequired,
  changeCalendarMode: prop_types_default.a.func.isRequired,
  icon: prop_types_default.a.bool,
  inline: prop_types_default.a.bool,
  displayMode: prop_types_default.a.oneOf(['landscape', 'portrait']),

  /**
   * The first day of week: 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
   */
  firstDayOfWeek: prop_types_default.a.oneOf([0, 1, 2, 3, 4, 5, 6]),

  /**
   * True if weekends are to be greyed out.
   */
  disableWeekEnds: prop_types_default.a.bool,

  /**
   * True if dates from adjacent months should be shown in calendar.
   */
  showAllDays: prop_types_default.a.bool,
  disableOuterDates: prop_types_default.a.bool,

  /**
   * An optional className to apply to the header of date picker.
   */
  headerClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the content container of date picker.
   */
  contentClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the footer of date picker.
   */
  footerClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the calendar container of date picker.
   */
  calendarClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the year picker of date picker.
   */
  yearPickerClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to a date in calendar.
   */
  calendarDateClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to a date from an adjacent month in calendar.
   */
  calendarOuterDateClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the title in calendar header.
   */
  calendarTitleClassName: prop_types_default.a.string,

  /**
   * The DateTimeFormat options to apply to format the title in calendar header.
   */
  calendarTitleFormat: prop_types_default.a.shape({
    era: prop_types_default.a.oneOf(['narrow', 'short', 'long']),
    year: prop_types_default.a.oneOf(['numeric', '2-digit']),
    month: prop_types_default.a.oneOf(['numeric', '2-digit', 'narrow', 'short', 'long'])
  }),

  /**
   * An optional className to apply to a weekday in calendar header.
   */
  calendarWeekdayClassName: prop_types_default.a.string,

  /**
   * The DateTimeFormat option to apply to format a weekday in calendar header.
   */
  calendarWeekdayFormat: prop_types_default.a.oneOf(['narrow', 'short', 'long'])
};
/* harmony default export */ var Pickers_DatePicker = (DatePicker_DatePicker);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/DatePickerContainer.js
var DatePickerContainer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function DatePickerContainer_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function DatePickerContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DatePickerContainer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DatePickerContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable new-cap,no-shadow */






















/**
 * The `DatePickerContainer` component is a wrapper for the main `DatePicker` component
 * to manage the state and _logic_ for rendering the `DatePicker`. This component will
 * either render inline or in a `Dialog` depending if the `inline` prop is set to `true`.
 *
 * NOTE: This component is actually exported as `DatePicker` when using the `import { member }` syntax.
 * The following two lines are equivalent:
 *
 * ```js
 * import { DatePicker } from 'react-md/lib/Pickers';
 * import DatePicker from 'react-md/lib/Pickers/DatePickerContainer';
 * ```
 */

var DatePickerContainer_DatePickerContainer = function (_PureComponent) {
  DatePickerContainer_inherits(DatePickerContainer, _PureComponent);

  function DatePickerContainer(props) {
    DatePickerContainer_classCallCheck(this, DatePickerContainer);

    var _this = DatePickerContainer_possibleConstructorReturn(this, _PureComponent.call(this, props));

    DatePickerContainer_initialiseProps.call(_this);

    var date = void 0;
    var value = void 0;
    var defaultValue = props.defaultValue,
        DateTimeFormat = props.DateTimeFormat,
        locales = props.locales,
        formatOptions = props.formatOptions,
        minDate = props.minDate,
        maxDate = props.maxDate;


    if (typeof props.value !== 'undefined') {
      date = _this._getDate(props.value);
    } else if (defaultValue) {
      date = _this._getDate(defaultValue);
      value = typeof defaultValue === 'string' ? defaultValue : DateTimeFormat(locales, formatOptions).format(defaultValue);
    } else {
      date = new Date();
      value = '';
    }

    date = _this._validateDateRange(date, minDate, maxDate);

    var defaultCalendarDate = typeof props.initialCalendarDate !== 'undefined' ? props.initialCalendarDate : props.defaultCalendarDate;
    var calendarTempDate = date;
    if (typeof defaultCalendarDate !== 'undefined' && !props.value && !props.defaultValue) {
      calendarTempDate = _this._getDate(defaultCalendarDate);
      date = calendarTempDate;
    } else if (calendarTempDate === null) {
      calendarTempDate = new Date();
      date = new Date();
    }

    var visible = typeof props.initiallyOpen !== 'undefined' ? props.initiallyOpen : !!props.defaultVisible;

    _this.state = {
      value: value,
      visible: visible,
      calendarDate: date,
      calendarTempDate: calendarTempDate,
      calendarMode: props.initialCalendarMode || props.defaultCalendarMode
    };
    return _this;
  }

  DatePickerContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var value = nextProps.value,
        minDate = nextProps.minDate,
        maxDate = nextProps.maxDate;

    var minEqual = isSameDay(this.props.minDate, minDate);
    var maxEqual = isSameDay(this.props.maxDate, maxDate);
    if (this.props.value !== value || !minEqual || !maxEqual) {
      var calendarDate = this.state.calendarDate;

      if (typeof value !== 'undefined') {
        calendarDate = this._getDate(value);
      }

      calendarDate = this._validateDateRange(calendarDate, minDate, maxDate);

      if (!isSameDay(this.state.calendarDate, calendarDate)) {
        this.setState({ calendarDate: calendarDate, calendarTempDate: calendarDate });
      }
    }
  };

  DatePickerContainer.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var _props = this.props,
        inline = _props.inline,
        isOpen = _props.isOpen;

    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(this.props, this.state, 'visible');
    var pVisible = typeof prevProps.isOpen !== 'undefined' ? prevProps.isOpen : getField(prevProps, prevState, 'visible');

    if (visible === pVisible) {
      return;
    }

    if (visible) {
      if (inline) {
        handleWindowClickListeners(this._handleOutsideClick, true);
        window.addEventListener('keydown', this._closeOnEsc);
      }
    } else if (inline) {
      handleWindowClickListeners(this._handleOutsideClick, false);
      window.removeEventListener('keydown', this._closeOnEsc);
    }
  };

  DatePickerContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    var visible = typeof this.props.isOpen !== 'undefined' ? this.props.isOpen : getField(this.props, this.state, 'visible');

    if (visible && this.props.inline) {
      handleWindowClickListeners(this._handleOutsideClick, false);
      window.removeEventListener('keydown', this._closeOnEsc);
    }
  };

  DatePickerContainer.prototype._getDate = function _getDate(value) {
    if (value === '' || value === null) {
      return new Date();
    } else if (typeof value === 'string') {
      return new Date(value);
    }

    return value;
  };

  /**
   * Gets the current value from the date picker as a formatted string.
   *
   * @param {Object} props? the props object to use.
   * @param {Object} state? the state object to use.
   * @return {String} a formatted date string or the empty string.
   */
  DatePickerContainer.prototype._getFormattedValue = function _getFormattedValue(props, state) {
    var DateTimeFormat = props.DateTimeFormat,
        locales = props.locales,
        formatOptions = props.formatOptions;

    var value = getField(props, state, 'value');
    if (!value) {
      return '';
    } else if (value instanceof Date) {
      return DateTimeFormat(locales, formatOptions).format(new Date(value));
    } else {
      return value;
    }
  };

  /**
   * Attempts to validate the `calendarDate` in the state against the min and
   * max dates.
   *
   * This will return null if the current calendarDate is still within the range.
   *
   * @param {Date} calendarDate - The current calendar date to compare to.
   * @param {Date} minDate - An optional min date to compare to.
   * @param {Date} maxDate - An optional max date to compare to.
   * @return {Object} - The new state object with the updated calendarDate and
   *    calendarTempDate keys or null.
   */


  DatePickerContainer.prototype._validateDateRange = function _validateDateRange(calendarDate, minDate, maxDate) {
    var date = calendarDate;
    if (minDate && minDate > calendarDate) {
      date = new Date(minDate);
    }

    if (maxDate && maxDate < calendarDate) {
      date = new Date(maxDate);
    }

    return date;
  };

  DatePickerContainer.prototype.render = function render() {
    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        pickerStyle = _props2.pickerStyle,
        pickerClassName = _props2.pickerClassName,
        pickerHeaderClassName = _props2.pickerHeaderClassName,
        pickerContentClassName = _props2.pickerContentClassName,
        pickerFooterClassName = _props2.pickerFooterClassName,
        inputStyle = _props2.inputStyle,
        inputClassName = _props2.inputClassName,
        textFieldStyle = _props2.textFieldStyle,
        textFieldClassName = _props2.textFieldClassName,
        label = _props2.label,
        placeholder = _props2.placeholder,
        icon = _props2.icon,
        inline = _props2.inline,
        displayMode = _props2.displayMode,
        fullWidth = _props2.fullWidth,
        lineDirection = _props2.lineDirection,
        id = _props2.id,
        disabled = _props2.disabled,
        closeOnEsc = _props2.closeOnEsc,
        animateInline = _props2.animateInline,
        portal = _props2.portal,
        renderNode = _props2.renderNode,
        lastChild = _props2.lastChild,
        block = _props2.block,
        paddedBlock = _props2.paddedBlock,
        active = _props2.active,
        error = _props2.error,
        floating = _props2.floating,
        required = _props2.required,
        leftIconStateful = _props2.leftIconStateful,
        rightIcon = _props2.rightIcon,
        rightIconStateful = _props2.rightIconStateful,
        customSize = _props2.customSize,
        errorText = _props2.errorText,
        helpText = _props2.helpText,
        helpOnFocus = _props2.helpOnFocus,
        inlineIndicator = _props2.inlineIndicator,
        disableScrollLocking = _props2.disableScrollLocking,
        ariaLabel = _props2['aria-label'],
        propNextIcon = _props2.nextIcon,
        propPreviousIcon = _props2.previousIcon,
        isOpen = _props2.isOpen,
        previousIconChildren = _props2.previousIconChildren,
        previousIconClassName = _props2.previousIconClassName,
        nextIconChildren = _props2.nextIconChildren,
        nextIconClassName = _props2.nextIconClassName,
        propValue = _props2.value,
        propVisible = _props2.visible,
        defaultValue = _props2.defaultValue,
        defaultVisible = _props2.defaultVisible,
        onChange = _props2.onChange,
        readOnly = _props2.readOnly,
        onVisibilityChange = _props2.onVisibilityChange,
        defaultCalendarDate = _props2.defaultCalendarDate,
        initialCalendarDate = _props2.initialCalendarDate,
        initiallyOpen = _props2.initiallyOpen,
        adjustMinWidth = _props2.adjustMinWidth,
        props = DatePickerContainer_objectWithoutProperties(_props2, ['style', 'className', 'pickerStyle', 'pickerClassName', 'pickerHeaderClassName', 'pickerContentClassName', 'pickerFooterClassName', 'inputStyle', 'inputClassName', 'textFieldStyle', 'textFieldClassName', 'label', 'placeholder', 'icon', 'inline', 'displayMode', 'fullWidth', 'lineDirection', 'id', 'disabled', 'closeOnEsc', 'animateInline', 'portal', 'renderNode', 'lastChild', 'block', 'paddedBlock', 'active', 'error', 'floating', 'required', 'leftIconStateful', 'rightIcon', 'rightIconStateful', 'customSize', 'errorText', 'helpText', 'helpOnFocus', 'inlineIndicator', 'disableScrollLocking', 'aria-label', 'nextIcon', 'previousIcon', 'isOpen', 'previousIconChildren', 'previousIconClassName', 'nextIconChildren', 'nextIconClassName', 'value', 'visible', 'defaultValue', 'defaultVisible', 'onChange', 'readOnly', 'onVisibilityChange', 'defaultCalendarDate', 'initialCalendarDate', 'initiallyOpen', 'adjustMinWidth']);

    var nextIcon = getDeprecatedIcon(nextIconClassName, nextIconChildren, propNextIcon);
    var previousIcon = getDeprecatedIcon(previousIconClassName, previousIconChildren, propPreviousIcon);
    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(this.props, this.state, 'visible');

    var picker = react_default.a.createElement(Pickers_DatePicker, DatePickerContainer_extends({}, this.state, props, {
      nextIcon: nextIcon,
      previousIcon: previousIcon,
      icon: !!icon,
      inline: inline,
      style: pickerStyle,
      className: pickerClassName,
      headerClassName: pickerHeaderClassName,
      contentClassName: pickerContentClassName,
      footerClassName: pickerFooterClassName,
      displayMode: displayMode,
      onCancelClick: this._handleCancelClick,
      onOkClick: this._handleOkClick,
      changeCalendarMode: this._changeCalendarMode,
      onPreviousClick: this._previousMonth,
      onNextClick: this._nextMonth,
      onCalendarDateClick: this._setCalendarTempDate,
      onCalendarYearClick: this._setCalendarTempYear
    }));

    var content = void 0;
    if (inline) {
      content = react_default.a.createElement(
        Helpers_Collapse,
        { collapsed: !visible, animate: animateInline },
        picker
      );
    } else {
      content = react_default.a.createElement(
        Dialogs_DialogContainer,
        {
          id: id + '-dialog',
          visible: visible,
          onHide: this._handleCancelClick,
          dialogClassName: 'md-dialog--picker',
          contentClassName: 'md-dialog-content--picker',
          'aria-label': ariaLabel,
          closeOnEsc: closeOnEsc,
          renderNode: renderNode,
          portal: portal,
          lastChild: lastChild,
          focusOnMount: false,
          disableScrollLocking: disableScrollLocking
        },
        picker
      );
    }

    return react_default.a.createElement(
      'div',
      { style: style, className: classnames_default()('md-picker-container', className), ref: this._setContainer },
      react_default.a.createElement(TextFields_TextField, {
        id: id,
        style: textFieldStyle,
        className: classnames_default()({ 'md-pointer--hover': !disabled }, textFieldClassName),
        inputStyle: inputStyle,
        inputClassName: classnames_default()({ 'md-pointer--hover': !disabled }, inputClassName),
        active: active || visible,
        error: error,
        floating: floating || visible,
        required: required,
        disabled: disabled,
        leftIcon: icon,
        leftIconStateful: leftIconStateful,
        rightIcon: rightIcon,
        rightIconStateful: rightIconStateful,
        inlineIndicator: inlineIndicator,
        block: block,
        paddedBlock: paddedBlock,
        fullWidth: fullWidth,
        lineDirection: lineDirection,
        customSize: customSize,
        helpText: helpText,
        helpOnFocus: helpOnFocus,
        errorText: errorText,
        label: label,
        placeholder: placeholder,
        onClick: this._toggleOpen,
        onKeyDown: this._handleKeyDown,
        value: this._getFormattedValue(this.props, this.state),
        readOnly: true
      }),
      content
    );
  };

  return DatePickerContainer;
}(react["PureComponent"]);

DatePickerContainer_DatePickerContainer.propTypes = {
  /**
   * An id for the text field in the date picker. This is require for a11y.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])),

  /**
   * An aria label for the dialog. This is required for a11y.
   */
  'aria-label': isRequiredForA11y_default()(prop_types_default.a.string),

  /**
   * An optional style to apply to the date picker's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the date picker's container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the date picker.
   */
  pickerStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the date picker.
   */
  pickerClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the header of date picker.
   */
  pickerHeaderClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the content container of date picker.
   */
  pickerContentClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the footer of date picker.
   */
  pickerFooterClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the calendar container of date picker.
   */
  calendarClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the year picker of date picker.
   */
  yearPickerClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the input tag.
   */
  inputStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the input tag.
   */
  inputClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the text field's container.
   */
  textFieldStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the text field's container.
   */
  textFieldClassName: prop_types_default.a.string,

  /**
   * An optional icon to display with the date picker.
   *
   * @see {@link TextFields/TextField#leftIcon}
   */
  icon: prop_types_default.a.node,

  /**
   * Boolean if the date picker is open by default.
   */
  defaultVisible: prop_types_default.a.bool,

  /**
   * An optional label to be displayed in the date picker's text
   * field.
   */
  label: prop_types_default.a.node,

  /**
   * An optional placeholder to be displayed in the date picker's text field.
   */
  placeholder: prop_types_default.a.string,

  /**
   * The value of the date picker. This will make the date picker
   * be a controlled component. This value should either be a
   * formatted date string or a date object.
   */
  value: controlled(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.instanceOf(Date)]), 'onChange', 'defaultValue'),

  /**
   * An optional default value to give for the date picker. This should
   * either be a formatted date string or a date object.
   */
  defaultValue: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.instanceOf(Date)]),

  /**
   * An optional date to use when the calendar is opened for the first time.
   * If this is omitted, it will either be the `defaultValue`, `value`, or
   * today.
   */
  defaultCalendarDate: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.instanceOf(Date)]),

  /**
   * An optional function to call when the selected date is changed
   * by hitting the OK button. The newly formatted date string,
   * the new Date object, and the change event will be given.
   *
   * `onChange(dateString, dateObject, event)`.
   */
  onChange: prop_types_default.a.func,

  /**
   * A function to format the dates since it should be formatted to the user's
   * locale. This _should_ be the `Intl.DateTimeFormat` function. You
   * can also create your own if you really wanted. Inadvisable though.
   *
   * See [intl-polyfill](https://github.com/andyearnshaw/Intl.js/) for more info.
   */
  DateTimeFormat: prop_types_default.a.func.isRequired,

  /**
   * The locales to use for formatting the date. This will default to using
   * the user's language in the browser or `'en-US'` when server rendering.
   */
  locales: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]).isRequired,

  /**
   * The label to use for the ok button on the date picker.
   */
  okLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the ok button should be styled with the primary color.
   */
  okPrimary: prop_types_default.a.bool,

  /**
   * The label to use for the cancel button on the date picker.
   */
  cancelLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the cancel button should be styled with the primary color.
   */
  cancelPrimary: prop_types_default.a.bool,

  /**
   * The initial mode to open the calendar in.
   */
  defaultCalendarMode: prop_types_default.a.oneOf(['calendar', 'year']),

  /**
   * The icon to use to display the previous month icon in the calendar.
   */
  previousIcon: prop_types_default.a.node,

  /**
   * The icon to use to display the next month icon in the calendar.
   */
  nextIcon: prop_types_default.a.node,

  /**
   * An optional min date to use for the date picker. This will prevent
   * any dates before this time to be chosen.
   */
  minDate: prop_types_default.a.instanceOf(Date),

  /**
   * An optional max date to use for the date picker. This will prevent
   * any dates after this time to be chosen.
   */
  maxDate: function maxDate(props, propName, component) {
    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      others[_key - 3] = arguments[_key];
    }

    var err = prop_types_default.a.instanceOf(Date).apply(undefined, [props, propName, component].concat(others));
    if (err || !props.minDate || !props[propName]) {
      return err;
    }

    var minDate = props.minDate,
        maxDate = props.maxDate;

    if (minDate > maxDate) {
      return new Error('The min date: \'' + minDate + '\' is greater than the max date: \'' + maxDate + '\'');
    }

    return null;
  },

  /**
   * Boolean if the date should automatically be selected when a user clicks
   * on a new date instead of making them hit the ok button.
   */
  autoOk: prop_types_default.a.bool,

  /**
   * The number of years to display.
   */
  yearsDisplayed: prop_types_default.a.number,

  /**
   * Boolean if the date picker should be displayed inline instead of in a
   * dialog.
   */
  inline: prop_types_default.a.bool,

  /**
   * An optional force of the display mode of the date picker.
   * This _should_ not really be used since there are media queries
   * to use the correct mode based on device orientation.
   */
  displayMode: prop_types_default.a.oneOf(['landscape', 'portrait']),

  /**
   * The DateTimeFormat options to apply to format the date.
   */
  formatOptions: prop_types_default.a.shape({
    weekday: prop_types_default.a.oneOf(['narrow', 'short', 'long']),
    era: prop_types_default.a.oneOf(['narrow', 'short', 'long']),
    year: prop_types_default.a.oneOf(['numeric', '2-digit']),
    month: prop_types_default.a.oneOf(['numeric', '2-digit', 'narrow', 'short', 'long']),
    day: prop_types_default.a.oneOf(['numeric', '2-digit']),
    hour: prop_types_default.a.oneOf(['numeric', '2-digit']),
    minute: prop_types_default.a.oneOf(['numeric', '2-digit']),
    second: prop_types_default.a.oneOf(['numeric', '2-digit']),
    timeZoneName: prop_types_default.a.oneOf(['short', 'long'])
  }),

  /**
   * Boolean if the text field for the Date Picker should be displayed as full width.
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * The direction that the text field divider expands from when the text field
   * in the date picker gains focus.
   */
  lineDirection: prop_types_default.a.oneOf(['left', 'center', 'right']),

  /**
   * An optional boolean if the time picker is current visible by dialog or inline.
   * If this is set, the `onOpenToggle` function is required.
   */
  visible: controlled(prop_types_default.a.bool, 'onVisibilityChange', 'defaultVisible'),

  /**
   * An optional function to call when the date picker is opened in either a dialog, or
   * inline. The callback will include the next state.
   *
   * ```js
   * onVisibilityChange(!visible, e);
   * ```
   */
  onVisibilityChange: prop_types_default.a.func,

  /**
   * Boolean if the time picker is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * Boolean if the dialog should be able to close if a keyboard user presses the escape key.
   */
  closeOnEsc: prop_types_default.a.bool,

  /**
   * Boolean if the inline time picker's visibility should be animated.
   */
  animateInline: prop_types_default.a.bool,

  /**
   * Boolean if the time is required.
   *
   * @see {@link TextFields/TextField#required}
   */
  required: prop_types_default.a.bool,

  /**
   * @see {@link TextFields/TextField#block}
   */
  block: TextFields_TextField.propTypes.block,

  /**
   * @see {@link TextFields/TextField#paddedBlock}
   */
  paddedBlock: TextFields_TextField.propTypes.paddedBlock,

  /**
   * @see {@link TextFields/TextField#active}
   */
  active: TextFields_TextField.propTypes.active,

  /**
   * @see {@link TextFields/TextField#error}
   */
  error: TextFields_TextField.propTypes.error,

  /**
   * @see {@link TextFields/TextField#floating}
   */
  floating: TextFields_TextField.propTypes.floating,

  /**
   * @see {@link TextFields/TextField#leftIconStateful}
   */
  leftIconStateful: TextFields_TextField.propTypes.leftIconStateful,

  /**
   * @see {@link TextFields/TextField#rightIcon}
   */
  rightIcon: TextFields_TextField.propTypes.rightIcon,

  /**
   * @see {@link TextFields/TextField#rightIconStateful}
   */
  rightIconStateful: TextFields_TextField.propTypes.rightIconStateful,

  /**
   * @see {@link TextFields/TextField#customSize}
   */
  customSize: TextFields_TextField.propTypes.customSize,

  /**
   * @see {@link TextFields/TextField#errorText}
   */
  errorText: TextFields_TextField.propTypes.errorText,

  /**
   * @see {@link TextFields/TextField#helpText}
   */
  helpText: TextFields_TextField.propTypes.helpText,

  /**
   * @see {@link TextFields/TextField#helpOnFocus}
   */
  helpOnFocus: TextFields_TextField.propTypes.helpOnFocus,

  /**
   * @see {@link TextFields/TextField#inlineIndicator}
   */
  inlineIndicator: TextFields_TextField.propTypes.inlineIndicator,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the dialog.
   *
   * @see {@link Helpers/Portal}
   */
  portal: prop_types_default.a.bool,

  /**
   * An optional DOM Node to render the dialog into. The default is to render as the first child
   * in the `body`.
   */
  renderNode: prop_types_default.a.object,

  /**
   * Boolean if the DatePicker should be read only. This will prevent the user from opening the picker
   * and only display the current date in the text field.
   */
  readOnly: prop_types_default.a.bool,

  /**
   * The first day of week: 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
   */
  firstDayOfWeek: prop_types_default.a.oneOf([0, 1, 2, 3, 4, 5, 6]),

  /**
   * True if weekends are to be greyed out.
   */
  disableWeekEnds: prop_types_default.a.bool,

  /**
   * True if dates from adjacent months should be shown in calendar.
   */
  showAllDays: prop_types_default.a.bool,

  /**
   * Boolean if the dates from adjacent months should be disabled. This will only
   * do something if the `showAllDays` prop is enabled as well.
   *
   * This is really only helpful if youd like the other days to appear, but not be
   * clickable until the user switches to that month.
   *
   * @see {@link #showAllDays}
   */
  disableOuterDates: prop_types_default.a.bool,

  /**
   * An optional className to apply to a date in calendar.
   */
  calendarDateClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to a date from an adjacent month in calendar. This will be applied
   * along with the `calendarDateClassName`.
   *
   * @see {@link #showAllDays}
   * @see {@link #calendarDateClassName}
   */
  calendarOuterDateClassName: prop_types_default.a.string,

  /**
   * An optional className to apply to the title in calendar header.
   */
  calendarTitleClassName: prop_types_default.a.string,

  /**
   * The DateTimeFormat options to apply to format the title in calendar header.
   */
  calendarTitleFormat: prop_types_default.a.shape({
    era: prop_types_default.a.oneOf(['narrow', 'short', 'long']),
    year: prop_types_default.a.oneOf(['numeric', '2-digit']),
    month: prop_types_default.a.oneOf(['numeric', '2-digit', 'narrow', 'short', 'long'])
  }),

  /**
   * An optional className to apply to a weekday in calendar header.
   */
  calendarWeekdayClassName: prop_types_default.a.string,

  /**
   * The DateTimeFormat option to apply to format a weekday in calendar header.
   */
  calendarWeekdayFormat: prop_types_default.a.oneOf(['narrow', 'short', 'long']),

  /**
   * @see {@link Dialogs/DialogContainer#disableScrollLocking}
   */
  disableScrollLocking: prop_types_default.a.bool,

  /**
   * Boolean if the dialog should be rendered as the last child of the `renderNode` or `body` instead
   * of the first.
   */
  lastChild: prop_types_default.a.bool,

  /**
   * True if the datepicker should swap to calendar mode automatically after a year is picked
   * while in `year` mode.
   */
  closeYearOnSelect: prop_types_default.a.bool,

  previousIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `previousIcon` prop instead'),
  previousIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `previousIcon` prop instead'),
  nextIconChildren: deprecated_default()(prop_types_default.a.node, 'use the `nextIcon` prop instead'),
  nextIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `nextIcon` prop instead'),
  adjustMinWidth: deprecated_default()(prop_types_default.a.bool, 'No longer valid for a text field'),
  isOpen: deprecated_default()(prop_types_default.a.bool, 'Use `visible` instead'),
  initiallyOpen: deprecated_default()(prop_types_default.a.bool, 'Use `defaultVisible` instead'),
  initialCalendarDate: deprecated_default()(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.instanceOf(Date)]), 'Use `defaultCalendarDate` instead'),
  initialCalendarMode: deprecated_default()(prop_types_default.a.oneOf(['calendar', 'year']), 'Use `defaultCalendarMode` instead'),
  initialYearsDisplayed: deprecated_default()(prop_types_default.a.number, 'Use `yearsDisplayed` instead. I have not implemented infinite loading years')
};
DatePickerContainer_DatePickerContainer.defaultProps = {
  animateInline: true,
  previousIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'chevron_left'
  ),
  nextIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'chevron_right'
  ),
  autoOk: false,
  icon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'date_range'
  ),
  yearsDisplayed: 100,
  defaultCalendarMode: 'calendar',
  DateTimeFormat: DateUtils_DateTimeFormat, // eslint-disable-line object-shorthand
  locales: typeof window !== 'undefined' ? window.navigator.userLanguage || window.navigator.language : 'en-US',
  okLabel: 'Ok',
  okPrimary: true,
  cancelLabel: 'Cancel',
  cancelPrimary: true,
  closeOnEsc: true,
  closeYearOnSelect: false,
  disableScrollLocking: false,
  'aria-label': 'Pick a date'
};

var DatePickerContainer_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setContainer = function (container) {
    _this2._container = container;
  };

  this._closeOnEsc = function (e) {
    if ((e.which || e.keyCode) === ESC) {
      _this2._handleCancelClick(e);
    }
  };

  this._handleOutsideClick = function (e) {
    if (_this2._container && !_this2._container.contains(e.target)) {
      _this2._handleCancelClick(e);
    }
  };

  this._toggleOpen = function (e) {
    if (_this2.props.disabled || _this2.props.readOnly) {
      return;
    }

    var visible = !(typeof _this2.props.isOpen !== 'undefined' ? _this2.props.isOpen : getField(_this2.props, _this2.state, 'visible'));

    if (_this2.props.onVisibilityChange) {
      _this2.props.onVisibilityChange(visible, e);
    }

    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.visible === 'undefined') {
      _this2.setState({ visible: visible });
    }
  };

  this._handleKeyDown = function (e) {
    handleKeyboardAccessibility(e, _this2._toggleOpen, true, true);

    if ((e.which || e.keyCode) === TAB && _this2.state.active) {
      _this2.setState({ active: false });
    }
  };

  this._handleOkClick = function (e) {
    var _props3 = _this2.props,
        DateTimeFormat = _props3.DateTimeFormat,
        locales = _props3.locales,
        onChange = _props3.onChange,
        formatOptions = _props3.formatOptions,
        onVisibilityChange = _props3.onVisibilityChange;

    var value = DateTimeFormat(locales, formatOptions).format(_this2.state.calendarTempDate);
    if (onChange) {
      onChange(value, new Date(_this2.state.calendarTempDate), e);
    }

    if (onVisibilityChange) {
      onVisibilityChange(false, e);
    }

    var state = void 0;
    if (typeof _this2.props.value === 'undefined') {
      state = { value: value };
    }

    if (typeof _this2.props.visible === 'undefined' && typeof _this2.props.isOpen === 'undefined') {
      state = state || {};
      state.visible = false;
    }

    if (state) {
      _this2.setState(state);
    }
  };

  this._handleCancelClick = function (e) {
    var state = { calendarTempDate: _this2.state.calendarDate };
    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.isOpen === 'undefined') {
      state.visible = false;
    }

    if (_this2.props.onVisibilityChange) {
      _this2.props.onVisibilityChange(false, e);
    }

    _this2.setState(state);
  };

  this._changeCalendarMode = function (calendarMode) {
    if (_this2.state.calendarMode === calendarMode) {
      return;
    }

    _this2.setState({ calendarMode: calendarMode });
  };

  this._previousMonth = function () {
    var calendarDate = addDate(_this2.state.calendarDate, -1, 'M');
    _this2.setState({ calendarDate: calendarDate });
  };

  this._nextMonth = function () {
    var calendarDate = addDate(_this2.state.calendarDate, 1, 'M');
    _this2.setState({ calendarDate: calendarDate });
  };

  this._setCalendarTempDate = function (calendarTempDate) {
    var _props4 = _this2.props,
        autoOk = _props4.autoOk,
        DateTimeFormat = _props4.DateTimeFormat,
        locales = _props4.locales,
        onChange = _props4.onChange,
        formatOptions = _props4.formatOptions;


    var state = { calendarTempDate: calendarTempDate };
    if (autoOk) {
      var value = DateTimeFormat(locales, formatOptions).format(calendarTempDate);
      if (onChange) {
        onChange(value, new Date(calendarTempDate));
      }

      if (typeof _this2.props.value === 'undefined') {
        state.value = value;
      }

      _this2._timeout = setTimeout(function () {
        _this2._timeout = null;

        if (_this2.props.onVisibilityChange) {
          _this2.props.onVisibilityChange(false);
        }

        if (typeof _this2.props.visible === 'undefined' && typeof _this2.props.isOpen === 'undefined') {
          _this2.setState({ visible: false });
        }
      });
    }
    _this2.setState(state);
  };

  this._setCalendarTempYear = function (year) {
    var _state = _this2.state,
        calendarTempDate = _state.calendarTempDate,
        calendarDate = _state.calendarDate;

    if (calendarTempDate.getFullYear() === year) {
      return;
    }

    var _props5 = _this2.props,
        minDate = _props5.minDate,
        maxDate = _props5.maxDate;

    var nextDate = new Date(calendarDate.setFullYear(year));
    var nextTemp = new Date(calendarTempDate.setFullYear(year));

    if (minDate && nextTemp < minDate) {
      nextDate = new Date(minDate);
      nextTemp = new Date(minDate);
    }

    if (maxDate && nextTemp > maxDate) {
      nextDate = new Date(maxDate);
      nextTemp = new Date(maxDate);
    }

    _this2.setState({
      calendarDate: nextDate,
      calendarTempDate: nextTemp
    });

    if (_this2.props.closeYearOnSelect) {
      _this2._changeCalendarMode('calendar');
    }
  };
};

/* harmony default export */ var Pickers_DatePickerContainer = (DatePickerContainer_DatePickerContainer);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/DateUtils/formatTime.js
/** @module utils/DateUtils/formatTime */

/**
 * Formats a date as a time string using the DateTimeFormat function and locales.
 *
 * @param {function} DateTimeFormat the DateTimeFormat function to use.
 * @param {string|string[]} locales the locales to use.
 * @param {Boolean} showSeconds boolean if seconds should be formatted
 * @param {Date} time the time to format into a string.
 * @return a string of the formatted time.
 */
function formatTime(DateTimeFormat, locales, showSeconds, time) {
  var format = void 0;
  if (showSeconds === true) {
    format = { hour: 'numeric', minute: '2-digit', second: '2-digit' };
  } else {
    format = { hour: 'numeric', minute: '2-digit' };
  }

  return new DateTimeFormat(locales, format).format(time);
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/DateUtils/extractTimeParts.js
/** @module utils/DateUtils/extractTimeParts */


/**
 * Extracts the hours, minutes, and optional time period from
 * a date time.
 *
 * @param {function} DateTimeFormat the DateTimeFormat function to use.
 * @param {string|string[]} locales the locales to use.
 * @param {Boolean} showSeconds boolean if seconds should be extracted
 * @param {Date} time the time to extract from.
 * @return {Object} an object of { hours, minutes, timePeriod }
 */
function extractTimeParts(DateTimeFormat, locales, showSeconds, time) {
  var hours = void 0;
  var minutes = void 0;
  var seconds = void 0;
  var minuteSeparator = void 0;
  var secondSeparator = void 0;
  var remaining = void 0;
  var formatted = formatTime(DateTimeFormat, locales, showSeconds, time);
  // IE does not like lookaheads or splitting on [^0-9]
  // it will include the non-printable characters..

  if (showSeconds === true) {
    var _formatted$match = formatted.match(/[0-9]+/g);

    hours = _formatted$match[0];
    minutes = _formatted$match[1];
    seconds = _formatted$match[2];

    var _formatted$match2 = formatted.match(/[ ,.:A-z]+/g);

    minuteSeparator = _formatted$match2[0];
    secondSeparator = _formatted$match2[1];
    remaining = _formatted$match2.slice(2);
  } else {
    var _formatted$match3 = formatted.match(/[0-9]+/g);

    hours = _formatted$match3[0];
    minutes = _formatted$match3[1];

    var _formatted$match4 = formatted.match(/[ ,.:A-z]+/g);

    minuteSeparator = _formatted$match4[0];
    remaining = _formatted$match4.slice(1);
  }

  var timePeriod = void 0;
  if (remaining && remaining.length) {
    timePeriod = remaining.join('').trim();
  }

  if (showSeconds === true) {
    return {
      hours: hours,
      minutes: minuteSeparator + minutes,
      seconds: secondSeparator + seconds,
      timePeriod: timePeriod
    };
  }

  return {
    hours: hours,
    minutes: minuteSeparator + minutes,
    timePeriod: timePeriod
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/NumberUtils/calcTimeFromPoint.js
/** @module utils/NumberUtils/calcTimeFromPoint */

function isPointInCircle(cx, cy, r, x, y) {
  var distance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);
  return distance <= Math.pow(r, 2);
}

function toDegrees(radians) {
  return radians * (180 / Math.PI);
}

/**
 * Takes a point from a mouse or touch event and a center point of a circle to determine
 * what the new time should be.
 *
 * If the point.y < center.y, the point is in the top half of the circle.
 * If the point.x < center.x, the point is in the left half of the circle.
 *
 * @param {Object} point - The mouse or touch event's point that contains an x and y coordinate.
 * @param {Object} center - The center point for the circle that contains an x and y coordinate.
 * @param {Number} innerRadius - An inner radius for clocks that have 24 hour times. This is
 *    a circle that contains hours 12-23.
 * @param {Boolean} minutes - Boolena if the current time to be calculated is minutes instead of
 *    hours.
 * @param {Boolean} hour12 - Boolean if the clock is a 12 hour clock.
 * @return {Number} the new time.
 */
function calcTimeFromPoint(point, center, innerRadius, minutes, hour12) {
  var x = point.x - center.x;
  var y = point.y - center.y;
  var degrees = toDegrees(Math.atan2(y, x));
  var sectors = minutes ? 60 : 12;
  var sectorSize = 360 / sectors;
  var time = Math.round(degrees / sectorSize);

  // Since the css transform has 0π at π/2 place, we need to offset the
  // time to that location.
  time += minutes ? 15 : 3;

  // If time is still negative, it is in the top half of the circle
  if (time < 0) {
    time += sectors;
  }

  // Finally, if it is a 24 hour clock, need to check if the point is actually
  // selecting hours 13 - 24 (0).
  if (!minutes && !hour12) {
    var isInCircle = isPointInCircle(0, 0, innerRadius, x, y);

    if (time === 0 && !isInCircle || time !== 0 && isInCircle) {
      time += 12;
    }
  }

  return time;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/ClockTime.js
function ClockTime_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ClockTime_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ClockTime_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var CLOCK_PADDING = 4;

/**
 * The `ClockTime` component is used for positioning hours or minutes
 * in a clock. The time will be positioned based on it's given index
 * and the radius of the clock.
 */

var ClockTime_ClockTime = function (_PureComponent) {
  ClockTime_inherits(ClockTime, _PureComponent);

  function ClockTime(props) {
    ClockTime_classCallCheck(this, ClockTime);

    var _this = ClockTime_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._handleKeyUp = function (e) {
      if ((e.which || e.keyCode) === TAB) {
        _this.props.onKeyboardFocus(_this.props.time);
      }
    };

    _this._setTime = function (time) {
      _this._time = time;
      if (time !== null) {
        _this._setPosition(_this.props, time);

        if (_this.props.active) {
          time.focus();
        }
      }
    };

    _this._setPosition = function (_ref, time) {
      var radius = _ref.radius,
          index = _ref.index;

      // 36 is default size for the time
      var size = (time.offsetWidth || 36) / 2;
      var timeRadians = Math.PI / 2 - index * (Math.PI / 6);
      var innerCircle = index > 12;

      var outerRadius = radius - size;
      var innerRadius = outerRadius - CLOCK_PADDING - (innerCircle ? size * 2 : 0);

      _this.setState({
        style: {
          top: outerRadius - innerRadius * Math.sin(timeRadians),
          left: outerRadius + innerRadius * Math.cos(timeRadians)
        }
      });
    };

    _this.state = {
      // default size in scss
      size: 18
    };
    return _this;
  }

  ClockTime.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.radius !== nextProps.radius || this.props.index !== nextProps.index) {
      this._setPosition(nextProps, this._time);
    }
  };

  ClockTime.prototype.render = function render() {
    var _props = this.props,
        time = _props.time,
        active = _props.active;

    return react_default.a.createElement(
      'div',
      {
        ref: this._setTime,
        tabIndex: 0,
        className: classnames_default()('md-clock-time md-text-no-select md-pointer--none', {
          'md-picker-text--active': active
        }, themeColors({ text: !active })),
        style: this.state.style,
        onKeyUp: this._handleKeyUp
      },
      react_default.a.createElement(
        'span',
        { className: 'md-clock-time-value' },
        time
      )
    );
  };

  return ClockTime;
}(react["PureComponent"]);

ClockTime_ClockTime.propTypes = {
  /**
   * The index of the current time to be displayed. This
   * should be a number between 1 and 24.
   */
  index: prop_types_default.a.number.isRequired,

  /**
   * The time number to display.
   */
  time: prop_types_default.a.number.isRequired,

  /**
   * Boolean if this time is currently selected.
   */
  active: prop_types_default.a.bool.isRequired,

  /**
   * The radius of the clock.
   */
  radius: prop_types_default.a.number.isRequired,

  onKeyboardFocus: prop_types_default.a.func.isRequired
};
/* harmony default export */ var Pickers_ClockTime = (ClockTime_ClockTime);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/ClockHand.js
function ClockHand_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ClockHand_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ClockHand_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The `ClockHand` component is just used to display the hand of the clock
 * and a ball to surround the selected time.
 */

var ClockHand_ClockHand = function (_PureComponent) {
  ClockHand_inherits(ClockHand, _PureComponent);

  function ClockHand(props) {
    ClockHand_classCallCheck(this, ClockHand);

    var _this = ClockHand_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = { active: false };
    return _this;
  }

  ClockHand.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (this.props.minutes !== nextProps.minutes) {
      if (this.state.timeout) {
        clearTimeout(this.state.timeout);
      }

      this.setState({
        active: true,
        timeout: setTimeout(function () {
          return _this2.setState({ active: false, timeout: null });
        }, 150)
      });
    }
  };

  ClockHand.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.state.timeout) {
      clearTimeout(this.state.timeout);
    }
  };

  ClockHand.prototype._calcCurrentDegrees = function _calcCurrentDegrees(_ref) {
    var time = _ref.time,
        minutes = _ref.minutes;

    var timeAt0Deg = minutes ? 15 : 3;
    var sectors = minutes ? 60 : 12;

    return (time % sectors - timeAt0Deg) * (360 / sectors);
  };

  ClockHand.prototype.render = function render() {
    var _props = this.props,
        coords = _props.coords,
        time = _props.time,
        minutes = _props.minutes;


    var degrees = this._calcCurrentDegrees(this.props);
    var invisibleMinute = false;
    if (minutes) {
      invisibleMinute = degrees % (360 / 12) !== 0;
    }

    var rotateTransform = 'rotate3d(0, 0, 1, ' + degrees + 'deg)';
    return react_default.a.createElement('div', {
      className: classnames_default()('md-clock-hand md-background--primary', {
        'md-clock-hand--active': this.state.active,
        'md-clock-hand--minute-hover': invisibleMinute,
        'md-clock-hand--inner': !minutes && (time > 12 || time === 0)
      }),
      style: {
        left: coords,
        top: coords,
        WebkitTransform: rotateTransform,
        MozTransform: rotateTransform,
        msTransform: rotateTransform,
        transform: rotateTransform
      }
    });
  };

  return ClockHand;
}(react["PureComponent"]);

ClockHand_ClockHand.propTypes = {
  /**
   * This is the x and y coordinate to use for the center of the `ClockFace`.
   * This should really be whatever the radius of the `ClockFace` is.
   */
  coords: prop_types_default.a.number,

  /**
   * The current time of the clock.
   */
  time: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the clock is displaying minutes instead of hours.
   */
  minutes: prop_types_default.a.bool.isRequired
};
/* harmony default export */ var Pickers_ClockHand = (ClockHand_ClockHand);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/ClockFace.js
function ClockFace_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ClockFace_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ClockFace_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }














/**
 * The `ClockFace` component is used for rendering all the clock's times
 * and the clock hand.
 */

var ClockFace_ClockFace = function (_PureComponent) {
  ClockFace_inherits(ClockFace, _PureComponent);

  function ClockFace(props) {
    ClockFace_classCallCheck(this, ClockFace);

    var _this = ClockFace_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setFace = function (face) {
      _this._face = face;
      _this._setPositioning();
    };

    _this._setPositioning = function () {
      if (!_this._face) {
        return;
      }

      var radius = _this._face.offsetWidth / 2;
      var offset = calcPageOffset(_this._face);
      _this._center = { x: offset.left + radius, y: offset.top + radius };
      _this._left = offset.left;
      _this._top = offset.top;

      if (_this.state.radius !== radius) {
        _this.setState({ radius: radius });
      }
    };

    _this._handleMouseEnter = function () {
      var hoverMode = _this.props.hoverMode;


      if (hoverMode) {
        _this._enableMouseMoving();
      }
    };

    _this._handleMouseLeave = function () {
      var hoverMode = _this.props.hoverMode;


      if (hoverMode) {
        _this._disableMouseMoving();
      }
    };

    _this._handleMouseDown = function (e) {
      if (!isValidClick(e)) {
        return;
      }

      var hoverMode = _this.props.hoverMode;


      if (!hoverMode) {
        _this._enableMouseMoving();
      }
    };

    _this._handleMouseMove = function (e) {
      if (!_this.state.moving) {
        return;
      }

      e.preventDefault();
      _this._calcNewTime(e);
    };

    _this._handleMouseUp = function (e) {
      if (!isValidClick(e)) {
        return;
      }

      var _this$props = _this.props,
          onTimeChosen = _this$props.onTimeChosen,
          hoverMode = _this$props.hoverMode;


      if (_this._face) {
        if (_this._face.contains(e.target)) {
          onTimeChosen();
          _this._calcNewTime(e);
        } else {
          captureNextEvent('click');
        }
      }

      if (!hoverMode) {
        _this._disableMouseMoving();
      }
    };

    _this._handleTouchStart = function () {
      captureNextEvent('mousedown');

      addTouchEvent(window, 'move', _this._handleTouchMove);
      addTouchEvent(window, 'end', _this._handleTouchEnd);
      _this.setState({ moving: true });
    };

    _this._handleTouchMove = function (e) {
      if (!_this.state.moving) {
        return;
      }

      _this._calcNewTime(e);
    };

    _this._handleTouchEnd = function (e) {
      _this._calcNewTime(e);
      if (_this._face && !_this._face.contains(e.target)) {
        captureNextEvent('click');
      }

      removeTouchEvent(window, 'move', _this._handleTouchMove);
      removeTouchEvent(window, 'end', _this._handleTouchEnd);

      _this.setState({ moving: false });
    };

    _this._calcNewTime = function (e) {
      var _ref = e.changedTouches ? e.changedTouches[0] : e,
          x = _ref.pageX,
          y = _ref.pageY;

      var innerRadius = _this.state.radius - 48;
      var _this$props2 = _this.props,
          onChange = _this$props2.onChange,
          minutes = _this$props2.minutes,
          timePeriod = _this$props2.timePeriod;

      onChange(calcTimeFromPoint({ x: x, y: y }, _this._center, innerRadius, minutes, timePeriod));
    };

    _this._enableMouseMoving = function () {
      window.addEventListener('mousemove', _this._handleMouseMove);
      window.addEventListener('mouseup', _this._handleMouseUp);

      _this.setState({ moving: true });
    };

    _this._disableMouseMoving = function () {
      window.removeEventListener('mousemove', _this._handleMouseMove);
      window.removeEventListener('mouseup', _this._handleMouseUp);

      _this.setState({ moving: false });
    };

    _this.state = { radius: 136, moving: false };
    _this._center = {};
    return _this;
  }

  ClockFace.prototype.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener('mousemove', this._handleMouseMove);
    window.removeEventListener('mouseup', this._handleMouseMove);

    removeTouchEvent(window, 'move', this._handleTouchMove);
    removeTouchEvent(window, 'end', this._handleTouchEnd);
    clearInterval(this.interval);
  };

  ClockFace.prototype.render = function render() {
    var _props = this.props,
        time = _props.time,
        minutes = _props.minutes,
        timePeriod = _props.timePeriod,
        onChange = _props.onChange,
        hoverMode = _props.hoverMode;
    var radius = this.state.radius;

    var size = !minutes && !timePeriod ? 24 : 12;
    var times = Array.apply(null, new Array(size)).map(function (_, i) {
      var clockTime = i + 1;
      if (minutes) {
        clockTime = clockTime * 5 % 60;
      } else {
        clockTime %= 24;
      }

      return react_default.a.createElement(Pickers_ClockTime, {
        key: 'time-' + i,
        index: i + 1,
        time: clockTime,
        active: clockTime === time,
        radius: radius,
        onKeyboardFocus: onChange
      });
    });

    return react_default.a.createElement(
      'div',
      {
        ref: this._setFace,
        className: 'md-clock-face md-block-centered md-pointer--hover',
        onMouseDown: this._handleMouseDown,
        onMouseEnter: hoverMode ? this._handleMouseEnter : undefined,
        onMouseLeave: hoverMode ? this._handleMouseLeave : undefined,
        onTouchStart: this._handleTouchStart
      },
      react_default.a.createElement(Helpers_ResizeObserver, { watchHeight: true, onResize: this._setPositioning }),
      times,
      react_default.a.createElement(Pickers_ClockHand, { time: time, coords: radius, minutes: minutes })
    );
  };

  return ClockFace;
}(react["PureComponent"]);

ClockFace_ClockFace.propTypes = {
  /**
   * The current time for the clock.
   */
  time: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the clock is on the minutes view.
   */
  minutes: prop_types_default.a.bool.isRequired,

  /**
   * A function to call when a new time is selected. It gives the
   * new time value. If it is 12 o'clock, 0 will be given.
   */
  onChange: prop_types_default.a.func.isRequired,

  /**
   * An optional time period string. This should be either AM or PM
   * if the locale uses them.
   */
  timePeriod: prop_types_default.a.string,

  /**
   * If true the hover mode of the Time Picker is activated.
   * In hover mode no clicks are required to start selecting an hour
   * and the timemode switches automatically when a time was chosen.
   * When a minute is selected the chosen time is applied automatically.
   */
  hoverMode: prop_types_default.a.bool,

  onTimeChosen: prop_types_default.a.func.isRequired
};
/* harmony default export */ var Pickers_ClockFace = (ClockFace_ClockFace);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/DateUtils/addHours.js
/** @module utils/DateUtils/addHours */

/**
 * Adds hours to a date.
 *
 * @param {Date} time the time to increment
 * @param {number} hours the number of hours to increment by.
 * @return a new Date with the new hours set.
 */
function addHours(time, hours) {
  var t = new Date(time.getTime());
  t.setHours(t.getHours() + hours);
  return t;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/TimePeriods.js
function TimePeriods_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TimePeriods_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TimePeriods_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * This component displays a section for switching between the AM
 * and PM time periods.
 */

var TimePeriods_TimePeriods = function (_PureComponent) {
  TimePeriods_inherits(TimePeriods, _PureComponent);

  function TimePeriods() {
    var _temp, _this, _ret;

    TimePeriods_classCallCheck(this, TimePeriods);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = TimePeriods_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._setAM = function () {
      if (_this.props.timePeriod !== 'AM') {
        _this.props.setTempTime(addHours(_this.props.tempTime, -12));
      }
    }, _this._setPM = function () {
      if (_this.props.timePeriod !== 'PM') {
        _this.props.setTempTime(addHours(_this.props.tempTime, 12));
      }
    }, _temp), TimePeriods_possibleConstructorReturn(_this, _ret);
  }

  TimePeriods.prototype.render = function render() {
    var timePeriod = this.props.timePeriod;

    return react_default.a.createElement(
      'div',
      { className: 'md-time-periods' },
      react_default.a.createElement(
        Pickers_PickerControl,
        { onClick: this._setAM, active: timePeriod === 'AM' },
        react_default.a.createElement(
          'h6',
          { className: 'md-time-period' },
          'AM'
        )
      ),
      react_default.a.createElement(
        Pickers_PickerControl,
        { onClick: this._setPM, active: timePeriod === 'PM' },
        react_default.a.createElement(
          'h6',
          { className: 'md-time-period' },
          'PM'
        )
      )
    );
  };

  return TimePeriods;
}(react["PureComponent"]);

TimePeriods_TimePeriods.propTypes = {
  /**
   * The current time for the time picker.
   */
  tempTime: prop_types_default.a.instanceOf(Date).isRequired,

  /**
   * A function to update the time for the time picker.
   */
  setTempTime: prop_types_default.a.func.isRequired,

  /**
   * The current time period.
   */
  timePeriod: prop_types_default.a.string.isRequired
};
/* harmony default export */ var Pickers_TimePeriods = (TimePeriods_TimePeriods);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/TimePickerHeader.js
function TimePickerHeader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TimePickerHeader_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TimePickerHeader_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The `TimePickerHeader` component is used for rendering the
 * current time for the `TimePicker` as well as switching between
 * the different views for the time picker.
 */

var TimePickerHeader_TimePickerHeader = function (_PureComponent) {
  TimePickerHeader_inherits(TimePickerHeader, _PureComponent);

  function TimePickerHeader() {
    var _temp, _this, _ret;

    TimePickerHeader_classCallCheck(this, TimePickerHeader);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = TimePickerHeader_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._setHour = function () {
      _this.props.setTimeMode('hour');
    }, _this._setMinute = function () {
      _this.props.setTimeMode('minute');
    }, _this._setSecond = function () {
      _this.props.setTimeMode('second');
    }, _temp), TimePickerHeader_possibleConstructorReturn(_this, _ret);
  }

  TimePickerHeader.prototype.render = function render() {
    var _props = this.props,
        timeMode = _props.timeMode,
        hours = _props.hours,
        minutes = _props.minutes,
        seconds = _props.seconds,
        timePeriod = _props.timePeriod,
        setTempTime = _props.setTempTime,
        tempTime = _props.tempTime,
        showSeconds = _props.showSeconds;

    var timePeriods = void 0;
    if (timePeriod) {
      timePeriods = react_default.a.createElement(Pickers_TimePeriods, { tempTime: tempTime, setTempTime: setTempTime, timePeriod: timePeriod });
    }

    var secondsControl = showSeconds === true ? react_default.a.createElement(
      Pickers_PickerControl,
      { onClick: this._setSecond, active: timeMode === 'second' },
      react_default.a.createElement(
        'h4',
        { className: 'md-display-3' },
        seconds
      )
    ) : null;

    return react_default.a.createElement(
      'header',
      { className: 'md-picker-header md-text-right' },
      react_default.a.createElement(
        Pickers_PickerControl,
        { onClick: this._setHour, active: timeMode === 'hour' },
        react_default.a.createElement(
          'h4',
          { className: 'md-display-3' },
          hours
        )
      ),
      react_default.a.createElement(
        Pickers_PickerControl,
        { onClick: this._setMinute, active: timeMode === 'minute' },
        react_default.a.createElement(
          'h4',
          { className: 'md-display-3' },
          minutes
        )
      ),
      secondsControl,
      timePeriods
    );
  };

  return TimePickerHeader;
}(react["PureComponent"]);

TimePickerHeader_TimePickerHeader.propTypes = {
  /**
   * The current time of the time picker.
   */
  tempTime: prop_types_default.a.instanceOf(Date).isRequired,

  /**
   * The current time type that is being changed.
   */
  timeMode: prop_types_default.a.oneOf(['hour', 'minute', 'second']).isRequired,

  /**
   * A function to update the time mode.
   */
  setTimeMode: prop_types_default.a.func.isRequired,

  /**
   * A function to update the time for the time picker.
   */
  setTempTime: prop_types_default.a.func.isRequired,

  /**
   * A formatted hours string for the user's locale. This
   * would be '3' for en-US if the time was '3:15'
   */
  hours: prop_types_default.a.string.isRequired,

  /**
   * A formatted minutes string for the user's locale.
   * This would be ':15' for en-US if the time was '3:15'.
   */
  minutes: prop_types_default.a.string.isRequired,

  /**
   * A formatted seconds string for the user's locale.
   * This would be ':00' for en-US if the time was '3:15:00'.
   */
  seconds: prop_types_default.a.string,

  /**
   * An optional time period to use for locales that use
   * 12 hour clocks and AM/PM.
   */
  timePeriod: prop_types_default.a.string,

  /**
   * A boolean that if true, seconds are displayed
   */
  showSeconds: prop_types_default.a.bool
};
/* harmony default export */ var Pickers_TimePickerHeader = (TimePickerHeader_TimePickerHeader);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/TimePicker.js
function TimePicker_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TimePicker_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TimePicker_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









/**
 * The `TimePicker` component is used to display a time picker
 * in the `TimePickerContainer` component.
 */

var TimePicker_TimePicker = function (_PureComponent) {
  TimePicker_inherits(TimePicker, _PureComponent);

  function TimePicker() {
    var _temp, _this, _ret;

    TimePicker_classCallCheck(this, TimePicker);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = TimePicker_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._updateTime = function (newTime) {
      var timePart = newTime;
      var _this$props = _this.props,
          tempTime = _this$props.tempTime,
          setTempTime = _this$props.setTempTime,
          timeMode = _this$props.timeMode,
          timePeriod = _this$props.timePeriod;

      var time = new Date(tempTime);
      if (timeMode === 'hour') {
        var isAM = timePeriod === 'AM';
        var is12 = timePart === 12;
        if (timePeriod && isAM && is12) {
          timePart = 0;
        } else if (timePeriod && !isAM && !is12) {
          timePart += 12;
        }

        time.setHours(timePart);
      }

      if (timeMode === 'minute') {
        time.setMinutes(timePart);
      }

      if (timeMode === 'second') {
        time.setSeconds(timePart);
      }

      setTempTime(time);
    }, _this._handleTimeChosen = function () {
      var _this$props2 = _this.props,
          hoverMode = _this$props2.hoverMode,
          setTimeMode = _this$props2.setTimeMode,
          onOkClick = _this$props2.onOkClick,
          timeMode = _this$props2.timeMode;


      if (hoverMode) {
        if (timeMode === 'hour') {
          setTimeMode('minute');
        } else {
          onOkClick();
        }
      }
    }, _temp), TimePicker_possibleConstructorReturn(_this, _ret);
  }

  /**
   * Takes in the new time (number o'clock or minutes), updates the temp time
   * with that new time, and then calls the setTempTime prop.
   */


  TimePicker.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        okLabel = _props.okLabel,
        okPrimary = _props.okPrimary,
        onOkClick = _props.onOkClick,
        cancelLabel = _props.cancelLabel,
        cancelPrimary = _props.cancelPrimary,
        onCancelClick = _props.onCancelClick,
        style = _props.style,
        className = _props.className,
        setTimeMode = _props.setTimeMode,
        setTempTime = _props.setTempTime,
        timeMode = _props.timeMode,
        tempTime = _props.tempTime,
        hours = _props.hours,
        minutes = _props.minutes,
        seconds = _props.seconds,
        timePeriod = _props.timePeriod,
        displayMode = _props.displayMode,
        inline = _props.inline,
        icon = _props.icon,
        hoverMode = _props.hoverMode,
        showSeconds = _props.showSeconds;


    var hoursInt = parseInt(hours, 10);
    var minutesInt = parseInt(minutes.replace(/[^0-9]/g, ''), 10);
    var secondsInt = void 0;
    if (showSeconds) secondsInt = parseInt(seconds.replace(/[^0-9]/g, ''), 10);

    var actions = [{
      key: 'cancel',
      onClick: onCancelClick,
      primary: cancelPrimary,
      secondary: !cancelPrimary,
      label: cancelLabel
    }, {
      key: 'ok',
      onClick: onOkClick,
      primary: okPrimary,
      secondary: !okPrimary,
      label: okLabel
    }];

    var time = void 0;
    if (timeMode === 'hour') time = hoursInt;
    if (timeMode === 'minute') time = minutesInt;
    if (timeMode === 'second') time = secondsInt;

    return react_default.a.createElement(
      'div',
      {
        style: style,
        className: classnames_default()('md-picker md-picker--time', (_cn = {}, _cn['md-picker--' + displayMode] = displayMode, _cn['md-picker--inline'] = inline, _cn['md-picker--inline-icon'] = inline && icon, _cn), className)
      },
      react_default.a.createElement(Pickers_TimePickerHeader, {
        tempTime: tempTime,
        timeMode: timeMode,
        setTimeMode: setTimeMode,
        setTempTime: setTempTime,
        hours: hours,
        minutes: minutes,
        seconds: seconds,
        timePeriod: timePeriod,
        showSeconds: showSeconds
      }),
      react_default.a.createElement(
        'div',
        { className: 'md-picker-content-container' },
        react_default.a.createElement(
          'div',
          { className: 'md-picker-content md-picker-content--clock' },
          react_default.a.createElement(Pickers_ClockFace, {
            time: time,
            minutes: timeMode === 'minute' || timeMode === 'second',
            onChange: this._updateTime,
            timePeriod: timePeriod,
            hoverMode: hoverMode,
            onTimeChosen: this._handleTimeChosen
          })
        ),
        react_default.a.createElement(Dialogs_DialogFooter, { actions: actions })
      )
    );
  };

  return TimePicker;
}(react["PureComponent"]);

TimePicker_TimePicker.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  okLabel: prop_types_default.a.node.isRequired,
  okPrimary: prop_types_default.a.bool.isRequired,
  onOkClick: prop_types_default.a.func.isRequired,
  cancelLabel: prop_types_default.a.node.isRequired,
  cancelPrimary: prop_types_default.a.bool.isRequired,
  onCancelClick: prop_types_default.a.func.isRequired,
  DateTimeFormat: prop_types_default.a.func.isRequired,
  locales: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]).isRequired,
  icon: prop_types_default.a.bool,
  inline: prop_types_default.a.bool,
  displayMode: prop_types_default.a.oneOf(['landscape', 'portrait']),

  /**
   * A function that will switch the state from hour to minute.
   */
  setTimeMode: prop_types_default.a.func.isRequired,

  /**
   * A function that will update the time for the TimePicker before
   * the user selects ok. This function will be given a new Date object
   * with a modified time.
   */
  setTempTime: prop_types_default.a.func.isRequired,

  /**
   * The current display mode of the time picker.
   */
  timeMode: prop_types_default.a.oneOf(['hour', 'minute', 'second']).isRequired,

  /**
   * The current time as a date object that is being displayed in the
   * time picker.
   */
  tempTime: prop_types_default.a.instanceOf(Date).isRequired,

  /**
   * A string that is a representation of the hours in the user's locale.
   */
  hours: prop_types_default.a.string.isRequired,

  /**
   * A string that is a representation of the minutes in the user's locale.
   * This will also include any separator the locale uses.
   *
   * Example: ':15' in '3:15 PM' for 'en-US'
   */
  minutes: prop_types_default.a.string.isRequired,

  /**
   * A string that is a representation of the seconds in the user's locale.
   * This will also include any separator the locale uses.
   *
   * Example: ':00' in '3:15:00 PM' for 'en-US'
   */
  seconds: prop_types_default.a.string,

  /**
   * An optional time period if a user's locale uses it.
   */
  timePeriod: prop_types_default.a.string,

  /**
   * If true the hover mode of the Time Picker is activated.
   * In hover mode no clicks are required to start selecting an hour
   * and the timemode switches automatically when a time was chosen.
   * When a minute is selected the chosen time is applied automatically.
   */
  hoverMode: prop_types_default.a.bool,

  /**
   * A boolean that if true, seconds are displayed
   */
  showSeconds: prop_types_default.a.bool
};
/* harmony default export */ var Pickers_TimePicker = (TimePicker_TimePicker);
// CONCATENATED MODULE: ../node_modules/react-md/es/Pickers/TimePickerContainer.js
var TimePickerContainer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TimePickerContainer_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TimePickerContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TimePickerContainer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TimePickerContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-shadow */




















/**
 * The `TimePickerContainer` component is a wrapper for the main `TimePicker` component
 * to manage the state and _logic_ for rendering the `TimePicker`. This component will
 * either render inline or in a `Dialog` depending if the `inline` prop is set
 * to `true`.
 *
 * NOTE: This component is actually exported as `TimePicker` when using the `import { member }` syntax.
 * The following two lines are equivalent:
 *
 * ```js
 * import { TimePicker } from 'react-md/lib/Pickers';
 * import TimePicker from 'react-md/lib/Pickers/TimePickerContainer';
 * ```
 */

var TimePickerContainer_TimePickerContainer = function (_PureComponent) {
  TimePickerContainer_inherits(TimePickerContainer, _PureComponent);

  function TimePickerContainer(props) {
    TimePickerContainer_classCallCheck(this, TimePickerContainer);

    var _this = TimePickerContainer_possibleConstructorReturn(this, _PureComponent.call(this, props));

    TimePickerContainer_initialiseProps.call(_this);

    var initialDate = void 0;
    if (props.defaultValue) {
      initialDate = new Date(props.defaultValue);
    } else if (props.value) {
      initialDate = new Date(props.value);
    } else {
      initialDate = new Date();
    }

    var visible = typeof props.initiallyOpen !== 'undefined' ? props.initiallyOpen : !!props.defaultVisible;

    _this.state = TimePickerContainer_extends({
      visible: visible
    }, _this._getTimeParts(initialDate, props), {
      value: props.defaultValue,
      time: initialDate,
      timeMode: props.initialTimeMode || props.defaultTimeMode,
      tempTime: initialDate
    });
    return _this;
  }

  TimePickerContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.value !== nextProps.value) {
      var time = nextProps.value || new Date();
      this.setState(TimePickerContainer_extends({ tempTime: time }, this._getTimeParts(time, nextProps)));
    }
  };

  TimePickerContainer.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var _props = this.props,
        inline = _props.inline,
        isOpen = _props.isOpen;

    var visible = typeof isOpen !== 'undefined' ? isOpen : getField(this.props, this.state, 'visible');
    var pVisible = typeof prevProps.isOpen !== 'undefined' ? prevProps.isOpen : getField(prevProps, prevState, 'visible');

    if (visible === pVisible) {
      return;
    }

    if (visible) {
      if (inline) {
        handleWindowClickListeners(this._handleOutsideClick, true);
        window.addEventListener('keydown', this._closeOnEsc);
      }
    } else if (inline) {
      handleWindowClickListeners(this._handleOutsideClick, false);
      window.removeEventListener('keydown', this._closeOnEsc);
    }
  };

  TimePickerContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    var visible = typeof this.props.isOpen !== 'undefined' ? this.props.isOpen : getField(this.props, this.state, 'visible');
    if (visible && this.props.inline) {
      handleWindowClickListeners(this._handleOutsideClick, false);
      window.removeEventListener('keydown', this._closeOnEsc);
    }
  };

  TimePickerContainer.prototype._getTimeParts = function _getTimeParts(date, props) {
    return extractTimeParts(props.DateTimeFormat, props.locales, props.showSeconds, date);
  };

  TimePickerContainer.prototype._getTextFieldValue = function _getTextFieldValue(props, state) {
    var DateTimeFormat = props.DateTimeFormat,
        locales = props.locales,
        showSeconds = props.showSeconds;

    var value = getField(props, state, 'value');
    if (!value) {
      return '';
    } else if (value instanceof Date) {
      return formatTime(DateTimeFormat, locales, showSeconds, value);
    } else {
      // currently don't support value of string
      return value;
    }
  };

  TimePickerContainer.prototype.render = function render() {
    var _state = this.state,
        timeMode = _state.timeMode,
        tempTime = _state.tempTime,
        hours = _state.hours,
        minutes = _state.minutes,
        seconds = _state.seconds,
        timePeriod = _state.timePeriod;

    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        pickerStyle = _props2.pickerStyle,
        pickerClassName = _props2.pickerClassName,
        inputStyle = _props2.inputStyle,
        inputClassName = _props2.inputClassName,
        textFieldStyle = _props2.textFieldStyle,
        textFieldClassName = _props2.textFieldClassName,
        id = _props2.id,
        disabled = _props2.disabled,
        label = _props2.label,
        placeholder = _props2.placeholder,
        icon = _props2.icon,
        inline = _props2.inline,
        displayMode = _props2.displayMode,
        fullWidth = _props2.fullWidth,
        lineDirection = _props2.lineDirection,
        closeOnEsc = _props2.closeOnEsc,
        hoverMode = _props2.hoverMode,
        showSeconds = _props2.showSeconds,
        portal = _props2.portal,
        renderNode = _props2.renderNode,
        lastChild = _props2.lastChild,
        animateInline = _props2.animateInline,
        block = _props2.block,
        paddedBlock = _props2.paddedBlock,
        active = _props2.active,
        error = _props2.error,
        floating = _props2.floating,
        required = _props2.required,
        leftIconStateful = _props2.leftIconStateful,
        rightIcon = _props2.rightIcon,
        rightIconStateful = _props2.rightIconStateful,
        customSize = _props2.customSize,
        errorText = _props2.errorText,
        helpText = _props2.helpText,
        helpOnFocus = _props2.helpOnFocus,
        inlineIndicator = _props2.inlineIndicator,
        disableScrollLocking = _props2.disableScrollLocking,
        ariaLabel = _props2['aria-label'],
        propValue = _props2.value,
        propVisible = _props2.visible,
        readOnly = _props2.readOnly,
        defaultValue = _props2.defaultValue,
        defaultVisible = _props2.defaultVisible,
        defaultTimeMode = _props2.defaultTimeMode,
        onVisibilityChange = _props2.onVisibilityChange,
        isOpen = _props2.isOpen,
        initialTimeMode = _props2.initialTimeMode,
        initiallyOpen = _props2.initiallyOpen,
        props = TimePickerContainer_objectWithoutProperties(_props2, ['style', 'className', 'pickerStyle', 'pickerClassName', 'inputStyle', 'inputClassName', 'textFieldStyle', 'textFieldClassName', 'id', 'disabled', 'label', 'placeholder', 'icon', 'inline', 'displayMode', 'fullWidth', 'lineDirection', 'closeOnEsc', 'hoverMode', 'showSeconds', 'portal', 'renderNode', 'lastChild', 'animateInline', 'block', 'paddedBlock', 'active', 'error', 'floating', 'required', 'leftIconStateful', 'rightIcon', 'rightIconStateful', 'customSize', 'errorText', 'helpText', 'helpOnFocus', 'inlineIndicator', 'disableScrollLocking', 'aria-label', 'value', 'visible', 'readOnly', 'defaultValue', 'defaultVisible', 'defaultTimeMode', 'onVisibilityChange', 'isOpen', 'initialTimeMode', 'initiallyOpen']);

    var visible = typeof this.props.isOpen !== 'undefined' ? this.props.isOpen : getField(this.props, this.state, 'visible');

    var picker = react_default.a.createElement(Pickers_TimePicker, TimePickerContainer_extends({}, props, {
      inline: inline,
      icon: !!icon,
      tempTime: tempTime,
      timeMode: timeMode,
      seconds: seconds,
      hours: hours,
      minutes: minutes,
      timePeriod: timePeriod,
      style: pickerStyle,
      className: pickerClassName,
      displayMode: displayMode,
      onOkClick: this._handleOkClick,
      onCancelClick: this._handleCancelClick,
      setTimeMode: this._setTimeMode,
      setTempTime: this._setTempTime,
      hoverMode: hoverMode,
      showSeconds: showSeconds
    }));

    var content = void 0;
    if (inline) {
      content = react_default.a.createElement(
        Helpers_Collapse,
        { collapsed: !visible, animate: animateInline },
        picker
      );
    } else {
      content = react_default.a.createElement(
        Dialogs_DialogContainer,
        {
          id: id + '-dialog',
          visible: visible,
          onHide: this._handleCancelClick,
          dialogClassName: 'md-dialog--picker',
          contentClassName: 'md-dialog-content--picker',
          'aria-label': ariaLabel,
          closeOnEsc: closeOnEsc,
          portal: portal,
          lastChild: lastChild,
          renderNode: renderNode,
          focusOnMount: false,
          disableScrollLocking: disableScrollLocking
        },
        picker
      );
    }

    return react_default.a.createElement(
      'div',
      { style: style, className: classnames_default()('md-picker-container', className), ref: this._setContainer },
      react_default.a.createElement(TextFields_TextField, {
        id: id,
        style: textFieldStyle,
        className: classnames_default()({ 'md-pointer--hover': !disabled }, textFieldClassName),
        inputStyle: inputStyle,
        inputClassName: classnames_default()({ 'md-pointer--hover': !disabled }, inputClassName),
        active: active || visible,
        error: error,
        floating: floating || visible,
        required: required,
        disabled: disabled,
        leftIcon: icon,
        leftIconStateful: leftIconStateful,
        rightIcon: rightIcon,
        rightIconStateful: rightIconStateful,
        inlineIndicator: inlineIndicator,
        block: block,
        paddedBlock: paddedBlock,
        fullWidth: fullWidth,
        lineDirection: lineDirection,
        customSize: customSize,
        helpText: helpText,
        helpOnFocus: helpOnFocus,
        errorText: errorText,
        label: label,
        placeholder: placeholder,
        onClick: this._toggleOpen,
        onKeyDown: this._handleKeyDown,
        value: this._getTextFieldValue(this.props, this.state),
        readOnly: true
      }),
      content
    );
  };

  return TimePickerContainer;
}(react["PureComponent"]);

TimePickerContainer_TimePickerContainer.propTypes = {
  /**
   * An id for the text field in the time picker. This is require for a11y.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])),

  /**
   * An aria-label to apply to the dialog when it has been opened. This is required for
   * a11y.
   */
  'aria-label': isRequiredForA11y_default()(prop_types_default.a.string),

  /**
   * An optional style to apply to the time picker's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the time picker's container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the time picker.
   */
  pickerStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the time picker.
   */
  pickerClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the input tag.
   */
  inputStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the input tag.
   */
  inputClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the text field's container.
   */
  textFieldStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the text field's container.
   */
  textFieldClassName: prop_types_default.a.string,

  /**
   * An optional icon to display with the time picker.
   *
   * @see {@link TextFields/TextField#leftIcon}
   */
  icon: prop_types_default.a.node,

  /**
   * Boolean if the time picker is open by default.
   */
  defaultVisible: prop_types_default.a.bool,

  /**
   * An optional label to be displayed in the time picker's text
   * field.
   */
  label: prop_types_default.a.node,

  /**
   * An optional placeholder to be displayed in the time picker's text field.
   */
  placeholder: prop_types_default.a.string,

  /**
   * The value of the time picker. This will make the time picker
   * be a controlled component.
   */
  value: controlled(prop_types_default.a.instanceOf(Date), 'onChange', 'defaultValue'),

  /**
   * An optional function to call when the selected date is changed
   * by hitting the OK button. The newly formatted time string,
   * the new Date object, and the change event will be given.
   *
   * `onChange(timeString, dateObject, event)`.
   */
  onChange: prop_types_default.a.func,

  /**
   * An optional default value to give for the year picker.
   */
  defaultValue: prop_types_default.a.instanceOf(Date),

  /**
   * A function to format the dates since it should be formatted to the user's
   * locale. This _should_ be the `Intl.DateTimeFormat` function. You
   * can also create your own if you really wanted. Inadvisable though.
   *
   * See [intl-polyfill](https://github.com/andyearnshaw/Intl.js/) for more info.
   */
  DateTimeFormat: prop_types_default.a.func.isRequired,

  /**
   * The locales to use for formatting the date. This will default to using
   * the user's language in the browser or `'en-US'` when server rendering.
   */
  locales: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string)]).isRequired,

  /**
   * The label to use for the ok button on the year picker.
   */
  okLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the ok button should be styled with the primary color.
   */
  okPrimary: prop_types_default.a.bool,

  /**
   * The label to use for the cancel button on the year picker.
   */
  cancelLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the cancel button should be styled with the primary color.
   */
  cancelPrimary: prop_types_default.a.bool,

  /**
   * The default mode to open the time picker in.
   */
  defaultTimeMode: prop_types_default.a.oneOf(['hour', 'minute', 'second']),

  /**
   * Boolean if the date should automatically be selected when a user clicks
   * on a new date instead of making them hit the ok button.
   */
  autoOk: prop_types_default.a.bool,

  /**
   * Boolean if the date picker should be displayed inline instead of in a
   * dialog.
   */
  inline: prop_types_default.a.bool,

  /**
   * An optional force of the display mode of the date picker.
   * This _should_ not really be used since there are media queries
   * to use the correct mode based on device orientation.
   */
  displayMode: prop_types_default.a.oneOf(['landscape', 'portrait']),

  /**
   * Boolean if the text field for the Time Picker should be displayed as full width.
   */
  fullWidth: prop_types_default.a.bool,

  /**
   * The direction that the text field divider expands from when the text field
   * in the date picker gains focus.
   */
  lineDirection: prop_types_default.a.oneOf(['left', 'center', 'right']),

  /**
   * An optional boolean if the time picker is current visible by dialog or inline.
   * If this is set, the `onVisibilityChange` function is required.
   */
  visible: controlled(prop_types_default.a.bool, 'onVisibilityChange', 'defaultVisible'),

  /**
   * An optional function to call when the date picker is opened in either a dialog, or
   * inline. The callback will include the next state.
   *
   * ```js
   * onVisibilityChange(!visible, e);
   * ```
   */
  onVisibilityChange: prop_types_default.a.func,

  /**
   * Boolean if the time picker is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * Boolean if the dialog should be able to close if a keyboard user presses the escape key.
   */
  closeOnEsc: prop_types_default.a.bool,

  /**
   * If true the hover mode of the Time Picker is activated.
   * In hover mode no clicks are required to start selecting an hour
   * and the time mode switches automatically when a time was chosen.
   * When a minute is selected the chosen time is applied automatically.
   */
  hoverMode: prop_types_default.a.bool,

  /**
   * If true seconds will be selectable in the Time Picker.
   */
  showSeconds: prop_types_default.a.bool,

  /**
   * Boolean if the inline time picker's visibility should be animated.
   */
  animateInline: prop_types_default.a.bool,

  /**
   * Boolean if the time is required.
   *
   * @see {@link TextFields/TextField#required}
   */
  required: prop_types_default.a.bool,

  /**
   * @see {@link TextFields/TextField#block}
   */
  block: TextFields_TextField.propTypes.block,

  /**
   * @see {@link TextFields/TextField#paddedBlock}
   */
  paddedBlock: TextFields_TextField.propTypes.paddedBlock,

  /**
   * @see {@link TextFields/TextField#active}
   */
  active: TextFields_TextField.propTypes.active,

  /**
   * @see {@link TextFields/TextField#error}
   */
  error: TextFields_TextField.propTypes.error,

  /**
   * @see {@link TextFields/TextField#floating}
   */
  floating: TextFields_TextField.propTypes.floating,

  /**
   * @see {@link TextFields/TextField#leftIconStateful}
   */
  leftIconStateful: TextFields_TextField.propTypes.leftIconStateful,

  /**
   * @see {@link TextFields/TextField#rightIcon}
   */
  rightIcon: TextFields_TextField.propTypes.rightIcon,

  /**
   * @see {@link TextFields/TextField#rightIconStateful}
   */
  rightIconStateful: TextFields_TextField.propTypes.rightIconStateful,

  /**
   * @see {@link TextFields/TextField#customSize}
   */
  customSize: TextFields_TextField.propTypes.customSize,

  /**
   * @see {@link TextFields/TextField#errorText}
   */
  errorText: TextFields_TextField.propTypes.errorText,

  /**
   * @see {@link TextFields/TextField#helpText}
   */
  helpText: TextFields_TextField.propTypes.helpText,

  /**
   * @see {@link TextFields/TextField#helpOnFocus}
   */
  helpOnFocus: TextFields_TextField.propTypes.helpOnFocus,

  /**
   * @see {@link TextFields/TextField#inlineIndicator}
   */
  inlineIndicator: TextFields_TextField.propTypes.inlineIndicator,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the dialog.
   *
   * @see {@link Helpers/Portal}
   */
  portal: prop_types_default.a.bool,

  /**
   * An optional DOM Node to render the dialog into. The default is to render as the first child
   * in the `body`.
   */
  renderNode: prop_types_default.a.object,

  /**
   * Boolean if the dialog should be rendered as the last child of the `renderNode` or `body` instead
   * of the first.
   */
  lastChild: prop_types_default.a.bool,

  /**
   * @see {@link Dialogs/DialogContainer#disableScrollLocking}
   */
  disableScrollLocking: prop_types_default.a.bool,

  /**
   * Boolean if the TimePicker should be read only. This will prevent the user from opening the picker
   * and only display the current date in the text field.
   */
  readOnly: prop_types_default.a.bool,

  isOpen: deprecated_default()(prop_types_default.a.bool, 'Use `visible` instead'),
  initiallyOpen: deprecated_default()(prop_types_default.a.bool, 'Use `defaultVisible` instead'),
  initialTimeMode: deprecated_default()(prop_types_default.a.oneOf(['hour', 'minute']), 'Use `defaultTimeMode` instead')
};
TimePickerContainer_TimePickerContainer.defaultProps = {
  animateInline: true,
  defaultTimeMode: 'hour',
  icon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'access_time'
  ),
  DateTimeFormat: DateUtils_DateTimeFormat, // eslint-disable-line object-shorthand
  locales: typeof window !== 'undefined' ? window.navigator.userLanguage || window.navigator.language : 'en-US',
  okLabel: 'Ok',
  okPrimary: true,
  cancelLabel: 'Cancel',
  cancelPrimary: true,
  closeOnEsc: true,
  disableScrollLocking: false,
  'aria-label': 'Select a time',
  hoverMode: false,
  showSeconds: false
};

var TimePickerContainer_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setContainer = function (container) {
    _this2._container = container;
  };

  this._closeOnEsc = function (e) {
    if ((e.which || e.keyCode) === ESC) {
      _this2._handleCancelClick(e);
    }
  };

  this._handleOutsideClick = function (e) {
    if (_this2._container && !_this2._container.contains(e.target)) {
      _this2._handleCancelClick(e);
    }
  };

  this._toggleOpen = function (e) {
    if (_this2.props.disabled || _this2.props.readOnly) {
      return;
    }

    var visible = !(typeof _this2.props.isOpen !== 'undefined' ? _this2.props.isOpen : getField(_this2.props, _this2.state, 'visible'));

    if (_this2.props.onVisibilityChange) {
      _this2.props.onVisibilityChange(visible, e);
    }

    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.visible === 'undefined') {
      var hoverMode = _this2.props.hoverMode;


      if (hoverMode) {
        _this2._setTimeMode('hour');
      }

      _this2.setState({ visible: visible });
    }
  };

  this._setTimeMode = function (timeMode) {
    if (_this2.state.timeMode === timeMode) {
      return;
    }

    _this2.setState({ timeMode: timeMode });
  };

  this._setTempTime = function (time) {
    if (_this2.state.tempTime === time) {
      return;
    }

    _this2.setState(TimePickerContainer_extends({ tempTime: time }, _this2._getTimeParts(time, _this2.props)));
  };

  this._handleKeyDown = function (e) {
    handleKeyboardAccessibility(e, _this2._toggleOpen, true, true);

    if ((e.which || e.keyCode) === TAB && _this2.state.active) {
      _this2.setState({ active: false });
    }
  };

  this._handleOkClick = function (e) {
    var _props3 = _this2.props,
        onVisibilityChange = _props3.onVisibilityChange,
        onChange = _props3.onChange,
        DateTimeFormat = _props3.DateTimeFormat,
        locales = _props3.locales,
        showSeconds = _props3.showSeconds;

    var value = new Date(_this2.state.tempTime);
    if (onChange) {
      onChange(formatTime(DateTimeFormat, locales, showSeconds, value), value, e);
    }

    if (onVisibilityChange) {
      onVisibilityChange(false, e);
    }

    var state = TimePickerContainer_extends({ time: value }, _this2._getTimeParts(value, _this2.props));
    if (typeof _this2.props.value === 'undefined') {
      state.value = value;
    }

    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.visible === 'undefined') {
      state.visible = false;
    }

    _this2.setState(state);
  };

  this._handleCancelClick = function (e) {
    if (_this2.props.onVisibilityChange) {
      _this2.props.onVisibilityChange(false, e);
    }

    var state = void 0;
    if (typeof _this2.props.isOpen === 'undefined' && typeof _this2.props.visible === 'undefined') {
      state = { visible: false };
    }

    var value = getField(_this2.props, _this2.state, 'value');
    if (value) {
      state = TimePickerContainer_extends({}, state, _this2._getTimeParts(value, _this2.props));
      state.tempTime = _this2.state.time;
    }

    if (state) {
      _this2.setState(state);
    }
  };
};

/* harmony default export */ var Pickers_TimePickerContainer = (TimePickerContainer_TimePickerContainer);
// CONCATENATED MODULE: ../node_modules/react-md/es/Progress/CircularProgress.js
var CircularProgress_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function CircularProgress_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function CircularProgress_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CircularProgress_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function CircularProgress_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var ROATE_DISTANCE = 360 * 1.75;
var BASE_SIZE = 24; // font-icon font size

/**
 * The `CircularProgress` component is used to give visual feedback while your app
 * is loading.
 *
 * There are two different types of circular progress bars: `Determinate` and `Indeterminate`.
 *
 * A `Determinate` circular progress bar should be used when you want to keep track of the current
 * progress. An example would be downloading a file.
 *
 * An `Indeterminate` circular progress bar should be used when you can not keep track of the progress
 * yourself. An example would be waiting for some API call to complete.
 */

var CircularProgress_CircularProgress = function (_PureComponent) {
  CircularProgress_inherits(CircularProgress, _PureComponent);

  function CircularProgress() {
    CircularProgress_classCallCheck(this, CircularProgress);

    return CircularProgress_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  /* eslint-disable max-len */
  CircularProgress.prototype.render = function render() {
    var _props = this.props,
        scale = _props.scale,
        style = _props.style,
        className = _props.className,
        value = _props.value,
        determinateDashoffset = _props.determinateDashoffset,
        centered = _props.centered,
        props = CircularProgress_objectWithoutProperties(_props, ['scale', 'style', 'className', 'value', 'determinateDashoffset', 'centered']);

    var isDeterminate = typeof value === 'number';
    var circleStyle = void 0;
    var svgStyle = style;
    if (isDeterminate) {
      var rotate = 'rotate3d(0, 0, 1, ' + ROATE_DISTANCE / 100 * value + 'deg)';
      circleStyle = {
        strokeDashoffset: determinateDashoffset - determinateDashoffset / 100 * value
      };

      svgStyle = Object.assign({}, style, {
        WebkitTransform: classnames_default()(style.WebkitTransform, rotate),
        MozTransform: classnames_default()(style.MozTransform, rotate),
        transform: classnames_default()(style.transform, rotate)
      });
    }

    var accessibilityProps = {
      role: 'progressbar',
      'aria-valuemin': 0,
      'aria-valuemax': 100
    };

    if (isDeterminate) {
      accessibilityProps['aria-valuenow'] = value;
    }

    return react_default.a.createElement(
      'svg',
      CircularProgress_extends({}, props, accessibilityProps, {
        style: svgStyle,
        className: classnames_default()('md-progress md-progress--circular', {
          'md-block-centered': centered,
          'md-progress--circular-determinate': isDeterminate,
          'md-progress--circular-indeterminate': !isDeterminate
        }, className),
        width: scale * BASE_SIZE,
        height: scale * BASE_SIZE,
        viewBox: '0 0 66 66'
      }),
      react_default.a.createElement('circle', {
        className: classnames_default()('md-circular-progress-path', {
          'md-circular-progress-path--animated': !isDeterminate
        }),
        strokeWidth: '6',
        strokeLinecap: 'round',
        style: circleStyle,
        cx: '33',
        cy: '33',
        r: '30'
      })
    );
  };

  return CircularProgress;
}(react["PureComponent"]);

CircularProgress_CircularProgress.propTypes = {
  /**
   * The `id` prop is required for accessibility concerns.
   * [Progress Bar Role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_progressbar_role)
   *
   * > If the progressbar is describing the loading progress of a particular region of a page, the author
   * __SHOULD__ use aria-describedby to point to the status, and set the aria-busy attribute to true on the
   * region until it is finished loading. It is not possible for the user to alter the value of a progressbar
   * because it is always readonly.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /* eslint-enable max-len */

  /**
   * A style object to apply to the SVG. If this is a determinate `CircularProgress`,
   * the `transform` (and vendor prefixes) styles will be merged with the current
   * progress rotation.
   */
  style: prop_types_default.a.object.isRequired,

  /**
   * An optional className to apply to the SVG.
   */
  className: prop_types_default.a.string,

  /**
   * The current value of the progress. If this value is defined, it will
   * be converted to a determinate circular progress. The progress will not
   * advance unless this value changes.
   *
   * This value should also be a number between 0 and 100.
   */
  value: between(prop_types_default.a.number, 0, 100),

  /**
   * The scale for the circular progress.
   */
  scale: prop_types_default.a.number.isRequired,

  /**
   * You probably don't want to update this. I'm not good at SVG. This should
   * match the SCSS variable `$md-circular-progress-stroke-dashoffset`.
   */
  determinateDashoffset: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the progress should be centered in it's container.
   */
  centered: prop_types_default.a.bool
};
CircularProgress_CircularProgress.defaultProps = {
  style: {},
  scale: 1,
  determinateDashoffset: 187,
  centered: true
};
/* harmony default export */ var Progress_CircularProgress = (CircularProgress_CircularProgress);
// CONCATENATED MODULE: ../node_modules/react-md/es/Progress/LinearProgress.js
var LinearProgress_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function LinearProgress_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function LinearProgress_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function LinearProgress_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function LinearProgress_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * There are 3 different types of linear progress bars: `Determinate`,
 * `Indeterminate`, and `Query Indeterminate`.
 *
 * A `Determinate` linear progress bar should be used when you can keep track of the
 * progress and have a percentage complete you can work with. An example would be
 * uploading/downloading a file.
 *
 * An `Indeterminate` linear progress bar should be used when you can not keep track
 * of the progress yourself. An example might be waiting for an API call to complete.
 *
 * A `Query Indeterminate` linear progress bar is used when you are combining
 * `Indeterminate` and `Determinate`. A Linear Progress component can be displayed
 * as a query indeterminate progress bar by adding the prop `query={true}` to the
 * component. Until a progress value is given, it will display the query linear
 * progress animation. Afterwards, it will start the determinate animation of where
 * you manually keep updating the value of the progress.
 */

var LinearProgress_LinearProgress = function (_PureComponent) {
  LinearProgress_inherits(LinearProgress, _PureComponent);

  function LinearProgress() {
    LinearProgress_classCallCheck(this, LinearProgress);

    return LinearProgress_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  /* eslint-disable max-len */
  LinearProgress.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        progressClassName = _props.progressClassName,
        progressStyle = _props.progressStyle,
        value = _props.value,
        query = _props.query,
        centered = _props.centered,
        props = LinearProgress_objectWithoutProperties(_props, ['className', 'progressClassName', 'progressStyle', 'value', 'query', 'centered']);

    var isDeterminate = typeof value === 'number';

    var accessibilityProps = {
      role: 'progressbar',
      'aria-valuemin': 0,
      'aria-valuemax': 100
    };

    var style = void 0;
    if (isDeterminate) {
      style = { width: value + '%' };
      accessibilityProps['aria-valuenow'] = value;
    }
    if (progressStyle) {
      style = Object.assign(style || {}, typeof progressStyle === 'function' ? progressStyle(value, this) : progressStyle);
    }

    return react_default.a.createElement(
      'div',
      LinearProgress_extends({}, props, {
        className: classnames_default()('md-progress md-progress--linear', { 'md-block-centered': centered }, className)
      }),
      react_default.a.createElement('div', LinearProgress_extends({}, accessibilityProps, {
        style: style,
        className: classnames_default()('md-progress--linear-active', {
          'md-progress--linear-query': query,
          'md-progress--linear-determinate': isDeterminate,
          'md-progress--linear-indeterminate': !isDeterminate
        }, typeof progressClassName === 'function' ? progressClassName(value, this) : progressClassName)
      }))
    );
  };

  return LinearProgress;
}(react["PureComponent"]);

LinearProgress_LinearProgress.propTypes = {
  /**
   * The `id` prop is required for accessibility concerns.
   * [Progress Bar Role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_progressbar_role)
   *
   * > If the progressbar is describing the loading progress of a particular region of a page, the author
   * __SHOULD__ use aria-describedby to point to the status, and set the aria-busy attribute to true on the
   * region until it is finished loading. It is not possible for the user to alter the value of a progressbar
   * because it is always readonly.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /* eslint-enable max-len */
  /**
   * An optional className to apply to the linear progress container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional className to apply to the progress bar element.
   *
   * If a function is specified it will be called to get necessary className.
   * Current progress value and reference to the component will be passed into the function.
   */
  progressClassName: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),

  /**
   * An optional style to apply to the progress bar element.
   *
   * If a function is specified it will be called to get necessary style.
   * Current progress value and reference to the component will be passed into the function.
   */
  progressStyle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.object]),

  /**
   * The current value of the progress. If this value is defined, it will
   * be converted to a determinate circular progress. The progress will not
   * advance unless this value changes.
   *
   * This value should also be a number between 0 and 100.
   */
  value: between(prop_types_default.a.number, 0, 100),

  /**
   * Boolean if this should be a query indeterminate progress bar.
   */
  query: prop_types_default.a.bool,

  /**
   * Boolean if the Linear Progress should be centered. This
   * will only work if the `max-width` style is set.
   */
  centered: prop_types_default.a.bool
};
LinearProgress_LinearProgress.defaultProps = {
  query: false
};
/* harmony default export */ var Progress_LinearProgress = (LinearProgress_LinearProgress);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/NumberUtils/minMaxLoop.js
/** @module utils/NumberUtils/minMaxLoop */

/**
 * Keeps a number within the min and max values. When the number becomes less
 * than the min, it will loop around and be the max value. When the number is
 * greater than the max, it will loop around and be the min value.
 *
 * @param {Number} current - the current number
 * @param {Number} min - the minimum number allowed
 * @param {Number} max - the maximum number allowed
 * @param {Boolean} increment - boolean if the value should be incremented or decremented by
 *    1.
 * @return {Number} the next number
 */
function minMaxLoop(current, min, max) {
  var increment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var next = current + (increment ? 1 : -1);
  if (max < next) {
    next = min;
  } else if (next < min) {
    next = max;
  }

  return next;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectionControls/SelectionControlGroup.js
var SelectionControlGroup_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function SelectionControlGroup_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SelectionControlGroup_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SelectionControlGroup_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SelectionControlGroup_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











/**
 * A custom PropTypes validator to make sure that each `control` in the `controls` prop
 * contains the given `propName`, or the `SelectionControlGroup` has defined that prop.
 */
function requiredByAllControls(validator) {
  return function validate(props, propName, component) {
    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      others[_key - 3] = arguments[_key];
    }

    var err = validator.apply(undefined, [props, propName, component].concat(others));

    if (!err && typeof props[propName] === 'undefined') {
      var invalids = props.controls.filter(function (c) {
        return !c[propName];
      }).map(function (_, i) {
        return i;
      });
      if (invalids.length) {
        var invalidPrefix = invalids.length === props.controls.length ? 'All `controls`' : 'The `controls` at indexes `' + invalids.join('`, `') + '`';
        var invalidMsg = invalidPrefix + ' are missing the `' + propName + '` prop.';

        err = new Error('The `' + propName + '` prop is required to make `' + component + '` accessible for users of ' + ('assistive technologies such as screen readers. Either add the `' + propName + '` to the `' + component + '` ') + ('or add the `' + propName + '` to each `control` in the `controls` prop. ' + invalidMsg));
      }
    }

    return err;
  };
}

/**
 * The `SelectionControlGroup` component is used to simplify the generation of a list
 * of `SelectionControl`. Any common props are extracted to this component and passed
 * to the `SelectionControl`.
 */

var SelectionControlGroup_SelectionControlGroup = function (_PureComponent) {
  SelectionControlGroup_inherits(SelectionControlGroup, _PureComponent);

  function SelectionControlGroup(props) {
    SelectionControlGroup_classCallCheck(this, SelectionControlGroup);

    var _this = SelectionControlGroup_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setGroup = function (group) {
      _this._group = group;
    };

    _this._handleChange = function (e) {
      var value = e.target.value;
      if (_this.props.type === 'checkbox') {
        var checked = e.target.checked;

        var currentValue = getField(_this.props, _this.state, 'value');
        var existsIndex = currentValue.indexOf(value);
        if (existsIndex === -1 && checked) {
          value = '' + (currentValue ? currentValue + ',' : '') + value;
        } else if (existsIndex > -1 && !checked) {
          value = currentValue.replace(new RegExp(value + ',?'), '');
        } else {
          value = currentValue;
        }
      }

      if (_this.props.onChange) {
        _this.props.onChange(value, e);
      }

      if (typeof _this.props.value === 'undefined') {
        _this.setState({ value: value });
      }
    };

    _this._handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }

      var key = e.which || e.keyCode;
      var dec = key === UP || key === LEFT;
      var inc = key === DOWN || key === RIGHT;
      if (!_this._group || !dec && !inc) {
        return;
      }

      e.preventDefault();
      var radios = _this._group.querySelectorAll('*[role="radio"]');
      _this._activeIndex = minMaxLoop(_this._activeIndex, 0, radios.length - 1, inc);
      radios[_this._activeIndex].focus();
      var value = _this.props.controls[_this._activeIndex].value;

      if (getField(_this.props, _this.state, 'value') !== value) {
        if (_this.props.onChange) {
          _this.props.onChange(value, e);
        }

        if (typeof _this.props.value === 'undefined') {
          _this.setState({ value: value });
        }
      }
    };

    var radio = props.type === 'radio';
    _this.state = {};

    if (typeof props.value === 'undefined') {
      var value = props.defaultValue;

      if (typeof value === 'undefined') {
        value = radio ? props.controls[0].value : '';
      }

      _this.state.value = value;
    }

    var groupValue = getField(props, _this.state, 'value');
    _this._activeIndex = -1;
    props.controls.some(function (_ref, i) {
      var value = _ref.value;

      if (value === groupValue) {
        _this._activeIndex = i;
      }

      return _this._activeIndex > -1;
    });
    return _this;
  }

  SelectionControlGroup.prototype._isChecked = function _isChecked(value, controlValue, type) {
    return type === 'radio' ? value === controlValue : value.split(',').indexOf(controlValue) !== -1;
  };

  SelectionControlGroup.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        id = _props.id,
        name = _props.name,
        type = _props.type,
        label = _props.label,
        labelClassName = _props.labelClassName,
        className = _props.className,
        controlStyle = _props.controlStyle,
        controlClassName = _props.controlClassName,
        Component = _props.component,
        LabelComponent = _props.labelComponent,
        inline = _props.inline,
        disabled = _props.disabled,
        checkedRadioIcon = _props.checkedRadioIcon,
        uncheckedRadioIcon = _props.uncheckedRadioIcon,
        checkedCheckboxIcon = _props.checkedCheckboxIcon,
        uncheckedCheckboxIcon = _props.uncheckedCheckboxIcon,
        ControlComponent = _props.controlComponent,
        propValue = _props.value,
        propControls = _props.controls,
        defaultValue = _props.defaultValue,
        props = SelectionControlGroup_objectWithoutProperties(_props, ['id', 'name', 'type', 'label', 'labelClassName', 'className', 'controlStyle', 'controlClassName', 'component', 'labelComponent', 'inline', 'disabled', 'checkedRadioIcon', 'uncheckedRadioIcon', 'checkedCheckboxIcon', 'uncheckedCheckboxIcon', 'controlComponent', 'value', 'controls', 'defaultValue']);

    var value = getField(this.props, this.state, 'value');
    var radio = type === 'radio';

    var controls = this.props.controls.map(function (control, i) {
      var style = control.style;
      if (controlStyle) {
        style = style ? SelectionControlGroup_extends({}, controlStyle, style) : controlStyle;
      }

      var checked = _this2._isChecked(value, control.value, type);
      var controlProps = SelectionControlGroup_extends({
        id: '' + id + i,
        key: 'control' + i,
        name: '' + name + (type === 'checkbox' ? '[]' : ''),
        type: type,
        inline: inline,
        disabled: disabled,
        checked: checked,
        tabIndex: !radio || checked || i === 0 && _this2._activeIndex === -1 ? undefined : -1,
        checkedRadioIcon: checkedRadioIcon,
        uncheckedRadioIcon: uncheckedRadioIcon,
        checkedCheckboxIcon: checkedCheckboxIcon,
        uncheckedCheckboxIcon: uncheckedCheckboxIcon,
        'aria-describedby': id + '-group-label'
      }, control, {
        style: style,
        className: classnames_default()(controlClassName, control.className)
      });

      return react_default.a.createElement(ControlComponent, controlProps);
    });

    var ariaLabel = void 0;
    if (label) {
      ariaLabel = react_default.a.createElement(
        LabelComponent,
        { className: labelClassName, id: id + '-group-label' },
        label
      );
    }

    return react_default.a.createElement(
      Component,
      SelectionControlGroup_extends({}, props, {
        ref: this._setGroup,
        className: classnames_default()('md-selection-control-group', className),
        onChange: this._handleChange,
        onKeyDown: radio ? this._handleKeyDown : null
      }),
      ariaLabel,
      controls
    );
  };

  return SelectionControlGroup;
}(react["PureComponent"]);

SelectionControlGroup_SelectionControlGroup.propTypes = {
  /**
   * An optional style to apply to the container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to every `SelectionControl`. This will be merged with any `style`
   * that a `control` might have.
   */
  controlStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to every `SelectionControl`. This will be merged with any
   * `className` that a `control` might have.
   */
  controlClassName: prop_types_default.a.string,

  /**
   * An optional base id to apply to each `SelectionControl`. When this is included, the id for
   * each control will start with this and end with their current index. If this is omitted,
   * each `control` in the `controls` prop *must* have an `id` prop. This is required for
   * accessibility.
   */
  id: requiredByAllControls(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * The type to apply to each `SelectionControl` in the group. Only `checkbox` and `radio` is
   * valid for a grouping.
   */
  type: prop_types_default.a.oneOf(['checkbox', 'radio']).isRequired,

  /**
   * The component to render the `SelectionControlGroup` in. This can only be a valid dom element
   * since it relies on the ref callback to add keyboard accessibility.
   */
  component: prop_types_default.a.string.isRequired,

  /**
   * An optional label to display above the group of `SelectionControl`s.
   */
  label: prop_types_default.a.node,

  /**
   * An optional className to apply to the node surrounding the `label` prop.
   */
  labelClassName: prop_types_default.a.string,

  /**
   * The component to render each item in the `controls` list as. By default, this will be the
   * `SelectionControl` component but you can change this to any React component that accepts
   * the selection control props. It is currently provided:
   *
   * ```js
   * const controlProps = {
   *   id: `${id}${i}`,
   *   key: `control${i}`,
   *   name: `${name}${type === 'checkbox' ? '[]' : ''}`,
   *   type,
   *   inline,
   *   disabled,
   *   checked,
   *   tabIndex: !radio || checked || (i === 0 && this._activeIndex === -1) ? undefined : -1,
   *   checkedRadioIcon,
   *   uncheckedRadioIcon,
   *   checkedCheckboxIcon,
   *   uncheckedCheckboxIcon,
   *   ...control,
   *   style,
   *   className: cn(controlClassName, control.className),
   * };
   * ```
   */
  controlComponent: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * The component to render the optional `label` in.
   */
  labelComponent: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func]).isRequired,

  /**
   * An optional function to call when any `SelectionControl`'s `checked` state is changed
   * in the group. If the `type` of the group is `radio`, the `value` of the `checked` radio
   * will be given in the callback. If the `type` of the group is `checkbox`, a comma-delimited
   * string of all `checked` checkboxes values will be given.
   *
   * ```js
   * // checkbox
   * onChange('Alpha,Omega', changeEvent);
   *
   * // radio
   * onChange('Omega', changeEvent);
   * ```
   */
  onChange: prop_types_default.a.func,

  /**
   * A name to use for each `SelectionControl` in the group. If the `type` of the group is
   * `checkbox`, the name will be updated to be an array name so that using
   * `document.querySelector('input[name="yourName[]"].value` will give the comma-delimited
   * string of checked checkboxes.
   *
   * It is either required to have this prop set or every `control` in the `controls` prop to
   * have the `name` prop.
   */
  name: requiredByAllControls(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * The default value for the `SelectionControlGroup`. This can either be a single value
   * or a comma-delimited string of checkbox values. When the `type` of the group is `radio`
   * and the group is uncontrolled, it is recommended to set this prop. Otherwise the first
   * value of the `controls` prop will be used as the default value.
   */
  defaultValue: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional value to use for the `SelectionControlGroup`. This will make the component
   * controlled and require the `onChange` prop to be defined. Like the `defaultValue`, this
   * can either be a single value or a comma-delimited list of checkbox values.
   */
  value: controlled(prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.number, prop_types_default.a.string]), 'onChange'),

  /**
   * A list of objects to create the `SelectionControl` components. The shape of the object
   * is the `propTypes` of the `SelectionControl` component, except that `value` prop is
   * now required.
   *
   * The `SelectionControl` will inherit any inheritable props from the `SelectionControlGroup`.
   */
  controls: prop_types_default.a.arrayOf(prop_types_default.a.shape({
    key: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
    label: prop_types_default.a.node.isRequired,
    value: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.number, prop_types_default.a.string]).isRequired
  })).isRequired,

  /**
   * Boolean if the `SelectionControl` should be displayed inline.
   */
  inline: prop_types_default.a.bool,

  /**
   * Boolean if all the selection controls in the group are disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * An optional function to call when the keydown event is triggered.
   */
  onKeyDown: prop_types_default.a.func,

  /**
   * An icon to use for a checked `radio` control. This will be applied to each
   * control that has a `type="radio"` in the `controls` list. This is just a simpler
   * way of applying the custom icons for each radio in the list.
   *
   * This will default to the `checkedRadioIcon` on the `SelectionControl`.
   *
   * @see {@link #controls}
   * @see {@link #uncheckedRadioIcon}
   * @see {@link SelectionControls/SelectionControls#checkedRadioIcon}
   * @see {@link SelectionControls/SelectionControls#uncheckedRadioIcon}
   */
  checkedRadioIcon: prop_types_default.a.node,

  /**
   * An icon to use for an unchecked `radio` control. This will be applied to each
   * control that has a `type="radio"` in the `controls` list. This is just a simpler
   * way of applying the custom icons for each radio in the list.
   *
   * This will default to the `uncheckedRadioIcon` on the `SelectionControl`.
   *
   * @see {@link #controls}
   * @see {@link #checkedRadioIcon}
   * @see {@link SelectionControls/SelectionControls#checkedRadioIcon}
   * @see {@link SelectionControls/SelectionControls#uncheckedRadioIcon}
   */
  uncheckedRadioIcon: prop_types_default.a.node,

  /**
   * An icon to use for a checked `checkbox` control. This will be applied to each
   * control that has a `type="checkbox"` in the `controls` list. This is just a simpler
   * way of applying the custom icons for each checkbox in the list.
   *
   * This will default to the `checkedCheckboxIcon` on the `SelectionControl`.
   *
   * @see {@link #controls}
   * @see {@link #uncheckedCheckboxIcon}
   * @see {@link SelectionControls/SelectionControls#checkedCheckboxIcon}
   * @see {@link SelectionControls/SelectionControls#uncheckedCheckboxIcon}
   */
  checkedCheckboxIcon: prop_types_default.a.node,

  /**
   * An icon to use for an unchecked `checkbox` control. This will be applied to each
   * control that has a `type="checkbox"` in the `controls` list. This is just a simpler
   * way of applying the custom icons for each checkbox in the list.
   *
   * This will default to the `uncheckedCheckboxIcon` on the `SelectionControl`.
   *
   * @see {@link #controls}
   * @see {@link #checkedCheckboxIcon}
   * @see {@link SelectionControls/SelectionControls#checkedCheckboxIcon}
   * @see {@link SelectionControls/SelectionControls#uncheckedCheckboxIcon}
   */
  uncheckedCheckboxIcon: prop_types_default.a.node
};
SelectionControlGroup_SelectionControlGroup.defaultProps = {
  component: 'fieldset',
  labelComponent: 'legend',
  labelClassName: 'md-subheading-1',
  controlComponent: SelectionControls_SelectionControl
};
/* harmony default export */ var SelectionControls_SelectionControlGroup = (SelectionControlGroup_SelectionControlGroup);
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectionControls/Checkbox.js
var Checkbox_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Checkbox_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Checkbox_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Checkbox_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Checkbox_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











/**
 * The `Checkbox` component is used for the selection of multiple options from a set.
 */

var Checkbox_Checkbox = function (_PureComponent) {
  Checkbox_inherits(Checkbox, _PureComponent);

  function Checkbox() {
    Checkbox_classCallCheck(this, Checkbox);

    return Checkbox_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Checkbox.prototype.render = function render() {
    var _props = this.props,
        checkedIcon = _props.checkedIcon,
        uncheckedIcon = _props.uncheckedIcon,
        checkedIconChildren = _props.checkedIconChildren,
        checkedIconClassName = _props.checkedIconClassName,
        uncheckedIconChildren = _props.uncheckedIconChildren,
        uncheckedIconClassName = _props.uncheckedIconClassName,
        props = Checkbox_objectWithoutProperties(_props, ['checkedIcon', 'uncheckedIcon', 'checkedIconChildren', 'checkedIconClassName', 'uncheckedIconChildren', 'uncheckedIconClassName']);

    var checked = getDeprecatedIcon(checkedIconClassName, checkedIconChildren, checkedIcon);
    var unchecked = getDeprecatedIcon(uncheckedIconClassName, uncheckedIconChildren, uncheckedIcon);

    return react_default.a.createElement(SelectionControls_SelectionControl, Checkbox_extends({
      type: 'checkbox',
      checkedCheckboxIcon: checked,
      uncheckedCheckboxIcon: unchecked,
      __superSecreteProp: true
    }, props));
  };

  return Checkbox;
}(react["PureComponent"]);

Checkbox_Checkbox.propTypes = {
  /**
   * An id to use with the checkbox. This is used for accessibility and so that the label
   * triggers the checkbox toggle.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])),

  /**
   * An optional style to apply to the checkbox's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the checkbox's container.
   */
  className: prop_types_default.a.string,

  /**
   * A label to display with the checkbox. This is required for accessibility and triggering
   * the toggle.
   */
  label: prop_types_default.a.node,

  /**
   * Boolean if the label should appear before the checkbox icon.
   */
  labelBefore: prop_types_default.a.bool,

  /**
   * A name to use for the `Checkbox`. This is required for accessibility. If the checkbox is
   * part of a group, it is recommended to make this a string ending in `[]` so that the
   * value can be found from `document.querySelector('input[name="someName[]"]').value`.
   */
  name: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * Boolean if the `Checkbox` is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * An optional function to call when the `checked` state of the `Checkbox` changes.
   * The callback will include the new checked state and the changeEvent.
   *
   * ```js
   * onChange(changeEvent.target.checked, changeEvent);
   * ```
   */
  onChange: prop_types_default.a.func,

  /**
   * An optional value for the `Checkbox`. It is recommended to use a value though.
   */
  value: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * Boolean if the `Checkbox` is checked by default.
   */
  defaultChecked: prop_types_default.a.bool,

  /**
   * A boolean if the `Checkbox` is currently checked. This will required the `onChange` prop
   * to be defined.
   */
  checked: controlled(prop_types_default.a.bool, 'onChange', 'defaultChecked'),

  /**
   * Boolean if the `Checkbox` should be displayed inline.
   */
  inline: prop_types_default.a.bool,

  /**
   * The icon to display when the checkbox is checked.
   */
  checkedIcon: prop_types_default.a.node,

  /**
   * The icon to display when the checkbox is unchecked.
   */
  uncheckedIcon: prop_types_default.a.node,

  checkedIconChildren: deprecated_default()(prop_types_default.a.node, 'Use `checkedIcon` instead'),
  checkedIconClassName: deprecated_default()(prop_types_default.a.string, 'Use `checkedIcon` instead'),
  uncheckedIconChildren: deprecated_default()(prop_types_default.a.node, 'Use `uncheckedIcon` instead'),
  uncheckedIconClassName: deprecated_default()(prop_types_default.a.string, 'Use `uncheckedIcon` instead')
};
Checkbox_Checkbox.defaultProps = {
  checkedIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'check_box'
  ),
  uncheckedIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'check_box_outline_blank'
  )
};
/* harmony default export */ var SelectionControls_Checkbox = (Checkbox_Checkbox);
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectionControls/Radio.js
var Radio_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Radio_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Radio_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Radio_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Radio_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }










/**
 * The `Radio` component is used for the selection of a single option from a set. Unfortunately
 * the `Radio` component must always be controlled because of the `FontIcon` toggles and how
 * the `radio` input type works. It is recommended to use the `SelectionControlGroup` component
 * to manage the `radio`.
 */

var Radio_Radio = function (_PureComponent) {
  Radio_inherits(Radio, _PureComponent);

  function Radio() {
    Radio_classCallCheck(this, Radio);

    return Radio_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Radio.prototype.render = function render() {
    var _props = this.props,
        checkedIcon = _props.checkedIcon,
        uncheckedIcon = _props.uncheckedIcon,
        checkedIconChildren = _props.checkedIconChildren,
        checkedIconClassName = _props.checkedIconClassName,
        uncheckedIconChildren = _props.uncheckedIconChildren,
        uncheckedIconClassName = _props.uncheckedIconClassName,
        props = Radio_objectWithoutProperties(_props, ['checkedIcon', 'uncheckedIcon', 'checkedIconChildren', 'checkedIconClassName', 'uncheckedIconChildren', 'uncheckedIconClassName']);

    var checked = getDeprecatedIcon(checkedIconClassName, checkedIconChildren, checkedIcon);
    var unchecked = getDeprecatedIcon(uncheckedIconClassName, uncheckedIconChildren, uncheckedIcon);

    return react_default.a.createElement(SelectionControls_SelectionControl, Radio_extends({
      type: 'radio',
      checkedCheckboxIcon: checked,
      uncheckedCheckboxIcon: unchecked,
      __superSecreteProp: true
    }, props));
  };

  return Radio;
}(react["PureComponent"]);

Radio_Radio.propTypes = {
  /**
   * An id to use with the radio. This is used for accessibility and so that the label
   * triggers the radio toggle.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])),

  /**
   * An optional style to apply to the radio's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the radio's container.
   */
  className: prop_types_default.a.string,

  /**
   * A label to display with the radio. This is required for accessibility and triggering
   * the toggle.
   */
  label: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the label should appear before the radio icon.
   */
  labelBefore: prop_types_default.a.bool,

  /**
   * A name to use for the `Radio`. This is required for accessibility.
   */
  name: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * Boolean if the `Radio` is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * A function to call when the `Radio` triggers the `change` event. The `onChange` callback
   * will include the current value of the checked `radio` and the change event.
   *
   * ```js
   * onChange(changeEvent.target.value, changeEvent);
   * ```
   */
  onChange: prop_types_default.a.func,

  /**
   * The value for the `Radio` component.
   */
  value: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.number, prop_types_default.a.string]).isRequired,

  /**
   * A boolean if the `Radio` is currently checked.
   */
  checked: prop_types_default.a.bool.isRequired,

  /**
   * Boolean if the `Radio` should be displayed inline.
   */
  inline: prop_types_default.a.bool,

  /**
   * The icon to display when the radio is checked/selected.
   */
  checkedIcon: prop_types_default.a.node.isRequired,

  /**
   * The icon to display when the radio is not checked/selected.
   */
  uncheckedIcon: prop_types_default.a.node.isRequired,
  checkedIconChildren: deprecated_default()(prop_types_default.a.node, 'Use `checkedIcon` instead'),
  checkedIconClassName: deprecated_default()(prop_types_default.a.string, 'Use `checkedIcon` instead'),
  uncheckedIconChildren: deprecated_default()(prop_types_default.a.node, 'Use `uncheckedIcon` instead'),
  uncheckedIconClassName: deprecated_default()(prop_types_default.a.string, 'Use `uncheckedIcon` instead')
};
Radio_Radio.defaultProps = {
  checkedIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'radio_button_checked'
  ),
  uncheckedIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'radio_button_unchecked'
  )
};
/* harmony default export */ var SelectionControls_Radio = (Radio_Radio);
// CONCATENATED MODULE: ../node_modules/react-md/es/SelectionControls/Switch.js
var Switch_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Switch_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Switch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Switch_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Switch_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









var Switch_Switch = function (_PureComponent) {
  Switch_inherits(Switch, _PureComponent);

  function Switch() {
    Switch_classCallCheck(this, Switch);

    return Switch_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Switch.prototype.render = function render() {
    var _props = this.props,
        toggled = _props.toggled,
        defaultToggled = _props.defaultToggled,
        props = Switch_objectWithoutProperties(_props, ['toggled', 'defaultToggled']);

    if (typeof toggled !== 'undefined' && typeof props.checked === 'undefined') {
      props.checked = toggled;
    }

    if (typeof defaultToggled !== 'undefined' && typeof props.defaultChecked === 'undefined') {
      props.defaultChecked = defaultToggled;
    }

    return react_default.a.createElement(SelectionControls_SelectionControl, Switch_extends({ type: 'switch' }, props, { __superSecreteProp: true }));
  };

  return Switch;
}(react["PureComponent"]);

Switch_Switch.propTypes = {
  /**
   * An id to use with the switch. This is used for accessibility and so that the label
   * triggers the switch toggle.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])),

  /**
   * An optional style to apply to the switch's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the switch's container.
   */
  className: prop_types_default.a.string,

  /**
   * A label to display with the switch. This is required for accessibility and triggering
   * the toggle.
   */
  label: prop_types_default.a.node,

  /**
   * Boolean if the label should appear before the switch.
   */
  labelBefore: prop_types_default.a.bool,

  /**
   * A name to use for the `Switch`. This is required for accessibility since behind the scenes
   * the `Switch` is renders as an `<input type="checkbox" />`.
   */
  name: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * Boolean if the `Switch` is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * An optional function to call when the `checked` state of the `Switch` changes.
   * The callback will include the new checked state and the changeEvent.
   *
   * ```js
   * onChange(changeEvent.target.checked, changeEvent);
   * ```
   */
  onChange: prop_types_default.a.func,

  /**
   * An optional value for the `Switch`. It is recommended to use a value though.
   */
  value: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * Boolean if the `Switch` is checked by default.
   */
  defaultChecked: prop_types_default.a.bool,

  /**
   * A boolean if the `Switch` is currently checked. This will required the `onChange` prop
   * to be defined.
   */
  checked: controlled(prop_types_default.a.bool, 'onChange', 'defaultChecked'),

  defaultToggled: deprecated_default()(prop_types_default.a.bool, 'Use the `defaultChecked` prop instead'),
  toggled: deprecated_default()(prop_types_default.a.bool, 'Use the `checked` prop instead')
};
/* harmony default export */ var SelectionControls_Switch = (Switch_Switch);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/NumberUtils/calculateValueDistance.js
/** @module utils/NumberUtils/calculateValueDistance */

/**
 * This calculates the distance from a screen x location to a position in some element
 * by comparing the width of the element and the element's page position to the screen
 * x position.
 *
 * If the distance is not _normalized_ the distance will be updated to be a percentage
 * of the element's total width.
 *
 * @param {Number} x - the screen x location.
 * @param {Number} width - the element's width
 * @param {Number} left - the element's page x position.
 * @param {Boolean} normalize - boolean if the distance should be a percentage.
 *
 * @return {Number} the distance from the element's left position to the page x
 *    location.
 */
function calculateDistance(x, width, left, normalize) {
  var distance = Math.min(width, Math.max(0, x - left));

  return normalize ? distance : distance / width * 100;
}

/**
 * This calculates the new value and distance for a slider. It will compare the page x
 * location of a touch or mouse event to the slider's track page x position. If the
 * final value and distance should be _normalized_, they will be updated to be rounded
 * with the scale and steps in mind.
 *
 * The distance will always be contained within a percentage of 0 - 100 while the
 * value will be contained within the min and max values.
 *
 * @param {Number} x - the page x location of the touch or mouse event.
 * @param {Number} width - the slider's width
 * @param {Number} left - the slider's left position in the page.
 * @param {Number} scale - the total number values included in the slider.
 * @param {Number} step - the amount to increment by.
 * @param {Number} min - the min value for the slider.
 * @param {Number} max - the max value for the slider.
 * @param {Boolean} normalize - boolean if the vaue and distance should be _normalized_.
 *
 * @return {Object} an object with the value and distance.
 */
function calculateValueDistance(x, width, left, scale, step, min, max, normalize) {
  var value = void 0;
  var distance = calculateDistance(x, width, left, normalize);
  if (normalize) {
    value = Math.round(distance / (width / scale));
    if (step < 1) {
      var decimals = String(step).split('.')[1];
      var corrector = typeof decimals !== 'undefined' && decimals.length > 0 ? Math.pow(10, decimals.length) : 1;

      var modded = value * corrector % (step * corrector);
      if (modded !== 0 && modded >= step / 2) {
        value += step - modded;
      } else if (modded !== 0) {
        value -= modded;
      }
    }

    distance = value / scale * 100;
    value = value * step + min;
  } else {
    value = min + step * Math.round(distance / 100 * scale);
  }

  return {
    distance: Math.max(0, Math.min(100, distance)),
    value: Math.max(min, Math.min(max, value))
  };
}
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/NumberUtils/isWithinStep.js
/** @module utils/NumberUtils/isWithinStep */

/**
 * Checks if a provided value is within the current step. I don't remember the main
 * usage for this, but it is for the Slider component.
 *
 * @param {number} value - the current value
 * @param {number} step - the step value
 * @return {Boolean} true if the vlaue is within the step
 */
function isWithinStep(value, step) {
  var decimals = String(step).split('.')[1];
  var corrector = typeof decimals !== 'undefined' && decimals.length > 0 ? Math.pow(10, decimals.length) : 1;

  return value * corrector % (step * corrector) === 0;
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Sliders/SliderLabel.js
var SliderLabel_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function SliderLabel_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SliderLabel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SliderLabel_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SliderLabel_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * This is just the label component for the slider. It will
 * return null if there are no children to display.
 */

var SliderLabel_SliderLabel = function (_PureComponent) {
  SliderLabel_inherits(SliderLabel, _PureComponent);

  function SliderLabel() {
    SliderLabel_classCallCheck(this, SliderLabel);

    return SliderLabel_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  SliderLabel.prototype.render = function render() {
    var _props = this.props,
        children = _props.children,
        className = _props.className,
        htmlFor = _props.htmlFor,
        props = SliderLabel_objectWithoutProperties(_props, ['children', 'className', 'htmlFor']);

    if (!children) {
      return null;
    }

    return react_default.a.createElement(
      'label',
      SliderLabel_extends({}, props, {
        htmlFor: htmlFor,
        className: classnames_default()('md-slider-label', themeColors({ text: true }), className)
      }),
      children
    );
  };

  return SliderLabel;
}(react["PureComponent"]);

SliderLabel_SliderLabel.propTypes = {
  className: prop_types_default.a.string,
  children: prop_types_default.a.node,
  htmlFor: function htmlFor(props, propName, component) {
    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      others[_key - 3] = arguments[_key];
    }

    var _PropTypes$string;

    if (typeof props.children === 'undefined') {
      return null;
    }

    return (_PropTypes$string = prop_types_default.a.string).isRequired.apply(_PropTypes$string, [props, propName, component].concat(others));
  }
};
/* harmony default export */ var Sliders_SliderLabel = (SliderLabel_SliderLabel);
// CONCATENATED MODULE: ../node_modules/react-md/es/utils/NumberUtils/updateUnit.js
/** @module utils/NumberUtils/updateUnit */

/**
 * Takes in a css unit (px, rem, em, etc) or a number and applies a function to the
 * number part of the unit.
 *
 * If the unit was a number to start with and a `toUnit` is given, the number will
 * be given the `toUnit`. Otherwise the number will be returned.
 *
 * If the unit was a string, the original units will be applied back to the updated
 * unit's value.
 *
 * @param {number|String} unit - the unit to apply a function to.
 * @param {function} fn - the function to apply to the number.
 * @param {String=} toUnit - an optional unit to cast the updated unit to.
 *
 * @return {String|number} the updated unit.
 */
function updateUnit(unit, fn, toUnit) {
  var updated = fn(parseInt(unit, 10));

  if (typeof unit === 'number') {
    return toUnit ? '' + updated + toUnit : updated;
  }

  return '' + updated + unit.replace(/[0-9]/g, '');
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Sliders/TrackFill.js
var TrackFill_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TrackFill_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TrackFill_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TrackFill_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TrackFill_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The `TrackFill` component is used for showing a colored bar
 * within the `Track` component to show the `Slider`'s position.
 *
 * If the `Slider` is disabled, this will just return null.
 */

var TrackFill_TrackFill = function (_PureComponent) {
  TrackFill_inherits(TrackFill, _PureComponent);

  function TrackFill() {
    TrackFill_classCallCheck(this, TrackFill);

    return TrackFill_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  TrackFill.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        trackFillWidth = _props.trackFillWidth,
        dragging = _props.dragging,
        disabled = _props.disabled,
        props = TrackFill_objectWithoutProperties(_props, ['style', 'className', 'trackFillWidth', 'dragging', 'disabled']);

    if (disabled) {
      return null;
    }

    return react_default.a.createElement('hr', TrackFill_extends({}, props, {
      style: Object.assign({}, style, { width: trackFillWidth }),
      className: classnames_default()('md-slider-track-fill', className, {
        'md-slider-track-fill--dragging': dragging
      })
    }));
  };

  return TrackFill;
}(react["PureComponent"]);

TrackFill_TrackFill.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  dragging: prop_types_default.a.bool,
  disabled: prop_types_default.a.bool,
  trackFillWidth: prop_types_default.a.string.isRequired
};
/* harmony default export */ var Sliders_TrackFill = (TrackFill_TrackFill);
// CONCATENATED MODULE: ../node_modules/react-md/es/Sliders/Thumb.js
var Thumb_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Thumb_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Thumb_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Thumb_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Thumb_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The `Thumb` component is the little ball for the slider.
 */

var Thumb_Thumb = function (_PureComponent) {
  Thumb_inherits(Thumb, _PureComponent);

  function Thumb() {
    Thumb_classCallCheck(this, Thumb);

    return Thumb_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Thumb.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        on = _props.on,
        off = _props.off,
        active = _props.active,
        disabled = _props.disabled,
        dragging = _props.dragging,
        thumbLeft = _props.thumbLeft,
        discrete = _props.discrete,
        props = Thumb_objectWithoutProperties(_props, ['style', 'className', 'on', 'off', 'active', 'disabled', 'dragging', 'thumbLeft', 'discrete']);

    return react_default.a.createElement(Helpers_AccessibleFakeButton, Thumb_extends({
      disabled: disabled
    }, props, {
      style: Object.assign({}, style, { left: thumbLeft }),
      className: classnames_default()('md-slider-thumb', className, {
        'md-slider-thumb--active': active,
        'md-slider-thumb--dragging': dragging,
        'md-slider-thumb--disabled': disabled,
        'md-slider-thumb--on': on,
        'md-slider-thumb--continuous-off': !discrete && off,
        'md-slider-thumb--discrete': discrete,
        'md-slider-thumb--discrete-on': discrete && active && on,
        'md-slider-thumb--discrete-off': discrete && !disabled && off,
        'md-slider-thumb--discrete-active': discrete && active,
        'md-slider-thumb--discrete-active-off': discrete && active && off
      })
    }));
  };

  return Thumb;
}(react["PureComponent"]);

Thumb_Thumb.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  thumbLeft: prop_types_default.a.string.isRequired,
  on: prop_types_default.a.bool,
  off: prop_types_default.a.bool,
  active: prop_types_default.a.bool,
  disabled: prop_types_default.a.bool,
  dragging: prop_types_default.a.bool,
  discrete: prop_types_default.a.bool
};
/* harmony default export */ var Sliders_Thumb = (Thumb_Thumb);
// CONCATENATED MODULE: ../node_modules/react-md/es/Sliders/ThumbMask.js
var ThumbMask_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function ThumbMask_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ThumbMask_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ThumbMask_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ThumbMask_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The `ThumbMask` component is used for either:
 *
 *  - rendering the ink behind the `Thumb` component when the `Thumb`
 *  has keyboard focus or touch focus
 *  - rendering a underlay to make the `Track` look broken for disabled
 *  Sliders.
 */

var ThumbMask_ThumbMask = function (_PureComponent) {
  ThumbMask_inherits(ThumbMask, _PureComponent);

  function ThumbMask() {
    ThumbMask_classCallCheck(this, ThumbMask);

    return ThumbMask_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  ThumbMask.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        thumbLeft = _props.thumbLeft,
        disabled = _props.disabled,
        dragging = _props.dragging,
        maskInked = _props.maskInked,
        discrete = _props.discrete,
        leaving = _props.leaving,
        props = ThumbMask_objectWithoutProperties(_props, ['style', 'className', 'thumbLeft', 'disabled', 'dragging', 'maskInked', 'discrete', 'leaving']);

    return react_default.a.createElement('span', ThumbMask_extends({}, props, {
      style: Object.assign({}, style, { left: thumbLeft }),
      className: classnames_default()('md-slider-thumb md-slider-thumb--mask', className, {
        'md-slider-thumb--dragging': dragging,
        'md-slider-thumb--mask-inked': maskInked,
        'md-slider-thumb--mask-disabled': disabled,
        'md-slider-thumb--discrete-mask-inked': maskInked && discrete,
        'md-slider-thumb--discrete-mask-leaving': discrete && leaving
      })
    }));
  };

  return ThumbMask;
}(react["PureComponent"]);

ThumbMask_ThumbMask.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  disabled: prop_types_default.a.bool,
  thumbLeft: prop_types_default.a.string.isRequired,
  maskInked: prop_types_default.a.bool,
  dragging: prop_types_default.a.bool,
  discrete: prop_types_default.a.bool,
  leaving: prop_types_default.a.bool
};
/* harmony default export */ var Sliders_ThumbMask = (ThumbMask_ThumbMask);
// CONCATENATED MODULE: ../node_modules/react-md/es/Sliders/DiscreteValue.js
var DiscreteValue_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function DiscreteValue_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function DiscreteValue_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DiscreteValue_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DiscreteValue_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var DiscreteValue_DiscreteValue = function (_PureComponent) {
  DiscreteValue_inherits(DiscreteValue, _PureComponent);

  function DiscreteValue() {
    DiscreteValue_classCallCheck(this, DiscreteValue);

    return DiscreteValue_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  DiscreteValue.prototype.render = function render() {
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        discrete = _props.discrete,
        dragging = _props.dragging,
        thumbLeft = _props.thumbLeft,
        active = _props.active,
        value = _props.value,
        valuePrecision = _props.valuePrecision,
        props = DiscreteValue_objectWithoutProperties(_props, ['style', 'className', 'discrete', 'dragging', 'thumbLeft', 'active', 'value', 'valuePrecision']);

    if (!discrete || !active) {
      return null;
    }

    var valueStr = value.toFixed(valuePrecision);
    if (valuePrecision > 0) {
      var _valueStr$split = valueStr.split('.'),
          w = _valueStr$split[0],
          d = _valueStr$split[1];

      if (parseInt(d, 10) === 0) {
        valueStr = w;
      }
    }
    return react_default.a.createElement(
      'span',
      DiscreteValue_extends({}, props, {
        style: Object.assign({}, style, { left: thumbLeft }),
        className: classnames_default()('md-slider-discrete-value', className, {
          'md-slider-discrete-value--dragging': dragging
        })
      }),
      valueStr
    );
  };

  return DiscreteValue;
}(react["PureComponent"]);

DiscreteValue_DiscreteValue.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  discrete: prop_types_default.a.bool,
  dragging: prop_types_default.a.bool,
  active: prop_types_default.a.bool,
  value: prop_types_default.a.number.isRequired,
  thumbLeft: prop_types_default.a.string.isRequired,
  valuePrecision: prop_types_default.a.number.isRequired
};
/* harmony default export */ var Sliders_DiscreteValue = (DiscreteValue_DiscreteValue);
// CONCATENATED MODULE: ../node_modules/react-md/es/Sliders/Track.js
var Track_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Track_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Track_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Track_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Track_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











var half = function half(w) {
  return w / 2;
};

/**
 * The `Track` component is used for showing the current state of the slider.
 * It will render the `TrackFill`, `Thumb`, and `ThumbMask` components.
 */

var Track_Track = function (_PureComponent) {
  Track_inherits(Track, _PureComponent);

  function Track() {
    Track_classCallCheck(this, Track);

    return Track_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Track.prototype.render = function render() {
    var _props = this.props,
        on = _props.on,
        off = _props.off,
        active = _props.active,
        disabled = _props.disabled,
        dragging = _props.dragging,
        className = _props.className,
        thumbLeft = _props.thumbLeft,
        trackFillWidth = _props.trackFillWidth,
        trackFillStyle = _props.trackFillStyle,
        trackFillClassName = _props.trackFillClassName,
        discreteValueStyle = _props.discreteValueStyle,
        discreteValueClassName = _props.discreteValueClassName,
        maskInked = _props.maskInked,
        maskLeaving = _props.maskLeaving,
        thumbStyle = _props.thumbStyle,
        thumbClassName = _props.thumbClassName,
        discrete = _props.discrete,
        onThumbFocus = _props.onThumbFocus,
        onThumbKeyUp = _props.onThumbKeyUp,
        onThumbKeyDown = _props.onThumbKeyDown,
        value = _props.value,
        tickWidth = _props.tickWidth,
        discreteTicks = _props.discreteTicks,
        scale = _props.scale,
        step = _props.step,
        valuePrecision = _props.valuePrecision,
        props = Track_objectWithoutProperties(_props, ['on', 'off', 'active', 'disabled', 'dragging', 'className', 'thumbLeft', 'trackFillWidth', 'trackFillStyle', 'trackFillClassName', 'discreteValueStyle', 'discreteValueClassName', 'maskInked', 'maskLeaving', 'thumbStyle', 'thumbClassName', 'discrete', 'onThumbFocus', 'onThumbKeyUp', 'onThumbKeyDown', 'value', 'tickWidth', 'discreteTicks', 'scale', 'step', 'valuePrecision']);

    var ticks = [];
    if (typeof discreteTicks !== 'undefined' && !disabled && discrete) {
      var amt = scale / (discreteTicks / step);
      var offset = updateUnit(tickWidth, half, 'px');
      var inc = 100 / amt;

      for (var i = 0; i <= amt; i++) {
        var left = i * inc + '%';
        var width = tickWidth;
        if (i === 0 || i === amt) {
          width = updateUnit(tickWidth, half);
        } else {
          left = 'calc(' + left + ' - ' + offset + ')';
        }

        ticks.push(react_default.a.createElement('span', {
          key: 'tick-' + i,
          className: 'md-slider-discrete-tick',
          style: { left: left, width: width }
        }));
      }
    }

    return react_default.a.createElement(
      'div',
      Track_extends({}, props, { className: classnames_default()('md-slider-track', className) }),
      ticks,
      react_default.a.createElement(Sliders_TrackFill, {
        style: trackFillStyle,
        className: trackFillClassName,
        disabled: disabled,
        dragging: dragging,
        trackFillWidth: trackFillWidth
      }),
      react_default.a.createElement(Sliders_Thumb, {
        style: thumbStyle,
        className: thumbClassName,
        on: on,
        off: off,
        disabled: disabled,
        dragging: dragging,
        active: active,
        thumbLeft: thumbLeft,
        onFocus: onThumbFocus,
        onKeyUp: onThumbKeyUp,
        onKeyDown: onThumbKeyDown,
        discrete: discrete
      }),
      react_default.a.createElement(Sliders_DiscreteValue, {
        style: discreteValueStyle,
        className: discreteValueClassName,
        discrete: discrete,
        dragging: dragging,
        active: active,
        value: value,
        thumbLeft: thumbLeft,
        valuePrecision: valuePrecision
      }),
      react_default.a.createElement(Sliders_ThumbMask, {
        dragging: dragging,
        disabled: disabled,
        thumbLeft: thumbLeft,
        maskInked: maskInked,
        discrete: discrete,
        leaving: maskLeaving
      })
    );
  };

  return Track;
}(react["PureComponent"]);

Track_Track.propTypes = {
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  thumbStyle: prop_types_default.a.object,
  thumbClassName: prop_types_default.a.string,
  trackFillStyle: prop_types_default.a.object,
  trackFillClassName: prop_types_default.a.string,
  discreteValueStyle: prop_types_default.a.object,
  discreteValueClassName: prop_types_default.a.string,
  on: prop_types_default.a.bool,
  off: prop_types_default.a.bool,
  active: prop_types_default.a.bool,
  dragging: prop_types_default.a.bool,
  disabled: prop_types_default.a.bool,
  thumbLeft: prop_types_default.a.string.isRequired,
  trackFillWidth: prop_types_default.a.string.isRequired,
  value: prop_types_default.a.number.isRequired,
  discrete: prop_types_default.a.bool,
  maskInked: prop_types_default.a.bool,
  maskLeaving: prop_types_default.a.bool,
  onThumbKeyUp: prop_types_default.a.func.isRequired,
  onThumbKeyDown: prop_types_default.a.func.isRequired,
  onThumbFocus: prop_types_default.a.func.isRequired,
  scale: prop_types_default.a.number,
  step: prop_types_default.a.number,
  discreteTicks: prop_types_default.a.number,
  tickWidth: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  valuePrecision: prop_types_default.a.number.isRequired
};
/* harmony default export */ var Sliders_Track = (Track_Track);
// CONCATENATED MODULE: ../node_modules/react-md/es/Sliders/Slider.js
var Slider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Slider_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Slider_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Slider_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Slider_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



















/**
 * The `Slider` component is used to let users select a value from a continuous
 * or discrete range of values by moving the slider thumb.
 *
 * When the user has finished dragging the Slider or increments the value by using
 * the edit field/keyboard arrows, the value will be rounded to the nearest `step`.
 */

var Slider_Slider = function (_PureComponent) {
  Slider_inherits(Slider, _PureComponent);

  function Slider(props) {
    Slider_classCallCheck(this, Slider);

    var _this = Slider_possibleConstructorReturn(this, _PureComponent.call(this, props));

    Slider_initialiseProps.call(_this);

    var min = props.min,
        max = props.max,
        step = props.step;

    var scale = Math.abs(max - min) / step;

    var value = typeof props.value !== 'undefined' ? props.value : props.defaultValue;

    if (typeof value === 'undefined') {
      value = min;
    }

    var distance = _this._calcDistance(value, min, max);
    var thumbLeft = _this._calcLeft(distance);
    var trackFillWidth = distance + '%';

    if (typeof props.value !== 'undefined') {
      value = undefined;
    }

    var trackWidth = void 0;
    if (props.label && !props.editable && !props.leftIcon && !props.rightIcon) {
      trackWidth = '100%';
    }

    _this.state = {
      value: value,
      scale: scale,
      distance: distance,
      thumbLeft: thumbLeft,
      trackWidth: trackWidth,
      trackFillWidth: trackFillWidth,
      active: false,
      dragging: false,
      maskInked: false
    };
    _this._dragAdded = false;
    return _this;
  }

  Slider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        leftIcon = _props.leftIcon,
        rightIcon = _props.rightIcon,
        label = _props.label,
        min = _props.min,
        max = _props.max,
        step = _props.step,
        value = _props.value;

    if (value !== nextProps.value) {
      var distance = this._calcDistance(nextProps.value, nextProps.min, nextProps.max);
      this.setState({ distance: distance, trackFillWidth: distance + '%', thumbLeft: this._calcLeft(distance) });
    }

    if (leftIcon !== nextProps.leftIcon || rightIcon !== nextProps.rightIcon || label !== nextProps.label) {
      this._calcTrackWidth(nextProps);
    }

    if (min !== nextProps.min || max !== nextProps.max || step !== nextProps.step) {
      this.setState({ scale: Math.abs(nextProps.max - nextProps.min) / nextProps.step });
    }
  };

  Slider.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var _state = this.state,
        active = _state.active,
        manualIncrement = _state.manualIncrement;

    var fn = window[(active ? 'add' : 'remove') + 'EventListener'];
    if (active !== prevState.active) {
      fn('click', this._blurOnOutsideClick);

      if (active) {
        this._focusThumb();
      }
    }

    var addDrag = active && !manualIncrement;
    fn = window[(addDrag ? 'add' : 'remove') + 'EventListener'];
    if (this._dragAdded !== addDrag) {
      fn('mousemove', this._handleDragMove);
      fn('mouseup', this._handleDragEnd);
      setTouchEvent(addDrag, window, 'move', this._handleDragMove);
      setTouchEvent(addDrag, window, 'end', this._handleDragEnd);

      this._dragAdded = addDrag;
    }
  };

  Slider.prototype.componentWillUnmount = function componentWillUnmount() {
    var rm = window.removeEventListener;
    rm('click', this._blurOnOutsideClick);
    rm('mousemove', this._handleMouseMove);
    rm('mouseup', this._handleMouseUp);
    removeTouchEvent(window, 'move', this._handleDragMove);
    removeTouchEvent(window, 'end', this._handleDragEnd);

    if (this._inkTimeout) {
      clearTimeout(this._inkTimeout);
    }

    if (this._focusTimeout) {
      clearTimeout(this._focusTimeout);
    }
  };

  /**
   * Gets the `left` position for the thumb based on the value given.
   *
   * @param {number} value - The current value.
   * @return {string} the `calc` string.
   */


  Slider.prototype._calcLeft = function _calcLeft(value) {
    return 'calc(' + value + '% - 6px)';
  };

  Slider.prototype._calcDistance = function _calcDistance(value, min, max) {
    return Math.max(0, Math.min(100, (value - min) / (max - min) * 100));
  };

  /**
   * Checks if a classList does not contain all the *bad* class names.
   *
   * @param {function} classList - The classList to check.
   * @return {Boolean} true if the classList does not contain any of the *bad* class names.
   */


  Slider.prototype._isValidClassList = function _isValidClassList(classList) {
    var invalid = false;
    ['md-slider-label', 'md-slider-ind', 'md-icon'].some(function (cl) {
      invalid = classList.contains(cl);
      return invalid;
    });

    return !invalid;
  };

  Slider.prototype._isInTextField = function _isInTextField(e) {
    var className = e.target.className;

    // SVG's className is an object instead of a string

    return typeof className.match === 'function' && className.match(/text-field/);
  };

  /**
   * Checks if the target is within the text field container.
   *
   * @param {Object} target - The event target.
   * @return {Boolean} true if the target is in the text field.
   */


  /**
   * Updates the slider's thumb position and the slider's track fill width based
   * on the thumb's current x position on the screen.
   *
   * The slider distance will be *normalized* when:
   *  - The user does a quick jump
   *  - The user stops dragging with the mouse
   *  - The user drops dragging with touch
   *
   * If the position is not *normalized*, the `onDragChange` prop will be called
   * with the new distance percentage, the value, and the move event.
   *
   * The `onChange` function will always be called.
   *
   * @param {Object} e - The current event to extract an x location from
   * @param {bool} normalize - Boolean if the distance should be normalized
   *    to the current scale of the slider.
   */


  /**
   * This will either allow a user to start dragging the slider or quickly
   * jump to a new value on the slider if the slider is not disabled.
   *
   * This will handle the `touchstart` and `mousedown` events.
   *
   * @param {Object} e - The touchstart or mousedown event.
   */


  /**
   * This will set the active state of the slider to false if the user
   * clicks outside of the slider's container.
   *
   * @param {Object} e - The window's click event.
   */


  /**
   * Updates the slider with the `step` prop and calls the `onChange`
   * function with the new value.
   *
   * @param {number} incrementedValue - The newly incremented value of the slider.
   * @param {Object} e - Either the text field's change event, mouse down event, or
   *    touch start event.
   * @param {bool} disableTransition - Boolean if the jump's transition should be disabled.
   */


  /**
   * This will increment the Slider's value by the `step` prop. If the left or
   * right key arrow is pressed.
   *
   * @param {Object} e - the keydown event.
   */


  /**
   * This function will animate the discrete Slider's ink if it gains focus
   * by a tab event.
   *
   * @param {Object} e - the key up event.
   */


  /**
   * For some reason the width of the track gets set to 0 if the `Slider` has a label and
   * does not include the `leftIcon`, `rightIcon`, and is not `editable` OR it is
   * `editable` and does not include the `leftIcon`. All other cases the width works
   * correctly.
   *
   * This function just checks these things, and sets the width accordingly.
   */


  /**
   * The ink for a Discrete slider is only visible for a short time on initial
   * focus. This function will handle the in/out transitions.
   */


  /**
   * This is a helper function for focusing the Slider's thumb component. There
   * is a short delay because the body sometimes gets focused immediately after
   * if there is no timeout..
   */


  Slider.prototype.render = function render() {
    var _state2 = this.state,
        dragging = _state2.dragging,
        active = _state2.active,
        thumbLeft = _state2.thumbLeft,
        trackFillWidth = _state2.trackFillWidth,
        maskInked = _state2.maskInked,
        trackWidth = _state2.trackWidth,
        scale = _state2.scale,
        distance = _state2.distance;

    var _props2 = this.props,
        id = _props2.id,
        min = _props2.min,
        max = _props2.max,
        disabled = _props2.disabled,
        className = _props2.className,
        trackStyle = _props2.trackStyle,
        trackClassName = _props2.trackClassName,
        thumbStyle = _props2.thumbStyle,
        thumbClassName = _props2.thumbClassName,
        discreteValueStyle = _props2.discreteValueStyle,
        discreteValueClassName = _props2.discreteValueClassName,
        label = _props2.label,
        editable = _props2.editable,
        step = _props2.step,
        inputWidth = _props2.inputWidth,
        leftIcon = _props2.leftIcon,
        rightIcon = _props2.rightIcon,
        discrete = _props2.discrete,
        discreteTicks = _props2.discreteTicks,
        tickWidth = _props2.tickWidth,
        valuePrecision = _props2.valuePrecision,
        propValue = _props2.value,
        onChange = _props2.onChange,
        onDragChange = _props2.onDragChange,
        discreteInkTransitionTime = _props2.discreteInkTransitionTime,
        stepPrecision = _props2.stepPrecision,
        props = Slider_objectWithoutProperties(_props2, ['id', 'min', 'max', 'disabled', 'className', 'trackStyle', 'trackClassName', 'thumbStyle', 'thumbClassName', 'discreteValueStyle', 'discreteValueClassName', 'label', 'editable', 'step', 'inputWidth', 'leftIcon', 'rightIcon', 'discrete', 'discreteTicks', 'tickWidth', 'valuePrecision', 'value', 'onChange', 'onDragChange', 'discreteInkTransitionTime', 'stepPrecision']);

    var value = getField(this.props, this.state);
    var rightChildren = rightIcon;
    if (editable) {
      rightChildren = react_default.a.createElement(TextFields_TextField, {
        id: id + '-editor',
        ref: this._setField,
        type: 'number',
        value: value,
        inputClassName: 'md-slider-editor',
        style: { width: inputWidth },
        onChange: this._handleTextFieldChange,
        step: step
      });
    }

    return react_default.a.createElement(
      'div',
      Slider_extends({}, props, {
        ref: this._setNode,
        className: classnames_default()('md-slider-container', className, {
          'md-pointer--hover': !disabled
        }),
        onMouseDown: this._handleDragStart,
        onTouchStart: this._handleDragStart
      }),
      react_default.a.createElement(
        Sliders_SliderLabel,
        { htmlFor: id },
        label
      ),
      react_default.a.createElement('input', {
        id: id,
        type: 'range',
        className: 'md-slider-input',
        readOnly: true,
        min: min,
        max: max,
        value: value,
        disabled: disabled
      }),
      leftIcon,
      react_default.a.createElement(Sliders_Track, {
        ref: this._setTrack,
        style: Object.assign({}, trackStyle, { width: trackWidth }),
        className: classnames_default()(trackClassName, {
          'md-slider-track--ind-left': leftIcon,
          'md-slider-track--ind-right': rightIcon
        }),
        thumbStyle: thumbStyle,
        thumbClassName: thumbClassName,
        discreteValueStyle: discreteValueStyle,
        discreteValueClassName: discreteValueClassName,
        active: active,
        dragging: dragging,
        disabled: disabled,
        thumbLeft: thumbLeft,
        trackFillWidth: trackFillWidth,
        on: !disabled && distance > 0,
        off: distance === 0,
        maskInked: maskInked,
        onThumbKeyUp: this._handleKeyUp,
        onThumbKeyDown: this._handleKeyDown,
        onThumbFocus: this._handleFocus,
        discrete: discrete,
        tickWidth: tickWidth,
        discreteTicks: discreteTicks,
        valuePrecision: valuePrecision,
        step: step,
        scale: scale,
        value: value
      }),
      rightChildren
    );
  };

  return Slider;
}(react["PureComponent"]);

Slider_Slider.propTypes = {
  /**
   * An id to use for the `Slider`. This is required if the `label` prop
   * is defined.
   */
  id: function id(props, propName, component) {
    for (var _len = arguments.length, others = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      others[_key - 3] = arguments[_key];
    }

    if (typeof props.label === 'undefined') {
      return prop_types_default.a.string.apply(prop_types_default.a, [props, propName, component].concat(others));
    }

    return isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])).apply(undefined, [props, propName, component].concat(others));
  },

  /**
   * An optional style to apply to the slider's container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the slider's container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the slider's thumb.
   */
  thumbStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the slider's thumb.
   */
  thumbClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the slider's track.
   */
  trackStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the slider's track.
   */
  trackClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the slider's track fill.
   */
  trackFillStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the slider's track fill.
   */
  trackFillClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to a discrete slider's value.
   */
  discreteValueStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to a discrete slider's value.
   */
  discreteValueClassName: prop_types_default.a.string,

  /**
   * The default value for the slider. This number must be between the min and max values if
   * defined. If this is undefined, it's value will be set to the min value.
   */
  defaultValue: prop_types_default.a.number,

  /**
   * The min value for the slider. This value **must** be less than the `max` value.
   */
  min: function min(props, propName, component) {
    for (var _len2 = arguments.length, others = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      others[_key2 - 3] = arguments[_key2];
    }

    var _PropTypes$number;

    var err = (_PropTypes$number = prop_types_default.a.number).isRequired.apply(_PropTypes$number, [props, propName, component].concat(others));
    if (!err) {
      var min = props[propName];
      var name = void 0;
      if (min > props.value) {
        name = 'value';
      } else if (typeof props.defaultValue !== 'undefined' && min > props.defaultValue) {
        name = 'defaultValue';
      }

      if (name) {
        err = new Error('The \'' + propName + '\' prop must be less than or equal to the \'' + name + '\' prop for the \'' + component + '\' but ' + ('received: \'min: ' + min + '\' and \'' + name + ': ' + props[name] + '\''));
      }
    }

    return err;
  },

  /**
   * The max value for the slider. This value **must** be greater than the `min` value.
   */
  max: function max(props, propName, component) {
    for (var _len3 = arguments.length, others = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
      others[_key3 - 3] = arguments[_key3];
    }

    var _PropTypes$number2;

    var err = (_PropTypes$number2 = prop_types_default.a.number).isRequired.apply(_PropTypes$number2, [props, propName, component].concat(others));
    if (!err) {
      var max = props[propName];
      var name = void 0;
      if (max < props.value) {
        name = 'value';
      } else if (max < props.defaultValue) {
        name = 'defaultValue';
      }

      if (name) {
        err = new Error('The \'' + propName + '\' prop must be greater than or equal to the \'' + name + '\' prop for the \'' + component + '\' but ' + ('received: \'' + propName + ': ' + max + '\' and \'' + name + ': ' + props[name] + '\''));
      }
    }

    return err;
  },

  /**
   * Boolean if the slider is disabled.
   */
  disabled: prop_types_default.a.bool,

  /**
   * An optional value for the slider. This will make the component controlled
   * and require the `onChange` function.
   */
  value: controlled(prop_types_default.a.number, 'onChange'),

  /**
   * This is called when the slider's value gets updated. The value can be updated
   * by one of the following:
   *
   * - Clicking a section of the slider
   * - Dragging the slider with the mouse
   * - Touching a section of the slider.
   * - Dragging the slider with touch
   * - Using the text field to update the value either by typing or incrementing
   * - Using the left or right arrow keys to increment/decrement the value.
   *
   * The callback for this function is as follows:
   *
   * ```js
   * onChange(value, event);
   * ```
   *
   * where the event can either be:
   * - a touch start event
   * - a touch move event
   * - a touch end event
   * - a mouse down event
   * - a mouse move event
   * - a mouse up event
   * - a key up event
   * - a key down event
   */
  onChange: prop_types_default.a.func,

  /**
   * This is only called when the user is dragging the slider with either
   * the mouse or touch. Probably not really useful. It just includes the
   * new drag percentage while the `onChange` does not.
   *
   * The callback for this function is defined as:
   *
   * ```js
   * onDragChange(dragPercentage, value, (touchMove || mouseMove) event);
   * ```
   */
  onDragChange: prop_types_default.a.func,

  /**
   * An optional function to call when the slider's container has
   * the mousedown event.
   */
  onMouseDown: prop_types_default.a.func,

  /**
   * An optional function to call when the slider's container has
   * the touchstart event.
   */
  onTouchStart: prop_types_default.a.func,

  /**
   * An optional icon or letter to place to the left of the slider.
   * if you want to use a non-font icon or a letter, use the `md-slider-ind`
   * className on your element.
   */
  leftIcon: prop_types_default.a.element,

  /**
   * An optional icon or letter to place to the right of the slider.
   * if you want to use a non-font icon or a letter, use the `md-slider-ind`
   * className on your element.
   *
   * > NOTE: This can not be used if the `editable` prop is true.
   */
  rightIcon: prop_types_default.a.element,

  /**
   * An optional label to display above the slider. If this prop
   * is set, then an `id` must also be given.
   */
  label: prop_types_default.a.node,

  /**
   * The incremental amount when the user hits left or right with the
   * keyboard arrows, or the user hits the up or down buttons in the
   * editable number text field. This number must be a number between
   * 0 and 1 or a whole number above 1.
   */
  step: function step(props, propName, component) {
    for (var _len4 = arguments.length, others = Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
      others[_key4 - 3] = arguments[_key4];
    }

    var _PropTypes$number3;

    var err = (_PropTypes$number3 = prop_types_default.a.number).isRequired.apply(_PropTypes$number3, [props, propName, component].concat(others));
    if (!err) {
      var step = props[propName];
      if (step <= 0) {
        err = new Error('The \'' + propName + '\' for the \'' + component + '\' must be a number greater than 0. The ' + ('current value is \'' + step + '\'.'));
      } else {
        var valueDefined = typeof props.value !== 'undefined';
        var defaultDefined = typeof props.defaultValue !== 'undefined';
        var value = props.value;
        if (!valueDefined) {
          value = defaultDefined ? props.defaultValue : props.min;
        }

        var name = void 0;
        if (!isWithinStep(value, step)) {
          if (valueDefined) {
            name = 'value';
          } else if (defaultDefined) {
            name = 'defaultValue';
          } else {
            name = 'min';
          }
        }

        if (name) {
          err = new Error('The \'' + name + '\' prop on \'' + component + '\' should be a number divisible by the ' + ('\'' + propName + '\' prop. The current value is \'' + props[name] + '\' and the \'' + propName + '\' ') + ('is \'' + step + '\'.'));
        }
      }
    }

    return err;
  },

  /**
   * Boolean if the Slider should be editable. This will place a number text field
   * to the right of the slider. If this prop is set to `true`, the `rightIcon`
   * prop can not be set.
   */
  editable: function editable(props, propName, component) {
    for (var _len5 = arguments.length, others = Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {
      others[_key5 - 3] = arguments[_key5];
    }

    var _PropTypes$bool;

    if (typeof props[propName] === 'undefined') {
      return null;
    }

    var err = (_PropTypes$bool = prop_types_default.a.bool).isRequired.apply(_PropTypes$bool, [props, propName, component].concat(others));
    if (!err && typeof props.rightIcon !== 'undefined') {
      err = new Error('The \'' + component + '\' is unable to be \'editable\' and include a \'rightIcon\'.');
    }

    return err;
  },

  /**
   * The width for the number text field when the Slider is editable.
   */
  inputWidth: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,

  /**
   * Boolean if the slider should be discrete. This will update the slider to include a
   * _balloon_ with the current value inside. It will also not allow the `Slider` to be
   * editable.
   */
  discrete: function discrete(props, propName, component) {
    for (var _len6 = arguments.length, others = Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {
      others[_key6 - 3] = arguments[_key6];
    }

    if (typeof props[propName] === 'undefined') {
      return null;
    }

    var err = prop_types_default.a.bool.apply(prop_types_default.a, [props, propName, component].concat(others));
    if (!err && typeof props.editable !== 'undefined') {
      err = new Error('The \'' + component + '\' cannot be \'discrete\' and \'editable\'. Please choose one.');
    }

    return err;
  },

  /**
   * The width of each tick for a discrete slider with ticks. This can either be a number
   * which gets converted to `px`, or a valid CSS unit.
   */
  tickWidth: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,

  /**
   * This is number divisible by the total number of values included in the Slider. Every
   * value that is divisible by this number will include a tick mark. It is common recommended
   * to have this equal to the `step` prop.
   *
   * This prop is completely optional.
   */
  discreteTicks: function discreteTicks(props, propName, component) {
    for (var _len7 = arguments.length, others = Array(_len7 > 3 ? _len7 - 3 : 0), _key7 = 3; _key7 < _len7; _key7++) {
      others[_key7 - 3] = arguments[_key7];
    }

    if (typeof props[propName] === 'undefined') {
      return null;
    }

    var err = prop_types_default.a.number.apply(prop_types_default.a, [props, propName, component].concat(others));
    if (!err) {
      var min = props.min,
          max = props.max,
          step = props.step;

      var range = Math.abs(max - min);

      if (range / props[propName] % 1 !== 0) {
        err = new Error('The \'' + propName + '\' must be a number divisible by the range set by the \'min\' and ' + ('\'max\' props. The current range is \'' + range + '\' by including the min: \'' + min + '\' and ') + ('max: \'' + max + '\' values. The current value of \'' + propName + '\' is \'' + props[propName] + '\'.'));
      } else if (props[propName] % step !== 0) {
        err = new Error('The \'step\' prop must be a number divisible by the \'' + propName + '\'. It is common to have ' + ('them as the same value. The current \'step\' is \'' + step + '\' and the \'' + propName + '\' is \'' + props[propName] + '\'.'));
      }
    }

    return err;
  },

  /**
   * The transition time for a discrete Slider's keyboard focus ink. This should match the
   * `md-slider-discrete-ink-transition-time` value in your SCSS. This is used because
   * the ink is only visible temporarily for a discrete slider when keyboard focusing.
   */
  discreteInkTransitionTime: prop_types_default.a.number.isRequired,

  /**
   * The precision that the value should be rounded to when the Slider is updated. This
   * needs to be a whole number greater than or equal to 0.
   */
  valuePrecision: function valuePrecision(props, propName, component) {
    for (var _len8 = arguments.length, others = Array(_len8 > 3 ? _len8 - 3 : 0), _key8 = 3; _key8 < _len8; _key8++) {
      others[_key8 - 3] = arguments[_key8];
    }

    var _PropTypes$number4;

    var err = (_PropTypes$number4 = prop_types_default.a.number).isRequired.apply(_PropTypes$number4, [props, propName, component].concat(others));
    if (!err) {
      var precision = props[propName];

      if (precision % 1 !== 0 || precision < 0) {
        err = new Error('The \'' + propName + '\' must be a positive whole number or 0 on the \'' + component + '\'. ' + ('The current \'' + propName + '\' is \'' + precision + '\''));
      }
    }

    return err;
  },

  stepPrecision: deprecated_default()(prop_types_default.a.number, 'Use `step` and `valuePrecision` instead')
};
Slider_Slider.defaultProps = {
  min: 0,
  max: 100,
  step: 1,
  inputWidth: 40,
  tickWidth: 6,
  discreteInkTransitionTime: 300,
  valuePrecision: 0
};

var Slider_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._isTextField = function (target) {
    return _this2._field && _this2._field.contains(target);
  };

  this._updatePosition = function (e, normalize) {
    var x = (e.changedTouches ? e.changedTouches[0] : e).clientX;
    var scale = _this2.state.scale;
    var _props3 = _this2.props,
        onChange = _props3.onChange,
        onDragChange = _props3.onDragChange,
        min = _props3.min,
        max = _props3.max,
        step = _props3.step;

    var _calculateValueDistan = calculateValueDistance(x, _this2._track.offsetWidth, _this2._track.getBoundingClientRect().left, scale, step, min, max, normalize),
        value = _calculateValueDistan.value,
        distance = _calculateValueDistan.distance;

    var isNewValue = getField(_this2.props, _this2.state, 'value') !== value;
    if (onChange && isNewValue) {
      onChange(value, e);
    }

    if (!normalize && onDragChange && (isNewValue || _this2.state.distance !== distance)) {
      onDragChange(distance, value, e);
    }

    var state = {
      active: true,
      distance: distance,
      manualIncrement: false,
      dragging: !normalize,
      thumbLeft: _this2._calcLeft(distance),
      trackFillWidth: distance + '%'
    };

    if (e.type === 'touchend' || e.type === 'mousedown') {
      state.maskInked = false;
    }

    if (typeof _this2.props.value === 'undefined') {
      state.value = value;
    }

    _this2.setState(state);
  };

  this._handleDragStart = function (e) {
    if (e.type === 'mousedown' && _this2.props.onMouseDown) {
      _this2.props.onMouseDown(e);
    } else if (e.type === 'touchstart' && _this2.props.onTouchStart) {
      _this2.props.onTouchStart(e);
    }

    if (_this2.props.disabled || e.type === 'mousedown' && !isValidClick(e, 'mousedown') || _this2._isInTextField(e)) {
      return;
    }

    var classList = e.target.classList;

    var isDiscreteValue = classList.contains('md-slider-discrete-value');
    if (classList.contains('md-slider-thumb') || isDiscreteValue) {
      // Prevents text highlighting while dragging.
      if (e.type.match(/mouse/)) {
        e.preventDefault();
      }
      _this2.setState({ dragging: true, active: true, manualIncrement: false, maskInked: false });
    } else if (!_this2._isTextField(e.target) && _this2._isValidClassList(classList)) {
      _this2._updatePosition(e, true);
    }
  };

  this._setNode = function (node) {
    _this2._node = Object(react_dom["findDOMNode"])(node);
  };

  this._setTrack = function (track) {
    _this2._track = Object(react_dom["findDOMNode"])(track);
  };

  this._setField = function (field) {
    _this2._field = Object(react_dom["findDOMNode"])(field);
    _this2._calcTrackWidth(_this2.props);
  };

  this._handleDragMove = function (e) {
    if (_this2.props.disabled || !_this2.state.dragging) {
      return;
    }

    // Stops the text highlighting while dragging
    if (e.type.match(/mouse/)) {
      e.preventDefault();
    }

    _this2._updatePosition(e, false);
  };

  this._handleDragEnd = function (e) {
    if (!_this2.state.dragging || _this2.props.disabled || e.type === 'mouseup' && !isValidClick(e)) {
      return;
    }

    _this2._updatePosition(e, true);
  };

  this._blurOnOutsideClick = function (e) {
    if (_this2.state.dragging && !_this2.state.manualIncrement || _this2.props.disabled) {
      return;
    }

    if (!_this2._node.contains(e.target)) {
      _this2.setState({ active: false, maskInked: false });
    }
  };

  this._handleIncrement = function (incrementedValue, e, disableTransition) {
    var _props4 = _this2.props,
        onChange = _props4.onChange,
        min = _props4.min,
        max = _props4.max,
        discrete = _props4.discrete;


    var value = Math.max(min, Math.min(max, incrementedValue));
    var distance = _this2._calcDistance(value, min, max);

    if (onChange) {
      onChange(value, e);
    }

    var state = {
      distance: distance,
      manualIncrement: true,
      thumbLeft: _this2._calcLeft(distance),
      trackFillWidth: distance + '%',
      dragging: Math.abs(_this2.state.distance - distance) < 2 && disableTransition
    };

    if (typeof _this2.props.value === 'undefined') {
      state.value = value;
    }

    if (e.type === 'keydown' && !discrete) {
      state.maskInked = true;
    }

    _this2.setState(state);
  };

  this._handleTextFieldChange = function (newValue, e) {
    _this2._handleIncrement(newValue, e, false);
  };

  this._handleKeyDown = function (e) {
    var key = e.which || e.keyCode;
    var _props5 = _this2.props,
        min = _props5.min,
        max = _props5.max,
        step = _props5.step,
        disabled = _props5.disabled;

    if (disabled) {
      return;
    }

    if (key === TAB) {
      _this2.setState({ active: false, maskInked: false });
      return;
    } else if (key !== LEFT && key !== RIGHT) {
      return;
    }

    var nextValue = getField(_this2.props, _this2.state, 'value');
    nextValue = Math.max(min, Math.min((key === LEFT ? -step : step) + nextValue, max));

    _this2._handleIncrement(nextValue, e, true);
  };

  this._handleKeyUp = function (e) {
    if ((e.which || e.keyCode) !== TAB) {
      return;
    }

    if (_this2.props.discrete) {
      _this2._animateDiscreteInk();
    }

    _this2.setState({ maskInked: true });
  };

  this._handleFocus = function () {
    _this2.setState({ active: true });
  };

  this._calcTrackWidth = function (props) {
    var editable = props.editable,
        leftIcon = props.leftIcon,
        rightIcon = props.rightIcon,
        inputWidth = props.inputWidth,
        label = props.label;


    if (!label) {
      _this2.setState({ trackWidth: null });
      return;
    }

    var trackWidth = null;
    if (!leftIcon && !rightIcon && !editable) {
      trackWidth = '100%';
    } else if (_this2._field && editable && !leftIcon) {
      var cs = window.getComputedStyle(_this2._field);
      var pl = parseInt(cs.getPropertyValue('padding-left'), 10) || 0;
      var ml = parseInt(cs.getPropertyValue('margin-left'), 10) || 0;

      trackWidth = pl + ml + inputWidth;
    }

    if (trackWidth !== _this2.state.trackWidth) {
      _this2.setState({ trackWidth: trackWidth });
    }
  };

  this._animateDiscreteInk = function () {
    var wait = _this2.props.discreteInkTransitionTime;
    if (_this2._inkTimeout) {
      clearTimeout(_this2._inkTimeout);
    }

    _this2._inkTimeout = setTimeout(function () {
      _this2.setState({ leaving: true, maskInked: false });

      _this2._inkTimeout = setTimeout(function () {
        _this2._inkTimeout = null;
        _this2.setState({ leaving: false });
      }, wait);
    }, wait);
  };

  this._focusThumb = function () {
    if (_this2._focusTimeout) {
      clearTimeout(_this2._focusTimeout);
    }

    _this2._focusTimeout = setTimeout(function () {
      _this2._focusTimeout = null;
      if (!_this2._thumb) {
        _this2._thumb = _this2._node.querySelector('.md-slider-thumb');
      }

      _this2._thumb.focus();
    }, 100);
  };
};

/* harmony default export */ var Sliders_Slider = (Slider_Slider);
// CONCATENATED MODULE: ../node_modules/react-md/es/Snackbars/isInvalidAnimate.js
var gcc = 'getComposedComponent';

/**
 * Just checks if the fab is actually a ref to the FAB Button.
 */
function isInvalidAnimate(fab) {
  return typeof fab[gcc] !== 'function' || typeof fab[gcc]()[gcc] !== 'function' || typeof fab[gcc]()[gcc]()._animateForSnackbar !== 'function';
}
// CONCATENATED MODULE: ../node_modules/react-md/es/Snackbars/Snackbar.js
var Snackbar_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Snackbar_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Snackbar_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Snackbar_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Snackbar_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var Snackbar_Snackbar = function (_PureComponent) {
  Snackbar_inherits(Snackbar, _PureComponent);

  function Snackbar() {
    var _temp, _this, _ret;

    Snackbar_classCallCheck(this, Snackbar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Snackbar_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._handleClick = function (e) {
      var _this$props = _this.props,
          onDismiss = _this$props.onDismiss,
          action = _this$props.toast.action,
          leaveTimeout = _this$props.leaveTimeout,
          multiline = _this$props.multiline;

      if (typeof action.onClick === 'function') {
        action.onClick(e);
      }

      if (_this._fab) {
        _this._fab._animateForSnackbar(multiline, leaveTimeout);
      }

      onDismiss();
    }, _this._clearTimeout = function () {
      if (_this._timeout) {
        clearTimeout(_this._timeout);
        _this._timeout = null;
      }
    }, _this._handleAutohide = function () {
      var _this$props2 = _this.props,
          autohide = _this$props2.autohide,
          autohideTimeout = _this$props2.autohideTimeout,
          onDismiss = _this$props2.onDismiss,
          multiline = _this$props2.multiline,
          leaveTimeout = _this$props2.leaveTimeout;

      if (!autohide) {
        return;
      }

      window.addEventListener('blur', _this._handleWindowBlur);
      _this._eventType = 'blur';
      _this._timeout = setTimeout(function () {
        _this._timeout = null;
        _this._eventType = null;

        window.removeEventListener('blur', _this._handleWindowBlur);

        if (_this._fab) {
          _this._fab._animateForSnackbar(multiline, leaveTimeout);
        }

        onDismiss();
      }, autohideTimeout || _this.state.toast);
    }, _this._handleWindowBlur = function () {
      _this._clearTimeout();
      window.removeEventListener('blur', _this._handleWindowBlur);
      window.addEventListener('focus', _this._handleWindowFocus);
      _this._eventType = 'focus';
    }, _this._handleWindowFocus = function () {
      window.removeEventListener('focus', _this._handleWindowFocus);
      _this._eventType = null;
      _this._handleAutohide();
    }, _temp), Snackbar_possibleConstructorReturn(_this, _ret);
  }

  Snackbar.prototype.componentWillMount = function componentWillMount() {
    var _props = this.props,
        fab = _props.fab,
        multiline = _props.multiline,
        onAppear = _props.toast.onAppear;

    if (onAppear) {
      onAppear();
    }

    if (!fab || isInvalidAnimate(fab)) {
      return;
    }

    this._fab = fab.getComposedComponent().getComposedComponent();
    this._fab._animateForSnackbar(multiline);
  };

  Snackbar.prototype.componentDidMount = function componentDidMount() {
    this._handleAutohide();
  };

  Snackbar.prototype.componentWillUnmount = function componentWillUnmount() {
    this._clearTimeout();

    if (this._eventType === 'focus') {
      window.removeEventListener('focus', this._handleWindowFocus);
    } else if (this._eventType === 'blur') {
      window.removeEventListener('blur', this._handleWindowBlur);
    }
  };

  Snackbar.prototype.render = function render() {
    var _props2 = this.props,
        className = _props2.className,
        toast = _props2.toast,
        multiline = _props2.multiline,
        propId = _props2.id,
        fab = _props2.fab,
        autohide = _props2.autohide,
        autohideTimeout = _props2.autohideTimeout,
        leaveTimeout = _props2.leaveTimeout,
        onDismiss = _props2.onDismiss,
        props = Snackbar_objectWithoutProperties(_props2, ['className', 'toast', 'multiline', 'id', 'fab', 'autohide', 'autohideTimeout', 'leaveTimeout', 'onDismiss']);

    var text = toast.text,
        action = toast.action;
    var id = this.props.id;


    var Component = 'p';
    if (action) {
      Component = 'section';
      text = react_default.a.createElement(
        'p',
        { className: 'md-snackbar--toast md-snackbar--action' },
        text
      );

      var btnProps = {
        flat: true,
        onClick: this._handleClick,
        children: action,
        secondary: true,
        className: 'md-btn--snackbar'
      };

      if (typeof action !== 'string') {
        btnProps = Object.assign(btnProps, action, {
          className: classnames_default()(btnProps.className, action.className),
          onClick: this._handleClick
        });
      }

      action = react_default.a.createElement(Buttons_Button, btnProps);
    }

    if (!id) {
      id = 'snackbar-alert' + (action ? '-dialog' : '');
    }

    var role = 'alert' + (action ? 'dialog' : '');
    return react_default.a.createElement(
      Component,
      Snackbar_extends({}, props, {
        id: id,
        role: role,
        className: classnames_default()('md-snackbar', {
          'md-snackbar--multiline': multiline,
          'md-snackbar--toast': !action
        }, className)
      }),
      text,
      action
    );
  };

  return Snackbar;
}(react["PureComponent"]);

Snackbar_Snackbar.propTypes = {
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  style: prop_types_default.a.object,
  className: prop_types_default.a.string,
  children: prop_types_default.a.node,
  onDismiss: prop_types_default.a.func.isRequired,
  toast: prop_types_default.a.shape({
    text: prop_types_default.a.node.isRequired,
    action: prop_types_default.a.oneOfType([prop_types_default.a.node, prop_types_default.a.shape({
      label: prop_types_default.a.node,
      children: prop_types_default.a.node,
      onClick: prop_types_default.a.func
    })]),
    onAppear: prop_types_default.a.func
  }).isRequired,
  multiline: prop_types_default.a.bool,
  autohide: prop_types_default.a.bool,
  autohideTimeout: prop_types_default.a.number,
  fab: prop_types_default.a.object,
  leaveTimeout: prop_types_default.a.number.isRequired
};
/* harmony default export */ var Snackbars_Snackbar = (Snackbar_Snackbar);
// CONCATENATED MODULE: ../node_modules/react-md/es/Snackbars/SnackbarContainer.js
var SnackbarContainer_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var SnackbarContainer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function SnackbarContainer_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SnackbarContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SnackbarContainer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SnackbarContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }













var CHAINED_TOAST_DELAY = 50;

/**
 * The `Snackbar` component is used for displaying a concise and small message to the user about
 * an operation performed.
 *
 * > The main component for the `Snackbar` is actually named the `SnackbarContainer`, so you need
 * to make sure the import is `react-md/lib/Snackbars` or `react-md/lib/Snackbars/SnackbarContainer`.
 * The first import is preferable.
 */

var SnackbarContainer_SnackbarContainer = function (_PureComponent) {
  SnackbarContainer_inherits(SnackbarContainer, _PureComponent);

  function SnackbarContainer(props) {
    SnackbarContainer_classCallCheck(this, SnackbarContainer);

    var _this = SnackbarContainer_possibleConstructorReturn(this, _PureComponent.call(this, props));

    SnackbarContainer_initialiseProps.call(_this);

    var visible = !!props.toasts.length;
    _this.state = {
      visible: visible,
      toast: null
    };
    return _this;
  }

  SnackbarContainer.prototype.componentDidMount = function componentDidMount() {
    var toasts = this.props.toasts;

    if (toasts.length) {
      this._initAndToast(toasts[0]);
    }
  };

  SnackbarContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _nextProps$toasts = nextProps.toasts,
        toast = _nextProps$toasts[0];
    var _props$toasts = this.props.toasts,
        prevToast = _props$toasts[0];

    if (toast === prevToast || toast === this.state.toast) {
      return;
    }

    if (!toast) {
      this._createLeaveTimer();
    } else if (!this.state.visible) {
      this._initAndToast(toast);
    } else {
      this._createSwapTimer(toast);
    }
  };

  SnackbarContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._initTimeout) {
      clearTimeout(this._initTimeout);
    }

    if (this._leaveTimeout) {
      clearTimeout(this._leaveTimeout);
    }

    if (this._swapTimeout) {
      clearTimeout(this._swapTimeout);
    }

    if (this._dismissTimeout) {
      clearTimeout(this._dismissTimeout);
    }
  };

  /**
   * This function takes in a new toast object and checks if the message will span
   * multiple lines of text by creating the new snackbar before the `Snackbar` component
   * gets made, checking the height of the message, and then removing the temporary
   * snackbar.
   */


  SnackbarContainer.prototype.render = function render() {
    var _state = this.state,
        visible = _state.visible,
        toast = _state.toast,
        multiline = _state.multiline;

    var _props = this.props,
        transitionName = _props.transitionName,
        transitionEnterTimeout = _props.transitionEnterTimeout,
        transitionLeaveTimeout = _props.transitionLeaveTimeout,
        dismiss = _props.dismiss,
        onDismiss = _props.onDismiss,
        lastChild = _props.lastChild,
        portal = _props.portal,
        propRenderNode = _props.renderNode,
        toasts = _props.toasts,
        props = SnackbarContainer_objectWithoutProperties(_props, ['transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'dismiss', 'onDismiss', 'lastChild', 'portal', 'renderNode', 'toasts']);

    var renderNode = getField(this.props, this.context, 'renderNode');

    var snackbar = void 0;
    if (toast) {
      snackbar = react_default.a.createElement(Snackbars_Snackbar, SnackbarContainer_extends({}, props, {
        key: 'snackbar',
        leaveTimeout: transitionLeaveTimeout,
        toast: toast,
        multiline: multiline,
        onDismiss: onDismiss || dismiss
      }));
    }

    var container = react_default.a.createElement(
      CSSTransitionGroup_default.a,
      {
        ref: this._setContainer,
        key: 'container',
        className: 'md-snackbar-container',
        transitionName: transitionName,
        transitionEnterTimeout: transitionEnterTimeout,
        transitionLeaveTimeout: transitionLeaveTimeout
      },
      snackbar
    );

    if (!portal) {
      return visible ? container : null;
    }

    return react_default.a.createElement(
      Helpers_Portal,
      { visible: visible, renderNode: renderNode, lastChild: lastChild },
      container
    );
  };

  return SnackbarContainer;
}(react["PureComponent"]);

SnackbarContainer_SnackbarContainer.propTypes = {
  /**
   * An id for the Snackbar once a toast has been added and is visible. This is a recommended
   * prop for accessibility concerns. If it is omitted, the id will become `'snackbar-alert'`
   * when there is no action on the toast, or `'snackbar-alert-dialog'` when there is an action
   * on the toast.
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply to the snackbar once it appears.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the snackbar once it appears.
   */
  className: prop_types_default.a.string,

  /**
   * An immutable controlled queue of toasts that should appear in the snackbar.
   * The snackbar will always display the first toast in this list. When the user has
   * either clicked the action of the toast, or the `autohideTimeout` has been reached,
   * the `onDismiss` function will be called. The `onDismiss` function should remove the
   * first toast and return a new list of remaining toasts.
   *
   * ```js
   * let toasts = [];
   * const onDismiss = () => {
   *   const [, ...remainingToasts] = toasts;
   *   toasts = remainingToasts;
   * };
   * ```
   */
  toasts: prop_types_default.a.arrayOf(prop_types_default.a.shape({
    /**
     * The text to display in the toast.
     */
    text: prop_types_default.a.node.isRequired,

    /**
     * An optional action to take. If this value is a string, the `label` for the
     * button will be this value, Otherwise, all the keys in the action object will
     * be applied to the `Button`.
     */
    action: prop_types_default.a.oneOfType([prop_types_default.a.node, prop_types_default.a.shape({
      onClick: prop_types_default.a.func,
      children: prop_types_default.a.node,
      // Deprecated
      label: prop_types_default.a.node
    })])
  })).isRequired,

  /**
   * A function to call that will dismiss a toast. This will automatically be bound to
   * any toast that has an `action` and it will also be called when the `autohideTimeout`
   * has been reached.
   */
  onDismiss: prop_types_default.a.func.isRequired,

  /**
   * Boolean if the snackbar's toasts should automatically be dismissed after the
   * `autohideTimeout` has been reached.
   */
  autohide: prop_types_default.a.bool,

  /**
   * The amount of time before the snackbar should be dequeued and the next toast
   * should be displayed.
   */
  autohideTimeout: prop_types_default.a.number.isRequired,

  /**
   * The transition name to use for the snackbar appearing and disappearing.
   */
  transitionName: prop_types_default.a.string.isRequired,

  /**
   * The transition time for the snackbar to enter. This should match the `$md-snackbar-transition-time`
   * sass variable.
   */
  transitionEnterTimeout: prop_types_default.a.number.isRequired,

  /**
   * The transition time for the snackbar to leave. This should match the `$md-snackbar-transition-time`
   * sass variable.
   */
  transitionLeaveTimeout: prop_types_default.a.number.isRequired,

  /**
   * When the app contains a floating action button that is fixed to the bottom of the screen,
   * you should set this to be a ref of the floating action button. When a snackbar appears,
   * the FAB will be moved to not overlay the snackbar.
   */
  fab: function fab(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = typeof propValue === 'undefined' ? 'undefined' : SnackbarContainer_typeof(propValue);

    if (!propValue) {
      return null;
    }

    if (propType !== 'object' || typeof propValue.render !== 'function' || isInvalidAnimate(propValue)) {
      var componentNameSafe = componentName || '<<anonymous>>';
      var propFullNameSafe = propFullName || propName;
      return new Error('Invalid ' + location + ' `' + propFullNameSafe + '` supplied to `' + componentNameSafe + '`, expected a ' + 'ref to a floating `Button` component. This should not be a DOMElement from `findDOMNode` but instead ' + 'the React ref object.');
    }

    return null;
  },

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the snackbar.
   *
   * @see {@link Helpers/Portal}
   */
  portal: prop_types_default.a.bool,

  /**
   * An optional DOM node to render the Snackbar in. If this is omitted, it will render as the first
   * child in the `body`.
   */
  renderNode: prop_types_default.a.object,

  /**
   * Boolean if the snackbar should render as the last child in the `renderNode` or `body` instead of
   * as the first.
   */
  lastChild: prop_types_default.a.bool,
  dismiss: deprecated_default()(prop_types_default.a.func, 'Use `onDismiss` instead')
};
SnackbarContainer_SnackbarContainer.defaultProps = {
  autohide: true,
  toasts: [],
  autohideTimeout: 3000,
  transitionName: 'md-snackbar',
  transitionEnterTimeout: 300,
  transitionLeaveTimeout: 300
};
SnackbarContainer_SnackbarContainer.contextTypes = {
  renderNode: prop_types_default.a.object
};

var SnackbarContainer_initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._setContainer = function (container) {
    _this2._container = Object(react_dom["findDOMNode"])(container);
  };

  this._isMultiline = function (toast) {
    var container = _this2._container;
    if (container === null) {
      return false;
    }

    var message = document.createElement('p');
    message.classList.add('md-snackbar--toast');
    message.innerHTML = toast.text;

    var snackbar = void 0;
    if (toast.action) {
      message.classList.add('md-snackbar--action');

      snackbar = document.createElement('section');
      snackbar.className = 'md-snackbar';
      snackbar.appendChild(message);

      var action = document.createElement('button');
      action.innerHTML = typeof toast.action === 'string' ? toast.action : toast.action.label;
      action.className = 'md-btn md-btn--flat md-btn--text md-btn--snackbar';
      snackbar.appendChild(action);
    } else {
      snackbar = message;
    }

    // Only style we really want from the .md-snackbar
    snackbar.style.maxWidth = '568px';

    container.appendChild(snackbar);
    var multiline = message.offsetHeight > 20;
    container.removeChild(snackbar);

    return multiline;
  };

  this._initAndToast = function (toast) {
    _this2._initTimeout = setTimeout(function () {
      _this2._initTimeout = null;

      _this2.setState({ toast: toast, multiline: _this2._isMultiline(toast) });
    }, CSSTransitionGroupTick);

    _this2.setState({ visible: true });
  };

  this._createLeaveTimer = function () {
    var time = _this2.props.transitionLeaveTimeout;

    _this2._leaveTimeout = setTimeout(function () {
      _this2._leaveTimeout = null;

      _this2.setState({ visible: false });
    }, time + CSSTransitionGroupTick);

    _this2.setState({ toast: null });
  };

  this._createSwapTimer = function (toast) {
    _this2._swapTimeout = setTimeout(function () {
      _this2._swapTimeout = null;

      _this2.setState({ toast: toast, multiline: _this2._isMultiline(toast) });
    }, _this2.props.transitionLeaveTimeout + CHAINED_TOAST_DELAY);

    _this2.setState({ toast: null });
  };
};

/* harmony default export */ var Snackbars_SnackbarContainer = (SnackbarContainer_SnackbarContainer);
// CONCATENATED MODULE: ../node_modules/react-md/es/SVGIcons/SVGIcon.js
var SVGIcon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function SVGIcon_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function SVGIcon_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SVGIcon_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function SVGIcon_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








/**
 * The `SVGIcon` component is used for rendering inline SVG icons or sprite-mapped SVGs
 * as an icon.
 */

var SVGIcon_SVGIcon = function (_PureComponent) {
  SVGIcon_inherits(SVGIcon, _PureComponent);

  function SVGIcon(props) {
    SVGIcon_classCallCheck(this, SVGIcon);

    var _this = SVGIcon_possibleConstructorReturn(this, _PureComponent.call(this));

    _this._getIds = function (_ref) {
      var use = _ref.use,
          labels = _ref['aria-labelledby'],
          title = _ref.title,
          desc = _ref.desc;

      var titleId = null;
      var descId = null;
      var labelledBy = null;
      if (title || desc) {
        if (use) {
          var baseId = use.replace(/.*#/, '');
          titleId = baseId + '-title';
          descId = baseId + '-desc';

          if (title) {
            labelledBy = baseId + '-title';
          }

          if (desc) {
            labelledBy = '' + (labelledBy ? labelledBy + ' ' : '') + descId;
          }
        } else if (labels) {
          var _labels$split = labels.split(' ');

          titleId = _labels$split[0];
          descId = _labels$split[1];
        }
      }

      return { titleId: titleId, descId: descId, labelledBy: labelledBy };
    };

    _this._mergeStyles = function (_ref2) {
      var style = _ref2.style,
          size = _ref2.size;

      if (style && size) {
        return SVGIcon_extends({ height: size, width: size }, style);
      } else if (style) {
        return style;
      } else if (size) {
        return { height: size, width: size };
      }

      return undefined;
    };

    _this.state = SVGIcon_extends({
      styles: _this._mergeStyles(props)
    }, _this._getIds(props));
    return _this;
  }

  SVGIcon.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        style = _props.style,
        size = _props.size,
        use = _props.use,
        title = _props.title,
        desc = _props.desc,
        labels = _props['aria-labelledby'];

    var nextState = void 0;
    if (style !== nextProps.style || size !== nextProps.size) {
      nextState = { styles: this._mergeStyles(nextProps) };
    }

    if (title !== nextProps.title || desc !== nextProps.desc || (nextProps.title || nextProps.desc) && (use !== nextProps.use || labels !== nextProps['aria-labelledby'])) {
      nextState = SVGIcon_extends({}, nextState, this._getIds(nextProps));
    }

    if (nextState) {
      this.setState(nextState);
    }
  };

  SVGIcon.prototype.render = function render() {
    var _state = this.state,
        styles = _state.styles,
        titleId = _state.titleId,
        descId = _state.descId,
        labelledBy = _state.labelledBy;

    var _props2 = this.props,
        className = _props2.className,
        disabled = _props2.disabled,
        use = _props2.use,
        primary = _props2.primary,
        secondary = _props2.secondary,
        error = _props2.error,
        inherit = _props2.inherit,
        titleAttr = _props2.titleAttr,
        ariaLabelledBy = _props2['aria-labelledby'],
        size = _props2.size,
        propTitle = _props2.title,
        propDesc = _props2.desc,
        propStyle = _props2.style,
        propChildren = _props2.children,
        props = SVGIcon_objectWithoutProperties(_props2, ['className', 'disabled', 'use', 'primary', 'secondary', 'error', 'inherit', 'titleAttr', 'aria-labelledby', 'size', 'title', 'desc', 'style', 'children']);

    var _props3 = this.props,
        children = _props3.children,
        title = _props3.title,
        desc = _props3.desc;

    if (!children && use) {
      children = react_default.a.createElement('use', { xlinkHref: use });
    }

    if (title) {
      title = react_default.a.createElement(
        'title',
        { id: titleId },
        title
      );
    }

    if (desc) {
      desc = react_default.a.createElement(
        'desc',
        { id: descId },
        desc
      );
    }

    return react_default.a.createElement(
      'svg',
      SVGIcon_extends({}, props, {
        title: titleAttr,
        'aria-labelledby': ariaLabelledBy || labelledBy,
        style: styles,
        className: classnames_default()('md-icon', themeColors({
          disabled: disabled,
          error: error,
          inherit: inherit,
          primary: primary,
          secondary: secondary
        }, className))
      }),
      title,
      desc,
      children
    );
  };

  return SVGIcon;
}(react["PureComponent"]);

SVGIcon_SVGIcon.propTypes = {
  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * Boolean if the primary theme color should be applied.
   */
  primary: prop_types_default.a.bool,

  /**
   * Boolean if the secondary theme color should be applied.
   */
  secondary: prop_types_default.a.bool,

  /**
   * Boolean if the icon is considered disabled and should inherit the
   * disabled color.
   */
  disabled: prop_types_default.a.bool,

  /**
   * Boolean if the icon is considered errored and should inherit the error color.
   */
  error: prop_types_default.a.bool,

  /**
   * Boolean if the color of the icon should be inherited by parent elements.
   */
  inherit: prop_types_default.a.bool,

  /**
   * The role to apply to the SVG. When using icons, it is generally recommended to leave it as the default
   * `img` so that it is insured as a graphic.
   */
  role: prop_types_default.a.oneOf(['img', 'presentation']),

  /**
   * This prop is the title attribute to provide to the `<svg>` element itself. This should be used when you
   * are using a spritesheet that has defined `<title>` with each SVG symbol.
   */
  titleAttr: prop_types_default.a.string,

  /**
   * An optional list of ids to use to label the SVG icon with. This is helpful to add when you use the `title`
   * and `desc` props as this is used to create ids for those two props. This is super beneficial to screen readers.
   *
   * When this is defined, it is a space-delimited string of ids to provide to the title and desc (in order). If
   * this is omitted and the `use` prop is defined, it will take everything after the `#` sign and append `-title` and
   * `-desc` as a fallback. Check out the examples for more information about this.
   *
   * @see {@link #title}
   * @see {@link #desc}
   */
  'aria-labelledby': prop_types_default.a.string,

  /**
   * An optional title to give to your SVG icon. This is generally recommended for accessibility when not using
   * the `use` prop, or your spritemap does not contain `<title>` and `<desc>.
   *
   * @see {@link #aria-labelledby}
   */
  title: prop_types_default.a.string,

  /**
   * An optional description to give to your SVG icon. This is generally recommended for accessibility when not using
   * the `use` prop, or your spritemap does not contain `<title>` and `<desc>.
   *
   * @see {@link #aria-labelledby}
   */
  desc: prop_types_default.a.string,

  /**
   * This should be a link to a part of an SVG spritemap. So normally one of the following:
   * - `'#some-custom-svg'`
   * - `'/images/spritemap.svg#some-custom-svg'`
   *
   * This prop **should not** be used with the `children` prop as only one will be rendered.
   *
   * > NOTE: IE **does not support** external SVGs. Please see the demo for more details.
   */
  use: prop_types_default.a.string,

  /**
   * Any `<svg>` children to render to create your icon. This can not be used with the `use` prop.
   */
  children: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.arrayOf(prop_types_default.a.element), prop_types_default.a.node]),

  /**
   * Boolean if the SVG should gain the `focusable` attribute. This is disabled by default since IE11
   * and Edge actually default this to true and keyboard's will tab focus all SVGs.
   */
  focusable: prop_types_default.a.string,

  /**
   * An optional size to apply to the SVG. This can be used to set both the
   * `height` and `width` simultaneously. This will be provided as inline styles
   * since the `height` and `width` are normally controlled by CSS, and CSS has
   * higher precedence than the `height`/`width` attributes.
   */
  size: prop_types_default.a.number,

  /**
   * The `height` prop should not be used since the `height` and `width` are controlled by CSS and the CSS
   * has a higher precedence than inline attributes. If you want to set the `height`, it should be done via
   * CSS or the `size` prop.
   *
   * @see {@link #size}
   */
  height: deprecated_default()(prop_types_default.a.number, 'Use the `size` prop instead'),

  /**
   * The `width` prop should not be used since the `height` and `width` are controlled by CSS and the CSS
   * has a higher precedence than inline attributes. If you want to set the `height`, it should be done via
   * CSS or the `size` prop.
   *
   * @see {@link #size}
   */
  width: deprecated_default()(prop_types_default.a.number, 'Use the `size` prop instead'),

  /**
   * The viewBox attribute allows you to specify that a given set of graphics stretch to
   * fit a particular container element.
   *
   * The value of the viewBox attribute is a list of four numbers min-x, min-y, width and
   * height, separated by white space and/or a comma, which specify a rectangle in user
   * space which should be mapped to the bounds of the viewport established by the given
   * element, taking into account attribute preserveAspectRatio.
   *
   * Negative values for width or height are not permitted and a value of zero disables
   * rendering of the element.An optional viewbox for the SVG.
   *
   * For example, if the SVG element is 250 (width) by 200 (height) and you provide
   * `viewBox="0 0 25 20"`, the coordinates inside the SVG will go from the top left corner
   * (0, 0) to the bottom right (25, 20) and each unit will be worth `10px`.
   */
  viewBox: prop_types_default.a.string,

  /**
   * An optional xmlns string to provide. The `use` prop will not work without this prop
   * defined.
   */
  xmlns: prop_types_default.a.string
};
SVGIcon_SVGIcon.defaultProps = {
  role: 'img',
  focusable: 'false',
  xmlns: 'http://www.w3.org/2000/svg',
  viewBox: '0 0 24 24'
};
/* harmony default export */ var SVGIcons_SVGIcon = (SVGIcon_SVGIcon);
// EXTERNAL MODULE: ../node_modules/react-swipeable-views/lib/index.js
var lib = __webpack_require__("zaJg");
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// CONCATENATED MODULE: ../node_modules/react-md/es/Tabs/TabPanel.js
var TabPanel_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TabPanel_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TabPanel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TabPanel_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TabPanel_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * This component is just a simple accessibility wrapper when using tabs. If you use the
 * `TabsContainer` component, you *should* not manually use this as the `TabsContainer`
 * generates this for you.
 */

var TabPanel_TabPanel = function (_PureComponent) {
  TabPanel_inherits(TabPanel, _PureComponent);

  function TabPanel() {
    TabPanel_classCallCheck(this, TabPanel);

    return TabPanel_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  TabPanel.prototype.render = function render() {
    var _props = this.props,
        Component = _props.component,
        id = _props.id,
        active = _props.active,
        className = _props.className,
        controlledById = _props.controlledById,
        children = _props.children,
        props = TabPanel_objectWithoutProperties(_props, ['component', 'id', 'active', 'className', 'controlledById', 'children']);

    return react_default.a.createElement(
      Component,
      TabPanel_extends({}, props, {
        id: id,
        className: classnames_default()('md-tab-panel', className),
        role: 'tabpanel',
        'aria-hidden': !active,
        'aria-labelledby': controlledById
      }),
      children
    );
  };

  return TabPanel;
}(react["PureComponent"]);

TabPanel_TabPanel.propTypes = {
  /**
   * An id for the panel. This is used for a11y. This should equal the `controlsId`
   * of whichever tab's children will be placed in here.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * An id for the tab that owns this panel. This should equal the `id` of whichever
   * tab's children will be placed in here.
   */
  controlledById: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The component to render the panel as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * Boolean if the panel is currently active. This is used to generated the `aria-hidden`
   * attribute.
   */
  active: prop_types_default.a.bool,

  /**
   * Any children to display.
   */
  children: prop_types_default.a.node
};
TabPanel_TabPanel.defaultProps = {
  component: 'div'
};
/* harmony default export */ var Tabs_TabPanel = (TabPanel_TabPanel);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tabs/TabsContainer.js
var TabsContainer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TabsContainer_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TabsContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TabsContainer_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TabsContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }














/**
 * The `TabsContainer` component is used when you want to have your `Tabs` connected with
 * the `SwipeableViews`. This component will traverse the children subtree and extract out
 * the `children` from each tab, and render them in a swipeable container. However,
 * since this is using the `React.Children` traversal, You will have to keep the `Tabs`
 * and `Tab` component as a direct descendent. You are unable to make a separate component
 * that encompasses the `Tab` component.
 *
 * ```js
 * // valid
 * <TabsContainer>
 *   <Tabs>
 *     <Tab />
 *   </Tabs>
 * </TabsContainer>
 *
 * // invalid
 * <TabsContainer>
 *   <Tabs>
 *     <MyCustomTab />
 *   </Tabs>
 * </TabsContainer>
 * ```
 *
 * This is because it seems you are unable to access the `MyCustomTab`'s child Tab props correctly.
 * You can however have the tab's children as a separate component if you wish.
 */

var TabsContainer_TabsContainer = function (_PureComponent) {
  TabsContainer_inherits(TabsContainer, _PureComponent);

  function TabsContainer(props) {
    TabsContainer_classCallCheck(this, TabsContainer);

    var _this = TabsContainer_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._handleTabChange = function (index, tabId, tabControlsId, tabChildren, event) {
      if (_this.props.onTabChange) {
        _this.props.onTabChange(index, tabId, tabControlsId, tabChildren, event);
      }

      if (typeof _this.props.activeTabIndex === 'undefined') {
        _this.setState({ activeTabIndex: index });
      }
    };

    _this._handleSwipeChange = function (activeTabIndex) {
      _this._handleTabChange(activeTabIndex);
    };

    _this._setContainer = function (container) {
      _this._container = Object(react_dom["findDOMNode"])(container);
    };

    _this._resizePanel = function () {
      if (!_this._container) {
        return;
      }

      var activePanel = _this._container.querySelector('.md-tab-panel[aria-hidden=false]');
      if (activePanel && _this.state.panelHeight !== activePanel.scrollHeight) {
        _this.setState({ panelHeight: activePanel.scrollHeight });
      }
    };

    _this.state = {};
    if (typeof props.activeTabIndex === 'undefined') {
      _this.state.activeTabIndex = props.defaultTabIndex;
    }
    return _this;
  }

  TabsContainer.prototype.componentDidMount = function componentDidMount() {
    this._resizePanel();
  };

  TabsContainer.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var prevIndex = getField(prevProps, prevState, 'activeTabIndex');
    var currIndex = getField(this.props, this.state, 'activeTabIndex');

    if (prevIndex !== currIndex) {
      this._resizePanel();
    }
  };

  TabsContainer.prototype.render = function render() {
    var _this2 = this,
        _baseSlideStyle;

    var panelHeight = this.state.panelHeight;

    var _props = this.props,
        Component = _props.component,
        style = _props.style,
        className = _props.className,
        panelStyle = _props.panelStyle,
        panelClassName = _props.panelClassName,
        panelComponent = _props.panelComponent,
        headerStyle = _props.headerStyle,
        headerClassName = _props.headerClassName,
        slideStyle = _props.slideStyle,
        slideHeightProp = _props.slideHeightProp,
        swipeableViewsStyle = _props.swipeableViewsStyle,
        swipeableViewsClassName = _props.swipeableViewsClassName,
        headerComponent = _props.headerComponent,
        headerZDepth = _props.headerZDepth,
        children = _props.children,
        colored = _props.colored,
        fixed = _props.fixed,
        labelAndIcon = _props.labelAndIcon,
        swipeableViewsProps = _props.swipeableViewsProps,
        themed = _props.themed,
        propToolbar = _props.toolbar,
        propActiveTabeIndex = _props.activeTabIndex,
        onTabChange = _props.onTabChange,
        defaultTabIndex = _props.defaultTabIndex,
        props = TabsContainer_objectWithoutProperties(_props, ['component', 'style', 'className', 'panelStyle', 'panelClassName', 'panelComponent', 'headerStyle', 'headerClassName', 'slideStyle', 'slideHeightProp', 'swipeableViewsStyle', 'swipeableViewsClassName', 'headerComponent', 'headerZDepth', 'children', 'colored', 'fixed', 'labelAndIcon', 'swipeableViewsProps', 'themed', 'toolbar', 'activeTabIndex', 'onTabChange', 'defaultTabIndex']);

    var toolbar = this.props.toolbar;


    var activeTabIndex = getField(this.props, this.state, 'activeTabIndex');

    var tabsEl = react["Children"].only(children);
    var tabId = tabsEl.props.tabId;
    var content = react["Children"].map(tabsEl.props.children, function (tab, index) {
      if (!tab) {
        return tab;
      }

      return react_default.a.createElement(
        Tabs_TabPanel,
        {
          id: tab.props.controlsId || tabId + '-panel-' + index,
          active: activeTabIndex === index,
          style: panelStyle,
          className: panelClassName,
          component: panelComponent,
          controlledById: tab.props.id || tabId + '-' + index
        },
        react_default.a.createElement(Helpers_ResizeObserver, { watchHeight: true, onResize: _this2._resizePanel }),
        tab.props.children
      );
    });

    var childrenProps = react["Children"].only(children).props;
    var tabs = Object(react["cloneElement"])(children, {
      colored: typeof childrenProps.colored !== 'undefined' ? childrenProps.colored : colored,
      onTabChange: this._handleTabChange,
      activeTabIndex: activeTabIndex
    });

    var prominentToolbar = false;
    if (toolbar) {
      var toolbarProps = react["Children"].only(toolbar).props;
      toolbar = Object(react["cloneElement"])(toolbar, {
        component: toolbarProps.component || 'div',
        colored: typeof toolbarProps.colored !== 'undefined' ? childrenProps.colored : colored
      });

      prominentToolbar = toolbarProps.prominent || toolbarProps.prominentTitle;
    }

    var header = void 0;
    if (fixed) {
      header = react_default.a.createElement(
        Papers_Paper,
        {
          style: headerStyle,
          className: classnames_default()('md-tabs-fixed-container', {
            'md-toolbar--themed': themed
          }, headerClassName),
          zDepth: headerZDepth,
          component: headerComponent
        },
        toolbar,
        tabs
      );
    }

    var baseSlideStyle = (_baseSlideStyle = {}, _baseSlideStyle[slideHeightProp] = panelHeight, _baseSlideStyle);

    return react_default.a.createElement(
      Component,
      TabsContainer_extends({
        style: style,
        className: classnames_default()('md-tabs-container', className)
      }, props, {
        ref: this._setContainer
      }),
      header,
      header ? null : toolbar,
      header ? null : tabs,
      react_default.a.createElement(
        lib_default.a,
        TabsContainer_extends({}, swipeableViewsProps, {
          style: swipeableViewsStyle,
          className: classnames_default()('md-tabs-content', {
            'md-tabs-content--offset': !toolbar && !labelAndIcon && fixed,
            'md-tabs-content--offset-icon': !toolbar && fixed && labelAndIcon,
            'md-tabs-content--offset-toolbar': toolbar && fixed && !prominentToolbar && !labelAndIcon,
            'md-tabs-content--offset-toolbar-prominent': toolbar && fixed && prominentToolbar && !labelAndIcon,
            'md-tabs-content--offset-toolbar-icon': fixed && toolbar && labelAndIcon && !prominentToolbar,
            'md-tabs-content--offset-toolbar-prominent-icon': fixed && toolbar && labelAndIcon && prominentToolbar
          }, swipeableViewsClassName),
          slideStyle: TabsContainer_extends({}, baseSlideStyle, typeof slideStyle === 'function' ? slideStyle(baseSlideStyle, panelHeight) : slideStyle),
          index: activeTabIndex,
          onChangeIndex: this._handleSwipeChange
        }),
        content
      )
    );
  };

  return TabsContainer;
}(react["PureComponent"]);

TabsContainer_TabsContainer.propTypes = {
  /**
   * An optional style to apply to the container.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the container.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to each `TabPanel` that gets generated. Each tab's children
   * will get wrapped in a `TabPanel` component.
   */
  panelStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to each each `TabPanel` that gets generated. Each tab's
   * children will get wrapped in a `TabPanel` component.
   */
  panelClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the header component when the tabs are fixed to the top of the page.
   * The optional toolbar and tabs get wrapped in a `Paper` component.
   */
  headerStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the header component when the tabs are fixed to the top of the page.
   * The optional toolbar and tabs get wrapped in a `Paper` component.
   */
  headerClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to the `SwipeableViews`.
   *
   * @see https://github.com/oliviertassinari/react-swipeable-views#user-content-swipeableviews-
   */
  swipeableViewsStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the `SwipeableViews` container.
   */
  swipeableViewsClassName: prop_types_default.a.string,

  /**
   * An optional style to apply to each slide component or a function that returns such style.
   *
   * Default style and height of slide component will be passed in the function.
   * The function should return a style that will be merged with default style, or `null`.
   *
   * @see https://github.com/oliviertassinari/react-swipeable-views#user-content-swipeableviews-
   */
  slideStyle: prop_types_default.a.oneOfType([prop_types_default.a.object, prop_types_default.a.func]),

  /**
   * The property that should be used to set height of a slide component.
   */
  slideHeightProp: prop_types_default.a.oneOf(['height', 'minHeight', 'maxHeight']),

  /**
   * This should be a `Tabs` component with children of `Tab`. This is used to figure out which
   * tab's content is currently visible.
   */
  children: prop_types_default.a.element.isRequired,

  /**
   * The component to render the container as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * The component to render each `TabPanel` as.
   */
  panelComponent: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),

  /**
   * An optional toolbar to render above the tabs.
   */
  toolbar: prop_types_default.a.element,

  /**
   * An optional active tab index to use. If this is defined, the component will be controlled
   * and require the `onTabChange` prop to be defined.
   */
  activeTabIndex: controlled(prop_types_default.a.number, 'onTabChange', 'defaultTabIndex'),

  /**
   * An optional function to call when a new tab is selected by swiping or clicking a tab. When
   * a new tab has been clicked, the callback will include the active tab index, the tab's `id`,
   * the tab's `controlsId`, the tab's `children`, and the click event.
   *
   * If the tab was changed by swiping, it will only contain the new active tab index.
   *
   * ```js
   * onTabChange(newActiveTabIndex, tabId, tabControlsId, tabChildren, event);
   * ```
   */
  onTabChange: prop_types_default.a.func,

  /**
   * The default tab index to use when the component is uncontrolled.
   */
  defaultTabIndex: prop_types_default.a.number.isRequired,

  /**
   * Boolean if the `toolbar` and `Tabs` should be cloned with `colored: true`.
   */
  colored: prop_types_default.a.bool,

  /**
   * Boolean if the `toolbar` should be applied with the theme color. This _really_ only
   * applies when you create a `fixed` tabs container.
   */
  themed: prop_types_default.a.bool,

  /**
   * Boolean if the tabs and the optional toolbar should be fixed to the top of the page.
   */
  fixed: prop_types_default.a.bool,

  /**
   * A boolean if a `fixed` `TabsContainer` has tabs with a label and an icon.
   */
  labelAndIcon: prop_types_default.a.bool,

  /**
   * An optional component to render the fixed tabs header as.
   */
  headerComponent: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),

  /**
   * The zDepth for the fixed tabs header.
   */
  headerZDepth: between(prop_types_default.a.number, 0, 5),

  /**
   * Any additional props to apply to the SwipeableViews component. View the
   * [SwipeableViews API](https://github.com/oliviertassinari/react-swipeable-views#api)
   * for valid attributes.
   *
   * You will not be able to set the `style`, `className`, `slideStyle`, `index`,
   * or `onChangeIndex` props for the SwipeableViews.
   *
   * The styling and classnames can be updated with the other TabsContainer props.
   */
  swipeableViewsProps: prop_types_default.a.object
};
TabsContainer_TabsContainer.defaultProps = {
  component: 'section',
  defaultTabIndex: 0,
  headerZDepth: 1,
  slideHeightProp: 'height'
};
/* harmony default export */ var Tabs_TabsContainer = (TabsContainer_TabsContainer);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tabs/TabIndicator.js
function TabIndicator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TabIndicator_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TabIndicator_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var TabIndicator_TabIndicator = function (_PureComponent) {
  TabIndicator_inherits(TabIndicator, _PureComponent);

  function TabIndicator() {
    TabIndicator_classCallCheck(this, TabIndicator);

    return TabIndicator_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  TabIndicator.prototype.render = function render() {
    var visible = this.props.visible;

    return react_default.a.createElement(
      react_motion["Motion"],
      {
        style: {
          x: Object(react_motion["spring"])(this.props.offset),
          width: Object(react_motion["spring"])(this.props.width),
          height: Object(react_motion["spring"])(visible ? 2 : 0)
        }
      },
      function (_ref) {
        var x = _ref.x,
            height = _ref.height,
            width = _ref.width;

        var transform = 'translate3d(' + x + 'px, 0, 0)';
        return react_default.a.createElement('span', {
          style: {
            height: height,
            width: width,
            WebkitTransform: transform,
            MozTransform: transform,
            msTransform: transform,
            transform: transform
          },
          className: 'md-tab-indicator'
        });
      }
    );
  };

  return TabIndicator;
}(react["PureComponent"]);

TabIndicator_TabIndicator.propTypes = {
  offset: prop_types_default.a.number.isRequired,
  width: prop_types_default.a.number.isRequired,
  visible: prop_types_default.a.bool
};
/* harmony default export */ var Tabs_TabIndicator = (TabIndicator_TabIndicator);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tabs/MenuTab.js
var MenuTab_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function MenuTab_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function MenuTab_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MenuTab_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MenuTab_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }










/**
 * The `MenuTab` component is used when there are too many desktop tabs
 * to be displayed without any overflow. If the `Tabs` component is used,
 * this will automatically be included when the `menuOverflow` prop is true.
 */

var MenuTab_MenuTab = function (_PureComponent) {
  MenuTab_inherits(MenuTab, _PureComponent);

  function MenuTab() {
    var _temp, _this, _ret;

    MenuTab_classCallCheck(this, MenuTab);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = MenuTab_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { visible: false }, _this._toggleVisible = function (e) {
      if (_this.props.onClick) {
        _this.props.onClick(e);
      }

      _this.setState({ visible: !_this.state.visible });
    }, _this._handleClose = function () {
      _this.setState({ visible: false });
    }, _temp), MenuTab_possibleConstructorReturn(_this, _ret);
  }

  MenuTab.prototype.render = function render() {
    var _props = this.props,
        id = _props.id,
        style = _props.style,
        className = _props.className,
        tabStyle = _props.tabStyle,
        tabClassName = _props.tabClassName,
        tabs = _props.tabs,
        label = _props.label,
        activeTabIndex = _props.activeTabIndex,
        overflowAtIndex = _props.overflowAtIndex,
        props = MenuTab_objectWithoutProperties(_props, ['id', 'style', 'className', 'tabStyle', 'tabClassName', 'tabs', 'label', 'activeTabIndex', 'overflowAtIndex']);

    var active = activeTabIndex >= overflowAtIndex;

    var tab = react_default.a.createElement(
      AccessibleFakeInkedButton,
      MenuTab_extends({}, props, {
        onClick: this._toggleVisible,
        style: tabStyle,
        className: classnames_default()('md-tab md-tab--menu', tabClassName)
      }),
      label
    );

    return react_default.a.createElement(
      Menus_Menu,
      {
        id: id,
        style: style,
        className: classnames_default()('md-menu--tab', {
          'md-tab--active': active,
          'md-tab--inactive': !active
        }, className),
        toggle: tab,
        visible: this.state.visible,
        onClose: this._handleClose
      },
      tabs.map(mapToListParts)
    );
  };

  return MenuTab;
}(react["PureComponent"]);

MenuTab_MenuTab.propTypes = {
  /**
   * An id to give the tab's menu.
   */
  id: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * The current active tab index. This is used to determine which list item
   * is active in the menu, and if the styles for an active tab should be applied
   * to the menu.
   */
  activeTabIndex: prop_types_default.a.number.isRequired,

  /**
   * An tab index that caused the overflow to happen.
   */
  overflowAtIndex: prop_types_default.a.number.isRequired,

  /**
   * A list of tabs that should be rendered in the menu once opened. This can either
   * be:
   *
   * - a `ListItem`, `Divider`, or `Subheader` component
   * - a string to use as the `primaryText` for a list item
   * - an object that defines props to generate a `ListItem`, `Divider`, or `Subheader` component
   */
  tabs: prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.string, prop_types_default.a.shape({
    divider: prop_types_default.a.bool,
    subheader: prop_types_default.a.bool,
    primaryText: prop_types_default.a.node
  })])).isRequired,

  /**
   * An optional style to apply to the menu.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply to the menu.
   */
  className: prop_types_default.a.string,

  /**
   * An optional style to apply to the tab in the menu.
   */
  tabStyle: prop_types_default.a.object,

  /**
   * An optional className to apply to the tab in the menu.
   */
  tabClassName: prop_types_default.a.string,

  /**
   * An optional function to call when the tab is clicked.
   */
  onClick: prop_types_default.a.func,

  /**
   * The label to display in the tab. This should normally be some text with
   * a drop down arrow next to it.
   */
  label: prop_types_default.a.node.isRequired
};
/* harmony default export */ var Tabs_MenuTab = (MenuTab_MenuTab);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tabs/TabOverflowButton.js
var TabOverflowButton_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function TabOverflowButton_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TabOverflowButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TabOverflowButton_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TabOverflowButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var TabOverflowButton_TabOverflowButton = function (_PureComponent) {
  TabOverflowButton_inherits(TabOverflowButton, _PureComponent);

  function TabOverflowButton() {
    TabOverflowButton_classCallCheck(this, TabOverflowButton);

    return TabOverflowButton_possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  TabOverflowButton.prototype.render = function render() {
    var _props = this.props,
        left = _props.left,
        icon = _props.icon,
        props = TabOverflowButton_objectWithoutProperties(_props, ['left', 'icon']);

    return react_default.a.createElement(Buttons_Button, TabOverflowButton_extends({}, props, {
      icon: true,
      className: classnames_default()('md-icon--inherit md-btn--tab-overflow', {
        'md-btn--tab-overflow-left': left,
        'md-btn--tab-overflow-right': !left,
        'md-btn--tab-overflow-icon': icon
      })
    }));
  };

  return TabOverflowButton;
}(react["PureComponent"]);

TabOverflowButton_TabOverflowButton.propTypes = {
  left: prop_types_default.a.bool,
  icon: prop_types_default.a.bool
};
/* harmony default export */ var Tabs_TabOverflowButton = (TabOverflowButton_TabOverflowButton);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tabs/Tabs.js
var Tabs_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Tabs_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Tabs_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tabs_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Tabs_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

















var MOBILE_PADDING = 72;
var DESKTOP_PADDING = 80;
var MOBILE_TAB_MIN_WIDTH = 72;
var DESKTOP_TAB_MIN_WIDTH = 160;

/**
 * The `Tabs` component is used to manage the state of which tab is currently active.
 */

var Tabs_Tabs = function (_PureComponent) {
  Tabs_inherits(Tabs, _PureComponent);

  function Tabs(props) {
    Tabs_classCallCheck(this, Tabs);

    var _this = Tabs_possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setContainer = function (container) {
      _this._container = container;
      _this._positionElements(_this._container !== null);
    };

    _this._positionElements = function (initialRender) {
      initialRender = typeof initialRender === 'boolean' && initialRender;
      if (!_this._container) {
        return;
      }

      var _this$props = _this.props,
          centered = _this$props.centered,
          overflowMenu = _this$props.overflowMenu;
      var mobile = _this.props.mobile;


      var paddingLeft = void 0;
      if (!centered && _this._shouldAlign(_this.props)) {
        paddingLeft = _this._calcPaddingLeft(_this._container, mobile);
      }

      var overflowAtIndex = void 0;
      if (!mobile) {
        overflowAtIndex = _this._calcOverflowIndex(_this._container, paddingLeft, overflowMenu);
      }

      var indicatorPosition = _this._calcIndicatorPosition(_this._container, initialRender ? paddingLeft : 0);

      _this.setState(Tabs_extends({ mobile: mobile, paddingLeft: paddingLeft, overflowAtIndex: overflowAtIndex }, indicatorPosition), _this._scrollActiveIntoView);
    };

    _this._scrollActiveIntoView = function () {
      if (!_this._container || !_this.state.mobile) {
        return;
      }

      var active = _this._container.querySelector('.md-tab--active');
      if (!active) {
        return;
      }

      var allTabs = Array.prototype.slice.call(_this._container.querySelectorAll('.md-tab'));
      if (allTabs[0] === active) {
        _this._container.scrollLeft = 0;
        return;
      }

      var _this$_container = _this._container,
          containerWidth = _this$_container.offsetWidth,
          scrollLeft = _this$_container.scrollLeft;
      var activeWidth = active.offsetWidth,
          activeOffset = active.offsetLeft;

      var inFullViewLeft = activeOffset - scrollLeft >= 0;
      var inFullViewRight = activeOffset + activeWidth - (containerWidth + scrollLeft) <= 0;
      if (inFullViewLeft && inFullViewRight) {
        return;
      }

      var offset = 0;
      allTabs.some(function (tab, i) {
        if (i < _this.props.activeTabIndex) {
          offset += tab.offsetWidth;
        }

        return i < _this.state.activeTabIndex;
      });

      _this._container.scrollLeft = offset;
    };

    _this._handleTabChange = function (index, tabId, tabControlsId, tabChildren, event) {
      if (_this.props.onTabChange) {
        _this.props.onTabChange(index, tabId, tabControlsId, tabChildren, event);
      }

      if (typeof _this.props.activeTabIndex === 'undefined') {
        _this.setState(Tabs_extends({
          activeTabIndex: index
        }, _this._calcIndicatorPosition(_this._container, 0, index, _this.state.overflowAtIndex)));
      }
    };

    _this._mapToOverflowTabProps = function (tab, i) {
      var index = i + _this.state.overflowAtIndex;
      var active = getField(_this.props, _this.state, 'activeTabIndex') === index;
      var tabEl = react["Children"].only(tab);
      var handleTabChange = _this._handleTabChange;

      return {
        active: active,
        primaryText: tabEl.props.label,
        onClick: function handleClick(event) {
          var _tabEl$props = tabEl.props,
              onClick = _tabEl$props.onClick,
              id = _tabEl$props.id,
              controlsId = _tabEl$props.controlsId,
              children = _tabEl$props.children;

          if (onClick) {
            onClick(index, event);
          }

          handleTabChange(index, id, controlsId, children, event);
        }
      };
    };

    _this._nextIndexes = function (increment) {
      var _this$state = _this.state,
          overflowIndex = _this$state.overflowIndex,
          overflowAtIndex = _this$state.overflowAtIndex;

      var visibleAmt = (overflowAtIndex - overflowIndex) * (increment ? 1 : -1);

      _this.setState({
        overflowIndex: overflowIndex + visibleAmt,
        overflowAtIndex: overflowAtIndex + visibleAmt
      });
    };

    _this._showNextTabs = function () {
      _this._nextIndexes(true);
    };

    _this._showPreviousTabs = function () {
      _this._nextIndexes(false);
    };

    var defaultTabIndex = typeof props.activeTabIndex === 'undefined' ? props.defaultTabIndex : props.activeTabIndex;
    var indicatorWidth = props.mobile ? MOBILE_TAB_MIN_WIDTH : DESKTOP_TAB_MIN_WIDTH;
    _this.state = {
      indicatorWidth: indicatorWidth,
      indicatorOffset: indicatorWidth * defaultTabIndex,
      indicatorVisible: true,
      overflowIndex: 0
    };

    if (typeof props.activeTabIndex === 'undefined') {
      _this.state.activeTabIndex = defaultTabIndex;
    }
    return _this;
  }

  Tabs.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.activeTabIndex !== nextProps.activeTabIndex) {
      this.setState(Tabs_extends({}, this._calcIndicatorPosition(this._container, 0, nextProps.activeTabIndex, this.state.overflowAtIndex)), this._scrollActiveIntoView);
    } else if (!this._shouldAlign(nextProps) && this._shouldAlign(this.props)) {
      this.setState({ paddingLeft: null });
    }
  };

  Tabs.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (this._shouldAlign(this.props) && this.state.overflowAtIndex !== prevState.overflowAtIndex) {
      var paddingLeft = this._calcPaddingLeft(this._container, this.state.mobile);
      // Have to wait for the overflow menus to appear, then wop
      /* eslint-disable react/no-did-update-set-state */
      this.setState({ paddingLeft: paddingLeft });
    } else {
      var labels = react["Children"].map(react["Children"].toArray(this.props.children), function (_ref) {
        var label = _ref.props.label;
        return label;
      });
      var prevLabels = react["Children"].map(react["Children"].toArray(prevProps.children), function (_ref2) {
        var label = _ref2.props.label;
        return label;
      });
      if (labels.length !== prevLabels.length || labels.filter(function (_, i) {
        return labels[i] !== prevLabels[i];
      }).length) {
        this.setState(Tabs_extends({}, this._calcIndicatorPosition(this._container, 0, this.props.activeTabIndex, this.state.overflowAtIndex)), this._scrollActiveIntoView);
      }
    }
  };

  Tabs.prototype._shouldAlign = function _shouldAlign(props) {
    return typeof props.alignToKeyline === 'boolean' ? props.alignToKeyline : react["Children"].toArray(props.children).filter(function (child) {
      return !!child;
    }).length > 3;
  };

  Tabs.prototype._calcPaddingLeft = function _calcPaddingLeft(container, mobile) {
    var mediaPadding = mobile ? MOBILE_PADDING : DESKTOP_PADDING;
    var tab = container.querySelector('.md-tab');

    var _tab$querySelector = tab.querySelector('.md-tab-label'),
        labelOffset = _tab$querySelector.offsetLeft;

    return mediaPadding - labelOffset;
  };

  Tabs.prototype._calcOverflowIndex = function _calcOverflowIndex(container) {
    var paddingLeft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var menu = arguments[2];

    var containerWidth = container.offsetWidth;
    var overflowIndex = 0;
    if (containerWidth < container.scrollWidth) {
      var tabs = Array.prototype.slice.call(container.querySelectorAll('.md-tab'));
      var totalWidth = 0;
      tabs.some(function (tab, i) {
        overflowIndex = i;
        totalWidth += tab.offsetWidth;

        return totalWidth > containerWidth;
      });
    }

    return Math.max(0, overflowIndex - (menu ? 1 : 0));
  };

  Tabs.prototype._calcIndicatorPosition = function _calcIndicatorPosition(container) {
    var paddingLeft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var activeTabIndex = arguments[2];
    var overflowAtIndex = arguments[3];

    var activeItem = void 0;
    if (typeof activeTabIndex === 'number') {
      if (overflowAtIndex > 0 && activeTabIndex >= overflowAtIndex) {
        activeItem = container.querySelector('.md-menu--tab');
      } else {
        activeItem = container.querySelectorAll('.md-tab')[activeTabIndex];
      }
    } else {
      activeItem = container.querySelector('.md-tab--active');
    }

    if (!activeItem) {
      return { indicatorVisible: false };
    }

    var _activeItem = activeItem,
        indicatorWidth = _activeItem.offsetWidth,
        indicatorOffset = _activeItem.offsetLeft;

    return {
      indicatorWidth: indicatorWidth,
      indicatorOffset: indicatorOffset + paddingLeft,
      indicatorVisible: !overflowAtIndex || overflowAtIndex > activeTabIndex
    };
  };

  Tabs.prototype.render = function render() {
    var _this2 = this;

    var _state = this.state,
        indicatorOffset = _state.indicatorOffset,
        indicatorWidth = _state.indicatorWidth,
        indicatorVisible = _state.indicatorVisible,
        overflowIndex = _state.overflowIndex,
        overflowAtIndex = _state.overflowAtIndex,
        paddingLeft = _state.paddingLeft;

    var _props = this.props,
        Component = _props.component,
        style = _props.style,
        className = _props.className,
        activeTabClassName = _props.activeTabClassName,
        inactiveTabClassName = _props.inactiveTabClassName,
        colored = _props.colored,
        centered = _props.centered,
        tabId = _props.tabId,
        overflowMenu = _props.overflowMenu,
        overflowMenuLabel = _props.overflowMenuLabel,
        nextIcon = _props.nextIcon,
        previousIcon = _props.previousIcon,
        overflowMenuIcon = _props.overflowMenuIcon,
        overflowMenuIconChildren = _props.overflowMenuIconChildren,
        overflowMenuIconClassName = _props.overflowMenuIconClassName,
        nextIconChildren = _props.nextIconChildren,
        nextIconClassName = _props.nextIconClassName,
        previousIconChildren = _props.previousIconChildren,
        previousIconClassName = _props.previousIconClassName,
        propActiveIndex = _props.activeTabIndex,
        defaultTabIndex = _props.defaultTabIndex,
        onTabChange = _props.onTabChange,
        alignToKeyline = _props.alignToKeyline,
        mobile = _props.mobile,
        defaultMedia = _props.defaultMedia,
        desktopMinWidth = _props.desktopMinWidth,
        props = Tabs_objectWithoutProperties(_props, ['component', 'style', 'className', 'activeTabClassName', 'inactiveTabClassName', 'colored', 'centered', 'tabId', 'overflowMenu', 'overflowMenuLabel', 'nextIcon', 'previousIcon', 'overflowMenuIcon', 'overflowMenuIconChildren', 'overflowMenuIconClassName', 'nextIconChildren', 'nextIconClassName', 'previousIconChildren', 'previousIconClassName', 'activeTabIndex', 'defaultTabIndex', 'onTabChange', 'alignToKeyline', 'mobile', 'defaultMedia', 'desktopMinWidth']);

    var activeTabIndex = getField(this.props, this.state, 'activeTabIndex');

    var icon = false;
    var children = react["Children"].map(react["Children"].toArray(this.props.children), function (tab, index) {
      var handleOnClick = function handleOnClick(tabIndex, id, tabControlsId, tabChildren, event) {
        if (tab.props.onClick) {
          tab.props.onClick(tabId, id, tabControlsId, tabChildren, event);
        }

        _this2._handleTabChange(tabIndex, id, tabControlsId, tabChildren, event);
      };

      if (tab.props.icon) {
        icon = true;
      }

      return Object(react["cloneElement"])(tab, {
        index: index,
        activeClassName: activeTabClassName,
        inactiveClassName: inactiveTabClassName,
        id: tab.props.id || tabId + '-' + index,
        controlsId: tab.props.controlsId || tabId + '-panel-' + index,
        active: index === activeTabIndex,
        onClick: handleOnClick
      });
    });

    var overflow = void 0;
    var nextControl = void 0;
    var previousControl = void 0;
    if (overflowAtIndex) {
      var length = children.length;
      if (overflowMenu) {
        overflow = react_default.a.createElement(Tabs_MenuTab, {
          id: tabId + '-overflow-menu',
          activeTabIndex: activeTabIndex,
          overflowAtIndex: overflowAtIndex,
          label: react_default.a.createElement(
            Helpers_IconSeparator,
            { label: overflowMenuLabel },
            getDeprecatedIcon(overflowMenuIconClassName, overflowMenuIconChildren, overflowMenuIcon)
          ),
          tabs: children.slice(overflowAtIndex, children.length).map(this._mapToOverflowTabProps)
        });
      }

      children = children.slice(overflowIndex, overflowAtIndex);

      if (!overflowMenu && overflowIndex > 0) {
        previousControl = react_default.a.createElement(Tabs_TabOverflowButton, {
          left: true,
          icon: icon,
          iconEl: getDeprecatedIcon(previousIconClassName, previousIconChildren, previousIcon),
          onClick: this._showPreviousTabs
        });
      }

      if (!overflowMenu && length > 3 && overflowAtIndex + overflowIndex <= length) {
        nextControl = react_default.a.createElement(Tabs_TabOverflowButton, {
          icon: icon,
          onClick: this._showNextTabs,
          iconEl: getDeprecatedIcon(nextIconClassName, nextIconChildren, nextIcon)
        });
      }
    }

    return react_default.a.createElement(
      Component,
      Tabs_extends({}, props, {
        style: Tabs_extends({}, style, { paddingLeft: paddingLeft }),
        className: classnames_default()('md-tabs', {
          'md-tabs--pagination': overflowAtIndex && !overflowMenu,
          'md-tabs--centered': centered,
          'md-background--primary': colored
        }, className),
        role: 'tablist'
      }),
      react_default.a.createElement(Helpers_ResizeObserver, { watchWidth: true, watchHeight: true, onResize: this._positionElements, elRef: this._setContainer }),
      previousControl,
      children,
      nextControl,
      overflow,
      react_default.a.createElement(Tabs_TabIndicator, { offset: indicatorOffset, width: indicatorWidth, visible: indicatorVisible })
    );
  };

  return Tabs;
}(react["PureComponent"]);

Tabs_Tabs.propTypes = {
  /**
   * A base id to use for each `Tab`. When the child tabs are created, they are cloned
   * with some additional accessibility props. Each tab will get a prop with this and the
   * current index of the tab.
   */
  tabId: isRequiredForA11y_default()(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),

  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The className to use when a tab is currently active. The default className does not
   * actually apply any styles.
   *
   * If this prop is set, it will override any `activeClassName` props applied to the child
   * `Tab`s. Either set a custom `activeClassName` on each `Tab`, or use this prop to apply
   * the same `activeClassName` to each `Tab`.
   *
   * @see {@link Tabs/Tab#activeClassName}
   */
  activeTabClassName: prop_types_default.a.string,

  /**
   * The className to use when the tab is not active and not selected. By default,
   * this will set inactive tabs' color to `$md-white-base`. This works great
   * if the tabs are placed on a colored toolbar but fails when the tabs are not colored
   * or on a white background. In these cases, it is recommended to change this value
   * to `md-text--secondary` or some other class name.
   *
   * If this prop is set, it will override any `inactiveClassName` props applied to the child
   * `Tab`s. Either set a custom `inactiveClassName` on each `Tab`, or use this prop to apply
   * the same `inactiveClassName` to each `Tab`.
   *
   * @see {@link Tabs/Tab#inactiveClassName}
   */
  inactiveTabClassName: prop_types_default.a.string,

  /**
   * The component to render the tabs in.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * This should either be a single `Tab` component or a list of `Tab` components. Unfortunately,
   * the child *must* be exactly a `Tab` component because this is unable to extract the correct
   * `label` and `children` from a custom `Tab` component.
   */
  children: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.arrayOf(prop_types_default.a.element)]).isRequired,

  /**
   * Boolean if the tabs should be centered instead of aligned to the keyline. The tabs will
   * only be aligned to the keyline when there are more than 3 tabs and the `alignToKeyline`
   * prop is `false`.
   */
  centered: prop_types_default.a.bool,

  /**
   * Boolean if the tabs should align to a toolbar's title keyline. If this is undefined,
   * the tabs will try to align to the keyline when there are more than 3 tabs.
   */
  alignToKeyline: prop_types_default.a.bool,

  /**
   * Boolean if the tabs should be colored with the primary color. If this is false or undefined,
   * the tabs will be colored for the light or dark theme.
   */
  colored: prop_types_default.a.bool,

  /**
   * A boolean if the overflow tabs on desktop displays should appear in a menu. If this is false,
   * the additional tabs will be available by using pagination buttons.
   */
  overflowMenu: prop_types_default.a.bool,

  /**
   * An optional function to call when the active tab is changed. The callback will include
   * the new active tab index and a click event.
   *
   * ```js
   * onTabChange(newTabIndex, event);
   * ```
   */
  onTabChange: prop_types_default.a.func,

  /**
   * An optional active tab index to use. If this is defined, it will make the component controlled
   * and require the `onTabChange` prop to be defined.
   */
  activeTabIndex: controlled(prop_types_default.a.number, 'onTabChange', 'defaultTabIndex'),

  /**
   * The default tab index to use when the component is uncontrolled.
   */
  defaultTabIndex: prop_types_default.a.number.isRequired,

  /**
   * When the `overflowMenu` prop is false, this will be used to render the "next slice of tabs"
   * when there are too many tabs to display at once on desktop screens.
   */
  nextIcon: prop_types_default.a.element,

  /**
   * When the `overflowMenu` prop is false, this will be used to render the "previous slice of tabs"
   * when there are too many tabs to display at once on desktop screens.
   */
  previousIcon: prop_types_default.a.element,

  /**
   * When the `overflowMenu` prop is true, this will be used to render the `MenuTab` overflow menu.
   * This will be to render the icon to the right of the label.
   */
  overflowMenuIcon: prop_types_default.a.element,

  /**
   * When the `overflowMenu` prop is true, this will be used to render the `MenuTab` overflow menu.
   * This will be the text that displays as a tab.
   */
  overflowMenuLabel: prop_types_default.a.node.isRequired,

  /**
   * Boolean if the tabs are currently rendered on a mobile or tablet device. This is used to calculate
   * overflow/padding on the tabs.
   */
  mobile: prop_types_default.a.bool,
  defaultMedia: deprecated_default()(prop_types_default.a.oneOf(['mobile', 'tablet', 'desktop']), 'Use `mobile` instead'),
  desktopMinWidth: deprecated_default()(prop_types_default.a.number, 'Use `mobile` instead'),
  nextIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `nextIcon` prop instead'),
  nextIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `nextIcon` prop instead'),
  previousIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `previousIcon` prop instead'),
  previousIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `previousIcon` prop instead'),
  overflowMenuIconChildren: deprecated_default()(prop_types_default.a.node, 'Use the `overflowMenuIcon` prop instead'),
  overflowMenuIconClassName: deprecated_default()(prop_types_default.a.string, 'Use the `overflowMenuIcon` prop instead')
};
Tabs_Tabs.defaultProps = {
  component: 'ul',
  defaultTabIndex: 0,
  nextIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'keyboard_arrow_right'
  ),
  previousIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'keyboard_arrow_left'
  ),
  overflowMenuLabel: 'More',
  overflowMenuIcon: react_default.a.createElement(
    FontIcons_FontIcon,
    null,
    'arrow_drop_down'
  )
};
/* harmony default export */ var es_Tabs_Tabs = (Tabs_Tabs);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tabs/Tab.js
var Tab_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Tab_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Tab_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tab_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Tab_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








/**
 * The `Tab` component is used for rendering a single tab in the `Tabs` component.
 * It can optionally have either a `label`, an `icon` or both.
 */

var Tab_Tab = function (_PureComponent) {
  Tab_inherits(Tab, _PureComponent);

  function Tab() {
    var _temp, _this, _ret;

    Tab_classCallCheck(this, Tab);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Tab_possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._handleClick = function (e) {
      if (_this.props.onClick) {
        _this.props.onClick(_this.props.index, _this.props.id, _this.props.controlsId, _this.props.children, e);
      }
    }, _temp), Tab_possibleConstructorReturn(_this, _ret);
  }

  Tab.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        id = _props.id,
        controlsId = _props.controlsId,
        className = _props.className,
        activeClassName = _props.activeClassName,
        inactiveClassName = _props.inactiveClassName,
        active = _props.active,
        propIcon = _props.icon,
        propLabel = _props.label,
        index = _props.index,
        props = Tab_objectWithoutProperties(_props, ['id', 'controlsId', 'className', 'activeClassName', 'inactiveClassName', 'active', 'icon', 'label', 'index']);

    var _props2 = this.props,
        icon = _props2.icon,
        label = _props2.label;

    if (icon) {
      var iconEl = react["Children"].only(icon);
      icon = Object(react["cloneElement"])(icon, {
        className: classnames_default()('md-icon--tab', iconEl.props.className)
      });
    }

    if (Object(react["isValidElement"])(label)) {
      var labelEl = react["Children"].only(label);
      label = Object(react["cloneElement"])(label, {
        className: classnames_default()('md-tab-label', labelEl.props.className)
      });
    } else {
      label = react_default.a.createElement(
        'div',
        { className: 'md-tab-label' },
        label
      );
    }
    return react_default.a.createElement(
      AccessibleFakeInkedButton,
      Tab_extends({}, props, {
        id: id,
        role: 'tab',
        onClick: this._handleClick,
        className: classnames_default()('md-tab', (_cn = {
          'md-tab--icon': label && icon
        }, _cn[activeClassName] = activeClassName && active, _cn[inactiveClassName] = inactiveClassName && !active, _cn), className),
        'aria-controls': controlsId,
        'aria-selected': active
      }),
      icon,
      label
    );
  };

  return Tab;
}(react["PureComponent"]);

Tab_Tab.propTypes = {
  /**
   * An id for the tab. This is required for a11y. If you use the `Tabs` component, this
   * will automatically be generated for you and injected into this component.
   */
  id: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An id for a `TabPanel` that holds the children from this tab. This is required for a11y.
   * If you use the `Tabs` component, this will automatically be generated for you and injected
   * into this component.
   */
  controlsId: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),

  /**
   * An optional style to apply.
   */
  style: prop_types_default.a.object,

  /**
   * An optional className to apply.
   */
  className: prop_types_default.a.string,

  /**
   * The className to use when the tab is currently active. The default className does
   * not actually apply any styles.
   *
   * @see {@link Tabs/Tabs#activeTabClassName}
   */
  activeClassName: prop_types_default.a.string,

  /**
   * The className to use when the tab is not active. By default, this will set inactive
   * tabs' color to `$md-white-base`. This works great if the tabs are placed on a
   * colored toolbar but fails when the tabs are not colored or on a white background.
   * In these cases, it is recommended to change this value to `md-text--secondary`
   * or some other class name.
   *
   * @see {@link Tabs/Tabs#inactiveTabClassName}
   */
  inactiveClassName: prop_types_default.a.string,

  /**
   * The component to render as.
   */
  component: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired,

  /**
   * Any children to display once the tab has been selected.
   */
  children: prop_types_default.a.node,

  /**
   * An optional icon to display in the tab. This can either be used alone, or it
   * will be placed above the `label` if both are given.
   */
  icon: prop_types_default.a.element,

  /**
   * An optional label to display in the tab. This can either be used alone, or it
   * will be placed below the `icon` if both are given.
   */
  label: oneRequired(prop_types_default.a.node, 'icon'),

  /**
   * An optional function to call when the tab is clicked. The callback includes this tab's index,
   * id, controlsId, children, and finally click event. All the additional parameters are included
   * if you are not using the `TabsContainer` component. The `id` and `controlsId` are mainly passed
   * for accessibility.
   *
   * ```js
   * onClick(index, id, controlsId, children, event);
   * ```
   */
  onClick: prop_types_default.a.func,

  /**
   * Boolean if the tab is currently active. If you use the `Tabs` component, this is automatically
   * injected.
   */
  active: prop_types_default.a.bool,

  /**
   * Tab's index. If you use the `Tabs` component, this is automatically injected.
   */
  index: prop_types_default.a.number
};
Tab_Tab.defaultProps = {
  component: 'li',
  activeClassName: 'md-tab--active',
  inactiveClassName: 'md-tab--inactive'
};
/* harmony default export */ var Tabs_Tab = (Tab_Tab);
// CONCATENATED MODULE: ../node_modules/react-md/es/Tooltips/Tooltipped.js
var Tooltipped_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Tooltipped_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * Adds a tooltip for a component/element given as the only child.
 *
 * The component should render its children, or the tooltip will not be shown.
 * Also the component should be positioned by `className` or `style`
 * (CSS property `position` should have value `relative`, `absolute` or `fixed`),
 * or the tooltip can appear incorrectly.
 * Use `setPosition={true}` to automatically add `position: 'relative'` to the `style` of the wrapped component.
 *
 * Besides of `children` and `setPosition` all props set for `Tooltipped` component are passed through
 * to `TooltipContainer` that is added as a child of the wrapped component and controls the tooltip.
 *
 * ```js
 * <Tooltipped
 *   label="Tooltip for text"
 *   position="left"
 *   delay={1000}
 * >
 *   <span style={{position: 'absolute', top: '10px', left: '70%'}}>
 *     Some text
 *     <div>Another line of text</div>
 *   </span>
 * </Tooltipped>
 * ```
 *
 * ```js
 * <Tooltipped
 *   setPosition={true}
 *   label="Avatar's tooltip"
 *   position="top"
 * >
 *   <span style={{marginLeft: '30px'}}>
 *       <Avatar random>T</Avatar>
 *   </span>
 * </Tooltipped>
 * ```
 */
function Tooltipped(_ref) {
  var children = _ref.children,
      setPosition = _ref.setPosition,
      props = Tooltipped_objectWithoutProperties(_ref, ['children', 'setPosition']);

  var target = react_default.a.Children.only(children);
  var targetProps = target.props;

  if (props.label) {
    var clonedProps = targetProps;
    if (setPosition) {
      clonedProps = Tooltipped_extends({}, clonedProps, {
        style: Tooltipped_extends({}, clonedProps.style, { position: 'relative' })
      });
    }

    target = react_default.a.cloneElement(target, clonedProps, [targetProps.children, react_default.a.createElement(Tooltips_TooltipContainer, Tooltipped_extends({ key: 'tooltipContainer' }, props))]);
  }

  return target;
}

Tooltipped.displayName = 'Tooltipped';

Tooltipped.propTypes = {
  /**
   * A component/element the tooltip should be linked to.
   */
  children: prop_types_default.a.element.isRequired,
  /**
   * Tooltip's content.
   */
  label: prop_types_default.a.node,
  /**
   * Whether `position: relative` should be added to the `style` property of the wrapped component.
   */
  setPosition: prop_types_default.a.bool
};
// CONCATENATED MODULE: ../node_modules/react-md/es/Version.js
/* harmony default export */ var Version = ('1.6.1');
// CONCATENATED MODULE: ../node_modules/react-md/es/index.js
/* concated harmony reexport Autocomplete */__webpack_require__.d(__webpack_exports__, "Autocomplete", function() { return Autocompletes_Autocomplete; });
/* concated harmony reexport Avatar */__webpack_require__.d(__webpack_exports__, "Avatar", function() { return Avatars_Avatar; });
/* concated harmony reexport Badge */__webpack_require__.d(__webpack_exports__, "Badge", function() { return Badges_Badge; });
/* concated harmony reexport BottomNavigation */__webpack_require__.d(__webpack_exports__, "BottomNavigation", function() { return BottomNavigations_BottomNavigation; });
/* concated harmony reexport Button */__webpack_require__.d(__webpack_exports__, "Button", function() { return Buttons_Button; });
/* concated harmony reexport Card */__webpack_require__.d(__webpack_exports__, "Card", function() { return Cards_Card; });
/* concated harmony reexport CardActions */__webpack_require__.d(__webpack_exports__, "CardActions", function() { return Cards_CardActions; });
/* concated harmony reexport CardTitle */__webpack_require__.d(__webpack_exports__, "CardTitle", function() { return Cards_CardTitle; });
/* concated harmony reexport CardText */__webpack_require__.d(__webpack_exports__, "CardText", function() { return Cards_CardText; });
/* concated harmony reexport Chip */__webpack_require__.d(__webpack_exports__, "Chip", function() { return Chips_Chip; });
/* concated harmony reexport DataTable */__webpack_require__.d(__webpack_exports__, "DataTable", function() { return DataTables_DataTable; });
/* concated harmony reexport TableHeader */__webpack_require__.d(__webpack_exports__, "TableHeader", function() { return DataTables_TableHeader; });
/* concated harmony reexport TableBody */__webpack_require__.d(__webpack_exports__, "TableBody", function() { return DataTables_TableBody; });
/* concated harmony reexport TableFooter */__webpack_require__.d(__webpack_exports__, "TableFooter", function() { return DataTables_TableFooter; });
/* concated harmony reexport TableRow */__webpack_require__.d(__webpack_exports__, "TableRow", function() { return DataTables_TableRow; });
/* concated harmony reexport TableColumn */__webpack_require__.d(__webpack_exports__, "TableColumn", function() { return DataTables_TableColumn; });
/* concated harmony reexport TablePagination */__webpack_require__.d(__webpack_exports__, "TablePagination", function() { return DataTables_TablePagination; });
/* concated harmony reexport EditDialogColumn */__webpack_require__.d(__webpack_exports__, "EditDialogColumn", function() { return DataTables_EditDialogColumn; });
/* concated harmony reexport SelectFieldColumn */__webpack_require__.d(__webpack_exports__, "SelectFieldColumn", function() { return DataTables_SelectFieldColumn; });
/* concated harmony reexport MenuButtonColumn */__webpack_require__.d(__webpack_exports__, "MenuButtonColumn", function() { return DataTables_MenuButtonColumn; });
/* concated harmony reexport DropdownMenuColumn */__webpack_require__.d(__webpack_exports__, "DropdownMenuColumn", function() { return DataTables_DropdownMenuColumn; });
/* concated harmony reexport TableCardHeader */__webpack_require__.d(__webpack_exports__, "TableCardHeader", function() { return DataTables_TableCardHeader; });
/* concated harmony reexport DialogContainer */__webpack_require__.d(__webpack_exports__, "DialogContainer", function() { return Dialogs_DialogContainer; });
/* concated harmony reexport Dialog */__webpack_require__.d(__webpack_exports__, "Dialog", function() { return Dialogs_Dialog; });
/* concated harmony reexport Divider */__webpack_require__.d(__webpack_exports__, "Divider", function() { return Dividers_Divider; });
/* concated harmony reexport Drawer */__webpack_require__.d(__webpack_exports__, "Drawer", function() { return Drawers_Drawer; });
/* concated harmony reexport ExpansionPanel */__webpack_require__.d(__webpack_exports__, "ExpansionPanel", function() { return ExpansionPanels_ExpansionPanel; });
/* concated harmony reexport ExpansionList */__webpack_require__.d(__webpack_exports__, "ExpansionList", function() { return ExpansionPanels_ExpansionList; });
/* concated harmony reexport FileInput */__webpack_require__.d(__webpack_exports__, "FileInput", function() { return FileInputs_FileInput; });
/* concated harmony reexport FileUpload */__webpack_require__.d(__webpack_exports__, "FileUpload", function() { return FileInputs_FileUpload; });
/* concated harmony reexport FontIcon */__webpack_require__.d(__webpack_exports__, "FontIcon", function() { return FontIcons_FontIcon; });
/* concated harmony reexport Grid */__webpack_require__.d(__webpack_exports__, "Grid", function() { return Grids_Grid; });
/* concated harmony reexport Cell */__webpack_require__.d(__webpack_exports__, "Cell", function() { return Grids_Cell; });
/* concated harmony reexport GridList */__webpack_require__.d(__webpack_exports__, "GridList", function() { return Grids_GridList; });
/* concated harmony reexport AccessibleFakeButton */__webpack_require__.d(__webpack_exports__, "AccessibleFakeButton", function() { return Helpers_AccessibleFakeButton; });
/* concated harmony reexport AccessibleFakeInkedButton */__webpack_require__.d(__webpack_exports__, "AccessibleFakeInkedButton", function() { return AccessibleFakeInkedButton; });
/* concated harmony reexport Collapse */__webpack_require__.d(__webpack_exports__, "Collapse", function() { return Helpers_Collapse; });
/* concated harmony reexport FocusContainer */__webpack_require__.d(__webpack_exports__, "FocusContainer", function() { return Helpers_FocusContainer; });
/* concated harmony reexport Layover */__webpack_require__.d(__webpack_exports__, "Layover", function() { return Helpers_Layover; });
/* concated harmony reexport IconSeparator */__webpack_require__.d(__webpack_exports__, "IconSeparator", function() { return Helpers_IconSeparator; });
/* concated harmony reexport Portal */__webpack_require__.d(__webpack_exports__, "Portal", function() { return Helpers_Portal; });
/* concated harmony reexport ResizeObserver */__webpack_require__.d(__webpack_exports__, "ResizeObserver", function() { return Helpers_ResizeObserver; });
/* concated harmony reexport injectInk */__webpack_require__.d(__webpack_exports__, "injectInk", function() { return injectInk; });
/* concated harmony reexport List */__webpack_require__.d(__webpack_exports__, "List", function() { return Lists_List; });
/* concated harmony reexport ListItem */__webpack_require__.d(__webpack_exports__, "ListItem", function() { return Lists_ListItem; });
/* concated harmony reexport ListItemControl */__webpack_require__.d(__webpack_exports__, "ListItemControl", function() { return Lists_ListItemControl; });
/* concated harmony reexport Media */__webpack_require__.d(__webpack_exports__, "Media", function() { return es_Media_Media; });
/* concated harmony reexport MediaOverlay */__webpack_require__.d(__webpack_exports__, "MediaOverlay", function() { return Media_MediaOverlay; });
/* concated harmony reexport Menu */__webpack_require__.d(__webpack_exports__, "Menu", function() { return Menus_Menu; });
/* concated harmony reexport DropdownMenu */__webpack_require__.d(__webpack_exports__, "DropdownMenu", function() { return Menus_DropdownMenu; });
/* concated harmony reexport MenuButton */__webpack_require__.d(__webpack_exports__, "MenuButton", function() { return Menus_MenuButton; });
/* concated harmony reexport NavigationDrawer */__webpack_require__.d(__webpack_exports__, "NavigationDrawer", function() { return NavigationDrawers_NavigationDrawer; });
/* concated harmony reexport Paper */__webpack_require__.d(__webpack_exports__, "Paper", function() { return Papers_Paper; });
/* concated harmony reexport DatePicker */__webpack_require__.d(__webpack_exports__, "DatePicker", function() { return Pickers_DatePickerContainer; });
/* concated harmony reexport TimePicker */__webpack_require__.d(__webpack_exports__, "TimePicker", function() { return Pickers_TimePickerContainer; });
/* concated harmony reexport CircularProgress */__webpack_require__.d(__webpack_exports__, "CircularProgress", function() { return Progress_CircularProgress; });
/* concated harmony reexport LinearProgress */__webpack_require__.d(__webpack_exports__, "LinearProgress", function() { return Progress_LinearProgress; });
/* concated harmony reexport SelectionControl */__webpack_require__.d(__webpack_exports__, "SelectionControl", function() { return SelectionControls_SelectionControl; });
/* concated harmony reexport SelectionControlGroup */__webpack_require__.d(__webpack_exports__, "SelectionControlGroup", function() { return SelectionControls_SelectionControlGroup; });
/* concated harmony reexport Checkbox */__webpack_require__.d(__webpack_exports__, "Checkbox", function() { return SelectionControls_Checkbox; });
/* concated harmony reexport Radio */__webpack_require__.d(__webpack_exports__, "Radio", function() { return SelectionControls_Radio; });
/* concated harmony reexport Switch */__webpack_require__.d(__webpack_exports__, "Switch", function() { return SelectionControls_Switch; });
/* concated harmony reexport SelectField */__webpack_require__.d(__webpack_exports__, "SelectField", function() { return SelectFields_SelectField; });
/* concated harmony reexport Slider */__webpack_require__.d(__webpack_exports__, "Slider", function() { return Sliders_Slider; });
/* concated harmony reexport Snackbar */__webpack_require__.d(__webpack_exports__, "Snackbar", function() { return Snackbars_SnackbarContainer; });
/* concated harmony reexport SVGIcon */__webpack_require__.d(__webpack_exports__, "SVGIcon", function() { return SVGIcons_SVGIcon; });
/* concated harmony reexport Subheader */__webpack_require__.d(__webpack_exports__, "Subheader", function() { return Subheaders_Subheader; });
/* concated harmony reexport TabsContainer */__webpack_require__.d(__webpack_exports__, "TabsContainer", function() { return Tabs_TabsContainer; });
/* concated harmony reexport Tabs */__webpack_require__.d(__webpack_exports__, "Tabs", function() { return es_Tabs_Tabs; });
/* concated harmony reexport Tab */__webpack_require__.d(__webpack_exports__, "Tab", function() { return Tabs_Tab; });
/* concated harmony reexport MenuTab */__webpack_require__.d(__webpack_exports__, "MenuTab", function() { return Tabs_MenuTab; });
/* concated harmony reexport TabPanel */__webpack_require__.d(__webpack_exports__, "TabPanel", function() { return Tabs_TabPanel; });
/* concated harmony reexport TextField */__webpack_require__.d(__webpack_exports__, "TextField", function() { return TextFields_TextField; });
/* concated harmony reexport Toolbar */__webpack_require__.d(__webpack_exports__, "Toolbar", function() { return Toolbars_Toolbar; });
/* concated harmony reexport injectTooltip */__webpack_require__.d(__webpack_exports__, "injectTooltip", function() { return injectTooltip; });
/* concated harmony reexport Tooltipped */__webpack_require__.d(__webpack_exports__, "Tooltipped", function() { return Tooltipped; });
/* concated harmony reexport Version */__webpack_require__.d(__webpack_exports__, "Version", function() { return Version; });
/* concated harmony reexport bem */__webpack_require__.d(__webpack_exports__, "bem", function() { return bem; });





























































































































































/***/ }),

/***/ "3sBZ":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__("Fcif");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
var objectWithoutPropertiesLoose = __webpack_require__("+I+c");

// EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__("7L9N");

// EXTERNAL MODULE: ../node_modules/prop-types/index.js
var prop_types = __webpack_require__("W0B4");

// EXTERNAL MODULE: ../node_modules/dom-helpers/class/addClass.js
var class_addClass = __webpack_require__("Y7gb");
var addClass_default = /*#__PURE__*/__webpack_require__.n(class_addClass);

// EXTERNAL MODULE: ../node_modules/dom-helpers/class/removeClass.js
var class_removeClass = __webpack_require__("noPx");
var removeClass_default = /*#__PURE__*/__webpack_require__.n(class_removeClass);

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/react-dom/index.js
var react_dom = __webpack_require__("xARA");
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// CONCATENATED MODULE: ../node_modules/react-transition-group/esm/config.js
/* harmony default export */ var config = ({
  disabled: false
});
// CONCATENATED MODULE: ../node_modules/react-transition-group/esm/TransitionGroupContext.js

/* harmony default export */ var TransitionGroupContext = (react_default.a.createContext(null));
// CONCATENATED MODULE: ../node_modules/react-transition-group/esm/Transition.js








var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition_Transition =
/*#__PURE__*/
function (_React$Component) {
  Object(inheritsLoose["a" /* default */])(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  }; // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }


  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();
      var node = react_dom_default.a.findDOMNode(this);

      if (nextStatus === ENTERING) {
        this.performEnter(node, mounting);
      } else {
        this.performExit(node);
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(node, mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(node);
      });
      return;
    }

    this.props.onEnter(node, appearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(node, appearing);

      _this2.onTransitionEnd(node, enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(node, appearing);
        });
      });
    });
  };

  _proto.performExit = function performExit(node) {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(node);
      });
      return;
    }

    this.props.onExit(node);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(node);

      _this3.onTransitionEnd(node, timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(node);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
    this.setNextCallback(handler);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      this.props.addEndListener(node, this.nextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children,
        childProps = Object(objectWithoutPropertiesLoose["a" /* default */])(_this$props, ["children"]); // filter props for Transtition


    delete childProps.in;
    delete childProps.mountOnEnter;
    delete childProps.unmountOnExit;
    delete childProps.appear;
    delete childProps.enter;
    delete childProps.exit;
    delete childProps.timeout;
    delete childProps.addEndListener;
    delete childProps.onEnter;
    delete childProps.onEntering;
    delete childProps.onEntered;
    delete childProps.onExit;
    delete childProps.onExiting;
    delete childProps.onExited;

    if (typeof children === 'function') {
      // allows for nested Transitions
      return react_default.a.createElement(TransitionGroupContext.Provider, {
        value: null
      }, children(status, childProps));
    }

    var child = react_default.a.Children.only(children);
    return (// allows for nested Transitions
      react_default.a.createElement(TransitionGroupContext.Provider, {
        value: null
      }, react_default.a.cloneElement(child, childProps))
    );
  };

  return Transition;
}(react_default.a.Component);

Transition_Transition.contextType = TransitionGroupContext;
Transition_Transition.propTypes =  false ? undefined : {};

function noop() {}

Transition_Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition_Transition.UNMOUNTED = 0;
Transition_Transition.EXITED = 1;
Transition_Transition.ENTERING = 2;
Transition_Transition.ENTERED = 3;
Transition_Transition.EXITING = 4;
/* harmony default export */ var esm_Transition = (Transition_Transition);
// CONCATENATED MODULE: ../node_modules/react-transition-group/esm/CSSTransition.js










var _addClass = function addClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return addClass_default()(node, c);
  });
};

var CSSTransition_removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return removeClass_default()(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](http://www.nganimate.org/) library, you should use it if you're
 * using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition_CSSTransition =
/*#__PURE__*/
function (_React$Component) {
  Object(inheritsLoose["a" /* default */])(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (node, appearing) {
      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(node, appearing);
      }
    };

    _this.onEntering = function (node, appearing) {
      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(node, appearing);
      }
    };

    _this.onEntered = function (node, appearing) {
      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(node, appearing);
      }
    };

    _this.onExit = function (node) {
      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(node);
      }
    };

    _this.onExiting = function (node) {
      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(node);
      }
    };

    _this.onExited = function (node) {
      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(node);
      }
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    if (type === 'appear' && phase === 'done') {
      className += " " + this.getClassNames('enter').doneClassName;
    } // This is for to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      /* eslint-disable no-unused-expressions */
      node && node.scrollTop;
    }

    this.appliedClasses[type][phase] = className;

    _addClass(node, className);
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      CSSTransition_removeClass(node, baseClassName);
    }

    if (activeClassName) {
      CSSTransition_removeClass(node, activeClassName);
    }

    if (doneClassName) {
      CSSTransition_removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        _ = _this$props.classNames,
        props = Object(objectWithoutPropertiesLoose["a" /* default */])(_this$props, ["classNames"]);

    return react_default.a.createElement(esm_Transition, Object(esm_extends["a" /* default */])({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(react_default.a.Component);

CSSTransition_CSSTransition.defaultProps = {
  classNames: ''
};
CSSTransition_CSSTransition.propTypes =  false ? undefined : {};
/* harmony default export */ var esm_CSSTransition = (CSSTransition_CSSTransition);
// CONCATENATED MODULE: ../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
// CONCATENATED MODULE: ../node_modules/react-transition-group/esm/utils/ChildMapping.js

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */

function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && Object(react["isValidElement"])(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) react["Children"].map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return Object(react["cloneElement"])(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!Object(react["isValidElement"])(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = Object(react["isValidElement"])(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = Object(react["cloneElement"])(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = Object(react["cloneElement"])(child, {
        in: false
      });
    } else if (hasNext && hasPrev && Object(react["isValidElement"])(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = Object(react["cloneElement"])(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}
// CONCATENATED MODULE: ../node_modules/react-transition-group/esm/TransitionGroup.js









var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
  /**
   * The `<TransitionGroup>` component manages a set of transition components
   * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
   * components, `<TransitionGroup>` is a state machine for managing the mounting
   * and unmounting of components over time.
   *
   * Consider the example below. As items are removed or added to the TodoList the
   * `in` prop is toggled automatically by the `<TransitionGroup>`.
   *
   * Note that `<TransitionGroup>`  does not define any animation behavior!
   * Exactly _how_ a list item animates is up to the individual transition
   * component. This means you can mix and match animations across different list
   * items.
   */

};

var TransitionGroup_TransitionGroup =
/*#__PURE__*/
function (_React$Component) {
  Object(inheritsLoose["a" /* default */])(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this))); // Initial children should all be entering, dependent on appear


    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = Object(esm_extends["a" /* default */])({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = Object(objectWithoutPropertiesLoose["a" /* default */])(_this$props, ["component", "childFactory"]);

    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return react_default.a.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }

    return react_default.a.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, react_default.a.createElement(Component, props, children));
  };

  return TransitionGroup;
}(react_default.a.Component);

TransitionGroup_TransitionGroup.propTypes =  false ? undefined : {};
TransitionGroup_TransitionGroup.defaultProps = defaultProps;
/* harmony default export */ var esm_TransitionGroup = (TransitionGroup_TransitionGroup);
// CONCATENATED MODULE: ../node_modules/react-transition-group/esm/ReplaceTransition.js






/**
 * The `<ReplaceTransition>` component is a specialized `Transition` component
 * that animates between two children.
 *
 * ```jsx
 * <ReplaceTransition in>
 *   <Fade><div>I appear first</div></Fade>
 *   <Fade><div>I replace the above</div></Fade>
 * </ReplaceTransition>
 * ```
 */

var ReplaceTransition_ReplaceTransition =
/*#__PURE__*/
function (_React$Component) {
  Object(inheritsLoose["a" /* default */])(ReplaceTransition, _React$Component);

  function ReplaceTransition() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

    _this.handleEnter = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _this.handleLifecycle('onEnter', 0, args);
    };

    _this.handleEntering = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _this.handleLifecycle('onEntering', 0, args);
    };

    _this.handleEntered = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return _this.handleLifecycle('onEntered', 0, args);
    };

    _this.handleExit = function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return _this.handleLifecycle('onExit', 1, args);
    };

    _this.handleExiting = function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return _this.handleLifecycle('onExiting', 1, args);
    };

    _this.handleExited = function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return _this.handleLifecycle('onExited', 1, args);
    };

    return _this;
  }

  var _proto = ReplaceTransition.prototype;

  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;

    var children = this.props.children;
    var child = react_default.a.Children.toArray(children)[idx];
    if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) this.props[handler](react_dom_default.a.findDOMNode(this));
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        inProp = _this$props.in,
        props = Object(objectWithoutPropertiesLoose["a" /* default */])(_this$props, ["children", "in"]);

    var _React$Children$toArr = react_default.a.Children.toArray(children),
        first = _React$Children$toArr[0],
        second = _React$Children$toArr[1];

    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return react_default.a.createElement(esm_TransitionGroup, props, inProp ? react_default.a.cloneElement(first, {
      key: 'first',
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : react_default.a.cloneElement(second, {
      key: 'second',
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };

  return ReplaceTransition;
}(react_default.a.Component);

ReplaceTransition_ReplaceTransition.propTypes =  false ? undefined : {};
/* harmony default export */ var esm_ReplaceTransition = (ReplaceTransition_ReplaceTransition);
// CONCATENATED MODULE: ../node_modules/react-transition-group/esm/SwitchTransition.js


var _leaveRenders, _enterRenders;






function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren) return false;

  if (react_default.a.isValidElement(oldChildren) && react_default.a.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }

  return true;
}
/**
 * Enum of modes for SwitchTransition component
 * @enum { string }
 */


var modes = {
  out: 'out-in',
  in: 'in-out'
};

var callHook = function callHook(element, name, cb) {
  return function () {
    var _element$props;

    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb();
  };
};

var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function (_ref) {
  var current = _ref.current,
      changeState = _ref.changeState;
  return react_default.a.cloneElement(current, {
    in: false,
    onExited: callHook(current, 'onExited', function () {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function (_ref2) {
  var current = _ref2.current,
      changeState = _ref2.changeState,
      children = _ref2.children;
  return [current, react_default.a.cloneElement(children, {
    in: true,
    onEntered: callHook(children, 'onEntered', function () {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function (_ref3) {
  var children = _ref3.children,
      changeState = _ref3.changeState;
  return react_default.a.cloneElement(children, {
    in: true,
    onEntered: callHook(children, 'onEntered', function () {
      changeState(ENTERED, react_default.a.cloneElement(children, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function (_ref4) {
  var current = _ref4.current,
      children = _ref4.children,
      changeState = _ref4.changeState;
  return [react_default.a.cloneElement(current, {
    in: false,
    onExited: callHook(current, 'onExited', function () {
      changeState(ENTERED, react_default.a.cloneElement(children, {
        in: true
      }));
    })
  }), react_default.a.cloneElement(children, {
    in: true
  })];
}, _enterRenders);
/**
 * A transition component inspired by the [vue transition modes](https://vuejs.org/v2/guide/transitions.html#Transition-Modes).
 * You can use it when you want to control the render between state transitions.
 * Based on the selected mode and the child's key which is the `Transition` or `CSSTransition` component, the `SwitchTransition` makes a consistent transition between them.
 *
 * If the `out-in` mode is selected, the `SwitchTransition` waits until the old child leaves and then inserts a new child.
 * If the `in-out` mode is selected, the `SwitchTransition` inserts a new child first, waits for the new child to enter and then removes the old child
 *
 * ```jsx
 *
 * function App() {
 *  const [state, setState] = useState(false);
 *  return (
 *    <SwitchTransition>
 *      <FadeTransition key={state ? "Goodbye, world!" : "Hello, world!"}
 *        addEndListener={(node, done) => node.addEventListener("transitionend", done, false)}
 *        classNames='fade' >
 *        <button onClick={() => setState(state => !state)}>
 *          {state ? "Goodbye, world!" : "Hello, world!"}
 *        </button>
 *      </FadeTransition>
 *    </SwitchTransition>
 *  )
 * }
 * ```
 */

var SwitchTransition_SwitchTransition =
/*#__PURE__*/
function (_React$Component) {
  Object(inheritsLoose["a" /* default */])(SwitchTransition, _React$Component);

  function SwitchTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;

    _this.changeState = function (status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }

      _this.setState({
        status: status,
        current: current
      });
    };

    return _this;
  }

  var _proto = SwitchTransition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };

  SwitchTransition.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }

    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }

    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }

    return {
      current: react_default.a.cloneElement(props.children, {
        in: true
      })
    };
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        mode = _this$props.mode,
        _this$state = this.state,
        status = _this$state.status,
        current = _this$state.current;
    var data = {
      children: children,
      current: current,
      changeState: this.changeState,
      status: status
    };
    var component;

    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data);
        break;

      case EXITING:
        component = leaveRenders[mode](data);
        break;

      case ENTERED:
        component = current;
    }

    return react_default.a.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };

  return SwitchTransition;
}(react_default.a.Component);

SwitchTransition_SwitchTransition.propTypes =  false ? undefined : {};
SwitchTransition_SwitchTransition.defaultProps = {
  mode: modes.out
};
/* harmony default export */ var esm_SwitchTransition = (SwitchTransition_SwitchTransition);
// CONCATENATED MODULE: ../node_modules/react-transition-group/esm/index.js
/* concated harmony reexport CSSTransition */__webpack_require__.d(__webpack_exports__, "CSSTransition", function() { return esm_CSSTransition; });
/* concated harmony reexport ReplaceTransition */__webpack_require__.d(__webpack_exports__, "ReplaceTransition", function() { return esm_ReplaceTransition; });
/* concated harmony reexport SwitchTransition */__webpack_require__.d(__webpack_exports__, "SwitchTransition", function() { return esm_SwitchTransition; });
/* concated harmony reexport TransitionGroup */__webpack_require__.d(__webpack_exports__, "TransitionGroup", function() { return esm_TransitionGroup; });
/* concated harmony reexport Transition */__webpack_require__.d(__webpack_exports__, "Transition", function() { return esm_Transition; });
/* concated harmony reexport config */__webpack_require__.d(__webpack_exports__, "config", function() { return config; });







/***/ }),

/***/ "4DfG":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__("UdKW");
} else {}


/***/ }),

/***/ "4bSW":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__("vdEC");

var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TextLayer;
exports.TextLayerInternal = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _regenerator = _interopRequireDefault(__webpack_require__("NthX"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__("fFdx"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _PageContext = _interopRequireDefault(__webpack_require__("1VGG"));

var _TextLayerItem = _interopRequireDefault(__webpack_require__("5Qf2"));

var _utils = __webpack_require__("YliN");

var _propTypes2 = __webpack_require__("T5tG");

var TextLayerInternal =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(TextLayerInternal, _PureComponent);

  function TextLayerInternal() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, TextLayerInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(TextLayerInternal)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "state", {
      textItems: null
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "loadTextItems",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      var page, cancellable, _ref2, textItems;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              page = _this.props.page;
              _context.prev = 1;
              cancellable = (0, _utils.makeCancellable)(page.getTextContent());
              _this.runningTask = cancellable;
              _context.next = 6;
              return cancellable.promise;

            case 6:
              _ref2 = _context.sent;
              textItems = _ref2.items;

              _this.setState({
                textItems: textItems
              }, _this.onLoadSuccess);

              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);

              _this.onLoadError(_context.t0);

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 11]]);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadSuccess", function () {
      var onGetTextSuccess = _this.props.onGetTextSuccess;
      var textItems = _this.state.textItems;
      (0, _utils.callIfDefined)(onGetTextSuccess, textItems);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadError", function (error) {
      if ((0, _utils.isCancelException)(error)) {
        return;
      }

      _this.setState({
        textItems: false
      });

      (0, _utils.errorOnDev)(error);
      var onGetTextError = _this.props.onGetTextError;
      (0, _utils.callIfDefined)(onGetTextError, error);
    });
    return _this;
  }

  (0, _createClass2.default)(TextLayerInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var page = this.props.page;

      if (!page) {
        throw new Error('Attempted to load page text content, but no page was specified.');
      }

      this.loadTextItems();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var page = this.props.page;

      if (prevProps.page && page !== prevProps.page) {
        this.loadTextItems();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      (0, _utils.cancelRunningTask)(this.runningTask);
    }
  }, {
    key: "renderTextItems",
    value: function renderTextItems() {
      var textItems = this.state.textItems;

      if (!textItems) {
        return null;
      }

      return textItems.map(function (textItem, itemIndex) {
        return _react.default.createElement(_TextLayerItem.default // eslint-disable-next-line react/no-array-index-key
        , (0, _extends2.default)({
          key: itemIndex,
          itemIndex: itemIndex
        }, textItem));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var viewport = this.unrotatedViewport,
          rotate = this.rotate;
      return _react.default.createElement("div", {
        className: "react-pdf__Page__textContent",
        style: {
          position: 'absolute',
          top: '50%',
          left: '50%',
          width: "".concat(viewport.width, "px"),
          height: "".concat(viewport.height, "px"),
          color: 'transparent',
          transform: "translate(-50%, -50%) rotate(".concat(rotate, "deg)"),
          pointerEvents: 'none'
        }
      }, this.renderTextItems());
    }
  }, {
    key: "unrotatedViewport",
    get: function get() {
      var _this$props = this.props,
          page = _this$props.page,
          scale = _this$props.scale;
      return page.getViewport({
        scale: scale
      });
    }
    /**
     * It might happen that the page is rotated by default. In such cases, we shouldn't rotate
     * text content.
     */

  }, {
    key: "rotate",
    get: function get() {
      var _this$props2 = this.props,
          page = _this$props2.page,
          rotate = _this$props2.rotate;
      return rotate - page.rotate;
    }
  }]);
  return TextLayerInternal;
}(_react.PureComponent);

exports.TextLayerInternal = TextLayerInternal;
TextLayerInternal.propTypes = {
  onGetTextError: _propTypes.default.func,
  onGetTextSuccess: _propTypes.default.func,
  page: _propTypes2.isPage.isRequired,
  rotate: _propTypes2.isRotate,
  scale: _propTypes.default.number
};

function TextLayer(props) {
  return _react.default.createElement(_PageContext.default.Consumer, null, function (context) {
    return _react.default.createElement(TextLayerInternal, (0, _extends2.default)({}, context, props));
  });
}

/***/ }),

/***/ "5+ba":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, isValidElement, REACT_ELEMENT_TYPE; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("7dXs")();
}


/***/ }),

/***/ "53Ck":
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "5Qf2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__("vdEC");

var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TextLayerItem;
exports.TextLayerItemInternal = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _slicedToArray2 = _interopRequireDefault(__webpack_require__("nxTg"));

var _regenerator = _interopRequireDefault(__webpack_require__("NthX"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__("fFdx"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _PageContext = _interopRequireDefault(__webpack_require__("1VGG"));

var _propTypes2 = __webpack_require__("T5tG");

var TextLayerItemInternal =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(TextLayerItemInternal, _PureComponent);

  function TextLayerItemInternal() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, TextLayerItemInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(TextLayerItemInternal)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getElementWidth", function (element) {
      var _assertThisInitialize = (0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)),
          sideways = _assertThisInitialize.sideways;

      return element.getBoundingClientRect()[sideways ? 'height' : 'width'];
    });
    return _this;
  }

  (0, _createClass2.default)(TextLayerItemInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.alignTextItem();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.alignTextItem();
    }
  }, {
    key: "getFontData",
    value: function () {
      var _getFontData = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(fontName) {
        var page, font;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                page = this.props.page;
                _context.next = 3;
                return new Promise(function (resolve) {
                  page.commonObjs.get(fontName, resolve);
                });

              case 3:
                font = _context.sent;
                return _context.abrupt("return", font);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getFontData(_x) {
        return _getFontData.apply(this, arguments);
      }

      return getFontData;
    }()
  }, {
    key: "alignTextItem",
    value: function () {
      var _alignTextItem = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var element, _this$props, fontName, scale, width, fontData, fallbackFontName, targetWidth, actualWidth, transform, ascent;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                element = this.item;

                if (element) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                element.style.transform = '';
                _this$props = this.props, fontName = _this$props.fontName, scale = _this$props.scale, width = _this$props.width;
                element.style.fontFamily = "".concat(fontName, ", sans-serif");
                _context2.next = 8;
                return this.getFontData(fontName);

              case 8:
                fontData = _context2.sent;
                fallbackFontName = fontData ? fontData.fallbackName : 'sans-serif';
                element.style.fontFamily = "".concat(fontName, ", ").concat(fallbackFontName);
                targetWidth = width * scale;
                actualWidth = this.getElementWidth(element);
                transform = "scaleX(".concat(targetWidth / actualWidth, ")");
                ascent = fontData ? fontData.ascent : 0;

                if (ascent) {
                  transform += " translateY(".concat((1 - ascent) * 100, "%)");
                }

                element.style.transform = transform;

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function alignTextItem() {
        return _alignTextItem.apply(this, arguments);
      }

      return alignTextItem;
    }()
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var fontSize = this.fontSize,
          top = this.top,
          left = this.left;
      var _this$props2 = this.props,
          customTextRenderer = _this$props2.customTextRenderer,
          scale = _this$props2.scale,
          text = _this$props2.str;
      return _react.default.createElement("span", {
        style: {
          height: '1em',
          fontFamily: 'sans-serif',
          fontSize: "".concat(fontSize * scale, "px"),
          position: 'absolute',
          top: "".concat(top * scale, "px"),
          left: "".concat(left * scale, "px"),
          transformOrigin: 'left bottom',
          whiteSpace: 'pre',
          pointerEvents: 'all'
        },
        ref: function ref(_ref) {
          _this2.item = _ref;
        }
      }, customTextRenderer ? customTextRenderer(this.props) : text);
    }
  }, {
    key: "unrotatedViewport",
    get: function get() {
      var _this$props3 = this.props,
          page = _this$props3.page,
          scale = _this$props3.scale;
      return page.getViewport({
        scale: scale
      });
    }
    /**
     * It might happen that the page is rotated by default. In such cases, we shouldn't rotate
     * text content.
     */

  }, {
    key: "rotate",
    get: function get() {
      var _this$props4 = this.props,
          page = _this$props4.page,
          rotate = _this$props4.rotate;
      return rotate - page.rotate;
    }
  }, {
    key: "sideways",
    get: function get() {
      var rotate = this.rotate;
      return rotate % 180 !== 0;
    }
  }, {
    key: "defaultSideways",
    get: function get() {
      var rotation = this.unrotatedViewport.rotation;
      return rotation % 180 !== 0;
    }
  }, {
    key: "fontSize",
    get: function get() {
      var transform = this.props.transform;
      var defaultSideways = this.defaultSideways;

      var _transform = (0, _slicedToArray2.default)(transform, 2),
          fontHeightPx = _transform[0],
          fontWidthPx = _transform[1];

      return defaultSideways ? fontWidthPx : fontHeightPx;
    }
  }, {
    key: "top",
    get: function get() {
      var transform = this.props.transform;
      var viewport = this.unrotatedViewport,
          defaultSideways = this.defaultSideways;

      var _transform2 = (0, _slicedToArray2.default)(transform, 6),

      /* fontHeightPx */

      /* fontWidthPx */
      offsetX = _transform2[2],
          offsetY = _transform2[3],
          x = _transform2[4],
          y = _transform2[5];

      var _viewport$viewBox = (0, _slicedToArray2.default)(viewport.viewBox, 4),

      /* xMin */
      yMin = _viewport$viewBox[1],

      /* xMax */
      yMax = _viewport$viewBox[3];

      return defaultSideways ? x + offsetX + yMin : yMax - (y + offsetY);
    }
  }, {
    key: "left",
    get: function get() {
      var transform = this.props.transform;
      var viewport = this.unrotatedViewport,
          defaultSideways = this.defaultSideways;

      var _transform3 = (0, _slicedToArray2.default)(transform, 6),

      /* fontHeightPx */

      /* fontWidthPx */

      /* offsetX */

      /* offsetY */
      x = _transform3[4],
          y = _transform3[5];

      var _viewport$viewBox2 = (0, _slicedToArray2.default)(viewport.viewBox, 1),
          xMin = _viewport$viewBox2[0];

      return defaultSideways ? y - xMin : x - xMin;
    }
  }]);
  return TextLayerItemInternal;
}(_react.PureComponent);

exports.TextLayerItemInternal = TextLayerItemInternal;
TextLayerItemInternal.propTypes = {
  customTextRenderer: _propTypes.default.func,
  fontName: _propTypes.default.string.isRequired,
  itemIndex: _propTypes.default.number.isRequired,
  // eslint-disable-line react/no-unused-prop-types
  page: _propTypes2.isPage.isRequired,
  rotate: _propTypes2.isRotate,
  scale: _propTypes.default.number,
  str: _propTypes.default.string.isRequired,
  transform: _propTypes.default.arrayOf(_propTypes.default.number).isRequired,
  width: _propTypes.default.number.isRequired
};

function TextLayerItem(props) {
  return _react.default.createElement(_PageContext.default.Consumer, null, function (context) {
    return _react.default.createElement(TextLayerItemInternal, (0, _extends2.default)({}, context, props));
  });
}

/***/ }),

/***/ "5WRv":
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__("iNmH");

var iterableToArray = __webpack_require__("Qatm");

var nonIterableSpread = __webpack_require__("kluZ");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "5Zwl":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("9aUh"),
    now = __webpack_require__("hfno"),
    toNumber = __webpack_require__("j6ZD");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "5fOt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _componentDeprecated = __webpack_require__("9/Bt");

var _componentDeprecated2 = _interopRequireDefault(_componentDeprecated);

var _Button = __webpack_require__("Bff0");

var _Button2 = _interopRequireDefault(_Button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RaisedButton = function (_PureComponent) {
  _inherits(RaisedButton, _PureComponent);

  function RaisedButton() {
    _classCallCheck(this, RaisedButton);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  RaisedButton.prototype.render = function render() {
    return _react2.default.createElement(_Button2.default, _extends({}, this.props, { raised: true }));
  };

  return RaisedButton;
}(_react.PureComponent);

RaisedButton.propTypes = {
  /**
   * The label to display in the button.
   */
  label: _propTypes2.default.node.isRequired,

  /**
   * An optional className to apply to the button.
   */
  className: _propTypes2.default.string,

  /**
   * Boolean if the icon should be displayed before the label.
   */
  iconBefore: _propTypes2.default.bool,

  /**
   * A `FontIcon` to display in the button. It can be placed before
   * or after the label.
   */
  children: _propTypes2.default.node,

  /**
   * The button type.
   */
  type: _propTypes2.default.string,

  /**
   * Boolean if the button should be styled with the primary color.
   */
  primary: _propTypes2.default.bool,

  /**
   * Boolean if the button should be styled with the secondary color.
   */
  secondary: _propTypes2.default.bool,

  /**
   * Boolean if the button is disabled.
   */
  disabled: _propTypes2.default.bool,

  /**
   * An optional href to convert the button into a link button.
   */
  href: _propTypes2.default.string,

  /**
   * An optional function to call when the button is clicked.
   */
  onClick: _propTypes2.default.func,

  deprecated: (0, _componentDeprecated2.default)('The behavior of the `RaisedButton` can be achieved with the `Button` component ' + 'without the additional bundle size. Switch to the `Button` component and add a ' + 'prop `raised`.')
};
RaisedButton.defaultProps = {
  type: 'button',
  iconBefore: true
};
exports.default = RaisedButton;

/***/ }),

/***/ "5rOX":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var UAParser = __webpack_require__(6);

var UA = exports.UA = new UAParser();

var browser = exports.browser = UA.getBrowser();
var cpu = exports.cpu = UA.getCPU();
var device = exports.device = UA.getDevice();
var engine = exports.engine = UA.getEngine();
var os = exports.os = UA.getOS();
var ua = exports.ua = UA.getUA();
var setUA = exports.setUA = function setUA(uaStr) {
  return UA.setUA(uaStr);
};

var mockUserAgent = exports.mockUserAgent = function mockUserAgent(userAgent) {
  window.navigator.__defineGetter__("userAgent", function () {
    return userAgent;
  });
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isYandex = exports.isEdge = exports.getUA = exports.engineVersion = exports.engineName = exports.mobileModel = exports.mobileVendor = exports.browserName = exports.browserVersion = exports.fullBrowserVersion = exports.osName = exports.osVersion = exports.isIE = exports.isOpera = exports.isSafari = exports.isFirefox = exports.isChrome = exports.isIOS = exports.isWinPhone = exports.isAndroid = exports.isBrowser = exports.isTablet = exports.isMobileOnly = exports.isMobile = exports.isChromium = exports.isMobileSafari = exports.isWearable = exports.isConsole = exports.isSmartTV = undefined;

var _getUaData = __webpack_require__(0);

var _types = __webpack_require__(2);

var CHROME = _types.BROWSER_TYPES.CHROME,
    CHROMIUM = _types.BROWSER_TYPES.CHROMIUM,
    IE = _types.BROWSER_TYPES.IE,
    INTERNET_EXPLORER = _types.BROWSER_TYPES.INTERNET_EXPLORER,
    OPERA = _types.BROWSER_TYPES.OPERA,
    FIREFOX = _types.BROWSER_TYPES.FIREFOX,
    SAFARI = _types.BROWSER_TYPES.SAFARI,
    MOBILE_SAFARI = _types.BROWSER_TYPES.MOBILE_SAFARI,
    EDGE = _types.BROWSER_TYPES.EDGE,
    YANDEX = _types.BROWSER_TYPES.YANDEX;
var MOBILE = _types.DEVICE_TYPES.MOBILE,
    TABLET = _types.DEVICE_TYPES.TABLET,
    SMART_TV = _types.DEVICE_TYPES.SMART_TV,
    BROWSER = _types.DEVICE_TYPES.BROWSER,
    WEARABLE = _types.DEVICE_TYPES.WEARABLE,
    CONSOLE = _types.DEVICE_TYPES.CONSOLE;
var ANDROID = _types.OS_TYPES.ANDROID,
    WINDOWS_PHONE = _types.OS_TYPES.WINDOWS_PHONE,
    IOS = _types.OS_TYPES.IOS;


var isMobileType = function isMobileType() {
  return _getUaData.device.type === MOBILE;
};
var isTabletType = function isTabletType() {
  return _getUaData.device.type === TABLET;
};

var isMobileAndTabletType = function isMobileAndTabletType() {
  switch (_getUaData.device.type) {
    case MOBILE:
    case TABLET:
      return true;
    default:
      return false;
  }
};

var isSmartTVType = function isSmartTVType() {
  return _getUaData.device.type === SMART_TV;
};
var isBrowserType = function isBrowserType() {
  return _getUaData.device.type === BROWSER;
};
var isWearableType = function isWearableType() {
  return _getUaData.device.type === WEARABLE;
};
var isConsoleType = function isConsoleType() {
  return _getUaData.device.type === CONSOLE;
};
var isAndroidType = function isAndroidType() {
  return _getUaData.os.name === ANDROID;
};
var isWinPhoneType = function isWinPhoneType() {
  return _getUaData.os.name === WINDOWS_PHONE;
};
var isIOSType = function isIOSType() {
  return _getUaData.os.name === IOS;
};
var isChromeType = function isChromeType() {
  return _getUaData.browser.name === CHROME;
};
var isFirefoxType = function isFirefoxType() {
  return _getUaData.browser.name === FIREFOX;
};
var isChromiumType = function isChromiumType() {
  return _getUaData.browser.name === CHROMIUM;
};
var isEdgeType = function isEdgeType() {
  return _getUaData.browser.name === EDGE;
};
var isYandexType = function isYandexType() {
  return _getUaData.browser.name === YANDEX;
};
var isSafariType = function isSafariType() {
  return _getUaData.browser.name === SAFARI || _getUaData.browser.name === MOBILE_SAFARI;
};
var isMobileSafariType = function isMobileSafariType() {
  return _getUaData.browser.name === MOBILE_SAFARI;
};
var isOperaType = function isOperaType() {
  return _getUaData.browser.name === OPERA;
};
var isIEType = function isIEType() {
  return _getUaData.browser.name === INTERNET_EXPLORER || _getUaData.browser.name === IE;
};

var getBrowserFullVersion = function getBrowserFullVersion() {
  return _getUaData.browser.major;
};
var getBrowserVersion = function getBrowserVersion() {
  return _getUaData.browser.version;
};
var getOsVersion = function getOsVersion() {
  return _getUaData.os.version ? _getUaData.os.version : "none";
};
var getOsName = function getOsName() {
  return _getUaData.os.name ? _getUaData.os.name : "none";
};
var getBrowserName = function getBrowserName() {
  return _getUaData.browser.name;
};
var getMobileVendor = function getMobileVendor() {
  return _getUaData.device.vendor ? _getUaData.device.vendor : "none";
};
var getMobileModel = function getMobileModel() {
  return _getUaData.device.model ? _getUaData.device.model : "none";
};
var getEngineName = function getEngineName() {
  return _getUaData.engine.name;
};
var getEngineVersion = function getEngineVersion() {
  return _getUaData.engine.version;
};
var getUseragent = function getUseragent() {
  return _getUaData.ua;
};

var isSmartTV = exports.isSmartTV = isSmartTVType();
var isConsole = exports.isConsole = isConsoleType();
var isWearable = exports.isWearable = isWearableType();
var isMobileSafari = exports.isMobileSafari = isMobileSafariType();
var isChromium = exports.isChromium = isChromiumType();
var isMobile = exports.isMobile = isMobileAndTabletType();
var isMobileOnly = exports.isMobileOnly = isMobileType();
var isTablet = exports.isTablet = isTabletType();
var isBrowser = exports.isBrowser = isBrowserType();
var isAndroid = exports.isAndroid = isAndroidType();
var isWinPhone = exports.isWinPhone = isWinPhoneType();
var isIOS = exports.isIOS = isIOSType();
var isChrome = exports.isChrome = isChromeType();
var isFirefox = exports.isFirefox = isFirefoxType();
var isSafari = exports.isSafari = isSafariType();
var isOpera = exports.isOpera = isOperaType();
var isIE = exports.isIE = isIEType();
var osVersion = exports.osVersion = getOsVersion();
var osName = exports.osName = getOsName();
var fullBrowserVersion = exports.fullBrowserVersion = getBrowserFullVersion();
var browserVersion = exports.browserVersion = getBrowserVersion();
var browserName = exports.browserName = getBrowserName();
var mobileVendor = exports.mobileVendor = getMobileVendor();
var mobileModel = exports.mobileModel = getMobileModel();
var engineName = exports.engineName = getEngineName();
var engineVersion = exports.engineVersion = getEngineVersion();
var getUA = exports.getUA = getUseragent();
var isEdge = exports.isEdge = isEdgeType();
var isYandex = exports.isYandex = isYandexType();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wearPayload = exports.consolePayload = exports.stvPayload = exports.mobilePayload = exports.broPayload = exports.getCurrentBrowser = exports.checkType = exports.OS_TYPES = exports.BROWSER_TYPES = exports.DEVICE_TYPES = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _getUaData = __webpack_require__(0);

var DEVICE_TYPES = exports.DEVICE_TYPES = {
  MOBILE: 'mobile',
  TABLET: 'tablet',
  SMART_TV: 'smarttv',
  CONSOLE: 'console',
  WEARABLE: 'wearable',
  BROWSER: undefined
};

var BROWSER_TYPES = exports.BROWSER_TYPES = {
  CHROME: 'Chrome',
  FIREFOX: "Firefox",
  OPERA: "Opera",
  YANDEX: "Yandex",
  SAFARI: "Safari",
  INTERNET_EXPLORER: "Internet Explorer",
  EDGE: "Edge",
  CHROMIUM: "Chromium",
  IE: 'IE',
  MOBILE_SAFARI: "Mobile Safari"
};

var OS_TYPES = exports.OS_TYPES = {
  IOS: 'iOS',
  ANDROID: "Android",
  WINDOWS_PHONE: "Windows Phone"
};

var initialData = {
  isMobile: false,
  isTablet: false,
  isBrowser: false,
  isSmartTV: false,
  isConsole: false,
  isWearable: false
};

var checkType = exports.checkType = function checkType(type) {
  switch (type) {
    case DEVICE_TYPES.MOBILE:
      return { isMobile: true };
    case DEVICE_TYPES.TABLET:
      return { isTablet: true };
    case DEVICE_TYPES.SMART_TV:
      return { isSmartTV: true };
    case DEVICE_TYPES.CONSOLE:
      return { isConsole: true };
    case DEVICE_TYPES.WEARABLE:
      return { isWearable: true };
    case DEVICE_TYPES.BROWSER:
      return { isBrowser: true };
    default:
      return initialData;
  }
};

var getCurrentBrowser = exports.getCurrentBrowser = function getCurrentBrowser(name) {
  switch (name) {
    case BROWSER_TYPES.CHROME:
    case BROWSER_TYPES.FIREFOX:
    case BROWSER_TYPES.OPERA:
    case BROWSER_TYPES.YANDEX:
    case BROWSER_TYPES.SAFARI:
    case BROWSER_TYPES.IE:
    case BROWSER_TYPES.EDGE:
    case BROWSER_TYPES.CHROMIUM:
      return true;
    default:
      return false;
  }
};

var broPayload = exports.broPayload = function broPayload(isBrowser, browser, engine, os, ua) {
  return {
    isBrowser: isBrowser,
    browserMajorVersion: browser.major,
    browserFullVersion: browser.version,
    browserName: browser.name,
    engineName: engine.name || false,
    engineVersion: engine.version,
    osName: os.name,
    osVersion: os.version,
    userAgent: ua
  };
};

var mobilePayload = exports.mobilePayload = function mobilePayload(type, device, os, ua) {
  return _extends({}, type, {
    vendor: device.vendor || "none",
    model: device.model || "none",
    os: os.name || "none",
    osVersion: os.version || "none",
    ua: ua || "none"
  });
};

var stvPayload = exports.stvPayload = function stvPayload(isSmartTV, engine, os, ua) {
  return {
    isSmartTV: isSmartTV,
    engineName: engine.name || false,
    engineVersion: engine.version,
    osName: os.name,
    osVersion: os.version,
    userAgent: ua
  };
};

var consolePayload = exports.consolePayload = function consolePayload(isConsole, engine, os, ua) {
  return {
    isConsole: isConsole,
    engineName: engine.name || false,
    engineVersion: engine.version,
    osName: os.name,
    osVersion: os.version,
    userAgent: ua
  };
};

var wearPayload = exports.wearPayload = function wearPayload(isWearable, engine, os, ua) {
  return {
    isWearable: isWearable,
    engineName: engine.name || false,
    engineVersion: engine.version,
    osName: os.name,
    osVersion: os.version,
    userAgent: ua
  };
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deviceDetect = undefined;

var _views = __webpack_require__(4);

Object.keys(_views).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _views[key];
    }
  });
});

var _selectors = __webpack_require__(1);

Object.keys(_selectors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _selectors[key];
    }
  });
});

var _detect = __webpack_require__(8);

var _detect2 = _interopRequireDefault(_detect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.deviceDetect = _detect2.default;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomView = exports.WearableView = exports.ConsoleView = exports.SmartTVView = exports.MobileOnlyView = exports.WinPhoneView = exports.TabletView = exports.MobileView = exports.IOSView = exports.IEView = exports.BrowserView = exports.AndroidView = undefined;

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _selectors = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AndroidView = exports.AndroidView = function AndroidView(_ref) {
  var renderWithFragment = _ref.renderWithFragment,
      children = _ref.children,
      viewClassName = _ref.viewClassName,
      style = _ref.style;

  return _selectors.isAndroid ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var BrowserView = exports.BrowserView = function BrowserView(_ref2) {
  var renderWithFragment = _ref2.renderWithFragment,
      children = _ref2.children,
      viewClassName = _ref2.viewClassName,
      style = _ref2.style;

  return _selectors.isBrowser ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var IEView = exports.IEView = function IEView(_ref3) {
  var renderWithFragment = _ref3.renderWithFragment,
      children = _ref3.children,
      viewClassName = _ref3.viewClassName,
      style = _ref3.style;

  return _selectors.isIE ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var IOSView = exports.IOSView = function IOSView(_ref4) {
  var renderWithFragment = _ref4.renderWithFragment,
      children = _ref4.children,
      viewClassName = _ref4.viewClassName,
      style = _ref4.style;

  return _selectors.isIOS ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var MobileView = exports.MobileView = function MobileView(_ref5) {
  var renderWithFragment = _ref5.renderWithFragment,
      children = _ref5.children,
      viewClassName = _ref5.viewClassName,
      style = _ref5.style;

  return _selectors.isMobile ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var TabletView = exports.TabletView = function TabletView(_ref6) {
  var renderWithFragment = _ref6.renderWithFragment,
      children = _ref6.children,
      viewClassName = _ref6.viewClassName,
      style = _ref6.style;

  return _selectors.isTablet ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var WinPhoneView = exports.WinPhoneView = function WinPhoneView(_ref7) {
  var renderWithFragment = _ref7.renderWithFragment,
      children = _ref7.children,
      viewClassName = _ref7.viewClassName,
      style = _ref7.style;

  return _selectors.isWinPhone ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var MobileOnlyView = exports.MobileOnlyView = function MobileOnlyView(_ref8) {
  var renderWithFragment = _ref8.renderWithFragment,
      children = _ref8.children,
      viewClassName = _ref8.viewClassName,
      style = _ref8.style;

  return _selectors.isMobileOnly ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var SmartTVView = exports.SmartTVView = function SmartTVView(_ref9) {
  var renderWithFragment = _ref9.renderWithFragment,
      children = _ref9.children,
      viewClassName = _ref9.viewClassName,
      style = _ref9.style;

  return _selectors.isSmartTV ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var ConsoleView = exports.ConsoleView = function ConsoleView(_ref10) {
  var renderWithFragment = _ref10.renderWithFragment,
      children = _ref10.children,
      viewClassName = _ref10.viewClassName,
      style = _ref10.style;

  return _selectors.isConsole ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var WearableView = exports.WearableView = function WearableView(_ref11) {
  var renderWithFragment = _ref11.renderWithFragment,
      children = _ref11.children,
      viewClassName = _ref11.viewClassName,
      style = _ref11.style;

  return _selectors.isWearable ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

var CustomView = exports.CustomView = function CustomView(_ref12) {
  var renderWithFragment = _ref12.renderWithFragment,
      children = _ref12.children,
      viewClassName = _ref12.viewClassName,
      style = _ref12.style,
      condition = _ref12.condition;

  return condition ? renderWithFragment ? _react2.default.createElement(
    _react.Fragment,
    null,
    children
  ) : _react2.default.createElement(
    'div',
    { className: viewClassName, style: style },
    children
  ) : null;
};

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("mXGw");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * UAParser.js v0.7.18
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright © 2012-2016 Faisal Salman <fyzlman@gmail.com>
 * Dual licensed under GPLv2 or MIT
 */
(function(window,undefined){"use strict";var LIBVERSION="0.7.18",EMPTY="",UNKNOWN="?",FUNC_TYPE="function",UNDEF_TYPE="undefined",OBJ_TYPE="object",STR_TYPE="string",MAJOR="major",MODEL="model",NAME="name",TYPE="type",VENDOR="vendor",VERSION="version",ARCHITECTURE="architecture",CONSOLE="console",MOBILE="mobile",TABLET="tablet",SMARTTV="smarttv",WEARABLE="wearable",EMBEDDED="embedded";var util={extend:function(regexes,extensions){var margedRegexes={};for(var i in regexes){if(extensions[i]&&extensions[i].length%2===0){margedRegexes[i]=extensions[i].concat(regexes[i])}else{margedRegexes[i]=regexes[i]}}return margedRegexes},has:function(str1,str2){if(typeof str1==="string"){return str2.toLowerCase().indexOf(str1.toLowerCase())!==-1}else{return false}},lowerize:function(str){return str.toLowerCase()},major:function(version){return typeof version===STR_TYPE?version.replace(/[^\d\.]/g,"").split(".")[0]:undefined},trim:function(str){return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}};var mapper={rgx:function(ua,arrays){var i=0,j,k,p,q,matches,match;while(i<arrays.length&&!matches){var regex=arrays[i],props=arrays[i+1];j=k=0;while(j<regex.length&&!matches){matches=regex[j++].exec(ua);if(!!matches){for(p=0;p<props.length;p++){match=matches[++k];q=props[p];if(typeof q===OBJ_TYPE&&q.length>0){if(q.length==2){if(typeof q[1]==FUNC_TYPE){this[q[0]]=q[1].call(this,match)}else{this[q[0]]=q[1]}}else if(q.length==3){if(typeof q[1]===FUNC_TYPE&&!(q[1].exec&&q[1].test)){this[q[0]]=match?q[1].call(this,match,q[2]):undefined}else{this[q[0]]=match?match.replace(q[1],q[2]):undefined}}else if(q.length==4){this[q[0]]=match?q[3].call(this,match.replace(q[1],q[2])):undefined}}else{this[q]=match?match:undefined}}}}i+=2}},str:function(str,map){for(var i in map){if(typeof map[i]===OBJ_TYPE&&map[i].length>0){for(var j=0;j<map[i].length;j++){if(util.has(map[i][j],str)){return i===UNKNOWN?undefined:i}}}else if(util.has(map[i],str)){return i===UNKNOWN?undefined:i}}return str}};var maps={browser:{oldsafari:{version:{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}}},device:{amazon:{model:{"Fire Phone":["SD","KF"]}},sprint:{model:{"Evo Shift 4G":"7373KT"},vendor:{HTC:"APA",Sprint:"Sprint"}}},os:{windows:{version:{ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2000:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"}}}};var regexes={browser:[[/(opera\smini)\/([\w\.-]+)/i,/(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,/(opera).+version\/([\w\.]+)/i,/(opera)[\/\s]+([\w\.]+)/i],[NAME,VERSION],[/(opios)[\/\s]+([\w\.]+)/i],[[NAME,"Opera Mini"],VERSION],[/\s(opr)\/([\w\.]+)/i],[[NAME,"Opera"],VERSION],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,/(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,/(?:ms|\()(ie)\s([\w\.]+)/i,/(rekonq)\/([\w\.]*)/i,/(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark)\/([\w\.-]+)/i],[NAME,VERSION],[/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],[[NAME,"IE"],VERSION],[/(edge|edgios|edgea)\/((\d+)?[\w\.]+)/i],[[NAME,"Edge"],VERSION],[/(yabrowser)\/([\w\.]+)/i],[[NAME,"Yandex"],VERSION],[/(puffin)\/([\w\.]+)/i],[[NAME,"Puffin"],VERSION],[/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],[[NAME,"UCBrowser"],VERSION],[/(comodo_dragon)\/([\w\.]+)/i],[[NAME,/_/g," "],VERSION],[/(micromessenger)\/([\w\.]+)/i],[[NAME,"WeChat"],VERSION],[/(qqbrowserlite)\/([\w\.]+)/i],[NAME,VERSION],[/(QQ)\/([\d\.]+)/i],[NAME,VERSION],[/m?(qqbrowser)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(BIDUBrowser)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(2345Explorer)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(MetaSr)[\/\s]?([\w\.]+)/i],[NAME],[/(LBBROWSER)/i],[NAME],[/xiaomi\/miuibrowser\/([\w\.]+)/i],[VERSION,[NAME,"MIUI Browser"]],[/;fbav\/([\w\.]+);/i],[VERSION,[NAME,"Facebook"]],[/headlesschrome(?:\/([\w\.]+)|\s)/i],[VERSION,[NAME,"Chrome Headless"]],[/\swv\).+(chrome)\/([\w\.]+)/i],[[NAME,/(.+)/,"$1 WebView"],VERSION],[/((?:oculus|samsung)browser)\/([\w\.]+)/i],[[NAME,/(.+(?:g|us))(.+)/,"$1 $2"],VERSION],[/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],[VERSION,[NAME,"Android Browser"]],[/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],[NAME,VERSION],[/(dolfin)\/([\w\.]+)/i],[[NAME,"Dolphin"],VERSION],[/((?:android.+)crmo|crios)\/([\w\.]+)/i],[[NAME,"Chrome"],VERSION],[/(coast)\/([\w\.]+)/i],[[NAME,"Opera Coast"],VERSION],[/fxios\/([\w\.-]+)/i],[VERSION,[NAME,"Firefox"]],[/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],[VERSION,[NAME,"Mobile Safari"]],[/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],[VERSION,NAME],[/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[[NAME,"GSA"],VERSION],[/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[NAME,[VERSION,mapper.str,maps.browser.oldsafari.version]],[/(konqueror)\/([\w\.]+)/i,/(webkit|khtml)\/([\w\.]+)/i],[NAME,VERSION],[/(navigator|netscape)\/([\w\.-]+)/i],[[NAME,"Netscape"],VERSION],[/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,/(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,/(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,/(links)\s\(([\w\.]+)/i,/(gobrowser)\/?([\w\.]*)/i,/(ice\s?browser)\/v?([\w\._]+)/i,/(mosaic)[\/\s]([\w\.]+)/i],[NAME,VERSION]],cpu:[[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],[[ARCHITECTURE,"amd64"]],[/(ia32(?=;))/i],[[ARCHITECTURE,util.lowerize]],[/((?:i[346]|x)86)[;\)]/i],[[ARCHITECTURE,"ia32"]],[/windows\s(ce|mobile);\sppc;/i],[[ARCHITECTURE,"arm"]],[/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],[[ARCHITECTURE,/ower/,"",util.lowerize]],[/(sun4\w)[;\)]/i],[[ARCHITECTURE,"sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],[[ARCHITECTURE,util.lowerize]]],device:[[/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],[MODEL,VENDOR,[TYPE,TABLET]],[/applecoremedia\/[\w\.]+ \((ipad)/],[MODEL,[VENDOR,"Apple"],[TYPE,TABLET]],[/(apple\s{0,1}tv)/i],[[MODEL,"Apple TV"],[VENDOR,"Apple"]],[/(archos)\s(gamepad2?)/i,/(hp).+(touchpad)/i,/(hp).+(tablet)/i,/(kindle)\/([\w\.]+)/i,/\s(nook)[\w\s]+build\/(\w+)/i,/(dell)\s(strea[kpr\s\d]*[\dko])/i],[VENDOR,MODEL,[TYPE,TABLET]],[/(kf[A-z]+)\sbuild\/.+silk\//i],[MODEL,[VENDOR,"Amazon"],[TYPE,TABLET]],[/(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i],[[MODEL,mapper.str,maps.device.amazon.model],[VENDOR,"Amazon"],[TYPE,MOBILE]],[/\((ip[honed|\s\w*]+);.+(apple)/i],[MODEL,VENDOR,[TYPE,MOBILE]],[/\((ip[honed|\s\w*]+);/i],[MODEL,[VENDOR,"Apple"],[TYPE,MOBILE]],[/(blackberry)[\s-]?(\w+)/i,/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,/(hp)\s([\w\s]+\w)/i,/(asus)-?(\w+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/\(bb10;\s(\w+)/i],[MODEL,[VENDOR,"BlackBerry"],[TYPE,MOBILE]],[/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],[MODEL,[VENDOR,"Asus"],[TYPE,TABLET]],[/(sony)\s(tablet\s[ps])\sbuild\//i,/(sony)?(?:sgp.+)\sbuild\//i],[[VENDOR,"Sony"],[MODEL,"Xperia Tablet"],[TYPE,TABLET]],[/android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i],[MODEL,[VENDOR,"Sony"],[TYPE,MOBILE]],[/\s(ouya)\s/i,/(nintendo)\s([wids3u]+)/i],[VENDOR,MODEL,[TYPE,CONSOLE]],[/android.+;\s(shield)\sbuild/i],[MODEL,[VENDOR,"Nvidia"],[TYPE,CONSOLE]],[/(playstation\s[34portablevi]+)/i],[MODEL,[VENDOR,"Sony"],[TYPE,CONSOLE]],[/(sprint\s(\w+))/i],[[VENDOR,mapper.str,maps.device.sprint.vendor],[MODEL,mapper.str,maps.device.sprint.model],[TYPE,MOBILE]],[/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],[VENDOR,MODEL,[TYPE,TABLET]],[/(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,/(zte)-(\w*)/i,/(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i],[VENDOR,[MODEL,/_/g," "],[TYPE,MOBILE]],[/(nexus\s9)/i],[MODEL,[VENDOR,"HTC"],[TYPE,TABLET]],[/d\/huawei([\w\s-]+)[;\)]/i,/(nexus\s6p)/i],[MODEL,[VENDOR,"Huawei"],[TYPE,MOBILE]],[/(microsoft);\s(lumia[\s\w]+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/[\s\(;](xbox(?:\sone)?)[\s\);]/i],[MODEL,[VENDOR,"Microsoft"],[TYPE,CONSOLE]],[/(kin\.[onetw]{3})/i],[[MODEL,/\./g," "],[VENDOR,"Microsoft"],[TYPE,MOBILE]],[/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,/mot[\s-]?(\w*)/i,/(XT\d{3,4}) build\//i,/(nexus\s6)/i],[MODEL,[VENDOR,"Motorola"],[TYPE,MOBILE]],[/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],[MODEL,[VENDOR,"Motorola"],[TYPE,TABLET]],[/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],[[VENDOR,util.trim],[MODEL,util.trim],[TYPE,SMARTTV]],[/hbbtv.+maple;(\d+)/i],[[MODEL,/^/,"SmartTV"],[VENDOR,"Samsung"],[TYPE,SMARTTV]],[/\(dtv[\);].+(aquos)/i],[MODEL,[VENDOR,"Sharp"],[TYPE,SMARTTV]],[/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,/((SM-T\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,TABLET]],[/smart-tv.+(samsung)/i],[VENDOR,[TYPE,SMARTTV],MODEL],[/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,/(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i,/sec-((sgh\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,MOBILE]],[/sie-(\w*)/i],[MODEL,[VENDOR,"Siemens"],[TYPE,MOBILE]],[/(maemo|nokia).*(n900|lumia\s\d+)/i,/(nokia)[\s_-]?([\w-]*)/i],[[VENDOR,"Nokia"],MODEL,[TYPE,MOBILE]],[/android\s3\.[\s\w;-]{10}(a\d{3})/i],[MODEL,[VENDOR,"Acer"],[TYPE,TABLET]],[/android.+([vl]k\-?\d{3})\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,TABLET]],[/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],[[VENDOR,"LG"],MODEL,[TYPE,TABLET]],[/(lg) netcast\.tv/i],[VENDOR,MODEL,[TYPE,SMARTTV]],[/(nexus\s[45])/i,/lg[e;\s\/-]+(\w*)/i,/android.+lg(\-?[\d\w]+)\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,MOBILE]],[/android.+(ideatab[a-z0-9\-\s]+)/i],[MODEL,[VENDOR,"Lenovo"],[TYPE,TABLET]],[/linux;.+((jolla));/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/((pebble))app\/[\d\.]+\s/i],[VENDOR,MODEL,[TYPE,WEARABLE]],[/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/crkey/i],[[MODEL,"Chromecast"],[VENDOR,"Google"]],[/android.+;\s(glass)\s\d/i],[MODEL,[VENDOR,"Google"],[TYPE,WEARABLE]],[/android.+;\s(pixel c)\s/i],[MODEL,[VENDOR,"Google"],[TYPE,TABLET]],[/android.+;\s(pixel xl|pixel)\s/i],[MODEL,[VENDOR,"Google"],[TYPE,MOBILE]],[/android.+;\s(\w+)\s+build\/hm\1/i,/android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,/android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,/android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,MOBILE]],[/android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,TABLET]],[/android.+;\s(m[1-5]\snote)\sbuild/i],[MODEL,[VENDOR,"Meizu"],[TYPE,TABLET]],[/android.+a000(1)\s+build/i,/android.+oneplus\s(a\d{4})\s+build/i],[MODEL,[VENDOR,"OnePlus"],[TYPE,MOBILE]],[/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],[MODEL,[VENDOR,"RCA"],[TYPE,TABLET]],[/android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i],[MODEL,[VENDOR,"Dell"],[TYPE,TABLET]],[/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],[MODEL,[VENDOR,"Verizon"],[TYPE,TABLET]],[/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],[[VENDOR,"Barnes & Noble"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],[MODEL,[VENDOR,"NuVision"],[TYPE,TABLET]],[/android.+;\s(k88)\sbuild/i],[MODEL,[VENDOR,"ZTE"],[TYPE,TABLET]],[/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],[MODEL,[VENDOR,"Swiss"],[TYPE,MOBILE]],[/android.+[;\/]\s*(zur\d{3})\s+build/i],[MODEL,[VENDOR,"Swiss"],[TYPE,TABLET]],[/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],[MODEL,[VENDOR,"Zeki"],[TYPE,TABLET]],[/(android).+[;\/]\s+([YR]\d{2})\s+build/i,/android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i],[[VENDOR,"Dragon Touch"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i],[MODEL,[VENDOR,"Insignia"],[TYPE,TABLET]],[/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i],[MODEL,[VENDOR,"NextBook"],[TYPE,TABLET]],[/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],[[VENDOR,"Voice"],MODEL,[TYPE,MOBILE]],[/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i],[[VENDOR,"LvTel"],MODEL,[TYPE,MOBILE]],[/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],[MODEL,[VENDOR,"Envizen"],[TYPE,TABLET]],[/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],[MODEL,[VENDOR,"MachSpeed"],[TYPE,TABLET]],[/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*TU_(1491)\s+build/i],[MODEL,[VENDOR,"Rotor"],[TYPE,TABLET]],[/android.+(KS(.+))\s+build/i],[MODEL,[VENDOR,"Amazon"],[TYPE,TABLET]],[/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/\s(tablet|tab)[;\/]/i,/\s(mobile)(?:[;\/]|\ssafari)/i],[[TYPE,util.lowerize],VENDOR,MODEL],[/(android[\w\.\s\-]{0,9});.+build/i],[MODEL,[VENDOR,"Generic"]]],engine:[[/windows.+\sedge\/([\w\.]+)/i],[VERSION,[NAME,"EdgeHTML"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,/(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,/(icab)[\/\s]([23]\.[\d\.]+)/i],[NAME,VERSION],[/rv\:([\w\.]{1,9}).+(gecko)/i],[VERSION,NAME]],os:[[/microsoft\s(windows)\s(vista|xp)/i],[NAME,VERSION],[/(windows)\snt\s6\.2;\s(arm)/i,/(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,/(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],[NAME,[VERSION,mapper.str,maps.os.windows.version]],[/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],[[NAME,"Windows"],[VERSION,mapper.str,maps.os.windows.version]],[/\((bb)(10);/i],[[NAME,"BlackBerry"],VERSION],[/(blackberry)\w*\/?([\w\.]*)/i,/(tizen)[\/\s]([\w\.]+)/i,/(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]*)/i,/linux;.+(sailfish);/i],[NAME,VERSION],[/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i],[[NAME,"Symbian"],VERSION],[/\((series40);/i],[NAME],[/mozilla.+\(mobile;.+gecko.+firefox/i],[[NAME,"Firefox OS"],VERSION],[/(nintendo|playstation)\s([wids34portablevu]+)/i,/(mint)[\/\s\(]?(\w*)/i,/(mageia|vectorlinux)[;\s]/i,/(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,/(hurd|linux)\s?([\w\.]*)/i,/(gnu)\s?([\w\.]*)/i],[NAME,VERSION],[/(cros)\s[\w]+\s([\w\.]+\w)/i],[[NAME,"Chromium OS"],VERSION],[/(sunos)\s?([\w\.\d]*)/i],[[NAME,"Solaris"],VERSION],[/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i],[NAME,VERSION],[/(haiku)\s(\w+)/i],[NAME,VERSION],[/cfnetwork\/.+darwin/i,/ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i],[[VERSION,/_/g,"."],[NAME,"iOS"]],[/(mac\sos\sx)\s?([\w\s\.]*)/i,/(macintosh|mac(?=_powerpc)\s)/i],[[NAME,"Mac OS"],[VERSION,/_/g,"."]],[/((?:open)?solaris)[\/\s-]?([\w\.]*)/i,/(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,/(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,/(unix)\s?([\w\.]*)/i],[NAME,VERSION]]};var UAParser=function(uastring,extensions){if(typeof uastring==="object"){extensions=uastring;uastring=undefined}if(!(this instanceof UAParser)){return new UAParser(uastring,extensions).getResult()}var ua=uastring||(window&&window.navigator&&window.navigator.userAgent?window.navigator.userAgent:EMPTY);var rgxmap=extensions?util.extend(regexes,extensions):regexes;this.getBrowser=function(){var browser={name:undefined,version:undefined};mapper.rgx.call(browser,ua,rgxmap.browser);browser.major=util.major(browser.version);return browser};this.getCPU=function(){var cpu={architecture:undefined};mapper.rgx.call(cpu,ua,rgxmap.cpu);return cpu};this.getDevice=function(){var device={vendor:undefined,model:undefined,type:undefined};mapper.rgx.call(device,ua,rgxmap.device);return device};this.getEngine=function(){var engine={name:undefined,version:undefined};mapper.rgx.call(engine,ua,rgxmap.engine);return engine};this.getOS=function(){var os={name:undefined,version:undefined};mapper.rgx.call(os,ua,rgxmap.os);return os};this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}};this.getUA=function(){return ua};this.setUA=function(uastring){ua=uastring;return this};return this};UAParser.VERSION=LIBVERSION;UAParser.BROWSER={NAME:NAME,MAJOR:MAJOR,VERSION:VERSION};UAParser.CPU={ARCHITECTURE:ARCHITECTURE};UAParser.DEVICE={MODEL:MODEL,VENDOR:VENDOR,TYPE:TYPE,CONSOLE:CONSOLE,MOBILE:MOBILE,SMARTTV:SMARTTV,TABLET:TABLET,WEARABLE:WEARABLE,EMBEDDED:EMBEDDED};UAParser.ENGINE={NAME:NAME,VERSION:VERSION};UAParser.OS={NAME:NAME,VERSION:VERSION};if(typeof exports!==UNDEF_TYPE){if(typeof module!==UNDEF_TYPE&&module.exports){exports=module.exports=UAParser}exports.UAParser=UAParser}else{if("function"===FUNC_TYPE&&__webpack_require__(7)){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return UAParser}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else if(window){window.UAParser=UAParser}}var $=window&&(window.jQuery||window.Zepto);if(typeof $!==UNDEF_TYPE){var parser=new UAParser;$.ua=parser.getResult();$.ua.get=function(){return parser.getUA()};$.ua.set=function(uastring){parser.setUA(uastring);var result=parser.getResult();for(var prop in result){$.ua[prop]=result[prop]}}}})(typeof window==="object"?window:this);

/***/ }),
/* 7 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getUaData = __webpack_require__(0);

var _types = __webpack_require__(2);

var create = _interopRequireWildcard(_types);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var type = create.checkType(_getUaData.device.type);

exports.default = function () {
  var isBrowser = type.isBrowser,
      isMobile = type.isMobile,
      isTablet = type.isTablet,
      isSmartTV = type.isSmartTV,
      isConsole = type.isConsole,
      isWearable = type.isWearable;

  if (isBrowser) {
    return create.broPayload(isBrowser, _getUaData.browser, _getUaData.engine, _getUaData.os, _getUaData.ua);
  }

  if (isSmartTV) {
    return create.stvPayload(isSmartTV, _getUaData.engine, _getUaData.os, _getUaData.ua);
  }

  if (isConsole) {
    return create.consolePayload(isConsole, _getUaData.engine, _getUaData.os, _getUaData.ua);
  }

  if (isMobile) {
    return create.mobilePayload(type, _getUaData.device, _getUaData.os, _getUaData.ua);
  }

  if (isTablet) {
    return create.mobilePayload(type, _getUaData.device, _getUaData.os, _getUaData.ua);
  }

  if (isWearable) {
    return create.wearPayload(isWearable, _getUaData.engine, _getUaData.os, _getUaData.ua);
  }
};

/***/ })
/******/ ]);

/***/ }),

/***/ "63Ad":
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "6BtY":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "6SGH":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getChildMapping = getChildMapping;
exports.mergeChildMappings = mergeChildMappings;

var _react = __webpack_require__("mXGw");

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */
function getChildMapping(children) {
  if (!children) {
    return children;
  }
  var result = {};
  _react.Children.map(children, function (child) {
    return child;
  }).forEach(function (child) {
    result[child.key] = child;
  });
  return result;
}

/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    if (next.hasOwnProperty(key)) {
      return next[key];
    }

    return prev[key];
  }

  // For each key of `next`, the list of keys to insert before that key in
  // the combined list
  var nextKeysPending = {};

  var pendingKeys = [];
  for (var prevKey in prev) {
    if (next.hasOwnProperty(prevKey)) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i = void 0;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending.hasOwnProperty(nextKey)) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }

  // Finally, add the keys which didn't appear before any key in `next`
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

/***/ }),

/***/ "6gdi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getDisplayName;
/** @module utils/StringUtils/getDisplayName */

/**
 * Gets the display name for a composed component.
 *
 * @param {function|Object} ComposedComponent - The composed component to use
 * @param {String} hoc - The higher order component's name to use.
 * @return {String} the new name of the component.
 */
function getDisplayName(ComposedComponent, hoc) {
  var name = '' + (ComposedComponent.displayName || ComposedComponent.name || 'Component');

  return 'with' + hoc + '(' + name + ')';
}

/***/ }),

/***/ "7CSj":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ListItemControl = exports.ListItem = exports.List = undefined;

var _List2 = __webpack_require__("wvQ6");

var _List3 = _interopRequireDefault(_List2);

var _ListItem2 = __webpack_require__("SjVu");

var _ListItem3 = _interopRequireDefault(_ListItem2);

var _ListItemControl2 = __webpack_require__("sTV1");

var _ListItemControl3 = _interopRequireDefault(_ListItemControl2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _List3.default;
exports.List = _List3.default;
exports.ListItem = _ListItem3.default;
exports.ListItemControl = _ListItemControl3.default;

/***/ }),

/***/ "7L9N":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _inheritsLoose; });
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

/***/ }),

/***/ "7XVh":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "7c/Y":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getDeprecatedIcon;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _FontIcon = __webpack_require__("vMIC");

var _FontIcon2 = _interopRequireDefault(_FontIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDeprecatedIcon(className, children, icon) {
  if (className || children) {
    return _react2.default.createElement(
      _FontIcon2.default,
      { iconClassName: className },
      children
    );
  }

  return icon;
}

/***/ }),

/***/ "7dXs":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__("6BtY");
var invariant = __webpack_require__("KAlO");
var ReactPropTypesSecret = __webpack_require__("eqrH");

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "7nMe":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("7XVh")))

/***/ }),

/***/ "8JTt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.nameShape = undefined;
exports.transitionTimeout = transitionTimeout;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function transitionTimeout(transitionType) {
  var timeoutPropName = 'transition' + transitionType + 'Timeout';
  var enabledPropName = 'transition' + transitionType;

  return function (props) {
    // If the transition is enabled
    if (props[enabledPropName]) {
      // If no timeout duration is provided
      if (props[timeoutPropName] == null) {
        return new Error(timeoutPropName + ' wasn\'t supplied to CSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.');

        // If the duration isn't a number
      } else if (typeof props[timeoutPropName] !== 'number') {
        return new Error(timeoutPropName + ' must be a number (in milliseconds)');
      }
    }

    return null;
  };
}

var nameShape = exports.nameShape = _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
  enter: _propTypes2.default.string,
  leave: _propTypes2.default.string,
  active: _propTypes2.default.string
}), _propTypes2.default.shape({
  enter: _propTypes2.default.string,
  enterActive: _propTypes2.default.string,
  leave: _propTypes2.default.string,
  leaveActive: _propTypes2.default.string,
  appear: _propTypes2.default.string,
  appearActive: _propTypes2.default.string
})]);

/***/ }),

/***/ "8Jek":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "8Tgy":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _mapToZero = __webpack_require__("VNYx");

var _mapToZero2 = _interopRequireDefault(_mapToZero);

var _stripStyle = __webpack_require__("jL08");

var _stripStyle2 = _interopRequireDefault(_stripStyle);

var _stepper3 = __webpack_require__("1obq");

var _stepper4 = _interopRequireDefault(_stepper3);

var _performanceNow = __webpack_require__("7nMe");

var _performanceNow2 = _interopRequireDefault(_performanceNow);

var _raf = __webpack_require__("rQBY");

var _raf2 = _interopRequireDefault(_raf);

var _shouldStopAnimation = __webpack_require__("fsLg");

var _shouldStopAnimation2 = _interopRequireDefault(_shouldStopAnimation);

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("W0B4");

var _propTypes2 = _interopRequireDefault(_propTypes);

var msPerFrame = 1000 / 60;

var Motion = (function (_React$Component) {
  _inherits(Motion, _React$Component);

  _createClass(Motion, null, [{
    key: 'propTypes',
    value: {
      // TOOD: warn against putting a config in here
      defaultStyle: _propTypes2['default'].objectOf(_propTypes2['default'].number),
      style: _propTypes2['default'].objectOf(_propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].object])).isRequired,
      children: _propTypes2['default'].func.isRequired,
      onRest: _propTypes2['default'].func
    },
    enumerable: true
  }]);

  function Motion(props) {
    var _this = this;

    _classCallCheck(this, Motion);

    _React$Component.call(this, props);
    this.wasAnimating = false;
    this.animationID = null;
    this.prevTime = 0;
    this.accumulatedTime = 0;
    this.unreadPropStyle = null;

    this.clearUnreadPropStyle = function (destStyle) {
      var dirty = false;
      var _state = _this.state;
      var currentStyle = _state.currentStyle;
      var currentVelocity = _state.currentVelocity;
      var lastIdealStyle = _state.lastIdealStyle;
      var lastIdealVelocity = _state.lastIdealVelocity;

      for (var key in destStyle) {
        if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {
          continue;
        }

        var styleValue = destStyle[key];
        if (typeof styleValue === 'number') {
          if (!dirty) {
            dirty = true;
            currentStyle = _extends({}, currentStyle);
            currentVelocity = _extends({}, currentVelocity);
            lastIdealStyle = _extends({}, lastIdealStyle);
            lastIdealVelocity = _extends({}, lastIdealVelocity);
          }

          currentStyle[key] = styleValue;
          currentVelocity[key] = 0;
          lastIdealStyle[key] = styleValue;
          lastIdealVelocity[key] = 0;
        }
      }

      if (dirty) {
        _this.setState({ currentStyle: currentStyle, currentVelocity: currentVelocity, lastIdealStyle: lastIdealStyle, lastIdealVelocity: lastIdealVelocity });
      }
    };

    this.startAnimationIfNecessary = function () {
      // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
      // call cb? No, otherwise accidental parent rerender causes cb trigger
      _this.animationID = _raf2['default'](function (timestamp) {
        // check if we need to animate in the first place
        var propsStyle = _this.props.style;
        if (_shouldStopAnimation2['default'](_this.state.currentStyle, propsStyle, _this.state.currentVelocity)) {
          if (_this.wasAnimating && _this.props.onRest) {
            _this.props.onRest();
          }

          // no need to cancel animationID here; shouldn't have any in flight
          _this.animationID = null;
          _this.wasAnimating = false;
          _this.accumulatedTime = 0;
          return;
        }

        _this.wasAnimating = true;

        var currentTime = timestamp || _performanceNow2['default']();
        var timeDelta = currentTime - _this.prevTime;
        _this.prevTime = currentTime;
        _this.accumulatedTime = _this.accumulatedTime + timeDelta;
        // more than 10 frames? prolly switched browser tab. Restart
        if (_this.accumulatedTime > msPerFrame * 10) {
          _this.accumulatedTime = 0;
        }

        if (_this.accumulatedTime === 0) {
          // no need to cancel animationID here; shouldn't have any in flight
          _this.animationID = null;
          _this.startAnimationIfNecessary();
          return;
        }

        var currentFrameCompletion = (_this.accumulatedTime - Math.floor(_this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;
        var framesToCatchUp = Math.floor(_this.accumulatedTime / msPerFrame);

        var newLastIdealStyle = {};
        var newLastIdealVelocity = {};
        var newCurrentStyle = {};
        var newCurrentVelocity = {};

        for (var key in propsStyle) {
          if (!Object.prototype.hasOwnProperty.call(propsStyle, key)) {
            continue;
          }

          var styleValue = propsStyle[key];
          if (typeof styleValue === 'number') {
            newCurrentStyle[key] = styleValue;
            newCurrentVelocity[key] = 0;
            newLastIdealStyle[key] = styleValue;
            newLastIdealVelocity[key] = 0;
          } else {
            var newLastIdealStyleValue = _this.state.lastIdealStyle[key];
            var newLastIdealVelocityValue = _this.state.lastIdealVelocity[key];
            for (var i = 0; i < framesToCatchUp; i++) {
              var _stepper = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

              newLastIdealStyleValue = _stepper[0];
              newLastIdealVelocityValue = _stepper[1];
            }

            var _stepper2 = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

            var nextIdealX = _stepper2[0];
            var nextIdealV = _stepper2[1];

            newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;
            newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;
            newLastIdealStyle[key] = newLastIdealStyleValue;
            newLastIdealVelocity[key] = newLastIdealVelocityValue;
          }
        }

        _this.animationID = null;
        // the amount we're looped over above
        _this.accumulatedTime -= framesToCatchUp * msPerFrame;

        _this.setState({
          currentStyle: newCurrentStyle,
          currentVelocity: newCurrentVelocity,
          lastIdealStyle: newLastIdealStyle,
          lastIdealVelocity: newLastIdealVelocity
        });

        _this.unreadPropStyle = null;

        _this.startAnimationIfNecessary();
      });
    };

    this.state = this.defaultState();
  }

  Motion.prototype.defaultState = function defaultState() {
    var _props = this.props;
    var defaultStyle = _props.defaultStyle;
    var style = _props.style;

    var currentStyle = defaultStyle || _stripStyle2['default'](style);
    var currentVelocity = _mapToZero2['default'](currentStyle);
    return {
      currentStyle: currentStyle,
      currentVelocity: currentVelocity,
      lastIdealStyle: currentStyle,
      lastIdealVelocity: currentVelocity
    };
  };

  // it's possible that currentStyle's value is stale: if props is immediately
  // changed from 0 to 400 to spring(0) again, the async currentStyle is still
  // at 0 (didn't have time to tick and interpolate even once). If we naively
  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
  // In reality currentStyle should be 400

  Motion.prototype.componentDidMount = function componentDidMount() {
    this.prevTime = _performanceNow2['default']();
    this.startAnimationIfNecessary();
  };

  Motion.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
    if (this.unreadPropStyle != null) {
      // previous props haven't had the chance to be set yet; set them here
      this.clearUnreadPropStyle(this.unreadPropStyle);
    }

    this.unreadPropStyle = props.style;
    if (this.animationID == null) {
      this.prevTime = _performanceNow2['default']();
      this.startAnimationIfNecessary();
    }
  };

  Motion.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.animationID != null) {
      _raf2['default'].cancel(this.animationID);
      this.animationID = null;
    }
  };

  Motion.prototype.render = function render() {
    var renderedChildren = this.props.children(this.state.currentStyle);
    return renderedChildren && _react2['default'].Children.only(renderedChildren);
  };

  return Motion;
})(_react2['default'].Component);

exports['default'] = Motion;
module.exports = exports['default'];

// after checking for unreadPropStyle != null, we manually go set the
// non-interpolating values (those that are a number, without a spring
// config)

/***/ }),

/***/ "8VmE":
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "9/Bt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = componentDeprecated;
/** @module utils/PropTypes/componentDeprecated */

/**
 * A simple PropType validation that shows that a component is deprecated and also prints
 * a reason for the deprecation.
 *
 * @param {String} reason - The reason that the component is deprecated.
 * @return {Error} a prop type validation error.
 */
function componentDeprecated(reason) {
  return function validate(props, propName, componentName) {
    var componentNameSafe = componentName || '<<anonymous>>';

    return new Error('The `' + componentNameSafe + '` has been deprecated and will be removed in the next release. ' + reason);
  };
}

/***/ }),

/***/ "93Te":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ../node_modules/prop-types/index.js
var prop_types = __webpack_require__("W0B4");
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ../node_modules/react-dom/index.js
var react_dom = __webpack_require__("xARA");

// EXTERNAL MODULE: ../node_modules/classnames/index.js
var classnames = __webpack_require__("8Jek");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ../node_modules/lodash/debounce.js
var debounce = __webpack_require__("5Zwl");
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);

// CONCATENATED MODULE: ../node_modules/rc-steps/es/utils.js
// eslint-disable-next-line import/prefer-default-export
function isFlexSupported() {
  if (typeof window !== 'undefined' && window.document && window.document.documentElement) {
    var documentElement = window.document.documentElement;
    return 'flex' in documentElement.style || 'webkitFlex' in documentElement.style || 'Flex' in documentElement.style || 'msFlex' in documentElement.style;
  }

  return false;
}
// CONCATENATED MODULE: ../node_modules/rc-steps/es/Steps.js
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint react/no-did-mount-set-state: 0 */







var Steps_Steps =
/*#__PURE__*/
function (_Component) {
  _inherits(Steps, _Component);

  function Steps(props) {
    var _this;

    _classCallCheck(this, Steps);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Steps).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "onStepClick", function (next) {
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          current = _this$props.current;

      if (onChange && current !== next) {
        onChange(next);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "calcStepOffsetWidth", function () {
      if (isFlexSupported()) {
        return;
      }

      var lastStepOffsetWidth = _this.state.lastStepOffsetWidth; // Just for IE9

      var domNode = Object(react_dom["findDOMNode"])(_assertThisInitialized(_this));

      if (domNode.children.length > 0) {
        if (_this.calcTimeout) {
          clearTimeout(_this.calcTimeout);
        }

        _this.calcTimeout = setTimeout(function () {
          // +1 for fit edge bug of digit width, like 35.4px
          var offsetWidth = (domNode.lastChild.offsetWidth || 0) + 1; // Reduce shake bug

          if (lastStepOffsetWidth === offsetWidth || Math.abs(lastStepOffsetWidth - offsetWidth) <= 3) {
            return;
          }

          _this.setState({
            lastStepOffsetWidth: offsetWidth
          });
        });
      }
    });

    _this.state = {
      flexSupported: true,
      lastStepOffsetWidth: 0
    };
    _this.calcStepOffsetWidth = debounce_default()(_this.calcStepOffsetWidth, 150);
    return _this;
  }

  _createClass(Steps, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.calcStepOffsetWidth();

      if (!isFlexSupported()) {
        this.setState({
          flexSupported: false
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.calcStepOffsetWidth();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.calcTimeout) {
        clearTimeout(this.calcTimeout);
      }

      if (this.calcStepOffsetWidth && this.calcStepOffsetWidth.cancel) {
        this.calcStepOffsetWidth.cancel();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames,
          _this2 = this;

      var _this$props2 = this.props,
          prefixCls = _this$props2.prefixCls,
          _this$props2$style = _this$props2.style,
          style = _this$props2$style === void 0 ? {} : _this$props2$style,
          className = _this$props2.className,
          children = _this$props2.children,
          direction = _this$props2.direction,
          type = _this$props2.type,
          labelPlacement = _this$props2.labelPlacement,
          iconPrefix = _this$props2.iconPrefix,
          status = _this$props2.status,
          size = _this$props2.size,
          current = _this$props2.current,
          progressDot = _this$props2.progressDot,
          initial = _this$props2.initial,
          icons = _this$props2.icons,
          onChange = _this$props2.onChange,
          restProps = _objectWithoutProperties(_this$props2, ["prefixCls", "style", "className", "children", "direction", "type", "labelPlacement", "iconPrefix", "status", "size", "current", "progressDot", "initial", "icons", "onChange"]);

      var isNav = type === 'navigation';
      var _this$state = this.state,
          lastStepOffsetWidth = _this$state.lastStepOffsetWidth,
          flexSupported = _this$state.flexSupported;
      var filteredChildren = react_default.a.Children.toArray(children).filter(function (c) {
        return !!c;
      });
      var lastIndex = filteredChildren.length - 1;
      var adjustedlabelPlacement = progressDot ? 'vertical' : labelPlacement;
      var classString = classnames_default()(prefixCls, "".concat(prefixCls, "-").concat(direction), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-").concat(size), size), _defineProperty(_classNames, "".concat(prefixCls, "-label-").concat(adjustedlabelPlacement), direction === 'horizontal'), _defineProperty(_classNames, "".concat(prefixCls, "-dot"), !!progressDot), _defineProperty(_classNames, "".concat(prefixCls, "-navigation"), isNav), _defineProperty(_classNames, "".concat(prefixCls, "-flex-not-supported"), !flexSupported), _classNames));
      return react_default.a.createElement("div", _extends({
        className: classString,
        style: style
      }, restProps), react["Children"].map(filteredChildren, function (child, index) {
        if (!child) {
          return null;
        }

        var stepNumber = initial + index;

        var childProps = _objectSpread({
          stepNumber: "".concat(stepNumber + 1),
          stepIndex: stepNumber,
          prefixCls: prefixCls,
          iconPrefix: iconPrefix,
          wrapperStyle: style,
          progressDot: progressDot,
          icons: icons,
          onStepClick: onChange && _this2.onStepClick
        }, child.props);

        if (!flexSupported && direction !== 'vertical') {
          if (isNav) {
            childProps.itemWidth = "".concat(100 / (lastIndex + 1), "%");
            childProps.adjustMarginRight = 0;
          } else if (index !== lastIndex) {
            childProps.itemWidth = "".concat(100 / lastIndex, "%");
            childProps.adjustMarginRight = -Math.round(lastStepOffsetWidth / lastIndex + 1);
          }
        } // fix tail color


        if (status === 'error' && index === current - 1) {
          childProps.className = "".concat(prefixCls, "-next-error");
        }

        if (!child.props.status) {
          if (stepNumber === current) {
            childProps.status = status;
          } else if (stepNumber < current) {
            childProps.status = 'finish';
          } else {
            childProps.status = 'wait';
          }
        }

        childProps.active = stepNumber === current;
        return Object(react["cloneElement"])(child, childProps);
      }));
    }
  }]);

  return Steps;
}(react["Component"]);

_defineProperty(Steps_Steps, "propTypes", {
  type: prop_types_default.a.string,
  prefixCls: prop_types_default.a.string,
  className: prop_types_default.a.string,
  iconPrefix: prop_types_default.a.string,
  direction: prop_types_default.a.string,
  labelPlacement: prop_types_default.a.string,
  children: prop_types_default.a.any,
  status: prop_types_default.a.string,
  size: prop_types_default.a.string,
  progressDot: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.func]),
  style: prop_types_default.a.object,
  initial: prop_types_default.a.number,
  current: prop_types_default.a.number,
  icons: prop_types_default.a.shape({
    finish: prop_types_default.a.node,
    error: prop_types_default.a.node
  }),
  onChange: prop_types_default.a.func
});

_defineProperty(Steps_Steps, "defaultProps", {
  type: 'default',
  prefixCls: 'rc-steps',
  iconPrefix: 'rc',
  direction: 'horizontal',
  labelPlacement: 'horizontal',
  initial: 0,
  current: 0,
  status: 'process',
  size: '',
  progressDot: false
});


// CONCATENATED MODULE: ../node_modules/rc-steps/es/Step.js
function Step_extends() { Step_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Step_extends.apply(this, arguments); }

function Step_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Step_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Step_ownKeys(source, true).forEach(function (key) { Step_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Step_ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Step_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Step_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Step_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Step_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Step_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Step_createClass(Constructor, protoProps, staticProps) { if (protoProps) Step_defineProperties(Constructor.prototype, protoProps); if (staticProps) Step_defineProperties(Constructor, staticProps); return Constructor; }

function Step_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Step_assertThisInitialized(self); }

function Step_getPrototypeOf(o) { Step_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Step_getPrototypeOf(o); }

function Step_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Step_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Step_setPrototypeOf(subClass, superClass); }

function Step_setPrototypeOf(o, p) { Step_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Step_setPrototypeOf(o, p); }

function Step_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function isString(str) {
  return typeof str === 'string';
}

var Step_Step =
/*#__PURE__*/
function (_React$Component) {
  Step_inherits(Step, _React$Component);

  function Step() {
    var _getPrototypeOf2;

    var _this;

    Step_classCallCheck(this, Step);

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = Step_possibleConstructorReturn(this, (_getPrototypeOf2 = Step_getPrototypeOf(Step)).call.apply(_getPrototypeOf2, [this].concat(_args)));

    Step_defineProperty(Step_assertThisInitialized(_this), "onClick", function () {
      var _this$props = _this.props,
          onClick = _this$props.onClick,
          onStepClick = _this$props.onStepClick,
          stepIndex = _this$props.stepIndex;

      if (onClick) {
        onClick.apply(void 0, arguments);
      }

      onStepClick(stepIndex);
    });

    return _this;
  }

  Step_createClass(Step, [{
    key: "renderIconNode",
    value: function renderIconNode() {
      var _classNames;

      var _this$props2 = this.props,
          prefixCls = _this$props2.prefixCls,
          progressDot = _this$props2.progressDot,
          stepNumber = _this$props2.stepNumber,
          status = _this$props2.status,
          title = _this$props2.title,
          description = _this$props2.description,
          icon = _this$props2.icon,
          iconPrefix = _this$props2.iconPrefix,
          icons = _this$props2.icons;
      var iconNode;
      var iconClassName = classnames_default()("".concat(prefixCls, "-icon"), "".concat(iconPrefix, "icon"), (_classNames = {}, Step_defineProperty(_classNames, "".concat(iconPrefix, "icon-").concat(icon), icon && isString(icon)), Step_defineProperty(_classNames, "".concat(iconPrefix, "icon-check"), !icon && status === 'finish' && icons && !icons.finish), Step_defineProperty(_classNames, "".concat(iconPrefix, "icon-close"), !icon && status === 'error' && icons && !icons.error), _classNames));
      var iconDot = react_default.a.createElement("span", {
        className: "".concat(prefixCls, "-icon-dot")
      }); // `progressDot` enjoy the highest priority

      if (progressDot) {
        if (typeof progressDot === 'function') {
          iconNode = react_default.a.createElement("span", {
            className: "".concat(prefixCls, "-icon")
          }, progressDot(iconDot, {
            index: stepNumber - 1,
            status: status,
            title: title,
            description: description
          }));
        } else {
          iconNode = react_default.a.createElement("span", {
            className: "".concat(prefixCls, "-icon")
          }, iconDot);
        }
      } else if (icon && !isString(icon)) {
        iconNode = react_default.a.createElement("span", {
          className: "".concat(prefixCls, "-icon")
        }, icon);
      } else if (icons && icons.finish && status === 'finish') {
        iconNode = react_default.a.createElement("span", {
          className: "".concat(prefixCls, "-icon")
        }, icons.finish);
      } else if (icons && icons.error && status === 'error') {
        iconNode = react_default.a.createElement("span", {
          className: "".concat(prefixCls, "-icon")
        }, icons.error);
      } else if (icon || status === 'finish' || status === 'error') {
        iconNode = react_default.a.createElement("span", {
          className: iconClassName
        });
      } else {
        iconNode = react_default.a.createElement("span", {
          className: "".concat(prefixCls, "-icon")
        }, stepNumber);
      }

      return iconNode;
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames2;

      var _this$props3 = this.props,
          className = _this$props3.className,
          prefixCls = _this$props3.prefixCls,
          style = _this$props3.style,
          itemWidth = _this$props3.itemWidth,
          active = _this$props3.active,
          _this$props3$status = _this$props3.status,
          status = _this$props3$status === void 0 ? 'wait' : _this$props3$status,
          iconPrefix = _this$props3.iconPrefix,
          icon = _this$props3.icon,
          wrapperStyle = _this$props3.wrapperStyle,
          adjustMarginRight = _this$props3.adjustMarginRight,
          stepNumber = _this$props3.stepNumber,
          disabled = _this$props3.disabled,
          description = _this$props3.description,
          title = _this$props3.title,
          subTitle = _this$props3.subTitle,
          progressDot = _this$props3.progressDot,
          tailContent = _this$props3.tailContent,
          icons = _this$props3.icons,
          stepIndex = _this$props3.stepIndex,
          onStepClick = _this$props3.onStepClick,
          onClick = _this$props3.onClick,
          restProps = Step_objectWithoutProperties(_this$props3, ["className", "prefixCls", "style", "itemWidth", "active", "status", "iconPrefix", "icon", "wrapperStyle", "adjustMarginRight", "stepNumber", "disabled", "description", "title", "subTitle", "progressDot", "tailContent", "icons", "stepIndex", "onStepClick", "onClick"]);

      var classString = classnames_default()("".concat(prefixCls, "-item"), "".concat(prefixCls, "-item-").concat(status), className, (_classNames2 = {}, Step_defineProperty(_classNames2, "".concat(prefixCls, "-item-custom"), icon), Step_defineProperty(_classNames2, "".concat(prefixCls, "-item-active"), active), Step_defineProperty(_classNames2, "".concat(prefixCls, "-item-disabled"), disabled === true), _classNames2));

      var stepItemStyle = Step_objectSpread({}, style);

      if (itemWidth) {
        stepItemStyle.width = itemWidth;
      }

      if (adjustMarginRight) {
        stepItemStyle.marginRight = adjustMarginRight;
      }

      var accessibilityProps = {};

      if (onStepClick && !disabled) {
        accessibilityProps.role = 'button';
        accessibilityProps.tabIndex = 0;
        accessibilityProps.onClick = this.onClick;
      }

      return react_default.a.createElement("div", Step_extends({}, restProps, {
        className: classString,
        style: stepItemStyle
      }), react_default.a.createElement("div", Step_extends({
        onClick: onClick
      }, accessibilityProps, {
        className: "".concat(prefixCls, "-item-container")
      }), react_default.a.createElement("div", {
        className: "".concat(prefixCls, "-item-tail")
      }, tailContent), react_default.a.createElement("div", {
        className: "".concat(prefixCls, "-item-icon")
      }, this.renderIconNode()), react_default.a.createElement("div", {
        className: "".concat(prefixCls, "-item-content")
      }, react_default.a.createElement("div", {
        className: "".concat(prefixCls, "-item-title")
      }, title, subTitle && react_default.a.createElement("div", {
        title: subTitle,
        className: "".concat(prefixCls, "-item-subtitle")
      }, subTitle)), description && react_default.a.createElement("div", {
        className: "".concat(prefixCls, "-item-description")
      }, description))));
    }
  }]);

  return Step;
}(react_default.a.Component);

Step_defineProperty(Step_Step, "propTypes", {
  className: prop_types_default.a.string,
  prefixCls: prop_types_default.a.string,
  style: prop_types_default.a.object,
  wrapperStyle: prop_types_default.a.object,
  itemWidth: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  active: prop_types_default.a.bool,
  disabled: prop_types_default.a.bool,
  status: prop_types_default.a.string,
  iconPrefix: prop_types_default.a.string,
  icon: prop_types_default.a.node,
  adjustMarginRight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  stepNumber: prop_types_default.a.string,
  stepIndex: prop_types_default.a.number,
  description: prop_types_default.a.any,
  title: prop_types_default.a.any,
  subTitle: prop_types_default.a.any,
  progressDot: prop_types_default.a.oneOfType([prop_types_default.a.bool, prop_types_default.a.func]),
  tailContent: prop_types_default.a.any,
  icons: prop_types_default.a.shape({
    finish: prop_types_default.a.node,
    error: prop_types_default.a.node
  }),
  onClick: prop_types_default.a.func,
  onStepClick: prop_types_default.a.func
});


// CONCATENATED MODULE: ../node_modules/rc-steps/es/index.js
/* concated harmony reexport Step */__webpack_require__.d(__webpack_exports__, "Step", function() { return Step_Step; });


Steps_Steps.Step = Step_Step;

/* harmony default export */ var es = __webpack_exports__["default"] = (Steps_Steps);

/***/ }),

/***/ "942r":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__("xARA");

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _CSSTransitionGroup = __webpack_require__("snpA");

var _CSSTransitionGroup2 = _interopRequireDefault(_CSSTransitionGroup);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _handleWindowClickListeners = __webpack_require__("wHgh");

var _handleWindowClickListeners2 = _interopRequireDefault(_handleWindowClickListeners);

var _getSelectedTextPosition = __webpack_require__("lLgq");

var _getSelectedTextPosition2 = _interopRequireDefault(_getSelectedTextPosition);

var _getScroll = __webpack_require__("lQ3I");

var _getScroll2 = _interopRequireDefault(_getScroll);

var _viewport = __webpack_require__("WE6Q");

var _viewport2 = _interopRequireDefault(_viewport);

var _isOutOfBounds = __webpack_require__("L3SD");

var _isOutOfBounds2 = _interopRequireDefault(_isOutOfBounds);

var _anchorShape = __webpack_require__("gFhn");

var _anchorShape2 = _interopRequireDefault(_anchorShape);

var _fixedToShape = __webpack_require__("wp+c");

var _fixedToShape2 = _interopRequireDefault(_fixedToShape);

var _positionShape = __webpack_require__("fzjA");

var _positionShape2 = _interopRequireDefault(_positionShape);

var _HorizontalAnchors = __webpack_require__("uLv/");

var _HorizontalAnchors2 = _interopRequireDefault(_HorizontalAnchors);

var _VerticalAnchors = __webpack_require__("t1Fj");

var _VerticalAnchors2 = _interopRequireDefault(_VerticalAnchors);

var _Positions = __webpack_require__("w/sC");

var _Positions2 = _interopRequireDefault(_Positions);

var _ResizeObserver = __webpack_require__("XSm6");

var _ResizeObserver2 = _interopRequireDefault(_ResizeObserver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Layover component is used to keep a component fixed to another component
 * while the page is scrolling or a container is scrolling. When the fixed component
 * is considered out of view, it will be closed.
 *
 * > NOTE: Don't look at source code. Plz.
 */
var Layover = function (_PureComponent) {
  _inherits(Layover, _PureComponent);

  function Layover(props) {
    _classCallCheck(this, Layover);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this));

    _initialiseProps.call(_this);

    var child = _react2.default.Children.only(props.children);
    _this.state = {
      below: false,
      right: false,
      styles: child.props.style
    };

    _this._lastXFix = null;
    _this._lastYFix = null;
    _this._initialX = null;
    _this._initialY = null;
    _this._initialTop = null;
    _this._initialLeft = null;
    _this._child = null;
    _this._toggle = null;
    return _this;
  }

  Layover.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    if (false) {}

    var _props = this.props,
        visible = _props.visible,
        fixedTo = _props.fixedTo,
        sameWidth = _props.sameWidth,
        centered = _props.centered,
        simplified = _props.simplified;

    var anchor = this._getAnchor(this.props);
    if (visible) {
      (0, _handleWindowClickListeners2.default)(this._handleOutsideClick, true);

      // Don't worry about any of the other logic for a "simple" layover
      if (simplified) {
        return;
      }

      var rect = this._contextRect || this._toggle.getBoundingClientRect();
      if (this._dialog) {
        this._manageFixedToListener(this._dialog, true);
      } else if (!this._inFixed) {
        this._manageFixedToListener(fixedTo, true);
      }

      this._init(fixedTo, anchor, sameWidth, centered, rect);
    }
  };

  Layover.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var fixedTo = nextProps.fixedTo,
        visible = nextProps.visible,
        children = nextProps.children,
        sameWidth = nextProps.sameWidth,
        centered = nextProps.centered,
        simplified = nextProps.simplified;

    if (simplified) {
      if (this.props.simplified !== simplified) {
        this._reset();
      }
      return;
    }

    var anchor = this._getAnchor(nextProps);
    var visibileDiff = visible !== this.props.visible;
    var childStyle = _react2.default.Children.only(children).props.style;

    if (visibileDiff) {
      if (!visible) {
        this._reset();
      } else {
        // Initialize the layover logic
        var rect = this._contextRect || this._toggle.getBoundingClientRect();
        if (this._dialog) {
          this._manageFixedToListener(this._dialog, true);
        } else if (!this._inFixed) {
          this._manageFixedToListener(fixedTo, true);
        }

        this._init(fixedTo, anchor, sameWidth, centered, rect);
      }
    } else if (fixedTo !== this.props.fixedTo && visible) {
      // swap the fixedTo listeners
      this._manageFixedToListener(this.props.fixedTo, false);
      this._manageFixedToListener(fixedTo, true);
    } else if (childStyle !== _react2.default.Children.only(this.props.children).props.style) {
      // Re-merge styles... This is only required if all the others fail since all the other
      // logic always merges styles with the children styles
      this.setState({ styles: _extends({}, this.state.styles, childStyle) });
    }
  };

  Layover.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this3 = this;

    var _props2 = this.props,
        visible = _props2.visible,
        closeOnOutsideClick = _props2.closeOnOutsideClick;

    var enabled = visible && closeOnOutsideClick;
    var prevEnabled = prevProps.visible && prevProps.closeOnOutsideClick;
    if (enabled !== prevEnabled) {
      if (this._clickTimeout) {
        clearTimeout(this._clickTimeout);
        this._clickTimeout = null;
      }

      // This is really an arbitrary timeout time, but firefox needs to have a timeout
      // so the context menu doesn't close automatically due to an "outside click" being
      // triggered
      this._clickTimeout = setTimeout(function () {
        _this3._clickTimeout = null;
        (0, _handleWindowClickListeners2.default)(_this3._handleOutsideClick, enabled);
      }, enabled ? 300 : 0);
    }
  };

  Layover.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._clickTimeout) {
      clearTimeout(this._clickTimeout);
      this._clickTimeout = null;
    }
    (0, _handleWindowClickListeners2.default)(this._handleOutsideClick, false);

    if (!this.props.simplified) {
      this._manageFixedToListener(this.props.fixedTo, false);
      this._manageWindowResizeListener(false);
    }
  };

  Layover.prototype._getAnchor = function _getAnchor(_ref) {
    var anchor = _ref.anchor,
        belowAnchor = _ref.belowAnchor,
        animationPosition = _ref.animationPosition;

    return animationPosition === Layover.Positions.BELOW && belowAnchor || anchor;
  };

  /**
   * Whew. Ok. So since the fixedTo prop can either be two elements or a single item,
   * this utility function is used to add/remove the scrolling event listeners for
   * this prop.
   *
   * When the fixedTo prop has a horizontal and/or vertical attribute, the `window`
   * will be the fallback option. If both the horizontal and vertical attributes are
   * defined, the `window` still needs to have a scroll listener to make sure it
   * doesn't go off screen.
   */


  /**
   * This is just a simple utility function to merge the existing state styles,
   * any new styles, and the children's styles (with most precedence).
   */


  /**
   * This initializes the popover with the default styles, and the initial bookkeeping
   * variables to update while it is open.
   */


  /**
   * Attempts to fix the child by setting it's location ONLY for the entire
   * page viewport. I didn't bother attempting to fix it for additional fixedTo
   * stuff.
   */


  /**
   * When the child is initially mounted, it will update the styles for centering
   * the element (if enabled) and then attempt to fix any viewport issues.
   */


  /**
   * This is the meat of the stuff. Do lots of viewport / container checks to make sure
   * the element should still be visible. If it is still visible, it will update its
   * x and y position for the new scroll position.
   */


  /**
   * Attempts to fix a viewport problem by swapping the positioning. This only does
   * vertical switching right now.
   *
   * @param {Object} vp - The result of the viewport function
   * @return {boolean} true if the fix was able to be done and successful.
   */


  Layover.prototype.render = function render() {
    var _props3 = this.props,
        className = _props3.className,
        block = _props3.block,
        toggle = _props3.toggle,
        visible = _props3.visible,
        children = _props3.children,
        fullWidth = _props3.fullWidth,
        animationPosition = _props3.animationPosition,
        simplified = _props3.simplified,
        fillViewportWidth = _props3.fillViewportWidth,
        fillViewportHeight = _props3.fillViewportHeight,
        anchor = _props3.anchor,
        belowAnchor = _props3.belowAnchor,
        onClose = _props3.onClose,
        repositionOnScroll = _props3.repositionOnScroll,
        repositionOnResize = _props3.repositionOnResize,
        sameWidth = _props3.sameWidth,
        centered = _props3.centered,
        fixedTo = _props3.fixedTo,
        toggleQuery = _props3.toggleQuery,
        yThreshold = _props3.yThreshold,
        xThreshold = _props3.xThreshold,
        onContextMenu = _props3.onContextMenu,
        preventContextMenu = _props3.preventContextMenu,
        closeOnOutsideClick = _props3.closeOnOutsideClick,
        minLeft = _props3.minLeft,
        minRight = _props3.minRight,
        minBottom = _props3.minBottom,
        props = _objectWithoutProperties(_props3, ['className', 'block', 'toggle', 'visible', 'children', 'fullWidth', 'animationPosition', 'simplified', 'fillViewportWidth', 'fillViewportHeight', 'anchor', 'belowAnchor', 'onClose', 'repositionOnScroll', 'repositionOnResize', 'sameWidth', 'centered', 'fixedTo', 'toggleQuery', 'yThreshold', 'xThreshold', 'onContextMenu', 'preventContextMenu', 'closeOnOutsideClick', 'minLeft', 'minRight', 'minBottom']);

    var child = void 0;
    var childId = void 0;
    if (visible) {
      child = _react2.default.Children.only(children);
      if (child.props.id) {
        childId = child.props.id;
      } else if (props.id) {
        childId = props.id + '-layover';
      }

      child = _react2.default.cloneElement(children, {
        ref: this._fixateChild,
        id: childId,
        style: simplified ? child.props.style : this.state.styles,
        className: (0, _classnames2.default)('md-layover-child md-layover-child--' + animationPosition, {
          'md-layover-child--simplified': simplified
        }, child.props.className)
      });
    }

    var observer = null;
    if (!simplified && !fillViewportWidth && !fillViewportHeight) {
      observer = _react2.default.createElement(_ResizeObserver2.default, {
        watchWidth: !fillViewportWidth,
        watchHeight: !fillViewportHeight,
        target: this._child,
        onResize: this._handleResize
      });
    }

    return _react2.default.createElement(
      _CSSTransitionGroup2.default,
      _extends({}, props, {
        className: (0, _classnames2.default)('md-layover', {
          'md-layover--simplified': simplified,
          'md-inline-block': !block && !fullWidth,
          'md-full-width': fullWidth
        }, className),
        ref: this._setContainer,
        'aria-haspopup': true,
        'aria-owns': childId,
        'aria-expanded': visible,
        transitionEnter: props.transitionEnterTimeout !== 0,
        transitionLeave: props.transitionLeaveTimeout !== 0,
        onContextMenu: this._handleContextMenu
      }),
      observer,
      toggle,
      child
    );
  };

  return Layover;
}(_react.PureComponent);

Layover.HorizontalAnchors = _HorizontalAnchors2.default;
Layover.VerticalAnchors = _VerticalAnchors2.default;
Layover.Positions = _Positions2.default;
Layover.propTypes = {
  /**
   * A id to give the layover itself. This is generally recommended for accessibility. If the
   * child does not have an id, the child will automatically be updated to be `${id}-layover`.
   */
  id: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),

  /**
   * An optional style to apply to the layover.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply to the layover.
   */
  className: _propTypes2.default.string,

  /**
   * Boolean if the layover's child is currently visible.
   */
  visible: _propTypes2.default.bool.isRequired,

  /**
   * This should either be a single element or two elements that the layover recalculates
   * its fixed position when scrolling for horizontal and vertical.
   *
   * When it is a single element, it will recalculate for both horizontal and vertical
   * scrolling. Otherwise, you can specify the element for horizontal scrolling and a
   * separate element for vertical scrolling. If one is omitted, it will default to `window`.
   *
   * If the component is no longer considered to be in view after scrolling, the `onClose`
   * prop will be called.
   */
  fixedTo: _fixedToShape2.default.isRequired,

  /**
   * The renderable item that causes the Layover to become visible. This _should_
   * most likely be an `element` or `arrayOf(element)`, but anything is allowed.
   */
  toggle: _propTypes2.default.node,

  /**
   * Since the `toggle` prop can be anything, I need a way to be able to find an
   * element to base all the calculations on. This can either be a string that
   * gets passed to `layover.querySelector`, a DOM Element, or a function that
   * returns a DOM Element.
   */
  toggleQuery: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.object, _propTypes2.default.string]).isRequired,

  /**
   * A single child that should be fixed to the toggle element.
   */
  children: _propTypes2.default.element.isRequired,

  /**
   * Boolean if the Layover should be displayed as a block instead of as an inline block.
   */
  block: _propTypes2.default.bool,

  /**
   * Boolean if the `children` should be centered horizontally and vertically while keeping
   * its height in mind as well. This is *only* valid if both the x and y `anchor` targets
   * are `CENTER`.
   */
  centered: _propTypes2.default.bool,

  /**
   * Boolean if the layover should gain the `md-full-width` class name.
   */
  fullWidth: _propTypes2.default.bool,

  /**
   * Boolean if the width of the children should be updated automatically to be the width
   * of the toggle element.
   */
  sameWidth: _propTypes2.default.bool,

  /**
   * The minimum value the `left` style can be for the child component. This is really just used
   * to make sure it doesn't scroll off the left of the page. It can also be used to make
   * full screen layovers on devices when when the `fillViewportWidth` prop is enabled.
   *
   * This can either be a number of pixels or a string for percentages. If this value is a string
   * **it will always be used over the calculated values** so it is preferred to use a number.
   *
   * @see {@link #minRight}
   * @see {@link #fillViewportWidth}
   */
  minLeft: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]).isRequired,

  /**
   * The minimum value the `right` style can be for the child component. This is really just used
   * to make sure it doesn't scroll off the right of the page when the `fillViewportWidth` prop is
   * enabled.
   *
   * This can either be a number of pixels or a string for percentages. If this value is a string
   * **it will always be used over the calculated values** so it is preferred to use a number.
   *
   * @see {@link #minLeft}
   * @see {@link #fillViewportWidth}
   */
  minRight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]).isRequired,

  /**
   * The minimum value that can be used for the `bottom` prop when the `fillViewportHeight` prop is enabled.
   * It is generally recommended to keep this value at `0` to keep it stretched to the bottom of the viewport
   * or setting it to a small positive number to add some padding.
   *
   * This can either be a number of pixels or a string for percentages. If this value is a string
   * **it will always be used over the calculated values** so it is preferred to use a number.
   *
   * @see {@link #fillViewportHeight}
   */
  minBottom: _propTypes2.default.number.isRequired,

  /**
   * Boolean if the layover should make the child fill the entire viewport's width. This will just
   * style the child element with:
   *
   * ```js
   * childStyle = {
   *   left: this.props.minLeft,
   *   right: this.props.minRight,
   * };
   * ```
   *
   * If you add any additional constraints such as `width` or `max-width`, it will not span the entire viewport's
   * width. This prop should generally really only be used on mobile devices. Using this prop along with
   * `fillViewportHeight` for Autocompletes can create great Android mobile searches. See the `fillViewportHeight`
   * for more information about why it is *only Android*.
   *
   * @see {@link #minLeft}
   * @see {@link #minRight}
   * @see {@link #fillViewportHeight}
   */
  fillViewportWidth: _propTypes2.default.bool,

  /**
   * Boolean if the layover should fill the height of the viewport from the current calculated `top`. This will just
   * style the child element with:
   *
   * ```js
   * childStyle = {
   *   top: currentCalculatedTop,
   *   bottom: this.props.minBottom,
   *   maxHeight: 'none',
   * };
   * ```
   *
   * This is *super* nice on Android devices since it will allow you to create nice toolbar search autocompletes
   * in your app and the list of items will grow until it reaches the soft keyboard. It isn't as nice on iOS since
   * iOS does not subtract the soft keyboard from the viewport's size so the list will still extend to the bottom
   * of the page.
   *
   * @see {@link #minBottom}
   * @see {@link #fillViewportWidth}
   */
  fillViewportHeight: _propTypes2.default.bool,

  /**
   * A function used to hide the visibility of the children when the children are no longer
   * visible or an element outside of the layover is clicked.
   */
  onClose: _propTypes2.default.func.isRequired,

  /**
   * The component to render the Layover as.
   */
  component: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]).isRequired,

  /**
   * The transition name to use for the children appearing/disappearing.
   */
  transitionName: _propTypes2.default.string.isRequired,

  /**
   * The transition duration for the enter animation. The animation can be disabled by setting
   * this value to 0.
   */
  transitionEnterTimeout: _propTypes2.default.number.isRequired,

  /**
   * The transition duration for the leave animation. The animation can be disabled by setting
   * this value to 0.
   */
  transitionLeaveTimeout: _propTypes2.default.number.isRequired,

  /**
   * This is a threshold that is used to calculate if the `children` is still in
   * view by applying this multiplier to the `children`'s width.
   */
  xThreshold: _propTypes2.default.number.isRequired,

  /**
   * This is a threshold that is used to calculate if the `children` is still in
   * view by applying this multiplier to the `toggle`'s height.
   */
  yThreshold: _propTypes2.default.number.isRequired,

  /**
   * Boolean if the `children` should be hidden when an element outside
   * of the `Layout` component has been clicked.
   */
  closeOnOutsideClick: _propTypes2.default.bool.isRequired,

  /**
   * This is how the children get "anchored" to the `toggle` element and how the
   * auto-fix attempts will be made. Right now, the auto fixes will only be handled
   * on viewport boundaries instead of `fixedTo` boundaries. It was too hard for
   * first attempt.
   *
   * The general behavior will be that an equal-opposite of an anchor will be chosen
   * when that direction is out of viewport. So for example, the children are out
   * of viewport for the right of the screen, and the `anchor.x` value is
   * `Layover.HorizontalPositions.RIGHT`, the children will be swapped to be the `LEFT`
   * of the `toggle` component now.
   *
   * So a full list:
   * - `LEFT` / `RIGHT`
   * - `INNER_LEFT` / `INNER_RIGHT`
   * - `TOP` / `BOTTOM`
   *
   * The `CENTER` and `OVERLAP` positions can not be automatically adjusted.
   *
   * > To be safe, you should use the enum values for the `x` and `y` values.
   * @see {@link #VerticalAnchors}
   * @see {@link #HorizontalAnchors}
   */
  anchor: _anchorShape2.default.isRequired,

  /**
   * This is how the children get "anchored" when the `animationPositions` is set to `Layover.Positions.BELOW`.
   * Set this to `null` to continue using the base `anchor` prop instead of switching to this anchor.
   *
   * @see {@link #anchor}
   */
  belowAnchor: _anchorShape2.default,

  /**
   * This is the position that the children should animate from. It directly ties into
   * the `$md-layover-child-positions` Sass variable.
   */
  animationPosition: _positionShape2.default.isRequired,

  /**
   * If you would like the layover to interact as a context menu, provide this prop. It will
   * make the children appear relative to the context menu origin automatically.
   *
   * @see {@link #preventContextMenu}
   */
  onContextMenu: _propTypes2.default.func,

  /**
   * Boolean if the default behavior of the context menu should be prevented when using the
   * `onContextMenu` prop.
   *
   * @see {@link #onContextMenu}
   */
  preventContextMenu: _propTypes2.default.bool,

  /**
   * Boolean if the layover should attempt to automatically adjust the position of the element to
   * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called
   * instead.
   */
  repositionOnScroll: _propTypes2.default.bool,

  /**
   * Boolean if the layover should attempt to automatically adjust the position of the element to
   * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called
   * instead.
   */
  repositionOnResize: _propTypes2.default.bool,

  /**
   * Boolean if the layover should become "simplified". This basically disables all the logic for
   * keeping the child within the viewport and allows you to manage all the positioning via CSS.
   *
   * When this is enabled, it updates the `Layover` to have `position: relative` while the child will
   * have `position: absolute` which will allow for simple `top`, `right`, `bottom`, and/or `left` CSS
   * to position as wanted.
   *
   * This is really only helpful in cases where the layover can't calculate things correctly due to
   * being in fixed containers somewhere in the page or some other weird stuff. Hopefully this won't
   * really need to be used much.
   */
  simplified: _propTypes2.default.bool
};
Layover.defaultProps = {
  anchor: {
    x: Layover.HorizontalAnchors.INNER_LEFT,
    y: Layover.VerticalAnchors.OVERLAP
  },
  belowAnchor: {
    x: Layover.HorizontalAnchors.CENTER,
    y: Layover.VerticalAnchors.BOTTOM
  },
  animationPosition: Layover.Positions.BELOW,
  repositionOnScroll: true,
  repositionOnResize: false,
  component: 'div',
  fixedTo: typeof window !== 'undefined' ? window : {},
  toggleQuery: '.md-text-field-container,button,*[role="button"],*[role="listbox"]',
  transitionName: 'md-layover',
  transitionEnterTimeout: 200,
  transitionLeaveTimeout: 200,
  yThreshold: 0.38,
  xThreshold: 0.38,
  closeOnOutsideClick: true,
  preventContextMenu: true,
  simplified: false,
  minLeft: 0,
  minRight: 0,
  minBottom: 0,
  fillViewportWidth: false,
  fillViewportHeight: false
};

var _initialiseProps = function _initialiseProps() {
  var _this4 = this;

  this._isCenteredDialog = function () {
    return _this4._dialog && _this4._dialog.classList.contains('md-dialog--centered');
  };

  this._createStyles = function (anchor, centered, child, rect) {
    var x = anchor.x,
        y = anchor.y;
    var offsetWidth = child.offsetWidth,
        offsetHeight = child.offsetHeight;


    var left = void 0;
    var top = void 0;
    if (x === _HorizontalAnchors2.default.CENTER) {
      left = rect.left + rect.width / 2 - offsetWidth / 2;
    } else if (x === _HorizontalAnchors2.default.INNER_RIGHT) {
      left = rect.right - offsetWidth;
    } else if (x === _HorizontalAnchors2.default.LEFT) {
      left = rect.left - offsetWidth;
    } else if (x === _HorizontalAnchors2.default.RIGHT) {
      left = rect.right;
    }

    if (centered && x === _HorizontalAnchors2.default.CENTER && y === _VerticalAnchors2.default.CENTER) {
      top = rect.top - offsetHeight / 2 + rect.height / 2;
    } else if (y === _VerticalAnchors2.default.TOP) {
      top = rect.top - offsetHeight;
    } else if (y === _VerticalAnchors2.default.CENTER) {
      top = rect.top + rect.height / 2;
    } else if (y === _VerticalAnchors2.default.BOTTOM) {
      top = rect.bottom;
    }

    if (_this4._isCenteredDialog()) {
      var dialogRect = _this4._dialog.getBoundingClientRect();
      left -= dialogRect.left;
      top -= dialogRect.top;
    }

    var style = {};
    if (top) {
      style.top = top;
    }

    if (left) {
      style.left = left;
    }

    return style;
  };

  this._manageFixedToListener = function (fixedTo, add) {
    var listener = (add ? 'add' : 'remove') + 'EventListener';
    if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {
      var x = fixedTo.x,
          y = fixedTo.y;

      if (x) {
        x[listener]('scroll', _this4._handleScroll);
      } else {
        window[listener]('scroll', _this4._handleScroll);
      }

      if (y) {
        y[listener]('scroll', _this4._handleScroll);
      } else if (!x) {
        // Only add the window event listener once
        window[listener]('scroll', _this4._handleScroll);
      }

      if (y && y !== window && x && x !== window) {
        window[listener]('scroll', _this4._handleScroll);
      }
    } else {
      fixedTo[listener]('scroll', _this4._handleScroll);

      if (fixedTo !== window) {
        window[listener]('scroll', _this4._handleScroll);
      }
    }
  };

  this._manageWindowResizeListener = function (enabled) {
    if (_this4._windowResizeTimeout) {
      clearTimeout(_this4._windowResizeTimeout);
      _this4._windowResizeTimeout = null;
    }

    if (enabled) {
      // add a 2 second delay before watching resize events since Android soft keyboards trigger a resize event.
      _this4._windowResizeTimeout = setTimeout(function () {
        _this4._windowResizeTimeout = null;
        window.addEventListener('resize', _this4._handleWindowResize);
      }, 2000);
    } else {
      window.removeEventListener('resize', _this4._handleWindowResize);
    }
  };

  this._mergeStyles = function (style) {
    var _props4 = _this4.props,
        minLeft = _props4.minLeft,
        minRight = _props4.minRight,
        minBottom = _props4.minBottom,
        fillViewportWidth = _props4.fillViewportWidth,
        fillViewportHeight = _props4.fillViewportHeight;

    if (fillViewportWidth) {
      style.left = minLeft;
      style.right = minRight;
    } else {
      if (style.left) {
        style.left = Math.max(minLeft, style.left);
      }

      if (style.right) {
        style.right = Math.max(minRight, style.right);
      }
    }

    if (fillViewportHeight) {
      style.bottom = minBottom;
      style.maxHeight = 'none';
    } else {
      // These styles are only created when filling the viewport height, so clear
      // them out again
      style.bottom = null;
      style.maxHeight = null;
    }

    return _extends({}, _this4.state.styles, style, _react2.default.Children.only(_this4.props.children).props.style);
  };

  this._init = function (fixedTo, anchor, sameWidth, centered, rect) {
    if (_this4._child) {
      // The init function can be called again if the user quickly toggles the layover. If that
      // is the case, we want the styles that were set after the _positionChild _attemptFix.
      return;
    }

    var height = rect.height,
        width = rect.width;
    var top = rect.top,
        left = rect.left,
        right = rect.right;

    var x = void 0;
    var y = void 0;
    if (_this4._dialog) {
      var scroll = (0, _getScroll2.default)(_this4._dialog);
      x = scroll.x;
      y = scroll.y;

      if (_this4._isCenteredDialog()) {
        var dialogRect = _this4._dialog.getBoundingClientRect();
        left -= dialogRect.left;
        top -= dialogRect.top;
        right -= dialogRect.right;
      }
    } else if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {
      x = (0, _getScroll2.default)(fixedTo.x || window).x;
      y = (0, _getScroll2.default)(fixedTo.y || window).y;
    } else {
      var _scroll = (0, _getScroll2.default)(fixedTo);
      x = _scroll.x;
      y = _scroll.y;
    }

    _this4._initialX = x;
    _this4._initialY = y;
    _this4._initialLeft = left;
    _this4._initialTop = top;

    if (anchor.x === _HorizontalAnchors2.default.INNER_RIGHT) {
      _this4._initialLeft = left + width;
    } else if (anchor.x === _HorizontalAnchors2.default.RIGHT) {
      _this4._initialLeft = right;
    }

    if (!centered) {
      _this4._lastYFix = anchor.y === _VerticalAnchors2.default.TOP ? 'bottom' : 'top';
    } else {
      // Centered is not fixable
      _this4._lastYFix = null;
    }
    if (anchor.x === _HorizontalAnchors2.default.LEFT || anchor.x === _HorizontalAnchors2.default.INNER_LEFT) {
      _this4._lastXFix = 'right';
    } else if (anchor.x === _HorizontalAnchors2.default.RIGHT || anchor.x === _HorizontalAnchors2.default.INNER_RIGHT) {
      _this4._lastXFix = 'left';
    } else {
      // Can't fix others
      _this4._lastXFix = null;
    }

    if (anchor.y === _VerticalAnchors2.default.BOTTOM) {
      _this4._initialTop = top + height;
    }

    if (fixedTo !== window && !fixedTo.y && !fixedTo.x) {
      var _scroll2 = (0, _getScroll2.default)(window);
      _this4._initialWinX = _scroll2.x;
      _this4._initialWinY = _scroll2.y;
    }

    var styles = _this4._mergeStyles({
      left: _this4._initialLeft,
      top: _this4._initialTop,
      transformOrigin: undefined,
      width: sameWidth ? width : undefined
    });

    _this4.setState({ styles: styles });
  };

  this._reset = function () {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this4.props,
        fixedTo = _ref2.fixedTo;

    // Reset all the bookkeeping variables for a fresh start on re-visible
    _this4._lastXFix = null;
    _this4._lastYFix = null;
    _this4._initialX = null;
    _this4._initialY = null;
    _this4._initialTop = null;
    _this4._initialLeft = null;

    if (!_this4._inFixed) {
      if (_this4._dialog) {
        _this4._manageFixedToListener(_this4._dialog, false);
      }

      _this4._manageFixedToListener(fixedTo, false);
    }
  };

  this._setContainer = function (container) {
    _this4._container = (0, _reactDom.findDOMNode)(container);
    _this4._toggle = null;
    if (!_this4._container) {
      return;
    }

    var _props5 = _this4.props,
        toggleQuery = _props5.toggleQuery,
        onContextMenu = _props5.onContextMenu;

    if (typeof toggleQuery === 'function') {
      _this4._toggle = toggleQuery();
    } else if (typeof toggleQuery === 'string') {
      _this4._toggle = _this4._container.querySelector(toggleQuery);
    } else {
      _this4._toggle = toggleQuery;
    }

    if (!_this4._toggle && !onContextMenu && "production" !== 'production') {
      var error = new Error('Unable to find a toggle component with the provided `toggleQuery` and `toggle` element. \n' + ('`toggleQuery`: `' + toggleQuery + '`'));
      error.toggleQuery = toggleQuery;
      error.toggle = _this4.props.toggle;

      throw error;
    }

    var node = _this4._container;
    while (node) {
      var fixed = window.getComputedStyle(node).position === 'fixed';
      if (fixed && node.className.match(/md-dialog--(full-page|centered)/)) {
        _this4._dialog = node;
        return;
      } else if (fixed && !node.classList.contains('md-layover-child')) {
        _this4._inFixed = true;
        return;
      }

      node = node.offsetParent;
    }
  };

  this._initialFix = function () {
    // Need to make a clone that disables any transitions to calculate positioning stuff
    var clone = _this4._child.cloneNode(true);
    clone.style.webkitTransform = 'none';
    clone.style.transfrom = 'none';
    clone.style.webkitTransition = 'none';
    clone.style.transition = 'none';

    _this4._child.parentNode.appendChild(clone);
    var vp = (0, _viewport2.default)(clone);
    var childHeight = clone.offsetHeight,
        childWidth = clone.offsetWidth;

    _this4._child.parentNode.removeChild(clone);

    if (vp === true || !_this4._toggle || !_this4._child) {
      return;
    }

    var _getAnchor2 = _this4._getAnchor(_this4.props),
        x = _getAnchor2.x,
        y = _getAnchor2.y;

    var toggleHeight = void 0;
    var toggleWidth = void 0;
    if (_this4._contextRect) {
      toggleHeight = _this4._contextRect.height;
      toggleWidth = _this4._contextRect.width;
    } else {
      toggleHeight = _this4._toggle.offsetHeight;
      toggleWidth = _this4._toggle.offsetWidth;
    }

    var addToTop = 0;
    var addToLeft = 0;

    // Android devices will never get this far because they consider the keyboard as part
    // of the viewport, iOS will and cause it to be a giant negative number. *sigh*
    // Prevent any additional vertical positioning for iOS
    if (!_this4.props.fillViewportHeight && (!vp.top || !vp.bottom)) {
      var multiplier = vp.top ? -1 : 1;
      if (!vp.bottom && y === _VerticalAnchors2.default.OVERLAP) {
        addToTop += toggleHeight;
      } else if (y === _VerticalAnchors2.default.TOP || y === _VerticalAnchors2.default.BOTTOM) {
        addToTop += multiplier * toggleHeight;
      }

      addToTop += multiplier * childHeight;

      _this4._lastYFix = vp.top ? 'bottom' : 'top';
    }

    if (!_this4.props.fillViewportWidth && x !== _HorizontalAnchors2.default.CENTER && (!vp.left || !vp.right)) {
      if (!vp.left && x === _HorizontalAnchors2.default.LEFT) {
        addToLeft += toggleWidth + childWidth;
        _this4._lastXFix = 'left';
      } else if (!vp.left && x === _HorizontalAnchors2.default.INNER_LEFT) {
        addToLeft += toggleWidth;
        _this4._lastXFix = 'left';
      } else if (!vp.right && x === _HorizontalAnchors2.default.RIGHT) {
        addToLeft -= toggleWidth + childWidth;
        _this4._lastXFix = 'right';
      } else if (!vp.right && x === _HorizontalAnchors2.default.INNER_RIGHT) {
        addToLeft -= toggleWidth;
        _this4._lastXFix = 'right';
      }
    }

    if (addToTop !== 0 || addToLeft !== 0) {
      _this4._initialTop += addToTop;
      _this4._initialLeft += addToLeft;

      _this4.setState({ styles: _this4._mergeStyles({ top: _this4._initialTop, left: _this4._initialLeft }) });
    }
  };

  this._fixateChild = function (child) {
    _this4._child = (0, _reactDom.findDOMNode)(child);

    if (_this4._child !== null) {
      _this4._childComponent = _react2.default.Children.only(_this4.props.children);

      // If child also has a ref callback, simulate the same thing
      if (typeof _this4._childComponent.ref === 'function') {
        _this4._childComponent.ref(child);
      }

      if (_this4.props.simplified || !_this4._child || !_this4._toggle && !_this4._contextRect) {
        return;
      }

      if (_this4._dialog && _this4._dialog.classList.contains('md-dialog--centered')) {
        return;
      }

      _this4._manageWindowResizeListener(true);
      _this4._positionChild();
    } else if (_this4._childComponent && typeof _this4._childComponent.ref === 'function') {
      _this4._childComponent.ref(child);
    }
  };

  this._positionChild = function () {
    var centered = _this4.props.centered;

    var anchor = _this4._getAnchor(_this4.props);
    var rect = _this4._contextRect || _this4._toggle.getBoundingClientRect();
    _this4._height = rect.height;
    _this4._width = rect.width;
    var styles = _this4._createStyles(anchor, centered, _this4._child, rect);
    if (styles.top || styles.left) {
      _this4._initialLeft = styles.left || _this4._initialLeft;
      _this4._initialTop = styles.top || _this4._initialTop;
      _this4.setState({ styles: _this4._mergeStyles(styles) }, _this4._initialFix);
    } else {
      _this4._initialFix();
    }
  };

  this._handleResize = function () {
    if (_this4.props.visible) {
      _this4._positionChild();
    }
  };

  this._handleScroll = function (e) {
    if (!_this4.props.repositionOnScroll) {
      _this4._manageFixedToListener(_this4.props.fixedTo, false);
      _this4.props.onClose(e);
    }

    if (!_this4._ticking) {
      requestAnimationFrame(function () {
        return _this4._handleTick(e);
      });
    }

    _this4._ticking = true;
  };

  this._handleTick = function (e) {
    var _props6 = _this4.props,
        fixedTo = _props6.fixedTo,
        xThreshold = _props6.xThreshold,
        yThreshold = _props6.yThreshold;

    var vp = (0, _viewport2.default)(_this4._child);
    if (vp !== true && vp.left && vp.right) {
      var fixed = !_this4._contextRect && _this4._attemptFix(vp);
      if (!fixed) {
        _this4.props.onClose(e);
        _this4._ticking = false;
      }

      return;
    } else if ((0, _isOutOfBounds2.default)(fixedTo, _this4._child, _this4._toggle, yThreshold, xThreshold)) {
      _this4.props.onClose(e);
      _this4._ticking = false;
      return;
    }

    var x = void 0;
    var y = void 0;
    if (_this4._dialog) {
      var scroll = (0, _getScroll2.default)(_this4._dialog);
      x = scroll.x;
      y = scroll.y;
    } else if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {
      x = (0, _getScroll2.default)(fixedTo.x || window).x;
      y = (0, _getScroll2.default)(fixedTo.y || window).y;
    } else {
      var _scroll3 = (0, _getScroll2.default)(fixedTo);
      x = _scroll3.x;
      y = _scroll3.y;
    }

    var winX = void 0;
    var winY = void 0;
    // When using the additional fixedTo stuff, need to also keep track of the entire
    // window's scrolling..
    if (fixedTo !== window && !fixedTo.x && !fixedTo.y) {
      var _scroll4 = (0, _getScroll2.default)(window);
      winX = _scroll4.x;
      winY = _scroll4.y;
    }

    var styles = _this4.state.styles;
    var left = styles.left,
        top = styles.top;

    if (_this4._initialX !== x) {
      left = _this4._initialX - x + _this4._initialLeft;
    }

    if (winX && _this4._initialWinX !== winX) {
      left = _this4._initialWinX - winX + _this4._initialX;
    }

    if (_this4._initialY !== y) {
      top = _this4._initialY - y + _this4._initialTop;
    }

    if (winY && _this4._initialWinY !== winY) {
      top = _this4._initialWinY - winY + _this4._initialTop + (_this4._initialY - y);
    }

    if (styles.top !== top || styles.left !== left) {
      _this4.setState({ styles: _this4._mergeStyles({ left: left, top: top }) }, function () {
        _this4._ticking = false;
      });
    } else {
      _this4._ticking = false;
    }
  };

  this._handleOutsideClick = function (e) {
    if (_this4._contextRect && _this4._child && !_this4._child.contains(e.target) || _this4._container && !_this4._container.contains(e.target)) {
      _this4.props.onClose(e);
    }
  };

  this._handleWindowResize = function (e) {
    var _props7 = _this4.props,
        onClose = _props7.onClose,
        repositionOnResize = _props7.repositionOnResize;

    if (repositionOnResize) {
      _this4._handleResize();
    } else {
      onClose(e);
      _this4._manageWindowResizeListener(false);
    }
  };

  this._attemptFix = function (vp) {
    var _getAnchor3 = _this4._getAnchor(_this4.props),
        x = _getAnchor3.x,
        y = _getAnchor3.y;

    var centered = x === _HorizontalAnchors2.default.CENTER && y === _VerticalAnchors2.default.CENTER && _this4.props.centered;
    if (centered || _this4._lastYFix === 'top' && !vp.top || _this4._lastYFix === 'bottom' && !vp.bottom) {
      return false;
    }

    var toggleTop = _this4._toggle.getBoundingClientRect().top;
    var toggleHeight = _this4._toggle.offsetHeight;
    var childHeight = _this4._child.offsetHeight;

    // Can;t fix if the child can't fit on the page based on the toggle's position

    if (toggleTop + toggleHeight + childHeight > window.innerHeight) {
      return false;
    }

    var _child$getBoundingCli = _this4._child.getBoundingClientRect(),
        top = _child$getBoundingCli.top;

    var newTop = _this4._initialTop;
    var addToTop = childHeight * (vp.top ? -1 : 1);
    if (y === _VerticalAnchors2.default.OVERLAP) {
      addToTop += (vp.top ? 1 : -1) * toggleHeight;
    } else if (y === _VerticalAnchors2.default.TOP || y === _VerticalAnchors2.default.BOTTOM) {
      addToTop += (_this4._lastYFix === 'top' ? -1 : 1) * toggleHeight;
    }

    if (addToTop !== 0) {
      newTop = top + addToTop;
      _this4._lastYFix = vp.top ? 'bottom' : 'top';
    }

    if (newTop !== _this4._initialTop) {
      _this4._initialTop = newTop;
      var fixedTo = _this4.props.fixedTo;

      var scrollEl = fixedTo;
      if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {
        scrollEl = fixedTo.y || window;
      }

      _this4._initialY = (0, _getScroll2.default)(scrollEl).y;

      _this4.setState({ styles: _this4._mergeStyles({ top: _this4._initialTop }) }, function () {
        _this4._ticking = false;
      });
      return true;
    }

    return false;
  };

  this._handleContextMenu = function (e) {
    var anchor = _this4._getAnchor(_this4.props);
    var _props8 = _this4.props,
        onContextMenu = _props8.onContextMenu,
        preventContextMenu = _props8.preventContextMenu,
        fixedTo = _props8.fixedTo,
        sameWidth = _props8.sameWidth,
        centered = _props8.centered,
        visible = _props8.visible;

    if (!onContextMenu) {
      return;
    }

    _this4._contextRect = (0, _getSelectedTextPosition2.default)(e);
    if (preventContextMenu && (!_this4._child || !_this4._child.contains(e.target))) {
      e.preventDefault();
    }

    onContextMenu(e);
    if (visible) {
      _this4._init(fixedTo, anchor, sameWidth, centered, _this4._contextRect);
    }
  };
};

exports.default = Layover;

/***/ }),

/***/ "9aUh":
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "9t1y":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.9.0
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__("mXGw"),m=__webpack_require__("IL7q"),q=__webpack_require__("4DfG");function t(a){for(var b=a.message,c="https://reactjs.org/docs/error-decoder.html?invariant="+b,d=1;d<arguments.length;d++)c+="&args[]="+encodeURIComponent(arguments[d]);a.message="Minified React error #"+b+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ";return a}if(!aa)throw t(Error(227));var ba=null,ca={};
function da(){if(ba)for(var a in ca){var b=ca[a],c=ba.indexOf(a);if(!(-1<c))throw t(Error(96),a);if(!ea[c]){if(!b.extractEvents)throw t(Error(97),a);ea[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],h=b,g=d;if(fa.hasOwnProperty(g))throw t(Error(99),g);fa[g]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&ha(k[e],h,g);e=!0}else f.registrationName?(ha(f.registrationName,h,g),e=!0):e=!1;if(!e)throw t(Error(98),d,a);}}}}
function ha(a,b,c){if(ia[a])throw t(Error(100),a);ia[a]=b;ja[a]=b.eventTypes[c].dependencies}var ea=[],fa={},ia={},ja={};function ka(a,b,c,d,e,f,h,g,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(n){this.onError(n)}}var la=!1,ma=null,na=!1,oa=null,pa={onError:function(a){la=!0;ma=a}};function qa(a,b,c,d,e,f,h,g,k){la=!1;ma=null;ka.apply(pa,arguments)}
function ra(a,b,c,d,e,f,h,g,k){qa.apply(this,arguments);if(la){if(la){var l=ma;la=!1;ma=null}else throw t(Error(198));na||(na=!0,oa=l)}}var sa=null,ta=null,va=null;function wa(a,b,c){var d=a.type||"unknown-event";a.currentTarget=va(c);ra(d,b,void 0,a);a.currentTarget=null}function xa(a,b){if(null==b)throw t(Error(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}
function ya(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var za=null;function Aa(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)wa(a,b[d],c[d]);else b&&wa(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function Ba(a){null!==a&&(za=xa(za,a));a=za;za=null;if(a){ya(a,Aa);if(za)throw t(Error(95));if(na)throw a=oa,na=!1,oa=null,a;}}
var Ca={injectEventPluginOrder:function(a){if(ba)throw t(Error(101));ba=Array.prototype.slice.call(a);da()},injectEventPluginsByName:function(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!ca.hasOwnProperty(c)||ca[c]!==d){if(ca[c])throw t(Error(102),c);ca[c]=d;b=!0}}b&&da()}};
function Da(a,b){var c=a.stateNode;if(!c)return null;var d=sa(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw t(Error(231),b,typeof c);
return c}var Ea=Math.random().toString(36).slice(2),Fa="__reactInternalInstance$"+Ea,Ga="__reactEventHandlers$"+Ea;function Ha(a){if(a[Fa])return a[Fa];for(;!a[Fa];)if(a.parentNode)a=a.parentNode;else return null;a=a[Fa];return 5===a.tag||6===a.tag?a:null}function Ia(a){a=a[Fa];return!a||5!==a.tag&&6!==a.tag?null:a}function Ja(a){if(5===a.tag||6===a.tag)return a.stateNode;throw t(Error(33));}function Ka(a){return a[Ga]||null}function La(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}
function Ma(a,b,c){if(b=Da(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=xa(c._dispatchListeners,b),c._dispatchInstances=xa(c._dispatchInstances,a)}function Na(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=La(b);for(b=c.length;0<b--;)Ma(c[b],"captured",a);for(b=0;b<c.length;b++)Ma(c[b],"bubbled",a)}}
function Oa(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Da(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=xa(c._dispatchListeners,b),c._dispatchInstances=xa(c._dispatchInstances,a))}function Pa(a){a&&a.dispatchConfig.registrationName&&Oa(a._targetInst,null,a)}function Qa(a){ya(a,Na)}var Ra=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement);
function Sa(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Ta={animationend:Sa("Animation","AnimationEnd"),animationiteration:Sa("Animation","AnimationIteration"),animationstart:Sa("Animation","AnimationStart"),transitionend:Sa("Transition","TransitionEnd")},Ua={},Va={};
Ra&&(Va=document.createElement("div").style,"AnimationEvent"in window||(delete Ta.animationend.animation,delete Ta.animationiteration.animation,delete Ta.animationstart.animation),"TransitionEvent"in window||delete Ta.transitionend.transition);function Wa(a){if(Ua[a])return Ua[a];if(!Ta[a])return a;var b=Ta[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Va)return Ua[a]=b[c];return a}
var Xa=Wa("animationend"),Ya=Wa("animationiteration"),Za=Wa("animationstart"),ab=Wa("transitionend"),bb="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),cb=null,db=null,eb=null;
function fb(){if(eb)return eb;var a,b=db,c=b.length,d,e="value"in cb?cb.value:cb.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var h=c-a;for(d=1;d<=h&&b[c-d]===e[f-d];d++);return eb=e.slice(a,1<d?1-d:void 0)}function gb(){return!0}function hb(){return!1}
function y(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?gb:hb;this.isPropagationStopped=hb;return this}
m(y.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=gb)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=gb)},persist:function(){this.isPersistent=gb},isPersistent:hb,destructor:function(){var a=this.constructor.Interface,
b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=hb;this._dispatchInstances=this._dispatchListeners=null}});y.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
y.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;m(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=m({},d.Interface,a);c.extend=d.extend;ib(c);return c};ib(y);function jb(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
function kb(a){if(!(a instanceof this))throw t(Error(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function ib(a){a.eventPool=[];a.getPooled=jb;a.release=kb}var lb=y.extend({data:null}),mb=y.extend({data:null}),nb=[9,13,27,32],ob=Ra&&"CompositionEvent"in window,pb=null;Ra&&"documentMode"in document&&(pb=document.documentMode);
var qb=Ra&&"TextEvent"in window&&!pb,sb=Ra&&(!ob||pb&&8<pb&&11>=pb),tb=String.fromCharCode(32),ub={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vb=!1;
function wb(a,b){switch(a){case "keyup":return-1!==nb.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function xb(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var yb=!1;function Ab(a,b){switch(a){case "compositionend":return xb(b);case "keypress":if(32!==b.which)return null;vb=!0;return tb;case "textInput":return a=b.data,a===tb&&vb?null:a;default:return null}}
function Bb(a,b){if(yb)return"compositionend"===a||!ob&&wb(a,b)?(a=fb(),eb=db=cb=null,yb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return sb&&"ko"!==b.locale?null:b.data;default:return null}}
var Cb={eventTypes:ub,extractEvents:function(a,b,c,d){var e=void 0;var f=void 0;if(ob)b:{switch(a){case "compositionstart":e=ub.compositionStart;break b;case "compositionend":e=ub.compositionEnd;break b;case "compositionupdate":e=ub.compositionUpdate;break b}e=void 0}else yb?wb(a,c)&&(e=ub.compositionEnd):"keydown"===a&&229===c.keyCode&&(e=ub.compositionStart);e?(sb&&"ko"!==c.locale&&(yb||e!==ub.compositionStart?e===ub.compositionEnd&&yb&&(f=fb()):(cb=d,db="value"in cb?cb.value:cb.textContent,yb=
!0)),e=lb.getPooled(e,b,c,d),f?e.data=f:(f=xb(c),null!==f&&(e.data=f)),Qa(e),f=e):f=null;(a=qb?Ab(a,c):Bb(a,c))?(b=mb.getPooled(ub.beforeInput,b,c,d),b.data=a,Qa(b)):b=null;return null===f?b:null===b?f:[f,b]}},Db=null,Eb=null,Fb=null;function Gb(a){if(a=ta(a)){if("function"!==typeof Db)throw t(Error(280));var b=sa(a.stateNode);Db(a.stateNode,a.type,b)}}function Hb(a){Eb?Fb?Fb.push(a):Fb=[a]:Eb=a}function Ib(){if(Eb){var a=Eb,b=Fb;Fb=Eb=null;Gb(a);if(b)for(a=0;a<b.length;a++)Gb(b[a])}}
function Jb(a,b){return a(b)}function Kb(a,b,c,d){return a(b,c,d)}function Lb(){}var Mb=Jb,Nb=!1;function Ob(){if(null!==Eb||null!==Fb)Lb(),Ib()}var Pb={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Qb(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Pb[a.type]:"textarea"===b?!0:!1}
function Rb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function Sb(a){if(!Ra)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Tb(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ub(a){var b=Tb(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function Vb(a){a._valueTracker||(a._valueTracker=Ub(a))}function Wb(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Tb(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Xb=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;Xb.hasOwnProperty("ReactCurrentDispatcher")||(Xb.ReactCurrentDispatcher={current:null});Xb.hasOwnProperty("ReactCurrentBatchConfig")||(Xb.ReactCurrentBatchConfig={suspense:null});
var Yb=/^(.*)[\\\/]/,B="function"===typeof Symbol&&Symbol.for,Zb=B?Symbol.for("react.element"):60103,$b=B?Symbol.for("react.portal"):60106,ac=B?Symbol.for("react.fragment"):60107,bc=B?Symbol.for("react.strict_mode"):60108,cc=B?Symbol.for("react.profiler"):60114,dc=B?Symbol.for("react.provider"):60109,ec=B?Symbol.for("react.context"):60110,fc=B?Symbol.for("react.concurrent_mode"):60111,gc=B?Symbol.for("react.forward_ref"):60112,hc=B?Symbol.for("react.suspense"):60113,ic=B?Symbol.for("react.suspense_list"):
60120,jc=B?Symbol.for("react.memo"):60115,kc=B?Symbol.for("react.lazy"):60116;B&&Symbol.for("react.fundamental");B&&Symbol.for("react.responder");var lc="function"===typeof Symbol&&Symbol.iterator;function mc(a){if(null===a||"object"!==typeof a)return null;a=lc&&a[lc]||a["@@iterator"];return"function"===typeof a?a:null}
function oc(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ac:return"Fragment";case $b:return"Portal";case cc:return"Profiler";case bc:return"StrictMode";case hc:return"Suspense";case ic:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case ec:return"Context.Consumer";case dc:return"Context.Provider";case gc:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":
"ForwardRef");case jc:return oc(a.type);case kc:if(a=1===a._status?a._result:null)return oc(a)}return null}function pc(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=oc(a.type);c=null;d&&(c=oc(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(Yb,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}
var qc=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,rc=Object.prototype.hasOwnProperty,sc={},tc={};
function uc(a){if(rc.call(tc,a))return!0;if(rc.call(sc,a))return!1;if(qc.test(a))return tc[a]=!0;sc[a]=!0;return!1}function vc(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
function wc(a,b,c,d){if(null===b||"undefined"===typeof b||vc(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function D(a,b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}var F={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){F[a]=new D(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];F[b]=new D(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){F[a]=new D(a,2,!1,a.toLowerCase(),null,!1)});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){F[a]=new D(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){F[a]=new D(a,3,!1,a.toLowerCase(),null,!1)});
["checked","multiple","muted","selected"].forEach(function(a){F[a]=new D(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){F[a]=new D(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){F[a]=new D(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){F[a]=new D(a,5,!1,a.toLowerCase(),null,!1)});var xc=/[\-:]([a-z])/g;function yc(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(xc,
yc);F[b]=new D(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(xc,yc);F[b]=new D(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(xc,yc);F[b]=new D(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){F[a]=new D(a,1,!1,a.toLowerCase(),null,!1)});
F.xlinkHref=new D("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){F[a]=new D(a,1,!1,a.toLowerCase(),null,!0)});
function zc(a,b,c,d){var e=F.hasOwnProperty(b)?F[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(wc(b,c,e,d)&&(c=null),d||null===e?uc(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}
function Ac(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function Bc(a,b){var c=b.checked;return m({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}
function Cc(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Ac(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function Dc(a,b){b=b.checked;null!=b&&zc(a,"checked",b,!1)}
function Ec(a,b){Dc(a,b);var c=Ac(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Fc(a,b.type,c):b.hasOwnProperty("defaultValue")&&Fc(a,b.type,Ac(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function Gc(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
function Fc(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}var Hc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function Ic(a,b,c){a=y.getPooled(Hc.change,a,b,c);a.type="change";Hb(c);Qa(a);return a}var Jc=null,Kc=null;function Lc(a){Ba(a)}
function Mc(a){var b=Ja(a);if(Wb(b))return a}function Nc(a,b){if("change"===a)return b}var Oc=!1;Ra&&(Oc=Sb("input")&&(!document.documentMode||9<document.documentMode));function Pc(){Jc&&(Jc.detachEvent("onpropertychange",Qc),Kc=Jc=null)}function Qc(a){if("value"===a.propertyName&&Mc(Kc))if(a=Ic(Kc,a,Rb(a)),Nb)Ba(a);else{Nb=!0;try{Jb(Lc,a)}finally{Nb=!1,Ob()}}}function Rc(a,b,c){"focus"===a?(Pc(),Jc=b,Kc=c,Jc.attachEvent("onpropertychange",Qc)):"blur"===a&&Pc()}
function Sc(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return Mc(Kc)}function Tc(a,b){if("click"===a)return Mc(b)}function Uc(a,b){if("input"===a||"change"===a)return Mc(b)}
var Vc={eventTypes:Hc,_isInputEventSupported:Oc,extractEvents:function(a,b,c,d){var e=b?Ja(b):window,f=void 0,h=void 0,g=e.nodeName&&e.nodeName.toLowerCase();"select"===g||"input"===g&&"file"===e.type?f=Nc:Qb(e)?Oc?f=Uc:(f=Sc,h=Rc):(g=e.nodeName)&&"input"===g.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(f=Tc);if(f&&(f=f(a,b)))return Ic(f,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Fc(e,"number",e.value)}},Wc=y.extend({view:null,detail:null}),Xc={Alt:"altKey",
Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Yc(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Xc[a])?!!b[a]:!1}function Zc(){return Yc}
var $c=0,ad=0,bd=!1,cd=!1,dd=Wc.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Zc,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=$c;$c=a.screenX;return bd?"mousemove"===a.type?a.screenX-b:0:(bd=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;
var b=ad;ad=a.screenY;return cd?"mousemove"===a.type?a.screenY-b:0:(cd=!0,0)}}),ed=dd.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fd={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",
dependencies:["pointerout","pointerover"]}},gd={eventTypes:fd,extractEvents:function(a,b,c,d){var e="mouseover"===a||"pointerover"===a,f="mouseout"===a||"pointerout"===a;if(e&&(c.relatedTarget||c.fromElement)||!f&&!e)return null;e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;f?(f=b,b=(b=c.relatedTarget||c.toElement)?Ha(b):null):f=null;if(f===b)return null;var h=void 0,g=void 0,k=void 0,l=void 0;if("mouseout"===a||"mouseover"===a)h=dd,g=fd.mouseLeave,k=fd.mouseEnter,l="mouse";
else if("pointerout"===a||"pointerover"===a)h=ed,g=fd.pointerLeave,k=fd.pointerEnter,l="pointer";var n=null==f?e:Ja(f);e=null==b?e:Ja(b);a=h.getPooled(g,f,c,d);a.type=l+"leave";a.target=n;a.relatedTarget=e;c=h.getPooled(k,b,c,d);c.type=l+"enter";c.target=e;c.relatedTarget=n;d=b;if(f&&d)a:{b=f;e=d;l=0;for(h=b;h;h=La(h))l++;h=0;for(k=e;k;k=La(k))h++;for(;0<l-h;)b=La(b),l--;for(;0<h-l;)e=La(e),h--;for(;l--;){if(b===e||b===e.alternate)break a;b=La(b);e=La(e)}b=null}else b=null;e=b;for(b=[];f&&f!==e;){l=
f.alternate;if(null!==l&&l===e)break;b.push(f);f=La(f)}for(f=[];d&&d!==e;){l=d.alternate;if(null!==l&&l===e)break;f.push(d);d=La(d)}for(d=0;d<b.length;d++)Oa(b[d],"bubbled",a);for(d=f.length;0<d--;)Oa(f[d],"captured",c);return[a,c]}};function hd(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var id=Object.prototype.hasOwnProperty;
function jd(a,b){if(hd(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!id.call(b,c[d])||!hd(a[c[d]],b[c[d]]))return!1;return!0}function kd(a,b){return{responder:a,props:b}}new Map;new Map;new Set;new Map;
function ld(a){var b=a;if(a.alternate)for(;b.return;)b=b.return;else{if(0!==(b.effectTag&2))return 1;for(;b.return;)if(b=b.return,0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function od(a){if(2!==ld(a))throw t(Error(188));}
function pd(a){var b=a.alternate;if(!b){b=ld(a);if(3===b)throw t(Error(188));return 1===b?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return od(e),a;if(f===d)return od(e),b;f=f.sibling}throw t(Error(188));}if(c.return!==d.return)c=e,d=f;else{for(var h=!1,g=e.child;g;){if(g===c){h=!0;c=e;d=f;break}if(g===d){h=!0;d=e;c=f;break}g=g.sibling}if(!h){for(g=f.child;g;){if(g===
c){h=!0;c=f;d=e;break}if(g===d){h=!0;d=f;c=e;break}g=g.sibling}if(!h)throw t(Error(189));}}if(c.alternate!==d)throw t(Error(190));}if(3!==c.tag)throw t(Error(188));return c.stateNode.current===c?a:b}function qd(a){a=pd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
var rd=y.extend({animationName:null,elapsedTime:null,pseudoElement:null}),sd=y.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),td=Wc.extend({relatedTarget:null});function ud(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}
var vd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},wd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},xd=Wc.extend({key:function(a){if(a.key){var b=vd[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=ud(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?wd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Zc,charCode:function(a){return"keypress"===
a.type?ud(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===a.type?ud(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),yd=dd.extend({dataTransfer:null}),zd=Wc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Zc}),Ad=y.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),Bd=dd.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in
a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),Cd=[["blur","blur",0],["cancel","cancel",0],["click","click",0],["close","close",0],["contextmenu","contextMenu",0],["copy","copy",0],["cut","cut",0],["auxclick","auxClick",0],["dblclick","doubleClick",0],["dragend","dragEnd",0],["dragstart","dragStart",0],["drop","drop",0],["focus","focus",0],["input","input",0],["invalid","invalid",0],
["keydown","keyDown",0],["keypress","keyPress",0],["keyup","keyUp",0],["mousedown","mouseDown",0],["mouseup","mouseUp",0],["paste","paste",0],["pause","pause",0],["play","play",0],["pointercancel","pointerCancel",0],["pointerdown","pointerDown",0],["pointerup","pointerUp",0],["ratechange","rateChange",0],["reset","reset",0],["seeked","seeked",0],["submit","submit",0],["touchcancel","touchCancel",0],["touchend","touchEnd",0],["touchstart","touchStart",0],["volumechange","volumeChange",0],["drag","drag",
1],["dragenter","dragEnter",1],["dragexit","dragExit",1],["dragleave","dragLeave",1],["dragover","dragOver",1],["mousemove","mouseMove",1],["mouseout","mouseOut",1],["mouseover","mouseOver",1],["pointermove","pointerMove",1],["pointerout","pointerOut",1],["pointerover","pointerOver",1],["scroll","scroll",1],["toggle","toggle",1],["touchmove","touchMove",1],["wheel","wheel",1],["abort","abort",2],[Xa,"animationEnd",2],[Ya,"animationIteration",2],[Za,"animationStart",2],["canplay","canPlay",2],["canplaythrough",
"canPlayThrough",2],["durationchange","durationChange",2],["emptied","emptied",2],["encrypted","encrypted",2],["ended","ended",2],["error","error",2],["gotpointercapture","gotPointerCapture",2],["load","load",2],["loadeddata","loadedData",2],["loadedmetadata","loadedMetadata",2],["loadstart","loadStart",2],["lostpointercapture","lostPointerCapture",2],["playing","playing",2],["progress","progress",2],["seeking","seeking",2],["stalled","stalled",2],["suspend","suspend",2],["timeupdate","timeUpdate",
2],[ab,"transitionEnd",2],["waiting","waiting",2]],Dd={},Ed={},Fd=0;for(;Fd<Cd.length;Fd++){var Gd=Cd[Fd],Hd=Gd[0],Id=Gd[1],Jd=Gd[2],Kd="on"+(Id[0].toUpperCase()+Id.slice(1)),Ld={phasedRegistrationNames:{bubbled:Kd,captured:Kd+"Capture"},dependencies:[Hd],eventPriority:Jd};Dd[Id]=Ld;Ed[Hd]=Ld}
var Md={eventTypes:Dd,getEventPriority:function(a){a=Ed[a];return void 0!==a?a.eventPriority:2},extractEvents:function(a,b,c,d){var e=Ed[a];if(!e)return null;switch(a){case "keypress":if(0===ud(c))return null;case "keydown":case "keyup":a=xd;break;case "blur":case "focus":a=td;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=dd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
yd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=zd;break;case Xa:case Ya:case Za:a=rd;break;case ab:a=Ad;break;case "scroll":a=Wc;break;case "wheel":a=Bd;break;case "copy":case "cut":case "paste":a=sd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=ed;break;default:a=y}b=a.getPooled(e,b,c,d);Qa(b);return b}},Nd=Md.getEventPriority,Od=[];
function Pd(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d;for(d=c;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo;if(!d)break;a.ancestors.push(c);c=Ha(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Rb(a.nativeEvent);d=a.topLevelType;for(var f=a.nativeEvent,h=null,g=0;g<ea.length;g++){var k=ea[g];k&&(k=k.extractEvents(d,b,f,e))&&(h=xa(h,k))}Ba(h)}}var Qd=!0;function G(a,b){Rd(b,a,!1)}
function Rd(a,b,c){switch(Nd(b)){case 0:var d=Sd.bind(null,b,1);break;case 1:d=Td.bind(null,b,1);break;default:d=Ud.bind(null,b,1)}c?a.addEventListener(b,d,!0):a.addEventListener(b,d,!1)}function Sd(a,b,c){Nb||Lb();var d=Ud,e=Nb;Nb=!0;try{Kb(d,a,b,c)}finally{(Nb=e)||Ob()}}function Td(a,b,c){Ud(a,b,c)}
function Ud(a,b,c){if(Qd){b=Rb(c);b=Ha(b);null===b||"number"!==typeof b.tag||2===ld(b)||(b=null);if(Od.length){var d=Od.pop();d.topLevelType=a;d.nativeEvent=c;d.targetInst=b;a=d}else a={topLevelType:a,nativeEvent:c,targetInst:b,ancestors:[]};try{if(c=a,Nb)Pd(c,void 0);else{Nb=!0;try{Mb(Pd,c,void 0)}finally{Nb=!1,Ob()}}}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>Od.length&&Od.push(a)}}}var Vd=new ("function"===typeof WeakMap?WeakMap:Map);
function Wd(a){var b=Vd.get(a);void 0===b&&(b=new Set,Vd.set(a,b));return b}function Xd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function Yd(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Zd(a,b){var c=Yd(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Yd(c)}}function $d(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?$d(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
function ae(){for(var a=window,b=Xd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xd(a.document)}return b}function be(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
var ce=Ra&&"documentMode"in document&&11>=document.documentMode,de={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},ee=null,fe=null,ge=null,he=!1;
function ie(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(he||null==ee||ee!==Xd(c))return null;c=ee;"selectionStart"in c&&be(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return ge&&jd(ge,c)?null:(ge=c,a=y.getPooled(de.select,fe,a,b),a.type="select",a.target=ee,Qa(a),a)}
var je={eventTypes:de,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Wd(e);f=ja.onSelect;for(var h=0;h<f.length;h++)if(!e.has(f[h])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Ja(b):window;switch(a){case "focus":if(Qb(e)||"true"===e.contentEditable)ee=e,fe=b,ge=null;break;case "blur":ge=fe=ee=null;break;case "mousedown":he=!0;break;case "contextmenu":case "mouseup":case "dragend":return he=!1,ie(c,d);case "selectionchange":if(ce)break;
case "keydown":case "keyup":return ie(c,d)}return null}};Ca.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));sa=Ka;ta=Ia;va=Ja;Ca.injectEventPluginsByName({SimpleEventPlugin:Md,EnterLeaveEventPlugin:gd,ChangeEventPlugin:Vc,SelectEventPlugin:je,BeforeInputEventPlugin:Cb});function ke(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}
function le(a,b){a=m({children:void 0},b);if(b=ke(b.children))a.children=b;return a}function me(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Ac(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function ne(a,b){if(null!=b.dangerouslySetInnerHTML)throw t(Error(91));return m({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function oe(a,b){var c=b.value;if(null==c){c=b.defaultValue;b=b.children;if(null!=b){if(null!=c)throw t(Error(92));if(Array.isArray(b)){if(!(1>=b.length))throw t(Error(93));b=b[0]}c=b}null==c&&(c="")}a._wrapperState={initialValue:Ac(c)}}
function pe(a,b){var c=Ac(b.value),d=Ac(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function qe(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)}var re={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function se(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function te(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?se(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var ue=void 0,ve=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==re.svg||"innerHTML"in a)a.innerHTML=b;else{ue=ue||document.createElement("div");ue.innerHTML="<svg>"+b+"</svg>";for(b=ue.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function we(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var xe={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ye=["Webkit","ms","Moz","O"];Object.keys(xe).forEach(function(a){ye.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);xe[b]=xe[a]})});function ze(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||xe.hasOwnProperty(a)&&xe[a]?(""+b).trim():b+"px"}
function Ae(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ze(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var Ce=m({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function De(a,b){if(b){if(Ce[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw t(Error(137),a,"");if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw t(Error(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw t(Error(61));}if(null!=b.style&&"object"!==typeof b.style)throw t(Error(62),"");}}
function Ee(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}
function Fe(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Wd(a);b=ja[b];for(var d=0;d<b.length;d++){var e=b[d];if(!c.has(e)){switch(e){case "scroll":Rd(a,"scroll",!0);break;case "focus":case "blur":Rd(a,"focus",!0);Rd(a,"blur",!0);c.add("blur");c.add("focus");break;case "cancel":case "close":Sb(e)&&Rd(a,e,!0);break;case "invalid":case "submit":case "reset":break;default:-1===bb.indexOf(e)&&G(e,a)}c.add(e)}}}function Ge(){}var He=null,Ie=null;
function Je(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Ke(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var Le="function"===typeof setTimeout?setTimeout:void 0,Me="function"===typeof clearTimeout?clearTimeout:void 0;
function Ne(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}new Set;var Oe=[],Pe=-1;function H(a){0>Pe||(a.current=Oe[Pe],Oe[Pe]=null,Pe--)}function J(a,b){Pe++;Oe[Pe]=a.current;a.current=b}var Qe={},L={current:Qe},M={current:!1},Re=Qe;
function Se(a,b){var c=a.type.contextTypes;if(!c)return Qe;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Te(a){H(M,a);H(L,a)}function Ue(a){H(M,a);H(L,a)}
function Ve(a,b,c){if(L.current!==Qe)throw t(Error(168));J(L,b,a);J(M,c,a)}function We(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw t(Error(108),oc(b)||"Unknown",e);return m({},c,d)}function Xe(a){var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||Qe;Re=L.current;J(L,b,a);J(M,M.current,a);return!0}
function Ye(a,b,c){var d=a.stateNode;if(!d)throw t(Error(169));c?(b=We(a,b,Re),d.__reactInternalMemoizedMergedChildContext=b,H(M,a),H(L,a),J(L,b,a)):H(M,a);J(M,c,a)}
var Ze=q.unstable_runWithPriority,$e=q.unstable_scheduleCallback,af=q.unstable_cancelCallback,bf=q.unstable_shouldYield,cf=q.unstable_requestPaint,df=q.unstable_now,ef=q.unstable_getCurrentPriorityLevel,ff=q.unstable_ImmediatePriority,hf=q.unstable_UserBlockingPriority,jf=q.unstable_NormalPriority,kf=q.unstable_LowPriority,lf=q.unstable_IdlePriority,mf={},nf=void 0!==cf?cf:function(){},of=null,pf=null,qf=!1,rf=df(),sf=1E4>rf?df:function(){return df()-rf};
function tf(){switch(ef()){case ff:return 99;case hf:return 98;case jf:return 97;case kf:return 96;case lf:return 95;default:throw t(Error(332));}}function uf(a){switch(a){case 99:return ff;case 98:return hf;case 97:return jf;case 96:return kf;case 95:return lf;default:throw t(Error(332));}}function vf(a,b){a=uf(a);return Ze(a,b)}function wf(a,b,c){a=uf(a);return $e(a,b,c)}function xf(a){null===of?(of=[a],pf=$e(ff,yf)):of.push(a);return mf}function O(){null!==pf&&af(pf);yf()}
function yf(){if(!qf&&null!==of){qf=!0;var a=0;try{var b=of;vf(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});of=null}catch(c){throw null!==of&&(of=of.slice(a+1)),$e(ff,O),c;}finally{qf=!1}}}function zf(a,b){if(1073741823===b)return 99;if(1===b)return 95;a=10*(1073741821-b)-10*(1073741821-a);return 0>=a?99:250>=a?98:5250>=a?97:95}function Af(a,b){if(a&&a.defaultProps){b=m({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}
function Bf(a){var b=a._result;switch(a._status){case 1:return b;case 2:throw b;case 0:throw b;default:a._status=0;b=a._ctor;b=b();b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)});switch(a._status){case 1:return a._result;case 2:throw a._result;}a._result=b;throw b;}}var Cf={current:null},Df=null,Ef=null,Ff=null;function Gf(){Ff=Ef=Df=null}
function Hf(a,b){var c=a.type._context;J(Cf,c._currentValue,a);c._currentValue=b}function If(a){var b=Cf.current;H(Cf,a);a.type._context._currentValue=b}function Jf(a,b){for(;null!==a;){var c=a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}
function Kf(a,b){Df=a;Ff=Ef=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(Lf=!0),a.firstContext=null)}function Mf(a,b){if(Ff!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Ff=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===Ef){if(null===Df)throw t(Error(308));Ef=b;Df.dependencies={expirationTime:0,firstContext:b,responders:null}}else Ef=Ef.next=b}return a._currentValue}var Nf=!1;
function Of(a){return{baseState:a,firstUpdate:null,lastUpdate:null,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}function Pf(a){return{baseState:a.baseState,firstUpdate:a.firstUpdate,lastUpdate:a.lastUpdate,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}
function Qf(a,b){return{expirationTime:a,suspenseConfig:b,tag:0,payload:null,callback:null,next:null,nextEffect:null}}function Rf(a,b){null===a.lastUpdate?a.firstUpdate=a.lastUpdate=b:(a.lastUpdate.next=b,a.lastUpdate=b)}
function Sf(a,b){var c=a.alternate;if(null===c){var d=a.updateQueue;var e=null;null===d&&(d=a.updateQueue=Of(a.memoizedState))}else d=a.updateQueue,e=c.updateQueue,null===d?null===e?(d=a.updateQueue=Of(a.memoizedState),e=c.updateQueue=Of(c.memoizedState)):d=a.updateQueue=Pf(e):null===e&&(e=c.updateQueue=Pf(d));null===e||d===e?Rf(d,b):null===d.lastUpdate||null===e.lastUpdate?(Rf(d,b),Rf(e,b)):(Rf(d,b),e.lastUpdate=b)}
function Tf(a,b){var c=a.updateQueue;c=null===c?a.updateQueue=Of(a.memoizedState):Uf(a,c);null===c.lastCapturedUpdate?c.firstCapturedUpdate=c.lastCapturedUpdate=b:(c.lastCapturedUpdate.next=b,c.lastCapturedUpdate=b)}function Uf(a,b){var c=a.alternate;null!==c&&b===c.updateQueue&&(b=a.updateQueue=Pf(b));return b}
function Vf(a,b,c,d,e,f){switch(c.tag){case 1:return a=c.payload,"function"===typeof a?a.call(f,d,e):a;case 3:a.effectTag=a.effectTag&-2049|64;case 0:a=c.payload;e="function"===typeof a?a.call(f,d,e):a;if(null===e||void 0===e)break;return m({},d,e);case 2:Nf=!0}return d}
function Wf(a,b,c,d,e){Nf=!1;b=Uf(a,b);for(var f=b.baseState,h=null,g=0,k=b.firstUpdate,l=f;null!==k;){var n=k.expirationTime;n<e?(null===h&&(h=k,f=l),g<n&&(g=n)):(Xf(n,k.suspenseConfig),l=Vf(a,b,k,l,c,d),null!==k.callback&&(a.effectTag|=32,k.nextEffect=null,null===b.lastEffect?b.firstEffect=b.lastEffect=k:(b.lastEffect.nextEffect=k,b.lastEffect=k)));k=k.next}n=null;for(k=b.firstCapturedUpdate;null!==k;){var z=k.expirationTime;z<e?(null===n&&(n=k,null===h&&(f=l)),g<z&&(g=z)):(l=Vf(a,b,k,l,c,d),null!==
k.callback&&(a.effectTag|=32,k.nextEffect=null,null===b.lastCapturedEffect?b.firstCapturedEffect=b.lastCapturedEffect=k:(b.lastCapturedEffect.nextEffect=k,b.lastCapturedEffect=k)));k=k.next}null===h&&(b.lastUpdate=null);null===n?b.lastCapturedUpdate=null:a.effectTag|=32;null===h&&null===n&&(f=l);b.baseState=f;b.firstUpdate=h;b.firstCapturedUpdate=n;a.expirationTime=g;a.memoizedState=l}
function Yf(a,b,c){null!==b.firstCapturedUpdate&&(null!==b.lastUpdate&&(b.lastUpdate.next=b.firstCapturedUpdate,b.lastUpdate=b.lastCapturedUpdate),b.firstCapturedUpdate=b.lastCapturedUpdate=null);Zf(b.firstEffect,c);b.firstEffect=b.lastEffect=null;Zf(b.firstCapturedEffect,c);b.firstCapturedEffect=b.lastCapturedEffect=null}function Zf(a,b){for(;null!==a;){var c=a.callback;if(null!==c){a.callback=null;var d=b;if("function"!==typeof c)throw t(Error(191),c);c.call(d)}a=a.nextEffect}}
var $f=Xb.ReactCurrentBatchConfig,ag=(new aa.Component).refs;function bg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:m({},b,c);a.memoizedState=c;d=a.updateQueue;null!==d&&0===a.expirationTime&&(d.baseState=c)}
var fg={isMounted:function(a){return(a=a._reactInternalFiber)?2===ld(a):!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=cg(),e=$f.suspense;d=dg(d,a,e);e=Qf(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Sf(a,e);eg(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=cg(),e=$f.suspense;d=dg(d,a,e);e=Qf(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Sf(a,e);eg(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=cg(),d=$f.suspense;
c=dg(c,a,d);d=Qf(c,d);d.tag=2;void 0!==b&&null!==b&&(d.callback=b);Sf(a,d);eg(a,c)}};function gg(a,b,c,d,e,f,h){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,h):b.prototype&&b.prototype.isPureReactComponent?!jd(c,d)||!jd(e,f):!0}
function hg(a,b,c){var d=!1,e=Qe;var f=b.contextType;"object"===typeof f&&null!==f?f=Mf(f):(e=N(b)?Re:L.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Se(a,e):Qe);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=fg;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function ig(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&fg.enqueueReplaceState(b,b.state,null)}
function jg(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=ag;var f=b.contextType;"object"===typeof f&&null!==f?e.context=Mf(f):(f=N(b)?Re:L.current,e.context=Se(a,f));f=a.updateQueue;null!==f&&(Wf(a,f,c,e,d),e.state=a.memoizedState);f=b.getDerivedStateFromProps;"function"===typeof f&&(bg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==
typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&fg.enqueueReplaceState(e,e.state,null),f=a.updateQueue,null!==f&&(Wf(a,f,c,e,d),e.state=a.memoizedState));"function"===typeof e.componentDidMount&&(a.effectTag|=4)}var kg=Array.isArray;
function lg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;var d=void 0;if(c){if(1!==c.tag)throw t(Error(309));d=c.stateNode}if(!d)throw t(Error(147),a);var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===ag&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw t(Error(284));if(!c._owner)throw t(Error(290),a);}return a}
function mg(a,b){if("textarea"!==a.type)throw t(Error(31),"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"");}
function ng(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=og(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function h(b){a&&null===b.alternate&&(b.effectTag=2);return b}function g(a,b,c,d){if(null===b||6!==b.tag)return b=pg(c,a.mode,d),b.return=a,b;b=e(b,c,d);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props,d),d.ref=lg(a,b,c),d.return=a,d;d=qg(c.type,c.key,c.props,null,a.mode,d);d.ref=lg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
c.implementation)return b=rg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[],d);b.return=a;return b}function n(a,b,c,d,f){if(null===b||7!==b.tag)return b=sg(c,a.mode,d,f),b.return=a,b;b=e(b,c,d);b.return=a;return b}function z(a,b,c){if("string"===typeof b||"number"===typeof b)return b=pg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Zb:return c=qg(b.type,b.key,b.props,null,a.mode,c),c.ref=lg(a,null,b),c.return=a,c;case $b:return b=rg(b,a.mode,c),b.return=a,b}if(kg(b)||
mc(b))return b=sg(b,a.mode,c,null),b.return=a,b;mg(a,b)}return null}function x(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:g(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Zb:return c.key===e?c.type===ac?n(a,b,c.props.children,d,e):k(a,b,c,d):null;case $b:return c.key===e?l(a,b,c,d):null}if(kg(c)||mc(c))return null!==e?null:n(a,b,c,d,null);mg(a,c)}return null}function v(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=
a.get(c)||null,g(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Zb:return a=a.get(null===d.key?c:d.key)||null,d.type===ac?n(b,a,d.props.children,e,d.key):k(b,a,d,e);case $b:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(kg(d)||mc(d))return a=a.get(c)||null,n(b,a,d,e,null);mg(b,d)}return null}function rb(e,h,g,k){for(var l=null,u=null,n=h,w=h=0,C=null;null!==n&&w<g.length;w++){n.index>w?(C=n,n=null):C=n.sibling;var p=x(e,n,g[w],k);if(null===p){null===n&&(n=C);break}a&&
n&&null===p.alternate&&b(e,n);h=f(p,h,w);null===u?l=p:u.sibling=p;u=p;n=C}if(w===g.length)return c(e,n),l;if(null===n){for(;w<g.length;w++)n=z(e,g[w],k),null!==n&&(h=f(n,h,w),null===u?l=n:u.sibling=n,u=n);return l}for(n=d(e,n);w<g.length;w++)C=v(n,e,w,g[w],k),null!==C&&(a&&null!==C.alternate&&n.delete(null===C.key?w:C.key),h=f(C,h,w),null===u?l=C:u.sibling=C,u=C);a&&n.forEach(function(a){return b(e,a)});return l}function Be(e,h,g,k){var l=mc(g);if("function"!==typeof l)throw t(Error(150));g=l.call(g);
if(null==g)throw t(Error(151));for(var n=l=null,u=h,w=h=0,C=null,p=g.next();null!==u&&!p.done;w++,p=g.next()){u.index>w?(C=u,u=null):C=u.sibling;var r=x(e,u,p.value,k);if(null===r){null===u&&(u=C);break}a&&u&&null===r.alternate&&b(e,u);h=f(r,h,w);null===n?l=r:n.sibling=r;n=r;u=C}if(p.done)return c(e,u),l;if(null===u){for(;!p.done;w++,p=g.next())p=z(e,p.value,k),null!==p&&(h=f(p,h,w),null===n?l=p:n.sibling=p,n=p);return l}for(u=d(e,u);!p.done;w++,p=g.next())p=v(u,e,w,p.value,k),null!==p&&(a&&null!==
p.alternate&&u.delete(null===p.key?w:p.key),h=f(p,h,w),null===n?l=p:n.sibling=p,n=p);a&&u.forEach(function(a){return b(e,a)});return l}return function(a,d,f,g){var k="object"===typeof f&&null!==f&&f.type===ac&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case Zb:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){if(7===k.tag?f.type===ac:k.elementType===f.type){c(a,k.sibling);d=e(k,f.type===ac?f.props.children:f.props,g);d.ref=lg(a,k,f);d.return=a;a=d;break a}c(a,
k);break}else b(a,k);k=k.sibling}f.type===ac?(d=sg(f.props.children,a.mode,g,f.key),d.return=a,a=d):(g=qg(f.type,f.key,f.props,null,a.mode,g),g.ref=lg(a,d,f),g.return=a,a=g)}return h(a);case $b:a:{for(k=f.key;null!==d;){if(d.key===k){if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[],g);d.return=a;a=d;break a}c(a,d);break}else b(a,d);d=d.sibling}d=rg(f,a.mode,g);d.return=a;a=d}return h(a)}if("string"===typeof f||
"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,g),d.return=a,a=d):(c(a,d),d=pg(f,a.mode,g),d.return=a,a=d),h(a);if(kg(f))return rb(a,d,f,g);if(mc(f))return Be(a,d,f,g);l&&mg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:throw a=a.type,t(Error(152),a.displayName||a.name||"Component");}return c(a,d)}}var tg=ng(!0),ug=ng(!1),vg={},wg={current:vg},xg={current:vg},yg={current:vg};function zg(a){if(a===vg)throw t(Error(174));return a}
function Ag(a,b){J(yg,b,a);J(xg,a,a);J(wg,vg,a);var c=b.nodeType;switch(c){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:te(null,"");break;default:c=8===c?b.parentNode:b,b=c.namespaceURI||null,c=c.tagName,b=te(b,c)}H(wg,a);J(wg,b,a)}function Bg(a){H(wg,a);H(xg,a);H(yg,a)}function Cg(a){zg(yg.current);var b=zg(wg.current);var c=te(b,a.type);b!==c&&(J(xg,a,a),J(wg,c,a))}function Dg(a){xg.current===a&&(H(wg,a),H(xg,a))}var Eg=1,Fg=1,Gg=2,P={current:0};
function Hg(a){for(var b=a;null!==b;){if(13===b.tag){if(null!==b.memoizedState)return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}
var Ig=0,Jg=2,Kg=4,Lg=8,Mg=16,Ng=32,Og=64,Pg=128,Qg=Xb.ReactCurrentDispatcher,Rg=0,Sg=null,Q=null,Tg=null,Ug=null,R=null,Vg=null,Wg=0,Xg=null,Yg=0,Zg=!1,$g=null,ah=0;function bh(){throw t(Error(321));}function ch(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!hd(a[c],b[c]))return!1;return!0}
function dh(a,b,c,d,e,f){Rg=f;Sg=b;Tg=null!==a?a.memoizedState:null;Qg.current=null===Tg?eh:fh;b=c(d,e);if(Zg){do Zg=!1,ah+=1,Tg=null!==a?a.memoizedState:null,Vg=Ug,Xg=R=Q=null,Qg.current=fh,b=c(d,e);while(Zg);$g=null;ah=0}Qg.current=hh;a=Sg;a.memoizedState=Ug;a.expirationTime=Wg;a.updateQueue=Xg;a.effectTag|=Yg;a=null!==Q&&null!==Q.next;Rg=0;Vg=R=Ug=Tg=Q=Sg=null;Wg=0;Xg=null;Yg=0;if(a)throw t(Error(300));return b}
function ih(){Qg.current=hh;Rg=0;Vg=R=Ug=Tg=Q=Sg=null;Wg=0;Xg=null;Yg=0;Zg=!1;$g=null;ah=0}function jh(){var a={memoizedState:null,baseState:null,queue:null,baseUpdate:null,next:null};null===R?Ug=R=a:R=R.next=a;return R}function kh(){if(null!==Vg)R=Vg,Vg=R.next,Q=Tg,Tg=null!==Q?Q.next:null;else{if(null===Tg)throw t(Error(310));Q=Tg;var a={memoizedState:Q.memoizedState,baseState:Q.baseState,queue:Q.queue,baseUpdate:Q.baseUpdate,next:null};R=null===R?Ug=a:R.next=a;Tg=Q.next}return R}
function lh(a,b){return"function"===typeof b?b(a):b}
function mh(a){var b=kh(),c=b.queue;if(null===c)throw t(Error(311));c.lastRenderedReducer=a;if(0<ah){var d=c.dispatch;if(null!==$g){var e=$g.get(c);if(void 0!==e){$g.delete(c);var f=b.memoizedState;do f=a(f,e.action),e=e.next;while(null!==e);hd(f,b.memoizedState)||(Lf=!0);b.memoizedState=f;b.baseUpdate===c.last&&(b.baseState=f);c.lastRenderedState=f;return[f,d]}}return[b.memoizedState,d]}d=c.last;var h=b.baseUpdate;f=b.baseState;null!==h?(null!==d&&(d.next=null),d=h.next):d=null!==d?d.next:null;if(null!==
d){var g=e=null,k=d,l=!1;do{var n=k.expirationTime;n<Rg?(l||(l=!0,g=h,e=f),n>Wg&&(Wg=n)):(Xf(n,k.suspenseConfig),f=k.eagerReducer===a?k.eagerState:a(f,k.action));h=k;k=k.next}while(null!==k&&k!==d);l||(g=h,e=f);hd(f,b.memoizedState)||(Lf=!0);b.memoizedState=f;b.baseUpdate=g;b.baseState=e;c.lastRenderedState=f}return[b.memoizedState,c.dispatch]}
function nh(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};null===Xg?(Xg={lastEffect:null},Xg.lastEffect=a.next=a):(b=Xg.lastEffect,null===b?Xg.lastEffect=a.next=a:(c=b.next,b.next=a,a.next=c,Xg.lastEffect=a));return a}function oh(a,b,c,d){var e=jh();Yg|=a;e.memoizedState=nh(b,c,void 0,void 0===d?null:d)}
function ph(a,b,c,d){var e=kh();d=void 0===d?null:d;var f=void 0;if(null!==Q){var h=Q.memoizedState;f=h.destroy;if(null!==d&&ch(d,h.deps)){nh(Ig,c,f,d);return}}Yg|=a;e.memoizedState=nh(b,c,f,d)}function qh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function rh(){}
function sh(a,b,c){if(!(25>ah))throw t(Error(301));var d=a.alternate;if(a===Sg||null!==d&&d===Sg)if(Zg=!0,a={expirationTime:Rg,suspenseConfig:null,action:c,eagerReducer:null,eagerState:null,next:null},null===$g&&($g=new Map),c=$g.get(b),void 0===c)$g.set(b,a);else{for(b=c;null!==b.next;)b=b.next;b.next=a}else{var e=cg(),f=$f.suspense;e=dg(e,a,f);f={expirationTime:e,suspenseConfig:f,action:c,eagerReducer:null,eagerState:null,next:null};var h=b.last;if(null===h)f.next=f;else{var g=h.next;null!==g&&
(f.next=g);h.next=f}b.last=f;if(0===a.expirationTime&&(null===d||0===d.expirationTime)&&(d=b.lastRenderedReducer,null!==d))try{var k=b.lastRenderedState,l=d(k,c);f.eagerReducer=d;f.eagerState=l;if(hd(l,k))return}catch(n){}finally{}eg(a,e)}}
var hh={readContext:Mf,useCallback:bh,useContext:bh,useEffect:bh,useImperativeHandle:bh,useLayoutEffect:bh,useMemo:bh,useReducer:bh,useRef:bh,useState:bh,useDebugValue:bh,useResponder:bh},eh={readContext:Mf,useCallback:function(a,b){jh().memoizedState=[a,void 0===b?null:b];return a},useContext:Mf,useEffect:function(a,b){return oh(516,Pg|Og,a,b)},useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return oh(4,Kg|Ng,qh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return oh(4,
Kg|Ng,a,b)},useMemo:function(a,b){var c=jh();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=jh();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={last:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=sh.bind(null,Sg,a);return[d.memoizedState,a]},useRef:function(a){var b=jh();a={current:a};return b.memoizedState=a},useState:function(a){var b=jh();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue=
{last:null,dispatch:null,lastRenderedReducer:lh,lastRenderedState:a};a=a.dispatch=sh.bind(null,Sg,a);return[b.memoizedState,a]},useDebugValue:rh,useResponder:kd},fh={readContext:Mf,useCallback:function(a,b){var c=kh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ch(b,d[1]))return d[0];c.memoizedState=[a,b];return a},useContext:Mf,useEffect:function(a,b){return ph(516,Pg|Og,a,b)},useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ph(4,Kg|Ng,qh.bind(null,
b,a),c)},useLayoutEffect:function(a,b){return ph(4,Kg|Ng,a,b)},useMemo:function(a,b){var c=kh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ch(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a},useReducer:mh,useRef:function(){return kh().memoizedState},useState:function(a){return mh(lh,a)},useDebugValue:rh,useResponder:kd},th=null,uh=null,vh=!1;
function wh(a,b){var c=xh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function yh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}
function zh(a){if(vh){var b=uh;if(b){var c=b;if(!yh(a,b)){b=Ne(c.nextSibling);if(!b||!yh(a,b)){a.effectTag|=2;vh=!1;th=a;return}wh(th,c)}th=a;uh=Ne(b.firstChild)}else a.effectTag|=2,vh=!1,th=a}}function Ah(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&18!==a.tag;)a=a.return;th=a}
function Bh(a){if(a!==th)return!1;if(!vh)return Ah(a),vh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!Ke(b,a.memoizedProps))for(b=uh;b;)wh(a,b),b=Ne(b.nextSibling);Ah(a);uh=th?Ne(a.stateNode.nextSibling):null;return!0}function Ch(){uh=th=null;vh=!1}var Dh=Xb.ReactCurrentOwner,Lf=!1;function S(a,b,c,d){b.child=null===a?ug(b,null,c,d):tg(b,a.child,c,d)}
function Eh(a,b,c,d,e){c=c.render;var f=b.ref;Kf(b,e);d=dh(a,b,c,d,f,e);if(null!==a&&!Lf)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),Fh(a,b,e);b.effectTag|=1;S(a,b,d,e);return b.child}
function Gh(a,b,c,d,e,f){if(null===a){var h=c.type;if("function"===typeof h&&!Hh(h)&&void 0===h.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=h,Ih(a,b,h,d,e,f);a=qg(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}h=a.child;if(e<f&&(e=h.memoizedProps,c=c.compare,c=null!==c?c:jd,c(e,d)&&a.ref===b.ref))return Fh(a,b,f);b.effectTag|=1;a=og(h,d,f);a.ref=b.ref;a.return=b;return b.child=a}
function Ih(a,b,c,d,e,f){return null!==a&&jd(a.memoizedProps,d)&&a.ref===b.ref&&(Lf=!1,e<f)?Fh(a,b,f):Jh(a,b,c,d,f)}function Kh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function Jh(a,b,c,d,e){var f=N(c)?Re:L.current;f=Se(b,f);Kf(b,e);c=dh(a,b,c,d,f,e);if(null!==a&&!Lf)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),Fh(a,b,e);b.effectTag|=1;S(a,b,c,e);return b.child}
function Lh(a,b,c,d,e){if(N(c)){var f=!0;Xe(b)}else f=!1;Kf(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),hg(b,c,d,e),jg(b,c,d,e),d=!0;else if(null===a){var h=b.stateNode,g=b.memoizedProps;h.props=g;var k=h.context,l=c.contextType;"object"===typeof l&&null!==l?l=Mf(l):(l=N(c)?Re:L.current,l=Se(b,l));var n=c.getDerivedStateFromProps,z="function"===typeof n||"function"===typeof h.getSnapshotBeforeUpdate;z||"function"!==typeof h.UNSAFE_componentWillReceiveProps&&
"function"!==typeof h.componentWillReceiveProps||(g!==d||k!==l)&&ig(b,h,d,l);Nf=!1;var x=b.memoizedState;k=h.state=x;var v=b.updateQueue;null!==v&&(Wf(b,v,d,h,e),k=b.memoizedState);g!==d||x!==k||M.current||Nf?("function"===typeof n&&(bg(b,c,n,d),k=b.memoizedState),(g=Nf||gg(b,c,g,d,x,k,l))?(z||"function"!==typeof h.UNSAFE_componentWillMount&&"function"!==typeof h.componentWillMount||("function"===typeof h.componentWillMount&&h.componentWillMount(),"function"===typeof h.UNSAFE_componentWillMount&&
h.UNSAFE_componentWillMount()),"function"===typeof h.componentDidMount&&(b.effectTag|=4)):("function"===typeof h.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=k),h.props=d,h.state=k,h.context=l,d=g):("function"===typeof h.componentDidMount&&(b.effectTag|=4),d=!1)}else h=b.stateNode,g=b.memoizedProps,h.props=b.type===b.elementType?g:Af(b.type,g),k=h.context,l=c.contextType,"object"===typeof l&&null!==l?l=Mf(l):(l=N(c)?Re:L.current,l=Se(b,l)),n=c.getDerivedStateFromProps,(z=
"function"===typeof n||"function"===typeof h.getSnapshotBeforeUpdate)||"function"!==typeof h.UNSAFE_componentWillReceiveProps&&"function"!==typeof h.componentWillReceiveProps||(g!==d||k!==l)&&ig(b,h,d,l),Nf=!1,k=b.memoizedState,x=h.state=k,v=b.updateQueue,null!==v&&(Wf(b,v,d,h,e),x=b.memoizedState),g!==d||k!==x||M.current||Nf?("function"===typeof n&&(bg(b,c,n,d),x=b.memoizedState),(n=Nf||gg(b,c,g,d,k,x,l))?(z||"function"!==typeof h.UNSAFE_componentWillUpdate&&"function"!==typeof h.componentWillUpdate||
("function"===typeof h.componentWillUpdate&&h.componentWillUpdate(d,x,l),"function"===typeof h.UNSAFE_componentWillUpdate&&h.UNSAFE_componentWillUpdate(d,x,l)),"function"===typeof h.componentDidUpdate&&(b.effectTag|=4),"function"===typeof h.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof h.componentDidUpdate||g===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof h.getSnapshotBeforeUpdate||g===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),b.memoizedProps=
d,b.memoizedState=x),h.props=d,h.state=x,h.context=l,d=n):("function"!==typeof h.componentDidUpdate||g===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof h.getSnapshotBeforeUpdate||g===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),d=!1);return Mh(a,b,c,d,f,e)}
function Mh(a,b,c,d,e,f){Kh(a,b);var h=0!==(b.effectTag&64);if(!d&&!h)return e&&Ye(b,c,!1),Fh(a,b,f);d=b.stateNode;Dh.current=b;var g=h&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&h?(b.child=tg(b,a.child,null,f),b.child=tg(b,null,g,f)):S(a,b,g,f);b.memoizedState=d.state;e&&Ye(b,c,!0);return b.child}function Nh(a){var b=a.stateNode;b.pendingContext?Ve(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Ve(a,b.context,!1);Ag(a,b.containerInfo)}
var Oh={};
function Ph(a,b,c){var d=b.mode,e=b.pendingProps,f=P.current,h=null,g=!1,k;(k=0!==(b.effectTag&64))||(k=0!==(f&Gg)&&(null===a||null!==a.memoizedState));k?(h=Oh,g=!0,b.effectTag&=-65):null!==a&&null===a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=Fg);f&=Eg;J(P,f,b);if(null===a)if(g){e=e.fallback;a=sg(null,d,0,null);a.return=b;if(0===(b.mode&2))for(g=null!==b.memoizedState?b.child.child:b.child,a.child=g;null!==g;)g.return=a,g=g.sibling;c=sg(e,d,c,null);c.return=b;a.sibling=
c;d=a}else d=c=ug(b,null,e.children,c);else{if(null!==a.memoizedState)if(f=a.child,d=f.sibling,g){e=e.fallback;c=og(f,f.pendingProps,0);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==f.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;e=og(d,e,d.expirationTime);e.return=b;c.sibling=e;d=c;c.childExpirationTime=0;c=e}else d=c=tg(b,f.child,e.children,c);else if(f=a.child,g){g=e.fallback;e=sg(null,d,0,null);e.return=b;e.child=f;null!==f&&(f.return=e);if(0===(b.mode&
2))for(f=null!==b.memoizedState?b.child.child:b.child,e.child=f;null!==f;)f.return=e,f=f.sibling;c=sg(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;d=e;e.childExpirationTime=0}else c=d=tg(b,f,e.children,c);b.stateNode=a.stateNode}b.memoizedState=h;b.child=d;return c}function Qh(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,last:d,tail:c,tailExpiration:0,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.last=d,f.tail=c,f.tailExpiration=0,f.tailMode=e)}
function Rh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;S(a,b,d.children,c);d=P.current;if(0!==(d&Gg))d=d&Eg|Gg,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag){if(null!==a.memoizedState){a.expirationTime<c&&(a.expirationTime=c);var h=a.alternate;null!==h&&h.expirationTime<c&&(h.expirationTime=c);Jf(a.return,c)}}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===
b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=Eg}J(P,d,b);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)d=c.alternate,null!==d&&null===Hg(d)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Qh(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){d=e.alternate;if(null!==d&&null===Hg(d)){b.child=e;break}d=e.sibling;e.sibling=c;c=e;e=d}Qh(b,!0,c,null,f);break;case "together":Qh(b,
!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}function Fh(a,b,c){null!==a&&(b.dependencies=a.dependencies);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw t(Error(153));if(null!==b.child){a=b.child;c=og(a,a.pendingProps,a.expirationTime);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=og(a,a.pendingProps,a.expirationTime),c.return=b;c.sibling=null}return b.child}function Sh(a){a.effectTag|=4}
var Th=void 0,Uh=void 0,Vh=void 0,Wh=void 0;Th=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(20===c.tag)a.appendChild(c.stateNode.instance);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Uh=function(){};
Vh=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var h=b.stateNode;zg(wg.current);a=null;switch(c){case "input":f=Bc(h,f);d=Bc(h,d);a=[];break;case "option":f=le(h,f);d=le(h,d);a=[];break;case "select":f=m({},f,{value:void 0});d=m({},d,{value:void 0});a=[];break;case "textarea":f=ne(h,f);d=ne(h,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(h.onclick=Ge)}De(c,d);h=c=void 0;var g=null;for(c in f)if(!d.hasOwnProperty(c)&&f.hasOwnProperty(c)&&null!=f[c])if("style"===
c){var k=f[c];for(h in k)k.hasOwnProperty(h)&&(g||(g={}),g[h]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(ia.hasOwnProperty(c)?a||(a=[]):(a=a||[]).push(c,null));for(c in d){var l=d[c];k=null!=f?f[c]:void 0;if(d.hasOwnProperty(c)&&l!==k&&(null!=l||null!=k))if("style"===c)if(k){for(h in k)!k.hasOwnProperty(h)||l&&l.hasOwnProperty(h)||(g||(g={}),g[h]="");for(h in l)l.hasOwnProperty(h)&&k[h]!==l[h]&&(g||
(g={}),g[h]=l[h])}else g||(a||(a=[]),a.push(c,g)),g=l;else"dangerouslySetInnerHTML"===c?(l=l?l.__html:void 0,k=k?k.__html:void 0,null!=l&&k!==l&&(a=a||[]).push(c,""+l)):"children"===c?k===l||"string"!==typeof l&&"number"!==typeof l||(a=a||[]).push(c,""+l):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(ia.hasOwnProperty(c)?(null!=l&&Fe(e,c),a||k===l||(a=[])):(a=a||[]).push(c,l))}g&&(a=a||[]).push("style",g);e=a;(b.updateQueue=e)&&Sh(b)}};Wh=function(a,b,c,d){c!==d&&Sh(b)};
function $h(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
function ai(a){switch(a.tag){case 1:N(a.type)&&Te(a);var b=a.effectTag;return b&2048?(a.effectTag=b&-2049|64,a):null;case 3:Bg(a);Ue(a);b=a.effectTag;if(0!==(b&64))throw t(Error(285));a.effectTag=b&-2049|64;return a;case 5:return Dg(a),null;case 13:return H(P,a),b=a.effectTag,b&2048?(a.effectTag=b&-2049|64,a):null;case 18:return null;case 19:return H(P,a),null;case 4:return Bg(a),null;case 10:return If(a),null;default:return null}}function bi(a,b){return{value:a,source:b,stack:pc(b)}}
var ci="function"===typeof WeakSet?WeakSet:Set;function di(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=pc(c));null!==c&&oc(c.type);b=b.value;null!==a&&1===a.tag&&oc(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function ei(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){fi(a,c)}}function gi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){fi(a,c)}else b.current=null}
function hi(a,b,c){c=c.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do{if((d.tag&a)!==Ig){var e=d.destroy;d.destroy=void 0;void 0!==e&&e()}(d.tag&b)!==Ig&&(e=d.create,d.destroy=e());d=d.next}while(d!==c)}}
function ii(a,b){"function"===typeof ji&&ji(a);switch(a.tag){case 0:case 11:case 14:case 15:var c=a.updateQueue;if(null!==c&&(c=c.lastEffect,null!==c)){var d=c.next;vf(97<b?97:b,function(){var b=d;do{var c=b.destroy;if(void 0!==c){var h=a;try{c()}catch(g){fi(h,g)}}b=b.next}while(b!==d)})}break;case 1:gi(a);b=a.stateNode;"function"===typeof b.componentWillUnmount&&ei(a,b);break;case 5:gi(a);break;case 4:ki(a,b)}}
function li(a,b){for(var c=a;;)if(ii(c,b),null!==c.child&&4!==c.tag)c.child.return=c,c=c.child;else{if(c===a)break;for(;null===c.sibling;){if(null===c.return||c.return===a)return;c=c.return}c.sibling.return=c.return;c=c.sibling}}function mi(a){return 5===a.tag||3===a.tag||4===a.tag}
function ni(a){a:{for(var b=a.return;null!==b;){if(mi(b)){var c=b;break a}b=b.return}throw t(Error(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw t(Error(161));}c.effectTag&16&&(we(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||mi(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;
if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){var f=5===e.tag||6===e.tag;if(f||20===e.tag){var h=f?e.stateNode:e.stateNode.instance;if(c)if(d){f=b;var g=h;h=c;8===f.nodeType?f.parentNode.insertBefore(g,h):f.insertBefore(g,h)}else b.insertBefore(h,c);else d?(g=b,8===g.nodeType?(f=g.parentNode,f.insertBefore(h,g)):(f=g,f.appendChild(h)),g=g._reactRootContainer,null!==g&&void 0!==g||null!==f.onclick||(f.onclick=Ge)):
b.appendChild(h)}else if(4!==e.tag&&null!==e.child){e.child.return=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e.return||e.return===a)return;e=e.return}e.sibling.return=e.return;e=e.sibling}}
function ki(a,b){for(var c=a,d=!1,e=void 0,f=void 0;;){if(!d){d=c.return;a:for(;;){if(null===d)throw t(Error(160));e=d.stateNode;switch(d.tag){case 5:f=!1;break a;case 3:e=e.containerInfo;f=!0;break a;case 4:e=e.containerInfo;f=!0;break a}d=d.return}d=!0}if(5===c.tag||6===c.tag)if(li(c,b),f){var h=e,g=c.stateNode;8===h.nodeType?h.parentNode.removeChild(g):h.removeChild(g)}else e.removeChild(c.stateNode);else if(20===c.tag)g=c.stateNode.instance,li(c,b),f?(h=e,8===h.nodeType?h.parentNode.removeChild(g):
h.removeChild(g)):e.removeChild(g);else if(4===c.tag){if(null!==c.child){e=c.stateNode.containerInfo;f=!0;c.child.return=c;c=c.child;continue}}else if(ii(c,b),null!==c.child){c.child.return=c;c=c.child;continue}if(c===a)break;for(;null===c.sibling;){if(null===c.return||c.return===a)return;c=c.return;4===c.tag&&(d=!1)}c.sibling.return=c.return;c=c.sibling}}
function oi(a,b){switch(b.tag){case 0:case 11:case 14:case 15:hi(Kg,Lg,b);break;case 1:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[Ga]=d;"input"===a&&"radio"===d.type&&null!=d.name&&Dc(c,d);Ee(a,e);b=Ee(a,d);for(e=0;e<f.length;e+=2){var h=f[e],g=f[e+1];"style"===h?Ae(c,g):"dangerouslySetInnerHTML"===h?ve(c,g):"children"===h?we(c,g):zc(c,h,g,b)}switch(a){case "input":Ec(c,d);break;case "textarea":pe(c,
d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?me(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?me(c,!!d.multiple,d.defaultValue,!0):me(c,!!d.multiple,d.multiple?[]:"",!1))}}}break;case 6:if(null===b.stateNode)throw t(Error(162));b.stateNode.nodeValue=b.memoizedProps;break;case 3:break;case 12:break;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,pi=sf());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=
f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=ze("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break a;for(;null===a.sibling;){if(null===
a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}qi(b);break;case 19:qi(b);break;case 17:break;case 20:break;default:throw t(Error(163));}}function qi(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new ci);b.forEach(function(b){var d=ri.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}var si="function"===typeof WeakMap?WeakMap:Map;
function ti(a,b,c){c=Qf(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){ui||(ui=!0,vi=d);di(a,b)};return c}
function wi(a,b,c){c=Qf(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){di(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===xi?xi=new Set([this]):xi.add(this),di(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}
var yi=Math.ceil,zi=Xb.ReactCurrentDispatcher,Ai=Xb.ReactCurrentOwner,T=0,Bi=8,Ci=16,Di=32,Ei=0,Fi=1,Gi=2,Hi=3,Ii=4,U=T,Ji=null,V=null,W=0,X=Ei,Ki=1073741823,Li=1073741823,Mi=null,Ni=!1,pi=0,Oi=500,Y=null,ui=!1,vi=null,xi=null,Pi=!1,Qi=null,Ri=90,Si=0,Ti=null,Ui=0,Vi=null,Wi=0;function cg(){return(U&(Ci|Di))!==T?1073741821-(sf()/10|0):0!==Wi?Wi:Wi=1073741821-(sf()/10|0)}
function dg(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=tf();if(0===(b&4))return 99===d?1073741823:1073741822;if((U&Ci)!==T)return W;if(null!==c)a=1073741821-25*(((1073741821-a+(c.timeoutMs|0||5E3)/10)/25|0)+1);else switch(d){case 99:a=1073741823;break;case 98:a=1073741821-10*(((1073741821-a+15)/10|0)+1);break;case 97:case 96:a=1073741821-25*(((1073741821-a+500)/25|0)+1);break;case 95:a=1;break;default:throw t(Error(326));}null!==Ji&&a===W&&--a;return a}var Xi=0;
function eg(a,b){if(50<Ui)throw Ui=0,Vi=null,t(Error(185));a=Yi(a,b);if(null!==a){a.pingTime=0;var c=tf();if(1073741823===b)if((U&Bi)!==T&&(U&(Ci|Di))===T)for(var d=Z(a,1073741823,!0);null!==d;)d=d(!0);else Zi(a,99,1073741823),U===T&&O();else Zi(a,c,b);(U&4)===T||98!==c&&99!==c||(null===Ti?Ti=new Map([[a,b]]):(c=Ti.get(a),(void 0===c||c>b)&&Ti.set(a,b)))}}
function Yi(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&(b>e.firstPendingTime&&(e.firstPendingTime=b),a=e.lastPendingTime,0===a||b<a)&&(e.lastPendingTime=
b);return e}function Zi(a,b,c){if(a.callbackExpirationTime<c){var d=a.callbackNode;null!==d&&d!==mf&&af(d);a.callbackExpirationTime=c;1073741823===c?a.callbackNode=xf($i.bind(null,a,Z.bind(null,a,c))):(d=null,1!==c&&(d={timeout:10*(1073741821-c)-sf()}),a.callbackNode=wf(b,$i.bind(null,a,Z.bind(null,a,c)),d))}}function $i(a,b,c){var d=a.callbackNode,e=null;try{return e=b(c),null!==e?$i.bind(null,a,e):null}finally{null===e&&d===a.callbackNode&&(a.callbackNode=null,a.callbackExpirationTime=0)}}
function aj(){(U&(1|Ci|Di))===T&&(bj(),cj())}function dj(a,b){var c=a.firstBatch;return null!==c&&c._defer&&c._expirationTime>=b?(wf(97,function(){c._onComplete();return null}),!0):!1}function bj(){if(null!==Ti){var a=Ti;Ti=null;a.forEach(function(a,c){xf(Z.bind(null,c,a))});O()}}function ej(a,b){var c=U;U|=1;try{return a(b)}finally{U=c,U===T&&O()}}function fj(a,b,c,d){var e=U;U|=4;try{return vf(98,a.bind(null,b,c,d))}finally{U=e,U===T&&O()}}
function gj(a,b){var c=U;U&=-2;U|=Bi;try{return a(b)}finally{U=c,U===T&&O()}}
function hj(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Me(c));if(null!==V)for(c=V.return;null!==c;){var d=c;switch(d.tag){case 1:var e=d.type.childContextTypes;null!==e&&void 0!==e&&Te(d);break;case 3:Bg(d);Ue(d);break;case 5:Dg(d);break;case 4:Bg(d);break;case 13:H(P,d);break;case 19:H(P,d);break;case 10:If(d)}c=c.return}Ji=a;V=og(a.current,null,b);W=b;X=Ei;Li=Ki=1073741823;Mi=null;Ni=!1}
function Z(a,b,c){if((U&(Ci|Di))!==T)throw t(Error(327));if(a.firstPendingTime<b)return null;if(c&&a.finishedExpirationTime===b)return ij.bind(null,a);cj();if(a!==Ji||b!==W)hj(a,b);else if(X===Hi)if(Ni)hj(a,b);else{var d=a.lastPendingTime;if(d<b)return Z.bind(null,a,d)}if(null!==V){d=U;U|=Ci;var e=zi.current;null===e&&(e=hh);zi.current=hh;if(c){if(1073741823!==b){var f=cg();if(f<b)return U=d,Gf(),zi.current=e,Z.bind(null,a,f)}}else Wi=0;do try{if(c)for(;null!==V;)V=jj(V);else for(;null!==V&&!bf();)V=
jj(V);break}catch(rb){Gf();ih();f=V;if(null===f||null===f.return)throw hj(a,b),U=d,rb;a:{var h=a,g=f.return,k=f,l=rb,n=W;k.effectTag|=1024;k.firstEffect=k.lastEffect=null;if(null!==l&&"object"===typeof l&&"function"===typeof l.then){var z=l,x=0!==(P.current&Fg);l=g;do{var v;if(v=13===l.tag)null!==l.memoizedState?v=!1:(v=l.memoizedProps,v=void 0===v.fallback?!1:!0!==v.unstable_avoidThisFallback?!0:x?!1:!0);if(v){g=l.updateQueue;null===g?(g=new Set,g.add(z),l.updateQueue=g):g.add(z);if(0===(l.mode&
2)){l.effectTag|=64;k.effectTag&=-1957;1===k.tag&&(null===k.alternate?k.tag=17:(n=Qf(1073741823,null),n.tag=2,Sf(k,n)));k.expirationTime=1073741823;break a}k=h;h=n;x=k.pingCache;null===x?(x=k.pingCache=new si,g=new Set,x.set(z,g)):(g=x.get(z),void 0===g&&(g=new Set,x.set(z,g)));g.has(h)||(g.add(h),k=kj.bind(null,k,z,h),z.then(k,k));l.effectTag|=2048;l.expirationTime=n;break a}l=l.return}while(null!==l);l=Error((oc(k.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
pc(k))}X!==Ii&&(X=Fi);l=bi(l,k);k=g;do{switch(k.tag){case 3:k.effectTag|=2048;k.expirationTime=n;n=ti(k,l,n);Tf(k,n);break a;case 1:if(z=l,h=k.type,g=k.stateNode,0===(k.effectTag&64)&&("function"===typeof h.getDerivedStateFromError||null!==g&&"function"===typeof g.componentDidCatch&&(null===xi||!xi.has(g)))){k.effectTag|=2048;k.expirationTime=n;n=wi(k,z,n);Tf(k,n);break a}}k=k.return}while(null!==k)}V=lj(f)}while(1);U=d;Gf();zi.current=e;if(null!==V)return Z.bind(null,a,b)}a.finishedWork=a.current.alternate;
a.finishedExpirationTime=b;if(dj(a,b))return null;Ji=null;switch(X){case Ei:throw t(Error(328));case Fi:return d=a.lastPendingTime,d<b?Z.bind(null,a,d):c?ij.bind(null,a):(hj(a,b),xf(Z.bind(null,a,b)),null);case Gi:if(1073741823===Ki&&!c&&(c=pi+Oi-sf(),10<c)){if(Ni)return hj(a,b),Z.bind(null,a,b);d=a.lastPendingTime;if(d<b)return Z.bind(null,a,d);a.timeoutHandle=Le(ij.bind(null,a),c);return null}return ij.bind(null,a);case Hi:if(!c){if(Ni)return hj(a,b),Z.bind(null,a,b);c=a.lastPendingTime;if(c<b)return Z.bind(null,
a,c);1073741823!==Li?c=10*(1073741821-Li)-sf():1073741823===Ki?c=0:(c=10*(1073741821-Ki)-5E3,d=sf(),b=10*(1073741821-b)-d,c=d-c,0>c&&(c=0),c=(120>c?120:480>c?480:1080>c?1080:1920>c?1920:3E3>c?3E3:4320>c?4320:1960*yi(c/1960))-c,b<c&&(c=b));if(10<c)return a.timeoutHandle=Le(ij.bind(null,a),c),null}return ij.bind(null,a);case Ii:return!c&&1073741823!==Ki&&null!==Mi&&(d=Ki,e=Mi,b=e.busyMinDurationMs|0,0>=b?b=0:(c=e.busyDelayMs|0,d=sf()-(10*(1073741821-d)-(e.timeoutMs|0||5E3)),b=d<=c?0:c+b-d),10<b)?(a.timeoutHandle=
Le(ij.bind(null,a),b),null):ij.bind(null,a);default:throw t(Error(329));}}function Xf(a,b){a<Ki&&1<a&&(Ki=a);null!==b&&a<Li&&1<a&&(Li=a,Mi=b)}function jj(a){var b=mj(a.alternate,a,W);a.memoizedProps=a.pendingProps;null===b&&(b=lj(a));Ai.current=null;return b}
function lj(a){V=a;do{var b=V.alternate;a=V.return;if(0===(V.effectTag&1024)){a:{var c=b;b=V;var d=W,e=b.pendingProps;switch(b.tag){case 2:break;case 16:break;case 15:case 0:break;case 1:N(b.type)&&Te(b);break;case 3:Bg(b);Ue(b);d=b.stateNode;d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===c||null===c.child)Bh(b),b.effectTag&=-3;Uh(b);break;case 5:Dg(b);d=zg(yg.current);var f=b.type;if(null!==c&&null!=b.stateNode)Vh(c,b,f,e,d),c.ref!==b.ref&&(b.effectTag|=128);else if(e){var h=
zg(wg.current);if(Bh(b)){c=b;e=void 0;f=c.stateNode;var g=c.type,k=c.memoizedProps;f[Fa]=c;f[Ga]=k;switch(g){case "iframe":case "object":case "embed":G("load",f);break;case "video":case "audio":for(var l=0;l<bb.length;l++)G(bb[l],f);break;case "source":G("error",f);break;case "img":case "image":case "link":G("error",f);G("load",f);break;case "form":G("reset",f);G("submit",f);break;case "details":G("toggle",f);break;case "input":Cc(f,k);G("invalid",f);Fe(d,"onChange");break;case "select":f._wrapperState=
{wasMultiple:!!k.multiple};G("invalid",f);Fe(d,"onChange");break;case "textarea":oe(f,k),G("invalid",f),Fe(d,"onChange")}De(g,k);l=null;for(e in k)k.hasOwnProperty(e)&&(h=k[e],"children"===e?"string"===typeof h?f.textContent!==h&&(l=["children",h]):"number"===typeof h&&f.textContent!==""+h&&(l=["children",""+h]):ia.hasOwnProperty(e)&&null!=h&&Fe(d,e));switch(g){case "input":Vb(f);Gc(f,k,!0);break;case "textarea":Vb(f);qe(f,k);break;case "select":case "option":break;default:"function"===typeof k.onClick&&
(f.onclick=Ge)}d=l;c.updateQueue=d;null!==d&&Sh(b)}else{k=f;c=e;g=b;l=9===d.nodeType?d:d.ownerDocument;h===re.html&&(h=se(k));h===re.html?"script"===k?(k=l.createElement("div"),k.innerHTML="<script>\x3c/script>",l=k.removeChild(k.firstChild)):"string"===typeof c.is?l=l.createElement(k,{is:c.is}):(l=l.createElement(k),"select"===k&&(k=l,c.multiple?k.multiple=!0:c.size&&(k.size=c.size))):l=l.createElementNS(h,k);k=l;k[Fa]=g;k[Ga]=c;c=k;Th(c,b,!1,!1);g=c;var n=d,z=Ee(f,e);switch(f){case "iframe":case "object":case "embed":G("load",
g);d=e;break;case "video":case "audio":for(d=0;d<bb.length;d++)G(bb[d],g);d=e;break;case "source":G("error",g);d=e;break;case "img":case "image":case "link":G("error",g);G("load",g);d=e;break;case "form":G("reset",g);G("submit",g);d=e;break;case "details":G("toggle",g);d=e;break;case "input":Cc(g,e);d=Bc(g,e);G("invalid",g);Fe(n,"onChange");break;case "option":d=le(g,e);break;case "select":g._wrapperState={wasMultiple:!!e.multiple};d=m({},e,{value:void 0});G("invalid",g);Fe(n,"onChange");break;case "textarea":oe(g,
e);d=ne(g,e);G("invalid",g);Fe(n,"onChange");break;default:d=e}De(f,d);k=void 0;l=f;h=g;var x=d;for(k in x)if(x.hasOwnProperty(k)){var v=x[k];"style"===k?Ae(h,v):"dangerouslySetInnerHTML"===k?(v=v?v.__html:void 0,null!=v&&ve(h,v)):"children"===k?"string"===typeof v?("textarea"!==l||""!==v)&&we(h,v):"number"===typeof v&&we(h,""+v):"suppressContentEditableWarning"!==k&&"suppressHydrationWarning"!==k&&"autoFocus"!==k&&(ia.hasOwnProperty(k)?null!=v&&Fe(n,k):null!=v&&zc(h,k,v,z))}switch(f){case "input":Vb(g);
Gc(g,e,!1);break;case "textarea":Vb(g);qe(g,e);break;case "option":null!=e.value&&g.setAttribute("value",""+Ac(e.value));break;case "select":d=g;g=e;d.multiple=!!g.multiple;k=g.value;null!=k?me(d,!!g.multiple,k,!1):null!=g.defaultValue&&me(d,!!g.multiple,g.defaultValue,!0);break;default:"function"===typeof d.onClick&&(g.onclick=Ge)}Je(f,e)&&Sh(b);b.stateNode=c}null!==b.ref&&(b.effectTag|=128)}else if(null===b.stateNode)throw t(Error(166));break;case 6:if(c&&null!=b.stateNode)Wh(c,b,c.memoizedProps,
e);else{if("string"!==typeof e&&null===b.stateNode)throw t(Error(166));c=zg(yg.current);zg(wg.current);Bh(b)?(d=b.stateNode,c=b.memoizedProps,d[Fa]=b,d.nodeValue!==c&&Sh(b)):(d=b,c=(9===c.nodeType?c:c.ownerDocument).createTextNode(e),c[Fa]=b,d.stateNode=c)}break;case 11:break;case 13:H(P,b);e=b.memoizedState;if(0!==(b.effectTag&64)){b.expirationTime=d;break a}d=null!==e;e=!1;null===c?Bh(b):(f=c.memoizedState,e=null!==f,d||null===f||(f=c.child.sibling,null!==f&&(g=b.firstEffect,null!==g?(b.firstEffect=
f,f.nextEffect=g):(b.firstEffect=b.lastEffect=f,f.nextEffect=null),f.effectTag=8)));if(d&&!e&&0!==(b.mode&2))if(null===c&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(P.current&Fg))X===Ei&&(X=Gi);else if(X===Ei||X===Gi)X=Hi;if(d||e)b.effectTag|=4;break;case 7:break;case 8:break;case 12:break;case 4:Bg(b);Uh(b);break;case 10:If(b);break;case 9:break;case 14:break;case 17:N(b.type)&&Te(b);break;case 18:break;case 19:H(P,b);e=b.memoizedState;if(null===e)break;f=0!==(b.effectTag&64);g=e.rendering;
if(null===g)if(f)$h(e,!1);else{if(X!==Ei||null!==c&&0!==(c.effectTag&64))for(c=b.child;null!==c;){g=Hg(c);if(null!==g){b.effectTag|=64;$h(e,!1);c=g.updateQueue;null!==c&&(b.updateQueue=c,b.effectTag|=4);b.firstEffect=b.lastEffect=null;for(c=b.child;null!==c;)e=c,f=d,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,g=e.alternate,null===g?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=
g.childExpirationTime,e.expirationTime=g.expirationTime,e.child=g.child,e.memoizedProps=g.memoizedProps,e.memoizedState=g.memoizedState,e.updateQueue=g.updateQueue,f=g.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),c=c.sibling;J(P,P.current&Eg|Gg,b);b=b.child;break a}c=c.sibling}}else{if(!f)if(c=Hg(g),null!==c){if(b.effectTag|=64,f=!0,$h(e,!0),null===e.tail&&"hidden"===e.tailMode){d=c.updateQueue;null!==d&&(b.updateQueue=
d,b.effectTag|=4);b=b.lastEffect=e.lastEffect;null!==b&&(b.nextEffect=null);break}}else sf()>e.tailExpiration&&1<d&&(b.effectTag|=64,f=!0,$h(e,!1),b.expirationTime=b.childExpirationTime=d-1);e.isBackwards?(g.sibling=b.child,b.child=g):(d=e.last,null!==d?d.sibling=g:b.child=g,e.last=g)}if(null!==e.tail){0===e.tailExpiration&&(e.tailExpiration=sf()+500);d=e.tail;e.rendering=d;e.tail=d.sibling;e.lastEffect=b.lastEffect;d.sibling=null;c=P.current;c=f?c&Eg|Gg:c&Eg;J(P,c,b);b=d;break a}break;case 20:break;
default:throw t(Error(156));}b=null}d=V;if(1===W||1!==d.childExpirationTime){c=0;for(e=d.child;null!==e;)f=e.expirationTime,g=e.childExpirationTime,f>c&&(c=f),g>c&&(c=g),e=e.sibling;d.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&1024)&&(null===a.firstEffect&&(a.firstEffect=V.firstEffect),null!==V.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=V.firstEffect),a.lastEffect=V.lastEffect),1<V.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=V:a.firstEffect=V,
a.lastEffect=V))}else{b=ai(V,W);if(null!==b)return b.effectTag&=1023,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=1024)}b=V.sibling;if(null!==b)return b;V=a}while(null!==V);X===Ei&&(X=Ii);return null}function ij(a){var b=tf();vf(99,nj.bind(null,a,b));null!==Qi&&wf(97,function(){cj();return null});return null}
function nj(a,b){cj();if((U&(Ci|Di))!==T)throw t(Error(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw t(Error(177));a.callbackNode=null;a.callbackExpirationTime=0;var e=c.expirationTime,f=c.childExpirationTime;e=f>e?f:e;a.firstPendingTime=e;e<a.lastPendingTime&&(a.lastPendingTime=e);a===Ji&&(V=Ji=null,W=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;
if(null!==e){f=U;U|=Di;Ai.current=null;He=Qd;var h=ae();if(be(h)){if("selectionStart"in h)var g={start:h.selectionStart,end:h.selectionEnd};else a:{g=(g=h.ownerDocument)&&g.defaultView||window;var k=g.getSelection&&g.getSelection();if(k&&0!==k.rangeCount){g=k.anchorNode;var l=k.anchorOffset,n=k.focusNode;k=k.focusOffset;try{g.nodeType,n.nodeType}catch(zb){g=null;break a}var z=0,x=-1,v=-1,rb=0,Be=0,u=h,w=null;b:for(;;){for(var C;;){u!==g||0!==l&&3!==u.nodeType||(x=z+l);u!==n||0!==k&&3!==u.nodeType||
(v=z+k);3===u.nodeType&&(z+=u.nodeValue.length);if(null===(C=u.firstChild))break;w=u;u=C}for(;;){if(u===h)break b;w===g&&++rb===l&&(x=z);w===n&&++Be===k&&(v=z);if(null!==(C=u.nextSibling))break;u=w;w=u.parentNode}u=C}g=-1===x||-1===v?null:{start:x,end:v}}else g=null}g=g||{start:0,end:0}}else g=null;Ie={focusedElem:h,selectionRange:g};Qd=!1;Y=e;do try{for(;null!==Y;){if(0!==(Y.effectTag&256)){var I=Y.alternate;h=Y;switch(h.tag){case 0:case 11:case 15:hi(Jg,Ig,h);break;case 1:if(h.effectTag&256&&null!==
I){var E=I.memoizedProps,ua=I.memoizedState,gh=h.stateNode,oj=gh.getSnapshotBeforeUpdate(h.elementType===h.type?E:Af(h.type,E),ua);gh.__reactInternalSnapshotBeforeUpdate=oj}break;case 3:case 5:case 6:case 4:case 17:break;default:throw t(Error(163));}}Y=Y.nextEffect}}catch(zb){if(null===Y)throw t(Error(330));fi(Y,zb);Y=Y.nextEffect}while(null!==Y);Y=e;do try{for(I=b;null!==Y;){var A=Y.effectTag;A&16&&we(Y.stateNode,"");if(A&128){var p=Y.alternate;if(null!==p){var r=p.ref;null!==r&&("function"===typeof r?
r(null):r.current=null)}}switch(A&14){case 2:ni(Y);Y.effectTag&=-3;break;case 6:ni(Y);Y.effectTag&=-3;oi(Y.alternate,Y);break;case 4:oi(Y.alternate,Y);break;case 8:E=Y;ki(E,I);E.return=null;E.child=null;E.memoizedState=null;E.updateQueue=null;E.dependencies=null;var K=E.alternate;null!==K&&(K.return=null,K.child=null,K.memoizedState=null,K.updateQueue=null,K.dependencies=null)}Y=Y.nextEffect}}catch(zb){if(null===Y)throw t(Error(330));fi(Y,zb);Y=Y.nextEffect}while(null!==Y);r=Ie;p=ae();A=r.focusedElem;
I=r.selectionRange;if(p!==A&&A&&A.ownerDocument&&$d(A.ownerDocument.documentElement,A)){null!==I&&be(A)&&(p=I.start,r=I.end,void 0===r&&(r=p),"selectionStart"in A?(A.selectionStart=p,A.selectionEnd=Math.min(r,A.value.length)):(r=(p=A.ownerDocument||document)&&p.defaultView||window,r.getSelection&&(r=r.getSelection(),E=A.textContent.length,K=Math.min(I.start,E),I=void 0===I.end?K:Math.min(I.end,E),!r.extend&&K>I&&(E=I,I=K,K=E),E=Zd(A,K),ua=Zd(A,I),E&&ua&&(1!==r.rangeCount||r.anchorNode!==E.node||r.anchorOffset!==
E.offset||r.focusNode!==ua.node||r.focusOffset!==ua.offset)&&(p=p.createRange(),p.setStart(E.node,E.offset),r.removeAllRanges(),K>I?(r.addRange(p),r.extend(ua.node,ua.offset)):(p.setEnd(ua.node,ua.offset),r.addRange(p))))));p=[];for(r=A;r=r.parentNode;)1===r.nodeType&&p.push({element:r,left:r.scrollLeft,top:r.scrollTop});"function"===typeof A.focus&&A.focus();for(A=0;A<p.length;A++)r=p[A],r.element.scrollLeft=r.left,r.element.scrollTop=r.top}Ie=null;Qd=!!He;He=null;a.current=c;Y=e;do try{for(A=d;null!==
Y;){var $a=Y.effectTag;if($a&36){var nc=Y.alternate;p=Y;r=A;switch(p.tag){case 0:case 11:case 15:hi(Mg,Ng,p);break;case 1:var md=p.stateNode;if(p.effectTag&4)if(null===nc)md.componentDidMount();else{var Fj=p.elementType===p.type?nc.memoizedProps:Af(p.type,nc.memoizedProps);md.componentDidUpdate(Fj,nc.memoizedState,md.__reactInternalSnapshotBeforeUpdate)}var Xh=p.updateQueue;null!==Xh&&Yf(p,Xh,md,r);break;case 3:var Yh=p.updateQueue;if(null!==Yh){K=null;if(null!==p.child)switch(p.child.tag){case 5:K=
p.child.stateNode;break;case 1:K=p.child.stateNode}Yf(p,Yh,K,r)}break;case 5:var Gj=p.stateNode;null===nc&&p.effectTag&4&&(r=Gj,Je(p.type,p.memoizedProps)&&r.focus());break;case 6:break;case 4:break;case 12:break;case 13:case 19:case 17:case 20:break;default:throw t(Error(163));}}if($a&128){var nd=Y.ref;if(null!==nd){var Zh=Y.stateNode;switch(Y.tag){case 5:var gf=Zh;break;default:gf=Zh}"function"===typeof nd?nd(gf):nd.current=gf}}$a&512&&(Pi=!0);Y=Y.nextEffect}}catch(zb){if(null===Y)throw t(Error(330));
fi(Y,zb);Y=Y.nextEffect}while(null!==Y);Y=null;nf();U=f}else a.current=c;if(Pi)Pi=!1,Qi=a,Si=d,Ri=b;else for(Y=e;null!==Y;)b=Y.nextEffect,Y.nextEffect=null,Y=b;b=a.firstPendingTime;0!==b?($a=cg(),$a=zf($a,b),Zi(a,$a,b)):xi=null;"function"===typeof pj&&pj(c.stateNode,d);1073741823===b?a===Vi?Ui++:(Ui=0,Vi=a):Ui=0;if(ui)throw ui=!1,a=vi,vi=null,a;if((U&Bi)!==T)return null;O();return null}
function cj(){if(null===Qi)return!1;var a=Qi,b=Si,c=Ri;Qi=null;Si=0;Ri=90;return vf(97<c?97:c,qj.bind(null,a,b))}function qj(a){if((U&(Ci|Di))!==T)throw t(Error(331));var b=U;U|=Di;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:hi(Pg,Ig,c),hi(Ig,Og,c)}}catch(d){if(null===a)throw t(Error(330));fi(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}U=b;O();return!0}
function rj(a,b,c){b=bi(c,b);b=ti(a,b,1073741823);Sf(a,b);a=Yi(a,1073741823);null!==a&&Zi(a,99,1073741823)}function fi(a,b){if(3===a.tag)rj(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){rj(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===xi||!xi.has(d))){a=bi(b,a);a=wi(c,a,1073741823);Sf(c,a);c=Yi(c,1073741823);null!==c&&Zi(c,99,1073741823);break}}c=c.return}}
function kj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);Ji===a&&W===c?X===Hi||X===Gi&&1073741823===Ki&&sf()-pi<Oi?hj(a,W):Ni=!0:a.lastPendingTime<c||(b=a.pingTime,0!==b&&b<c||(a.pingTime=c,a.finishedExpirationTime===c&&(a.finishedExpirationTime=0,a.finishedWork=null),b=cg(),b=zf(b,c),Zi(a,b,c)))}function ri(a,b){var c=a.stateNode;null!==c&&c.delete(b);c=cg();b=dg(c,a,null);c=zf(c,b);a=Yi(a,b);null!==a&&Zi(a,c,b)}var mj=void 0;
mj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||M.current)Lf=!0;else if(d<c){Lf=!1;switch(b.tag){case 3:Nh(b);Ch();break;case 5:Cg(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Xe(b);break;case 4:Ag(b,b.stateNode.containerInfo);break;case 10:Hf(b,b.memoizedProps.value);break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;if(0!==d&&d>=c)return Ph(a,b,c);J(P,P.current&
Eg,b);b=Fh(a,b,c);return null!==b?b.sibling:null}J(P,P.current&Eg,b);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return Rh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);J(P,P.current,b);if(!d)return null}return Fh(a,b,c)}}else Lf=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Se(b,L.current);Kf(b,c);e=dh(null,b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&
null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;ih();if(N(d)){var f=!0;Xe(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;var h=d.getDerivedStateFromProps;"function"===typeof h&&bg(b,d,h,a);e.updater=fg;b.stateNode=e;e._reactInternalFiber=b;jg(b,d,a,c);b=Mh(null,b,d,!0,f,c)}else b.tag=0,S(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Bf(e);b.type=e;f=b.tag=sj(e);
a=Af(e,a);switch(f){case 0:b=Jh(null,b,e,a,c);break;case 1:b=Lh(null,b,e,a,c);break;case 11:b=Eh(null,b,e,a,c);break;case 14:b=Gh(null,b,e,Af(e.type,a),d,c);break;default:throw t(Error(306),e,"");}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Af(d,e),Jh(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Af(d,e),Lh(a,b,d,e,c);case 3:Nh(b);d=b.updateQueue;if(null===d)throw t(Error(282));e=b.memoizedState;e=null!==e?e.element:null;Wf(b,d,b.pendingProps,
null,c);d=b.memoizedState.element;if(d===e)Ch(),b=Fh(a,b,c);else{e=b.stateNode;if(e=(null===a||null===a.child)&&e.hydrate)uh=Ne(b.stateNode.containerInfo.firstChild),th=b,e=vh=!0;e?(b.effectTag|=2,b.child=ug(b,null,d,c)):(S(a,b,d,c),Ch());b=b.child}return b;case 5:return Cg(b),null===a&&zh(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,h=e.children,Ke(d,e)?h=null:null!==f&&Ke(d,f)&&(b.effectTag|=16),Kh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):
(S(a,b,h,c),b=b.child),b;case 6:return null===a&&zh(b),null;case 13:return Ph(a,b,c);case 4:return Ag(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=tg(b,null,d,c):S(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Af(d,e),Eh(a,b,d,e,c);case 7:return S(a,b,b.pendingProps,c),b.child;case 8:return S(a,b,b.pendingProps.children,c),b.child;case 12:return S(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;h=b.memoizedProps;
f=e.value;Hf(b,f);if(null!==h){var g=h.value;f=hd(g,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(g,f):1073741823)|0;if(0===f){if(h.children===e.children&&!M.current){b=Fh(a,b,c);break a}}else for(g=b.child,null!==g&&(g.return=b);null!==g;){var k=g.dependencies;if(null!==k){h=g.child;for(var l=k.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===g.tag&&(l=Qf(c,null),l.tag=2,Sf(g,l));g.expirationTime<c&&(g.expirationTime=c);l=g.alternate;null!==l&&l.expirationTime<
c&&(l.expirationTime=c);Jf(g.return,c);k.expirationTime<c&&(k.expirationTime=c);break}l=l.next}}else h=10===g.tag?g.type===b.type?null:g.child:g.child;if(null!==h)h.return=g;else for(h=g;null!==h;){if(h===b){h=null;break}g=h.sibling;if(null!==g){g.return=h.return;h=g;break}h=h.return}g=h}}S(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,Kf(b,c),e=Mf(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,S(a,b,d,c),b.child;case 14:return e=b.type,f=Af(e,b.pendingProps),
f=Af(e.type,f),Gh(a,b,e,f,d,c);case 15:return Ih(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Af(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Xe(b)):a=!1,Kf(b,c),hg(b,d,e,c),jg(b,d,e,c),Mh(null,b,d,!0,a,c);case 19:return Rh(a,b,c)}throw t(Error(156));};var pj=null,ji=null;
function tj(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);pj=function(a){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(e){}};ji=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}
function uj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function xh(a,b,c,d){return new uj(a,b,c,d)}
function Hh(a){a=a.prototype;return!(!a||!a.isReactComponent)}function sj(a){if("function"===typeof a)return Hh(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===gc)return 11;if(a===jc)return 14}return 2}
function og(a,b){var c=a.alternate;null===c?(c=xh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,
firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function qg(a,b,c,d,e,f){var h=2;d=a;if("function"===typeof a)Hh(a)&&(h=1);else if("string"===typeof a)h=5;else a:switch(a){case ac:return sg(c.children,e,f,b);case fc:h=8;e|=7;break;case bc:h=8;e|=1;break;case cc:return a=xh(12,c,b,e|8),a.elementType=cc,a.type=cc,a.expirationTime=f,a;case hc:return a=xh(13,c,b,e),a.type=hc,a.elementType=hc,a.expirationTime=f,a;case ic:return a=xh(19,c,b,e),a.elementType=ic,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case dc:h=
10;break a;case ec:h=9;break a;case gc:h=11;break a;case jc:h=14;break a;case kc:h=16;d=null;break a}throw t(Error(130),null==a?a:typeof a,"");}b=xh(h,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function sg(a,b,c,d){a=xh(7,a,d,b);a.expirationTime=c;return a}function pg(a,b,c){a=xh(6,a,null,b);a.expirationTime=c;return a}
function rg(a,b,c){b=xh(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function vj(a,b,c){this.tag=b;this.current=null;this.containerInfo=a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=this.firstBatch=null;this.pingTime=this.lastPendingTime=this.firstPendingTime=this.callbackExpirationTime=0}function wj(a,b,c){a=new vj(a,b,c);b=xh(3,null,null,2===b?7:1===b?3:0);a.current=b;return b.stateNode=a}
function xj(a,b,c,d,e,f){var h=b.current;a:if(c){c=c._reactInternalFiber;b:{if(2!==ld(c)||1!==c.tag)throw t(Error(170));var g=c;do{switch(g.tag){case 3:g=g.stateNode.context;break b;case 1:if(N(g.type)){g=g.stateNode.__reactInternalMemoizedMergedChildContext;break b}}g=g.return}while(null!==g);throw t(Error(171));}if(1===c.tag){var k=c.type;if(N(k)){c=We(c,k,g);break a}}c=g}else c=Qe;null===b.context?b.context=c:b.pendingContext=c;b=f;e=Qf(d,e);e.payload={element:a};b=void 0===b?null:b;null!==b&&
(e.callback=b);Sf(h,e);eg(h,d);return d}function yj(a,b,c,d){var e=b.current,f=cg(),h=$f.suspense;e=dg(f,e,h);return xj(a,b,c,e,h,d)}function zj(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Aj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:$b,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
Db=function(a,b,c){switch(b){case "input":Ec(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Ka(d);if(!e)throw t(Error(90));Wb(d);Ec(d,e)}}}break;case "textarea":pe(a,c);break;case "select":b=c.value,null!=b&&me(a,!!c.multiple,b,!1)}};
function Bj(a){var b=1073741821-25*(((1073741821-cg()+500)/25|0)+1);b<=Xi&&--b;this._expirationTime=Xi=b;this._root=a;this._callbacks=this._next=null;this._hasChildren=this._didComplete=!1;this._children=null;this._defer=!0}Bj.prototype.render=function(a){if(!this._defer)throw t(Error(250));this._hasChildren=!0;this._children=a;var b=this._root._internalRoot,c=this._expirationTime,d=new Cj;xj(a,b,null,c,null,d._onCommit);return d};
Bj.prototype.then=function(a){if(this._didComplete)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a)}};
Bj.prototype.commit=function(){var a=this._root._internalRoot,b=a.firstBatch;if(!this._defer||null===b)throw t(Error(251));if(this._hasChildren){var c=this._expirationTime;if(b!==this){this._hasChildren&&(c=this._expirationTime=b._expirationTime,this.render(this._children));for(var d=null,e=b;e!==this;)d=e,e=e._next;if(null===d)throw t(Error(251));d._next=e._next;this._next=b;a.firstBatch=this}this._defer=!1;b=c;if((U&(Ci|Di))!==T)throw t(Error(253));xf(Z.bind(null,a,b));O();b=this._next;this._next=
null;b=a.firstBatch=b;null!==b&&b._hasChildren&&b.render(b._children)}else this._next=null,this._defer=!1};Bj.prototype._onComplete=function(){if(!this._didComplete){this._didComplete=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<a.length;b++)(0,a[b])()}};function Cj(){this._callbacks=null;this._didCommit=!1;this._onCommit=this._onCommit.bind(this)}Cj.prototype.then=function(a){if(this._didCommit)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a)}};
Cj.prototype._onCommit=function(){if(!this._didCommit){this._didCommit=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<a.length;b++){var c=a[b];if("function"!==typeof c)throw t(Error(191),c);c()}}};function Dj(a,b,c){this._internalRoot=wj(a,b,c)}function Ej(a,b){this._internalRoot=wj(a,2,b)}Ej.prototype.render=Dj.prototype.render=function(a,b){var c=this._internalRoot,d=new Cj;b=void 0===b?null:b;null!==b&&d.then(b);yj(a,c,null,d._onCommit);return d};
Ej.prototype.unmount=Dj.prototype.unmount=function(a){var b=this._internalRoot,c=new Cj;a=void 0===a?null:a;null!==a&&c.then(a);yj(null,b,null,c._onCommit);return c};Ej.prototype.createBatch=function(){var a=new Bj(this),b=a._expirationTime,c=this._internalRoot,d=c.firstBatch;if(null===d)c.firstBatch=a,a._next=null;else{for(c=null;null!==d&&d._expirationTime>=b;)c=d,d=d._next;a._next=d;null!==c&&(c._next=a)}return a};
function Hj(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}Jb=ej;Kb=fj;Lb=aj;Mb=function(a,b){var c=U;U|=2;try{return a(b)}finally{U=c,U===T&&O()}};function Ij(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new Dj(a,0,b)}
function Jj(a,b,c,d,e){var f=c._reactRootContainer,h=void 0;if(f){h=f._internalRoot;if("function"===typeof e){var g=e;e=function(){var a=zj(h);g.call(a)}}yj(b,h,a,e)}else{f=c._reactRootContainer=Ij(c,d);h=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=zj(h);k.call(a)}}gj(function(){yj(b,h,a,e)})}return zj(h)}function Kj(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Hj(b))throw t(Error(200));return Aj(a,b,null,c)}
var Nj={createPortal:Kj,findDOMNode:function(a){if(null==a)a=null;else if(1!==a.nodeType){var b=a._reactInternalFiber;if(void 0===b){if("function"===typeof a.render)throw t(Error(188));throw t(Error(268),Object.keys(a));}a=qd(b);a=null===a?null:a.stateNode}return a},hydrate:function(a,b,c){if(!Hj(b))throw t(Error(200));return Jj(null,a,b,!0,c)},render:function(a,b,c){if(!Hj(b))throw t(Error(200));return Jj(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){if(!Hj(c))throw t(Error(200));
if(null==a||void 0===a._reactInternalFiber)throw t(Error(38));return Jj(a,b,c,!1,d)},unmountComponentAtNode:function(a){if(!Hj(a))throw t(Error(40));return a._reactRootContainer?(gj(function(){Jj(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:function(){return Kj.apply(void 0,arguments)},unstable_batchedUpdates:ej,unstable_interactiveUpdates:function(a,b,c,d){aj();return fj(a,b,c,d)},unstable_discreteUpdates:fj,unstable_flushDiscreteUpdates:aj,flushSync:function(a,
b){if((U&(Ci|Di))!==T)throw t(Error(187));var c=U;U|=1;try{return vf(99,a.bind(null,b))}finally{U=c,O()}},unstable_createRoot:Lj,unstable_createSyncRoot:Mj,unstable_flushControlled:function(a){var b=U;U|=1;try{vf(99,a)}finally{U=b,U===T&&O()}},__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{Events:[Ia,Ja,Ka,Ca.injectEventPluginsByName,fa,Qa,function(a){ya(a,Pa)},Hb,Ib,Ud,Ba,cj,{current:!1}]}};
function Lj(a,b){if(!Hj(a))throw t(Error(299),"unstable_createRoot");return new Ej(a,null!=b&&!0===b.hydrate)}function Mj(a,b){if(!Hj(a))throw t(Error(299),"unstable_createRoot");return new Dj(a,1,null!=b&&!0===b.hydrate)}
(function(a){var b=a.findFiberByHostInstance;return tj(m({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Xb.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=qd(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Ha,bundleType:0,version:"16.9.0",
rendererPackageName:"react-dom"});var Oj={default:Nj},Pj=Oj&&Nj||Oj;module.exports=Pj.default||Pj;


/***/ }),

/***/ "A5Qw":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__("xARA");

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _getField = __webpack_require__("iouw");

var _getField2 = _interopRequireDefault(_getField);

var _getDisplayName = __webpack_require__("6gdi");

var _getDisplayName2 = _interopRequireDefault(_getDisplayName);

var _InkContainer = __webpack_require__("J1Hj");

var _InkContainer2 = _interopRequireDefault(_InkContainer);

var _inkContextTypes = __webpack_require__("H/WW");

var _inkContextTypes2 = _interopRequireDefault(_inkContextTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Takes any component and injects an ink container for having the Material Design Ink effect.
 *
 * The default triggers for an ink are:
 * - mouse down event
 * - touch start event
 * - keyboard focus
 * - form submit
 *
 * The form submit ink will only be triggered if the `ComposedComponent` has the attribute
 * `type="submit"`, the `ComposedComponent` is in a form, and the user hits the `enter` key
 * while not actively focusing the `ComposedComponent`.
 *
 * ```js
 * @param {function} ComposedComponent - The React Component to inject an `ink` prop into.
 * @return {function} a new React class rendering the `ComposedComponent` and adding an
 *    `ink` pop.
 * ```
 */
exports.default = function (ComposedComponent) {
  var _class, _temp2;

  return _temp2 = _class = function (_PureComponent) {
    _inherits(InkedComponent, _PureComponent);

    function InkedComponent() {
      var _temp, _this, _ret;

      _classCallCheck(this, InkedComponent);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.createInk = function (pageX, pageY) {
        if (_this._inkContainer && !_this.props.disabled && !_this.props.inkDisabled) {
          _this._inkContainer.createInk(pageX, pageY);
        }
      }, _this.focus = function () {
        if (_this.props.inkDisabled) {
          var composed = (0, _reactDom.findDOMNode)(_this._composed);
          if (composed) {
            composed.focus();
          }
        } else if (_this._inkContainer) {
          _this._inkContainer.focus();
        }
      }, _this.getComposedComponent = function () {
        return _this._composed;
      }, _this._setInkRef = function (inkContainer) {
        if (inkContainer) {
          _this._inkContainer = inkContainer;
        }
      }, _this._setComposedComponent = function (component) {
        _this._composed = component;
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    InkedComponent.prototype.componentDidMount = function componentDidMount() {
      var ref = this.props.__SUPER_SECRET_REF__;
      // Emulate the ref callback...

      if (ref) {
        ref(this);
      }
    };

    InkedComponent.prototype.componentWillUnmount = function componentWillUnmount() {
      var ref = this.props.__SUPER_SECRET_REF__;
      // Emulate the ref callback...

      if (ref) {
        ref(null);
      }
    };

    /**
     * A publicly accessible way to manually create an ink. This can be used with the `refs`.
     * The ink can either be created by using the `pageX` and `pageY` from a click/touch event
     * or it will be created in the center of the `ComposedComponent`.
     *
     * ```js
     * <SomeInkedComponent ref={inkHOC => inkHOC.createInk()} />
     * ```
     *
     * @param {number=} pageX - An optional pageX of the click or touch event.
     * @param {number=} pageY - An optional pageY of the click or touch event.
     */


    /**
     * This will attempt to focus the composed component. If the component is disabled, nothing
     * will happen. If the `disabled` and `inkDisabled` props are not set to `true`, an ink will
     * also be created.
     *
     * ```js
     * <SomeInkedComponent ref={inkHOC => inkHOC.focus()} />
     * ```
     */


    /**
     * Gets the composed component as a ref. This is useful if you need to access the ref of the
     * composed component instead of the `injectInk` HOC to use some publicly accessible methods.
     *
     * ```js
     * <SomeInkedComponent
     *   ref={inkHOC => {
     *     inkHOC.getComposedComponent().focus();
     *   }}
     * />
     * ```
     */


    InkedComponent.prototype.render = function render() {
      var _props = this.props,
          transitionOverlap = _props.inkTransitionOverlap,
          transitionEnterTimeout = _props.inkTransitionEnterTimeout,
          transitionLeaveTimeout = _props.inkTransitionLeaveTimeout,
          inkStyle = _props.inkStyle,
          inkClassName = _props.inkClassName,
          inkContainerStyle = _props.inkContainerStyle,
          inkContainerClassName = _props.inkContainerClassName,
          waitForInkTransition = _props.waitForInkTransition,
          disabledInteractions = _props.disabledInteractions,
          pulse = _props.pulse,
          propInkDisabled = _props.inkDisabled,
          __SUPER_SECRET_REF__ = _props.__SUPER_SECRET_REF__,
          props = _objectWithoutProperties(_props, ['inkTransitionOverlap', 'inkTransitionEnterTimeout', 'inkTransitionLeaveTimeout', 'inkStyle', 'inkClassName', 'inkContainerStyle', 'inkContainerClassName', 'waitForInkTransition', 'disabledInteractions', 'pulse', 'inkDisabled', '__SUPER_SECRET_REF__']);

      var inkDisabled = (0, _getField2.default)(this.props, this.context, 'inkDisabled');
      var inkDisabledInteractions = typeof disabledInteractions !== 'undefined' ? disabledInteractions : this.context.inkDisabledInteractions;

      if (!(props.disabled || inkDisabled)) {
        props.ink = _react2.default.createElement(_InkContainer2.default, {
          ref: this._setInkRef,
          key: 'ink-container',
          pulse: pulse,
          style: inkContainerStyle,
          className: inkContainerClassName,
          inkStyle: inkStyle,
          inkClassName: inkClassName,
          disabledInteractions: inkDisabledInteractions,
          transitionOverlap: transitionOverlap,
          transitionEnterTimeout: transitionEnterTimeout,
          transitionLeaveTimeout: transitionLeaveTimeout,
          waitForInkTransition: waitForInkTransition
        });
      }

      props.ref = this._setComposedComponent;

      return _react2.default.createElement(ComposedComponent, props);
    };

    return InkedComponent;
  }(_react.PureComponent), _class.displayName = (0, _getDisplayName2.default)(ComposedComponent, 'Ink'), _class.propTypes = {
    /**
     * An optional style to apply to each ink that gets generated.
     */
    inkStyle: _propTypes2.default.object,

    /**
     * An optional className to apply to each ink that gets generated.
     */
    inkClassName: _propTypes2.default.string,

    /**
     * An optional style to apply to the ink's container.
     */
    inkContainerStyle: _propTypes2.default.object,

    /**
     * An optional className to apply to the ink's container.
     */
    inkContainerClassName: _propTypes2.default.string,

    /**
     * Boolean if the composed component or the ink is disabled.
     */
    disabled: _propTypes2.default.bool,

    /**
     * Boolean if only the ink is disabled for the composed component.
     */
    inkDisabled: _propTypes2.default.bool,

    /**
     * The time (in ms) that the enter and leave transitions for the ink should overlap.
     * This really just allows for a more _fluid_ looking ink when something is quickly
     * touched or clicked by having it fade out while growing.
     */
    inkTransitionOverlap: _propTypes2.default.number.isRequired,

    /**
     * The transition time for the ink to be considered fully entered. This should really
     * map up to whatever value you set for `$md-ink-enter-transition-time`.
     */
    inkTransitionEnterTimeout: _propTypes2.default.number.isRequired,

    /**
     * The transition time for the ink to be considered fully leaved (left?). This should really
     * map up to whatever value you set for `$md-ink-leave-transition-time`.
     */
    inkTransitionLeaveTimeout: _propTypes2.default.number.isRequired,

    /**
     * Boolean if the `ComposedComponent`'s click event only after the ink has finished transitioning
     * in and out. This is really only to get a more _fluid_ looking click event when clicking on
     * the `ComposedComponent` ends up taking it out of the view. (ex: Closing a Dialog).
     */
    waitForInkTransition: _propTypes2.default.bool,

    /**
     * An optional array of interactions that can be disabled for the ink. This is a *very* limited
     * use case where `Switches` needed the ink disabled only when using a mouse.
     */
    disabledInteractions: _propTypes2.default.arrayOf(_propTypes2.default.oneOf(['keyboard', 'mouse', 'touch'])),

    /**
     * Boolean if the ink should do a pulse animation while focused. This was enabled by default in
     * previous versions.
     */
    pulse: _propTypes2.default.bool,

    /**
     * When using inked components in a `TransitionGroup`, the ref callback is not actually invoked.
     * This is a little _hack_ to get it to work by not using `ref`, but this name.
     */
    __SUPER_SECRET_REF__: _propTypes2.default.func
  }, _class.defaultProps = {
    inkTransitionOverlap: 150,
    inkTransitionEnterTimeout: 450,
    inkTransitionLeaveTimeout: 300
  }, _class.contextTypes = _inkContextTypes2.default, _temp2;
};

/***/ }),

/***/ "B7Yq":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.FontIcon = undefined;

var _FontIcon2 = __webpack_require__("vMIC");

var _FontIcon3 = _interopRequireDefault(_FontIcon2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _FontIcon3.default;
exports.FontIcon = _FontIcon3.default;

/***/ }),

/***/ "BF0r":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _mapToZero = __webpack_require__("VNYx");

var _mapToZero2 = _interopRequireDefault(_mapToZero);

var _stripStyle = __webpack_require__("jL08");

var _stripStyle2 = _interopRequireDefault(_stripStyle);

var _stepper3 = __webpack_require__("1obq");

var _stepper4 = _interopRequireDefault(_stepper3);

var _performanceNow = __webpack_require__("7nMe");

var _performanceNow2 = _interopRequireDefault(_performanceNow);

var _raf = __webpack_require__("rQBY");

var _raf2 = _interopRequireDefault(_raf);

var _shouldStopAnimation = __webpack_require__("fsLg");

var _shouldStopAnimation2 = _interopRequireDefault(_shouldStopAnimation);

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("W0B4");

var _propTypes2 = _interopRequireDefault(_propTypes);

var msPerFrame = 1000 / 60;

function shouldStopAnimationAll(currentStyles, styles, currentVelocities) {
  for (var i = 0; i < currentStyles.length; i++) {
    if (!_shouldStopAnimation2['default'](currentStyles[i], styles[i], currentVelocities[i])) {
      return false;
    }
  }
  return true;
}

var StaggeredMotion = (function (_React$Component) {
  _inherits(StaggeredMotion, _React$Component);

  _createClass(StaggeredMotion, null, [{
    key: 'propTypes',
    value: {
      // TOOD: warn against putting a config in here
      defaultStyles: _propTypes2['default'].arrayOf(_propTypes2['default'].objectOf(_propTypes2['default'].number)),
      styles: _propTypes2['default'].func.isRequired,
      children: _propTypes2['default'].func.isRequired
    },
    enumerable: true
  }]);

  function StaggeredMotion(props) {
    var _this = this;

    _classCallCheck(this, StaggeredMotion);

    _React$Component.call(this, props);
    this.animationID = null;
    this.prevTime = 0;
    this.accumulatedTime = 0;
    this.unreadPropStyles = null;

    this.clearUnreadPropStyle = function (unreadPropStyles) {
      var _state = _this.state;
      var currentStyles = _state.currentStyles;
      var currentVelocities = _state.currentVelocities;
      var lastIdealStyles = _state.lastIdealStyles;
      var lastIdealVelocities = _state.lastIdealVelocities;

      var someDirty = false;
      for (var i = 0; i < unreadPropStyles.length; i++) {
        var unreadPropStyle = unreadPropStyles[i];
        var dirty = false;

        for (var key in unreadPropStyle) {
          if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {
            continue;
          }

          var styleValue = unreadPropStyle[key];
          if (typeof styleValue === 'number') {
            if (!dirty) {
              dirty = true;
              someDirty = true;
              currentStyles[i] = _extends({}, currentStyles[i]);
              currentVelocities[i] = _extends({}, currentVelocities[i]);
              lastIdealStyles[i] = _extends({}, lastIdealStyles[i]);
              lastIdealVelocities[i] = _extends({}, lastIdealVelocities[i]);
            }
            currentStyles[i][key] = styleValue;
            currentVelocities[i][key] = 0;
            lastIdealStyles[i][key] = styleValue;
            lastIdealVelocities[i][key] = 0;
          }
        }
      }

      if (someDirty) {
        _this.setState({ currentStyles: currentStyles, currentVelocities: currentVelocities, lastIdealStyles: lastIdealStyles, lastIdealVelocities: lastIdealVelocities });
      }
    };

    this.startAnimationIfNecessary = function () {
      // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
      // call cb? No, otherwise accidental parent rerender causes cb trigger
      _this.animationID = _raf2['default'](function (timestamp) {
        var destStyles = _this.props.styles(_this.state.lastIdealStyles);

        // check if we need to animate in the first place
        if (shouldStopAnimationAll(_this.state.currentStyles, destStyles, _this.state.currentVelocities)) {
          // no need to cancel animationID here; shouldn't have any in flight
          _this.animationID = null;
          _this.accumulatedTime = 0;
          return;
        }

        var currentTime = timestamp || _performanceNow2['default']();
        var timeDelta = currentTime - _this.prevTime;
        _this.prevTime = currentTime;
        _this.accumulatedTime = _this.accumulatedTime + timeDelta;
        // more than 10 frames? prolly switched browser tab. Restart
        if (_this.accumulatedTime > msPerFrame * 10) {
          _this.accumulatedTime = 0;
        }

        if (_this.accumulatedTime === 0) {
          // no need to cancel animationID here; shouldn't have any in flight
          _this.animationID = null;
          _this.startAnimationIfNecessary();
          return;
        }

        var currentFrameCompletion = (_this.accumulatedTime - Math.floor(_this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;
        var framesToCatchUp = Math.floor(_this.accumulatedTime / msPerFrame);

        var newLastIdealStyles = [];
        var newLastIdealVelocities = [];
        var newCurrentStyles = [];
        var newCurrentVelocities = [];

        for (var i = 0; i < destStyles.length; i++) {
          var destStyle = destStyles[i];
          var newCurrentStyle = {};
          var newCurrentVelocity = {};
          var newLastIdealStyle = {};
          var newLastIdealVelocity = {};

          for (var key in destStyle) {
            if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {
              continue;
            }

            var styleValue = destStyle[key];
            if (typeof styleValue === 'number') {
              newCurrentStyle[key] = styleValue;
              newCurrentVelocity[key] = 0;
              newLastIdealStyle[key] = styleValue;
              newLastIdealVelocity[key] = 0;
            } else {
              var newLastIdealStyleValue = _this.state.lastIdealStyles[i][key];
              var newLastIdealVelocityValue = _this.state.lastIdealVelocities[i][key];
              for (var j = 0; j < framesToCatchUp; j++) {
                var _stepper = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

                newLastIdealStyleValue = _stepper[0];
                newLastIdealVelocityValue = _stepper[1];
              }

              var _stepper2 = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

              var nextIdealX = _stepper2[0];
              var nextIdealV = _stepper2[1];

              newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;
              newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;
              newLastIdealStyle[key] = newLastIdealStyleValue;
              newLastIdealVelocity[key] = newLastIdealVelocityValue;
            }
          }

          newCurrentStyles[i] = newCurrentStyle;
          newCurrentVelocities[i] = newCurrentVelocity;
          newLastIdealStyles[i] = newLastIdealStyle;
          newLastIdealVelocities[i] = newLastIdealVelocity;
        }

        _this.animationID = null;
        // the amount we're looped over above
        _this.accumulatedTime -= framesToCatchUp * msPerFrame;

        _this.setState({
          currentStyles: newCurrentStyles,
          currentVelocities: newCurrentVelocities,
          lastIdealStyles: newLastIdealStyles,
          lastIdealVelocities: newLastIdealVelocities
        });

        _this.unreadPropStyles = null;

        _this.startAnimationIfNecessary();
      });
    };

    this.state = this.defaultState();
  }

  StaggeredMotion.prototype.defaultState = function defaultState() {
    var _props = this.props;
    var defaultStyles = _props.defaultStyles;
    var styles = _props.styles;

    var currentStyles = defaultStyles || styles().map(_stripStyle2['default']);
    var currentVelocities = currentStyles.map(function (currentStyle) {
      return _mapToZero2['default'](currentStyle);
    });
    return {
      currentStyles: currentStyles,
      currentVelocities: currentVelocities,
      lastIdealStyles: currentStyles,
      lastIdealVelocities: currentVelocities
    };
  };

  StaggeredMotion.prototype.componentDidMount = function componentDidMount() {
    this.prevTime = _performanceNow2['default']();
    this.startAnimationIfNecessary();
  };

  StaggeredMotion.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
    if (this.unreadPropStyles != null) {
      // previous props haven't had the chance to be set yet; set them here
      this.clearUnreadPropStyle(this.unreadPropStyles);
    }

    this.unreadPropStyles = props.styles(this.state.lastIdealStyles);
    if (this.animationID == null) {
      this.prevTime = _performanceNow2['default']();
      this.startAnimationIfNecessary();
    }
  };

  StaggeredMotion.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.animationID != null) {
      _raf2['default'].cancel(this.animationID);
      this.animationID = null;
    }
  };

  StaggeredMotion.prototype.render = function render() {
    var renderedChildren = this.props.children(this.state.currentStyles);
    return renderedChildren && _react2['default'].Children.only(renderedChildren);
  };

  return StaggeredMotion;
})(_react2['default'].Component);

exports['default'] = StaggeredMotion;
module.exports = exports['default'];

// it's possible that currentStyle's value is stale: if props is immediately
// changed from 0 to 400 to spring(0) again, the async currentStyle is still
// at 0 (didn't have time to tick and interpolate even once). If we naively
// compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
// In reality currentStyle should be 400

// after checking for unreadPropStyles != null, we manually go set the
// non-interpolating values (those that are a number, without a spring
// config)

/***/ }),

/***/ "BdB7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.9.0
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var h=__webpack_require__("IL7q"),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,aa=n?Symbol.for("react.suspense_list"):60120,ba=n?Symbol.for("react.memo"):
60115,ca=n?Symbol.for("react.lazy"):60116;n&&Symbol.for("react.fundamental");n&&Symbol.for("react.responder");var z="function"===typeof Symbol&&Symbol.iterator;
function A(a){for(var b=a.message,d="https://reactjs.org/docs/error-decoder.html?invariant="+b,c=1;c<arguments.length;c++)d+="&args[]="+encodeURIComponent(arguments[c]);a.message="Minified React error #"+b+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ";return a}var B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C={};
function D(a,b,d){this.props=a;this.context=b;this.refs=C;this.updater=d||B}D.prototype.isReactComponent={};D.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw A(Error(85));this.updater.enqueueSetState(this,a,b,"setState")};D.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function E(){}E.prototype=D.prototype;function F(a,b,d){this.props=a;this.context=b;this.refs=C;this.updater=d||B}var G=F.prototype=new E;
G.constructor=F;h(G,D.prototype);G.isPureReactComponent=!0;var H={current:null},I={suspense:null},J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,d){var c=void 0,e={},g=null,k=null;if(null!=b)for(c in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=b[c]);var f=arguments.length-2;if(1===f)e.children=d;else if(1<f){for(var l=Array(f),m=0;m<f;m++)l[m]=arguments[m+2];e.children=l}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===e[c]&&(e[c]=f[c]);return{$$typeof:p,type:a,key:g,ref:k,props:e,_owner:J.current}}
function da(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var O=/\/+/g,P=[];function Q(a,b,d,c){if(P.length){var e=P.pop();e.result=a;e.keyPrefix=b;e.func=d;e.context=c;e.count=0;return e}return{result:a,keyPrefix:b,func:d,context:c,count:0}}
function R(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>P.length&&P.push(a)}
function S(a,b,d,c){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var g=!1;if(null===a)g=!0;else switch(e){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return d(c,a,""===b?"."+T(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){e=a[k];var f=b+T(e,k);g+=S(e,f,d,c)}else if(null===a||"object"!==typeof a?f=null:(f=z&&a[z]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=
0;!(e=a.next()).done;)e=e.value,f=b+T(e,k++),g+=S(e,f,d,c);else if("object"===e)throw d=""+a,A(Error(31),"[object Object]"===d?"object with keys {"+Object.keys(a).join(", ")+"}":d,"");return g}function U(a,b,d){return null==a?0:S(a,"",b,d)}function T(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function ea(a,b){a.func.call(a.context,b,a.count++)}
function fa(a,b,d){var c=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?V(a,c,d,function(a){return a}):null!=a&&(N(a)&&(a=da(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(O,"$&/")+"/")+d)),c.push(a))}function V(a,b,d,c,e){var g="";null!=d&&(g=(""+d).replace(O,"$&/")+"/");b=Q(b,g,c,e);U(a,fa,b);R(b)}function W(){var a=H.current;if(null===a)throw A(Error(321));return a}
var X={Children:{map:function(a,b,d){if(null==a)return a;var c=[];V(a,c,null,b,d);return c},forEach:function(a,b,d){if(null==a)return a;b=Q(null,null,b,d);U(a,ea,b);R(b)},count:function(a){return U(a,function(){return null},null)},toArray:function(a){var b=[];V(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw A(Error(143));return a}},createRef:function(){return{current:null}},Component:D,PureComponent:F,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,
_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a},forwardRef:function(a){return{$$typeof:x,render:a}},lazy:function(a){return{$$typeof:ca,_ctor:a,_status:-1,_result:null}},memo:function(a,b){return{$$typeof:ba,type:a,compare:void 0===b?null:b}},useCallback:function(a,b){return W().useCallback(a,b)},useContext:function(a,b){return W().useContext(a,b)},useEffect:function(a,b){return W().useEffect(a,b)},useImperativeHandle:function(a,
b,d){return W().useImperativeHandle(a,b,d)},useDebugValue:function(){},useLayoutEffect:function(a,b){return W().useLayoutEffect(a,b)},useMemo:function(a,b){return W().useMemo(a,b)},useReducer:function(a,b,d){return W().useReducer(a,b,d)},useRef:function(a){return W().useRef(a)},useState:function(a){return W().useState(a)},Fragment:r,Profiler:u,StrictMode:t,Suspense:y,unstable_SuspenseList:aa,createElement:M,cloneElement:function(a,b,d){if(null===a||void 0===a)throw A(Error(267),a);var c=void 0,e=
h({},a.props),g=a.key,k=a.ref,f=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,f=J.current);void 0!==b.key&&(g=""+b.key);var l=void 0;a.type&&a.type.defaultProps&&(l=a.type.defaultProps);for(c in b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=void 0===b[c]&&void 0!==l?l[c]:b[c])}c=arguments.length-2;if(1===c)e.children=d;else if(1<c){l=Array(c);for(var m=0;m<c;m++)l[m]=arguments[m+2];e.children=l}return{$$typeof:p,type:a.type,key:g,ref:k,props:e,_owner:f}},createFactory:function(a){var b=M.bind(null,a);
b.type=a;return b},isValidElement:N,version:"16.9.0",unstable_withSuspenseConfig:function(a,b){var d=I.suspense;I.suspense=void 0===b?null:b;try{a()}finally{I.suspense=d}},__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentDispatcher:H,ReactCurrentBatchConfig:I,ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:h}},Y={default:X},Z=Y&&X||Y;module.exports=Z.default||Z;


/***/ }),

/***/ "Bff0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _deprecated = __webpack_require__("PioW");

var _deprecated2 = _interopRequireDefault(_deprecated);

var _keyCodes = __webpack_require__("CNE2");

var _CSSTransitionGroupTick = __webpack_require__("+5Nw");

var _CSSTransitionGroupTick2 = _interopRequireDefault(_CSSTransitionGroupTick);

var _getBtnStyles2 = __webpack_require__("0dP6");

var _getBtnStyles3 = _interopRequireDefault(_getBtnStyles2);

var _invalidIf = __webpack_require__("dSJ2");

var _invalidIf2 = _interopRequireDefault(_invalidIf);

var _captureNextEvent = __webpack_require__("Z4DA");

var _captureNextEvent2 = _interopRequireDefault(_captureNextEvent);

var _FontIcon = __webpack_require__("vMIC");

var _FontIcon2 = _interopRequireDefault(_FontIcon);

var _IconSeparator = __webpack_require__("vPRa");

var _IconSeparator2 = _interopRequireDefault(_IconSeparator);

var _injectInk = __webpack_require__("A5Qw");

var _injectInk2 = _interopRequireDefault(_injectInk);

var _injectTooltip = __webpack_require__("TNjE");

var _injectTooltip2 = _interopRequireDefault(_injectTooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `Button` component can either be a `FlatButton`, `RaisedButton`, `IconButton`, or a
 * `FloatingButton`.
 *
 * A `FlatButton` is a button with no depth on the screen that is ideally used in `Dialog`s
 * or `CardActions`. The text can be optionally styled with the `primary` or `secondary` colors.
 *
 * A `RaisedButton` is a button with some depth to help actions have more prominent in flat
 * layouts or layouts with varying content. The background can be styled by the light/dark theme,
 * or optionally the `primary` or `secondary` color.
 *
 * An `IconButton` is a button that just displays a `FontIcon` as the child in a circle.
 * The `FontIcon` can be optionally styled with the `primary` or `secondary` color.
 *
 * A `FloatingButton` is a special case. Woop
 */
var Button = function (_PureComponent) {
  _inherits(Button, _PureComponent);

  function Button() {
    var _temp, _this, _ret;

    _classCallCheck(this, Button);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);
  }

  Button.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.disabled && !nextProps.disabled && this.state.hover) {
      this.setState({ hover: false });
    }
  };

  Button.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {
    var _this2 = this;

    if (!this.state.pressed && nextState.pressed) {
      this._timeout = setTimeout(function () {
        _this2._timeout = null;
        if (_this2._attemptedBlur) {
          _this2._attemptedBlur = false;

          _this2.setState({ pressed: false });
        }
      }, 450);
    }
  };

  Button.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    if (this._snackbarTimeout) {
      clearTimeout(this._snackbarTimeout);
    }

    window.removeEventListener('click', this._blur);
  };

  Button.prototype.render = function render() {
    var _getBtnStyles;

    var _props = this.props,
        className = _props.className,
        iconClassName = _props.iconClassName,
        iconChildren = _props.iconChildren,
        iconBefore = _props.iconBefore,
        href = _props.href,
        primary = _props.primary,
        secondary = _props.secondary,
        flat = _props.flat,
        raised = _props.raised,
        floating = _props.floating,
        mini = _props.mini,
        fixed = _props.fixed,
        fixedPosition = _props.fixedPosition,
        disabled = _props.disabled,
        component = _props.component,
        ink = _props.ink,
        tooltip = _props.tooltip,
        icon = _props.icon,
        forceIconSize = _props.forceIconSize,
        forceIconFontSize = _props.forceIconFontSize,
        type = _props.type,
        children = _props.children,
        swapTheming = _props.swapTheming,
        svg = _props.svg,
        propIconEl = _props.iconEl,
        label = _props.label,
        props = _objectWithoutProperties(_props, ['className', 'iconClassName', 'iconChildren', 'iconBefore', 'href', 'primary', 'secondary', 'flat', 'raised', 'floating', 'mini', 'fixed', 'fixedPosition', 'disabled', 'component', 'ink', 'tooltip', 'icon', 'forceIconSize', 'forceIconFontSize', 'type', 'children', 'swapTheming', 'svg', 'iconEl', 'label']);

    var iconEl = this.props.iconEl;


    if (!href) {
      props.type = type;
    }

    var _state = this.state,
        pressed = _state.pressed,
        hover = _state.hover,
        snackbar = _state.snackbar,
        snackbarType = _state.snackbarType;

    var iconBtnType = icon || floating;

    var visibleChildren = void 0;
    if (!iconEl && !svg && (iconClassName || iconChildren || iconBtnType || label && children)) {
      var resolvedIconChildren = iconChildren;
      if (typeof iconChildren === 'undefined') {
        resolvedIconChildren = iconBtnType || label ? children : null;
      }

      iconEl = _react2.default.createElement(
        _FontIcon2.default,
        { iconClassName: iconClassName, forceSize: forceIconSize, forceFontSize: forceIconFontSize, inherit: true },
        resolvedIconChildren
      );
    } else if (iconEl || svg) {
      var el = _react2.default.Children.only(iconEl || children);
      iconEl = _react2.default.cloneElement(el, { inherit: !el.props.error });
    }

    if (!iconBtnType) {
      visibleChildren = label || children;
      if (iconEl) {
        visibleChildren = _react2.default.createElement(
          _IconSeparator2.default,
          { label: visibleChildren, iconBefore: iconBefore },
          iconEl
        );
      }
    } else {
      visibleChildren = iconEl;
    }

    var Component = component || (href ? 'a' : 'button');
    return _react2.default.createElement(
      Component,
      _extends({}, props, {
        disabled: disabled,
        onTouchStart: this._handleTouchStart,
        onTouchEnd: this._handleTouchEnd,
        onMouseDown: this._handleMouseDown,
        onMouseUp: this._handleMouseUp,
        onKeyDown: this._handleKeyDown,
        onKeyUp: this._handleKeyUp,
        onMouseEnter: this._handleMouseEnter,
        onMouseLeave: this._handleMouseLeave,
        href: href,
        className: (0, _getBtnStyles3.default)({
          flat: flat,
          raised: raised,
          icon: icon,
          floating: floating,
          disabled: disabled,
          primary: primary,
          secondary: secondary,
          hover: hover,
          swapTheming: swapTheming,
          pressed: pressed,
          mini: mini,
          fixed: fixed,
          fixedPosition: fixedPosition
        }, (_getBtnStyles = {
          'md-btn--tooltip': tooltip,
          'md-btn--snackbar-floating': snackbar
        }, _getBtnStyles['md-btn--snackbar-floating-' + snackbarType + 'adjust'] = snackbar && snackbarType !== null, _getBtnStyles), 'md-inline-block', className)
      }),
      ink,
      tooltip,
      visibleChildren
    );
  };

  return Button;
}(_react.PureComponent);

Button.propTypes = {
  /**
   * An optional style to apply to the button.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply to the button.
   */
  className: _propTypes2.default.string,

  /**
   * A boolean if the icon should appear before or after the text for a `FlatButton` or
   * a `RaisedButton`.
   */
  iconBefore: _propTypes2.default.bool,

  /**
   * Any children used to display the button. When the button type is `icon` or `floating`,
   * this can be used to render the `FontIcon` instead of the `iconChildren` prop.
   *
   * When the button type is `raised` or `flat`, this will be the label or any other elements
   * you'd like to display in the button. This can work hand-in-hand with the `iconClassName`
   * and `iconChildren` to make a button with an icon and text.
   */
  children: _propTypes2.default.node,

  /**
   * An icon className to use in an optional `FontIcon` in any version of the button. This will
   * be used with the `children` prop. If the `floating` or `icon` props are set to true, this or
   * the children are required.
   *
   * @see {@link #iconEl}
   */
  iconClassName: _propTypes2.default.string,

  /**
   * Any children to use to display an icon in the button.
   *
   * @see {@link #iconEl}
   */
  iconChildren: _propTypes2.default.node,

  /**
   * An optional icon to display. This prop is recommended over the `iconClassName` and `iconChildren`
   * props since it allows more control for you. There is also better SVG support since it won't wrap
   * the SVG with the `FontIcon` element.
   */
  iconEl: _propTypes2.default.element,

  /**
   * The type for the button. This is required when the `component` prop is not
   * the 'a' tag, a `function`, or when the `href` prop is defined.
   */
  type: function type(props, propName, component) {
    for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      args[_key2 - 3] = arguments[_key2];
    }

    var c = props.component;
    var validator = _propTypes2.default.oneOf(['button', 'submit', 'reset']);
    if (!props.href && c !== 'a' && typeof c !== 'function') {
      validator = validator.isRequired;
    }

    return validator.apply(undefined, [props, propName, component].concat(args));
  },

  /**
   * Boolean if the button should be styled with the primary color.
   */
  primary: _propTypes2.default.bool,

  /**
   * Boolean if the button should be styled with the secondary color.
   */
  secondary: _propTypes2.default.bool,

  /**
   * Boolean if the button is disabled.
   */
  disabled: _propTypes2.default.bool,

  /**
   * An optional href for the button. This will style the `a` tag as a button.
   */
  href: _propTypes2.default.string,

  /**
   * An optional component to render the button as. This allows you to get all the styles and functionality
   * of the Button, but as a custom React component.
   */
  component: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),

  /**
   * An optional function to call when the `click` event is triggered.
   */
  onClick: _propTypes2.default.func,

  /**
   * An optional function to call when the `touchstart` event is triggered.
   */
  onTouchStart: _propTypes2.default.func,

  /**
   * An optional function to call when the `touchend` event is triggered.
   */
  onTouchEnd: _propTypes2.default.func,

  /**
   * An optional function to call when the `mousedown` event is triggered.
   */
  onMouseDown: _propTypes2.default.func,

  /**
   * An optional function to call when the `mouseup` event is triggered.
   */
  onMouseUp: _propTypes2.default.func,

  /**
   * An optional function to call when the `keyup` event is triggered.
   */
  onKeyUp: _propTypes2.default.func,

  /**
   * An optional function to call when the `keydown` event is triggered.
   */
  onKeyDown: _propTypes2.default.func,

  /**
   * An optional function to call when the `mouseenter` event is triggered.
   */
  onMouseEnter: _propTypes2.default.func,

  /**
   * An optional function to call when the `mouseleave` event is triggered.
   */
  onMouseLeave: _propTypes2.default.func,

  /**
   * Boolean if the `FloatingButton` should be fixed to the page. This prop can
   * only be enabled if the `floating` prop is true.
   */
  fixed: (0, _invalidIf2.default)(_propTypes2.default.bool, 'flat', 'raised', 'icon'),

  /**
   * The position that the `FloatingButton` should be fixed to the page. It will
   * either be fixed to the top right, top left, bottom right, or bottom left of
   * the page. This prop is only used if the `floating` prop and `fixed` prop are
   * `true`.
   */
  fixedPosition: _propTypes2.default.oneOf(['tr', 'tl', 'br', 'bl']).isRequired,

  /**
   * Boolean if the `FloatingButton` should be `mini`. This prop can only be used
   * when the `floating` prop is true.
   */
  mini: (0, _invalidIf2.default)(_propTypes2.default.bool, 'flat', 'raised', 'icon'),

  /**
   * Boolean if the `Button` should be styled as a `FlatButton`.
   */
  flat: _propTypes2.default.bool,

  /**
   * Boolean if the `Button` should be styled as a `RaisedButton`.
   */
  raised: _propTypes2.default.bool,

  /**
   * Boolean if the `Button` should be styled as a `IconButton`.
   *
   * @see {@link #svg}
   */
  icon: _propTypes2.default.bool,

  /**
   * Boolean if the `Button` should be styled as a `FloatingButton`.
   *
   * @see {@link #svg}
   */
  floating: _propTypes2.default.bool,

  /**
   * Boolean if the theming of `primary` or `secondary` should be swapped. By default,
   * only flat and icon buttons can gain the theme colors as text color while the raised
   * and floating buttons can gain the theme colors as background color.
   *
   * If this prop is enabled, the flat and icon buttons will gain the theme background colors
   * while the raised and icon will gain the theme text colors instead.
   *
   * @see {@link #primary}
   * @see {@link #secondary}
   */
  swapTheming: _propTypes2.default.bool,

  /**
   * An optional label to use for the tooltip. This is normally only used for
   * `IconButton`s or `FloatingButton`s, but can be used on `FlatButton`s and
   * `RaisedButton`s if you wish. Knock yourself out!
   *
   * If this prop is omitted, no tooltip will be included.
   */
  tooltipLabel: _propTypes2.default.node,

  /**
   * An optional delay before the tooltip appears on mouse over.
   */
  tooltipDelay: _propTypes2.default.number,

  /**
   * The position for the tooltip.
   */
  tooltipPosition: _propTypes2.default.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * An ink from `injectInk`.
   * @access private
   */
  ink: _propTypes2.default.node,

  /**
   * A tooltip from `injectTooltip`
   * @access private
   */
  tooltip: _propTypes2.default.node,

  /**
   * Custom validator for verifying that only one type is defined and that
   * at one type is defined.
   */
  _typeValidator: function _typeValidator(props, propName, component) {
    var flat = props.flat,
        raised = props.raised,
        icon = props.icon,
        floating = props.floating;


    var defined = [raised, flat, icon, floating].filter(function (d) {
      return d;
    });
    var len = defined.length;
    if (len === 0) {
      return new Error('A material design button type must be specified in the `' + component + '` but none were ' + 'given. Valid types are `flat`, `raised`, `icon`, or `floating`.');
    } else if (len !== 1) {
      return new Error('Only one material design button type may be specified in the `' + component + '` but `' + len + '` ' + 'were given. Select only one of `flat`, `raised`, `icon`, or `floating`.');
    }

    return null;
  },

  /**
   * Either a boolean that will enforce the 24x24 size of the font icon or a number of the size
   * to enforce. This is useful when using other font icon libraries that do not have a consistent
   * size.
   */
  forceIconSize: _FontIcon2.default.propTypes.forceSize,

  /**
   * Boolean if the `forceIconSize` prop should also force the `font-size` instead of only `width` and `height`.
   */
  forceIconFontSize: _propTypes2.default.bool,

  /**
   * Boolean if the child is an SVGIcon or FontIcon when using the `icon` or `floating` props. This is only needed
   * until the next release when the `label` migration can be removed.
   */
  svg: _propTypes2.default.bool,

  label: (0, _deprecated2.default)(_propTypes2.default.node, 'Use the `children` prop instead'),
  noIcon: (0, _deprecated2.default)(_propTypes2.default.bool, 'This has been removed during the alpha release. Children will always attempt to be rendered outside of an ' + 'icon by default for flat and raised buttons')
};
Button.defaultProps = {
  type: 'button',
  iconBefore: true,
  fixedPosition: 'br'
};

var _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.state = {
    pressed: false,
    snackbar: false,
    snackbarType: null
  };

  this._blur = function () {
    if (_this3.props.disabled) {
      return;
    }

    if (_this3._timeout) {
      _this3._attemptedBlur = true;
    } else {
      _this3.setState({ pressed: false });
    }
  };

  this._handleMouseUp = function (e) {
    if (_this3.props.onMouseUp) {
      _this3.props.onMouseUp(e);
    }

    _this3._blur();
  };

  this._handleMouseDown = function (e) {
    if (_this3.props.onMouseDown) {
      _this3.props.onMouseDown(e);
    }

    if (!_this3.props.disabled) {
      _this3.setState({ pressed: true });
    }
  };

  this._handleTouchStart = function (e) {
    if (_this3.props.onTouchStart) {
      _this3.props.onTouchStart(e);
    }

    if (!_this3.props.disabled) {
      _this3.setState({ pressed: true });
    }
  };

  this._handleTouchEnd = function (e) {
    if (_this3.props.onTouchEnd) {
      _this3.props.onTouchEnd(e);
    }

    _this3._blur();
    (0, _captureNextEvent2.default)('mouseover');
  };

  this._handleKeyUp = function (e) {
    if (_this3.props.onKeyUp) {
      _this3.props.onKeyUp(e);
    }

    if ((e.which || e.keyCode) === _keyCodes.TAB) {
      window.addEventListener('click', _this3._blur);
      _this3.setState({ pressed: true });
    }
  };

  this._handleKeyDown = function (e) {
    if (_this3.props.onKeyDown) {
      _this3.props.onKeyDown(e);
    }

    if ((e.which || e.keyCode) === _keyCodes.TAB) {
      window.removeEventListener('click', _this3._blur);
      _this3.setState({ pressed: false });
    }
  };

  this._handleMouseEnter = function (e) {
    if (_this3.props.onMouseEnter) {
      _this3.props.onMouseEnter(e);
    }

    if (!_this3.props.disabled) {
      _this3.setState({ hover: true });
    }
  };

  this._handleMouseLeave = function (e) {
    if (_this3.props.onMouseLeave) {
      _this3.props.onMouseLeave(e);
    }

    if (!_this3.props.disabled) {
      _this3.setState({ hover: false });
    }
  };

  this._animateForSnackbar = function (multiline, leaveTimeout) {
    if (typeof leaveTimeout === 'number') {
      _this3._snackbarTimeout = setTimeout(function () {
        _this3._snackbarTimeout = setTimeout(function () {
          _this3._snackbarTimeout = null;

          _this3.setState({ snackbar: false });
        }, leaveTimeout + 150);

        _this3.setState({ snackbarType: null });
      }, _CSSTransitionGroupTick2.default);
    } else {
      _this3._snackbarTimeout = setTimeout(function () {
        _this3._snackbarTimeout = null;

        _this3.setState({ snackbar: true, snackbarType: multiline ? 'multiline-' : '' });
      }, _CSSTransitionGroupTick2.default);
    }
  };
};

exports.default = (0, _injectInk2.default)((0, _injectTooltip2.default)(Button));

/***/ }),

/***/ "CNE2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var LEFT_MOUSE = exports.LEFT_MOUSE = 0;
var RIGHT_MOUSE = exports.RIGHT_MOUSE = 2;

var TAB = exports.TAB = 9;
var ENTER = exports.ENTER = 13;
var ESC = exports.ESC = 27;
var SPACE = exports.SPACE = 32;
var PAGE_UP = exports.PAGE_UP = 33;
var PAGE_DOWN = exports.PAGE_DOWN = 34;
var END = exports.END = 35;
var HOME = exports.HOME = 36;
var LEFT = exports.LEFT = 37;
var UP = exports.UP = 38;
var RIGHT = exports.RIGHT = 39;
var DOWN = exports.DOWN = 40;

var ZERO = exports.ZERO = 48;
var NINE = exports.NINE = 57;
var KEYPAD_ZERO = exports.KEYPAD_ZERO = 96;
var KEYPAD_NINE = exports.KEYPAD_NINE = 105;

/***/ }),

/***/ "Dhpq":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _default = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "E02R":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "EDUi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("10o/");

exports.__esModule = true;
exports.default = void 0;

var _inDOM = _interopRequireDefault(__webpack_require__("Dhpq"));

var off = function off() {};

if (_inDOM.default) {
  off = function () {
    if (document.addEventListener) return function (node, eventName, handler, capture) {
      return node.removeEventListener(eventName, handler, capture || false);
    };else if (document.attachEvent) return function (node, eventName, handler) {
      return node.detachEvent('on' + eventName, handler);
    };
  }();
}

var _default = off;
exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "EK6g":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  RESISTANCE_COEF: 0.6,
  // This value is closed to what browsers are using internally to
  // trigger a native scroll.
  UNCERTAINTY_THRESHOLD: 3 // px

};
exports.default = _default;

/***/ }),

/***/ "FIWN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = "production" !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);
    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  }

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

module.exports = warning;


/***/ }),

/***/ "FaXh":
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "Fcif":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "FesL":
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),

/***/ "FfeU":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("pCvA")))

/***/ }),

/***/ "GALk":
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "GI0s":
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__("jgJv"),
    getRawTag = __webpack_require__("vMVM"),
    objectToString = __webpack_require__("HLVI");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "GtMC":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__("vdEC");

var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PageCanvas;
exports.PageCanvasInternal = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _PageContext = _interopRequireDefault(__webpack_require__("1VGG"));

var _utils = __webpack_require__("YliN");

var _propTypes2 = __webpack_require__("T5tG");

var PageCanvasInternal =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(PageCanvasInternal, _PureComponent);

  function PageCanvasInternal() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, PageCanvasInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(PageCanvasInternal)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onRenderSuccess", function () {
      _this.renderer = null;
      var _this$props = _this.props,
          onRenderSuccess = _this$props.onRenderSuccess,
          page = _this$props.page,
          scale = _this$props.scale;
      (0, _utils.callIfDefined)(onRenderSuccess, (0, _utils.makePageCallback)(page, scale));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onRenderError", function (error) {
      if ((0, _utils.isCancelException)(error)) {
        return;
      }

      (0, _utils.errorOnDev)(error);
      var onRenderError = _this.props.onRenderError;
      (0, _utils.callIfDefined)(onRenderError, error);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "drawPageOnCanvas", function () {
      var _assertThisInitialize = (0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)),
          canvas = _assertThisInitialize.canvasLayer;

      if (!canvas) {
        return null;
      }

      var _assertThisInitialize2 = (0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)),
          renderViewport = _assertThisInitialize2.renderViewport,
          viewport = _assertThisInitialize2.viewport;

      var _this$props2 = _this.props,
          page = _this$props2.page,
          renderInteractiveForms = _this$props2.renderInteractiveForms;
      canvas.width = renderViewport.width;
      canvas.height = renderViewport.height;
      canvas.style.width = "".concat(Math.floor(viewport.width), "px");
      canvas.style.height = "".concat(Math.floor(viewport.height), "px");
      var renderContext = {
        get canvasContext() {
          return canvas.getContext('2d');
        },

        viewport: renderViewport,
        renderInteractiveForms: renderInteractiveForms
      }; // If another render is in progress, let's cancel it

      _this.cancelRenderingTask();

      _this.renderer = page.render(renderContext);
      return _this.renderer.promise.then(_this.onRenderSuccess).catch(_this.onRenderError);
    });
    return _this;
  }

  (0, _createClass2.default)(PageCanvasInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.drawPageOnCanvas();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props3 = this.props,
          page = _this$props3.page,
          renderInteractiveForms = _this$props3.renderInteractiveForms;

      if (renderInteractiveForms !== prevProps.renderInteractiveForms) {
        // Ensures the canvas will be re-rendered from scratch. Otherwise all form data will stay.
        page.cleanup();
        this.drawPageOnCanvas();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelRenderingTask();
      /**
       * Zeroing the width and height cause most browsers to release graphics
       * resources immediately, which can greatly reduce memory consumption.
       */

      if (this.canvasLayer) {
        this.canvasLayer.width = 0;
        this.canvasLayer.height = 0;
        this.canvasLayer = null;
      }
    }
  }, {
    key: "cancelRenderingTask",
    value: function cancelRenderingTask() {
      /* eslint-disable no-underscore-dangle */
      if (this.renderer && this.renderer._internalRenderTask.running) {
        this.renderer._internalRenderTask.cancel();
      }
      /* eslint-enable no-underscore-dangle */

    }
    /**
     * Called when a page is rendered successfully.
     */

  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return _react.default.createElement("canvas", {
        className: "react-pdf__Page__canvas",
        style: {
          display: 'block',
          userSelect: 'none'
        },
        ref: function ref(_ref) {
          _this2.canvasLayer = _ref;
        }
      });
    }
  }, {
    key: "renderViewport",
    get: function get() {
      var _this$props4 = this.props,
          page = _this$props4.page,
          rotate = _this$props4.rotate,
          scale = _this$props4.scale;
      var pixelRatio = (0, _utils.getPixelRatio)();
      return page.getViewport({
        scale: scale * pixelRatio,
        rotation: rotate
      });
    }
  }, {
    key: "viewport",
    get: function get() {
      var _this$props5 = this.props,
          page = _this$props5.page,
          rotate = _this$props5.rotate,
          scale = _this$props5.scale;
      return page.getViewport({
        scale: scale,
        rotation: rotate
      });
    }
  }]);
  return PageCanvasInternal;
}(_react.PureComponent);

exports.PageCanvasInternal = PageCanvasInternal;
PageCanvasInternal.propTypes = {
  onRenderError: _propTypes.default.func,
  onRenderSuccess: _propTypes.default.func,
  page: _propTypes2.isPage.isRequired,
  renderInteractiveForms: _propTypes.default.bool,
  rotate: _propTypes2.isRotate,
  scale: _propTypes.default.number
};

function PageCanvas(props) {
  return _react.default.createElement(_PageContext.default.Consumer, null, function (context) {
    return _react.default.createElement(PageCanvasInternal, (0, _extends2.default)({}, context, props));
  });
}

/***/ }),

/***/ "H/WW":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  inkDisabled: _propTypes2.default.bool,
  inkDisabledInteractions: _propTypes2.default.arrayOf(_propTypes2.default.oneOf(['keyboard', 'mouse', 'touch']))
};

/***/ }),

/***/ "HLVI":
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "HtUH":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getCollapserStyles;

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A simple utility function to get the dynamic collapser styles.
 */
function getCollapserStyles(_ref) {
  var _ref2;

  var flipped = _ref.flipped,
      suffix = _ref.suffix,
      suffixFlipped = _ref.suffixFlipped;

  for (var _len = arguments.length, classNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    classNames[_key - 1] = arguments[_key];
  }

  return _classnames2.default.apply(undefined, ['md-collapser', (_ref2 = {
    'md-collapser--flipped': flipped && (!suffixFlipped || !suffix)
  }, _ref2['md-collapser--' + suffix] = suffix, _ref2['md-collapser--' + suffix + '-flipped'] = suffix && flipped && suffixFlipped, _ref2)].concat(classNames));
}

/***/ }),

/***/ "IL7q":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "ILPZ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = oneRequiredForA11yIf;
/** @module utils/PropTypes/oneRequiredForA11yIf */

/**
 * A PropType validator to make sure that any of the other prop names have been defined
 * if the current prop is also defined.
 *
 * This is mostly useful for when adding a prop requires additional accessibility props defined
 * as well.
 *
 * @param {function} validator - The current prop's validator.
 */
function oneRequiredForA11yIf(validator) {
  for (var _len = arguments.length, otherPropNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    otherPropNames[_key - 1] = arguments[_key];
  }

  return function validate(props, propName, componentName, location, propFullName) {
    var filterUndefined = function filterUndefined(pn) {
      return typeof props[pn] !== 'undefined';
    };
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;
    var defined = typeof props[propName] !== 'undefined';
    var allPropNames = [propFullNameSafe].concat(otherPropNames);

    for (var _len2 = arguments.length, args = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      args[_key2 - 5] = arguments[_key2];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (!err && defined && !allPropNames.filter(filterUndefined).length) {
      err = new Error('One of the following props are required to make `' + componentNameSafe + '` accessible ' + ('for users of assistive technologies such as screen readers when using the `' + propFullNameSafe + '` ') + ('prop. `' + allPropNames.join('`, `') + '`.'));
    }

    return err;
  };
}

/***/ }),

/***/ "IsBi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("10o/");

exports.__esModule = true;
exports.default = void 0;

var _inDOM = _interopRequireDefault(__webpack_require__("Dhpq"));

var vendors = ['', 'webkit', 'moz', 'o', 'ms'];
var cancel = 'clearTimeout';
var raf = fallback;
var compatRaf;

var getKey = function getKey(vendor, k) {
  return vendor + (!vendor ? k : k[0].toUpperCase() + k.substr(1)) + 'AnimationFrame';
};

if (_inDOM.default) {
  vendors.some(function (vendor) {
    var rafKey = getKey(vendor, 'request');

    if (rafKey in window) {
      cancel = getKey(vendor, 'cancel');
      return raf = function raf(cb) {
        return window[rafKey](cb);
      };
    }
  });
}
/* https://github.com/component/raf */


var prev = new Date().getTime();

function fallback(fn) {
  var curr = new Date().getTime(),
      ms = Math.max(0, 16 - (curr - prev)),
      req = setTimeout(fn, ms);
  prev = curr;
  return req;
}

compatRaf = function compatRaf(cb) {
  return raf(cb);
};

compatRaf.cancel = function (id) {
  window[cancel] && typeof window[cancel] === 'function' && window[cancel](id);
};

var _default = compatRaf;
exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "J1Hj":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__("xARA");

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _TransitionGroup = __webpack_require__("kFlJ");

var _TransitionGroup2 = _interopRequireDefault(_TransitionGroup);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _keyCodes = __webpack_require__("CNE2");

var _isFormPartRole = __webpack_require__("awmu");

var _isFormPartRole2 = _interopRequireDefault(_isFormPartRole);

var _calcPageOffset = __webpack_require__("miBv");

var _calcPageOffset2 = _interopRequireDefault(_calcPageOffset);

var _isValidClick = __webpack_require__("KXO5");

var _isValidClick2 = _interopRequireDefault(_isValidClick);

var _touches = __webpack_require__("nuxT");

var _captureNextEvent = __webpack_require__("Z4DA");

var _captureNextEvent2 = _interopRequireDefault(_captureNextEvent);

var _calculateHypotenuse = __webpack_require__("n+IE");

var _calculateHypotenuse2 = _interopRequireDefault(_calculateHypotenuse);

var _Ink = __webpack_require__("OaVA");

var _Ink2 = _interopRequireDefault(_Ink);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `InkContainer` is used for holding the list of inks that get created by touch,
 * click, or keyboard focus.
 *
 * If the container element has the `type="submit"` attribute, the ink will also be
 * triggered when the user presses enter anywhere in the form.
 */
var InkContainer = function (_PureComponent) {
  _inherits(InkContainer, _PureComponent);

  function InkContainer() {
    var _temp, _this, _ret;

    _classCallCheck(this, InkContainer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { inks: [] }, _this.createInk = function (pageX, pageY) {
      _this._createInk(pageX, pageY);
      _this._removeTimeout = setTimeout(function () {
        _this._removeTimeout = null;
        _this._removeInk();
      }, _this.props.transitionOverlap);
    }, _this.focus = function () {
      _this._getKeyboardContainer().focus();
    }, _this._createInk = function (pageX, pageY) {
      var _this$_inkContainer = _this._inkContainer,
          offsetWidth = _this$_inkContainer.offsetWidth,
          offsetHeight = _this$_inkContainer.offsetHeight;


      var x = void 0;
      var y = void 0;
      if (typeof pageX !== 'undefined' && typeof pageY !== 'undefined') {
        var pageOffset = (0, _calcPageOffset2.default)(_this._inkContainer);

        x = pageX - pageOffset.left;
        y = pageY - pageOffset.top;
      } else {
        x = offsetWidth / 2;
        y = offsetHeight / 2;
      }

      var r = Math.max((0, _calculateHypotenuse2.default)(x, y), (0, _calculateHypotenuse2.default)(offsetWidth - x, y), (0, _calculateHypotenuse2.default)(offsetWidth - x, offsetHeight - y), (0, _calculateHypotenuse2.default)(x, offsetHeight - y));

      var ink = {
        left: x - r,
        top: y - r,
        size: r * 2,
        key: Date.now()
      };

      var inks = _this.state.inks.slice();
      inks.push(ink);
      _this.setState({ inks: inks });
    }, _this._removeInk = function () {
      var inks = _this.state.inks.slice();
      inks.pop();

      _this.setState({ inks: inks });
    }, _this._getKeyboardContainer = function () {
      if (_this._container.classList.contains('md-text-field-container')) {
        return _this._container.querySelector('.md-text-field');
      }

      return _this._container;
    }, _this._setContainers = function (group) {
      if (group !== null) {
        _this._inkContainer = (0, _reactDom.findDOMNode)(group);
        _this._container = _this._inkContainer.parentElement;

        if (_this._container) {
          _this._initOrRemoveEvents(_this.props);
        }
      }
    }, _this._initOrRemoveEvents = function (props) {
      var keyboardDiff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var mouseDiff = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var touchDiff = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      var mouseDisabled = _this._isListenerDisabled('mouse', props.disabledInteractions);
      var touchDisabled = _this._isListenerDisabled('touch', props.disabledInteractions);
      var keyboardDisabled = _this._isListenerDisabled('keyboard', props.disabledInteractions);

      if (keyboardDiff) {
        var fn = (keyboardDisabled ? 'remove' : 'add') + 'EventListener';
        _this._getKeyboardContainer()[fn]('focus', _this._handleFocus);
        _this._getKeyboardContainer()[fn]('keydown', _this._handleKeyDown);

        if (_this._container.getAttribute('type') === 'submit') {
          window[fn]('submit', _this._handleSubmit);
        }

        if (mouseDiff) {
          _this._container[(!mouseDisabled ? 'add' : 'remove') + 'EventListener']('mousedown', _this._stopPropagationToFocus);
        }

        if (touchDiff) {
          (0, _touches.setTouchEvent)(!touchDisabled, _this._container, 'start', _this._stopPropagationToFocus);
        }
      }

      if (mouseDiff) {
        var _fn = (mouseDisabled ? 'remove' : 'add') + 'EventListener';
        _this._container[_fn]('mousedown', _this._handleMouseDown);
        _this._container[_fn]('mouseup', _this._handleMouseUp);
      }

      if (touchDiff) {
        (0, _touches.setTouchEvent)(!touchDisabled, _this._container, 'start', _this._handleTouchStart);
        (0, _touches.setTouchEvent)(!touchDisabled, _this._container, 'end', _this._handleTouchEnd);
      }
    }, _this._maybeDelayClick = function () {
      if (!_this.props.waitForInkTransition) {
        return;
      }

      (0, _captureNextEvent2.default)('click', _this._container);
    }, _this._handleRemove = function () {
      if (_this._clicked && _this.props.waitForInkTransition) {
        // For some reason if the click event will make the ink unmount, it will no longer
        // have a debug id in the TransitionGroup and it displays a warning. Adding a 1ms timeout
        // fixes that issue... It only happens on an actual click instead of an enter click.
        setTimeout(function () {
          _this._container.click();
        }, 1);
      }

      _this._clicked = false;
    }, _this._handleKeyDown = function (e) {
      var key = e.which || e.keyCode;
      var enter = key === _keyCodes.ENTER;
      var space = key === _keyCodes.SPACE;
      // Don't trigger ink when enter key is pressed and the target has an input inside of it (SelectField)
      if (space || enter && !(0, _isFormPartRole2.default)(e.target) && !e.target.querySelector('input')) {
        _this._clicked = true;
        _this.createInk();
        _this._maybeDelayClick();
      }
    }, _this._handleFocus = function () {
      if (_this._clicked) {
        return;
      }

      _this._createInk();
      _this._getKeyboardContainer().addEventListener('blur', _this._handleBlur);
    }, _this._handleBlur = function () {
      _this._getKeyboardContainer().removeEventListener('blur', _this._handleBlur);
      _this._removeInk();
    }, _this._handleMouseDown = function (e) {
      _this._clicked = true;
      if (!(0, _isValidClick2.default)(e) || _this._skipNextMouse) {
        _this._skipNextMouse = false;
        return;
      }

      _this._mouseLeave = false;
      _this._container.addEventListener('mouseleave', _this._handleMouseLeave);
      _this._createInk(e.pageX, e.pageY);
    }, _this._handleMouseLeave = function () {
      _this._container.removeEventListener('mouseleave', _this._handleMouseLeave);
      _this._mouseLeave = true;
      _this._removeInk();
    }, _this._handleMouseUp = function () {
      if (_this._mouseLeave) {
        return;
      }

      _this._maybeDelayClick();
      _this._container.removeEventListener('mouseleave', _this._handleMouseLeave);
      _this._removeInk();
    }, _this._handleTouchStart = function (e) {
      _this._aborted = false;
      _this._clicked = true;
      _this._skipNextMouse = true;
      (0, _touches.addTouchEvent)(window, 'move', _this._handleTouchMove);

      var _e$changedTouches$ = e.changedTouches[0],
          pageX = _e$changedTouches$.pageX,
          pageY = _e$changedTouches$.pageY;

      _this._createInk(pageX, pageY);
    }, _this._handleTouchMove = function () {
      (0, _touches.removeTouchEvent)(window, 'move', _this._handleTouchMove);
      var lastInk = _this.state.inks[_this.state.inks.length - 1];
      if (!lastInk || Date.now() > lastInk.key + 200) {
        _this._aborted = false;
        return;
      }

      var inks = _this.state.inks.slice();
      var index = inks.length - 1;

      var abortedInk = Object.assign({}, lastInk, { aborted: true });
      inks.splice(index, 1, abortedInk);

      _this._aborted = true;
      _this.setState({ inks: inks }, _this._removeInk);
    }, _this._handleTouchEnd = function () {
      _this._skipNextMouse = true;

      if (_this._aborted) {
        return;
      } else {
        (0, _touches.removeTouchEvent)(window, 'move', _this._handleTouchMove);
      }

      _this._removeInk();
    }, _this._handleSubmit = function (e) {
      if (document.activeElement === _this._container || !e.target.contains(_this._container)) {
        return;
      }

      _this._maybeDelayClick();
      _this.createInk();
    }, _this._stopPropagationToFocus = function (e) {
      switch (e.type) {
        case 'touchstart':
          (0, _touches.addTouchEvent)(window, 'end', _this._stopPropagationToFocus, { capture: true });
          break;
        case 'touchend':
          (0, _touches.removeTouchEvent)(window, 'end', _this._stopPropagationToFocus, { capture: true });
          break;
        case 'mousedown':
          window.addEventListener('mouseup', _this._stopPropagationToFocus, true);
          break;
        case 'mouseup':
          window.removeEventListener('mouseup', _this._stopPropagationToFocus, true);
          break;
        default:
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  InkContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var di = this.props.disabledInteractions;
    var ndi = nextProps.disabledInteractions;

    if (di === ndi || !this._container) {
      return;
    }

    var mouseDisabledDiff = this._isListenerDisabledDiff('mouse', di, ndi);
    var touchDisabledDiff = this._isListenerDisabledDiff('touch', di, ndi);
    var keyboardDisabledDiff = this._isListenerDisabledDiff('keyboard', di, ndi);
    this._initOrRemoveEvents(nextProps, keyboardDisabledDiff, mouseDisabledDiff, touchDisabledDiff);
  };

  InkContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._removeTimeout) {
      clearTimeout(this._removeTimeout);
    }

    if (this._container) {
      this._initOrRemoveEvents({ disabledInteractions: ['keyboard', 'mouse', 'touch'] });
      this._getKeyboardContainer().removeEventListener('blur', this._handleBlur);
    }
  };

  /**
   * Creates an ink from pageX and pageY coordinates. These values should either come
   * from the `changedTouches` or just the base event (if clicked). These coordinates
   * are used to position the ink correctly in the container from touch/click point.
   * If either value is undefined, an ink will be created from the center of the
   * container.
   *
   * It will also automatically remove the ink.
   *
   * @param {number} pageX - The page x coordinate of the click or touch event.
   * @param {number} pageY - The page y coordinate of the click or touch event.
   */


  /**
   * Focuses the main element.
   */


  InkContainer.prototype._isListenerDisabledDiff = function _isListenerDisabledDiff(interaction, disabledInteractions, nextDisabledInteractions) {
    var i = disabledInteractions.indexOf(interaction);
    var ni = nextDisabledInteractions.indexOf(interaction);

    return i < 0 && ni >= 0 || i >= 0 && ni < 0;
  };

  InkContainer.prototype._isListenerDisabled = function _isListenerDisabled(interaction, disabledInteractions) {
    return disabledInteractions && disabledInteractions.indexOf(interaction) !== -1;
  };

  /**
   * Creates an ink from pageX and pageY coordinates. These values should either come
   * from the `changedTouches` or just the base event (if clicked). These coordinates
   * are used to position the ink correctly in the container from touch/click point.
   * If either value is undefined, an ink will be created from the center of the
   * container.
   *
   * @param {number} pageX - The page x coordinate of the click or touch event.
   * @param {number} pageY - The page y coordinate of the click or touch event.
   */


  /**
   * Removes an ink from the container.
   */


  /**
   * Gets the container for any keyboard events. This will almost always be the main element,
   * but text fields will need to be the input itself.
   */


  /**
   * Sets the ink container and the main container from the ref callback. When the component
   * is mounting, the keyboard, mouse, and keyboard events will be initialized.
   */


  /**
   * This function will either add or remove the event listeners for creating inks.
   *
   * @param {Object} props - The current props to use for figuring out if the events should
   *    be added or removed.
   * @param {bool=} keyboardDiff - Boolean if there was a difference between the current props and either
   *    the previous or next props for the keyboard interactions being disabled.
   * @param {bool=} mouseDiff - Boolean if there was a difference between the current props and either
   *    the previous or next props for the mouse interactions being disabled.
   * @param {bool=} touchDiff - Boolean if there was a difference between the current props and either
   *    the previous or next props for the touch interactions being disabled.
   */


  /**
   * If a form was submitted that contains the container of the ink and the current focus element
   * is not the container, trigger an ink effect.
   *
   * The current focus check is added so that two inks are not created.
   */


  InkContainer.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        style = _props.style,
        className = _props.className,
        inkStyle = _props.inkStyle,
        inkClassName = _props.inkClassName,
        transitionOverlap = _props.transitionOverlap,
        transitionEnterTimeout = _props.transitionEnterTimeout,
        transitionLeaveTimeout = _props.transitionLeaveTimeout,
        pulse = _props.pulse;

    var inks = this.state.inks.map(function (props) {
      return _react2.default.createElement(_Ink2.default, _extends({}, props, {
        pulse: pulse,
        style: inkStyle,
        className: inkClassName,
        onRemove: _this2._handleRemove,
        transitionOverlap: transitionOverlap,
        transitionEnterTimeout: transitionEnterTimeout,
        transitionLeaveTimeout: transitionLeaveTimeout
      }));
    });

    return _react2.default.createElement(
      _TransitionGroup2.default,
      {
        component: 'div',
        style: style,
        className: (0, _classnames2.default)('md-ink-container', className),
        ref: this._setContainers
      },
      inks
    );
  };

  return InkContainer;
}(_react.PureComponent);

InkContainer.propTypes = {
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  inkStyle: _propTypes2.default.object,
  inkClassName: _propTypes2.default.string,
  waitForInkTransition: _propTypes2.default.bool,
  disabledInteractions: _propTypes2.default.arrayOf(_propTypes2.default.oneOf(['keyboard', 'mouse', 'touch'])),
  transitionOverlap: _propTypes2.default.number.isRequired,
  transitionEnterTimeout: _propTypes2.default.number.isRequired,
  transitionLeaveTimeout: _propTypes2.default.number.isRequired,
  pulse: _propTypes2.default.bool
};
InkContainer.defaultProps = {
  transitionOverlap: 150,
  transitionEnterTimeout: 450,
  transitionLeaveTimeout: 300
};
exports.default = InkContainer;

/***/ }),

/***/ "Jg2a":
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "K4DB":
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__("e+GP");

var assertThisInitialized = __webpack_require__("T1e2");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "KAlO":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ "KBKS":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__("xARA");

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _TransitionGroup = __webpack_require__("kFlJ");

var _TransitionGroup2 = _interopRequireDefault(_TransitionGroup);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _keyCodes = __webpack_require__("CNE2");

var _captureNextEvent = __webpack_require__("Z4DA");

var _captureNextEvent2 = _interopRequireDefault(_captureNextEvent);

var _touches = __webpack_require__("nuxT");

var _Tooltip = __webpack_require__("eut8");

var _Tooltip2 = _interopRequireDefault(_Tooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function getContainer(tooltip) {
  return tooltip.parentNode;
}

var TooltipContainer = function (_PureComponent) {
  _inherits(TooltipContainer, _PureComponent);

  function TooltipContainer() {
    var _temp, _this, _ret;

    _classCallCheck(this, TooltipContainer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { visible: false }, _this._delayedTimeout = null, _this._unlinkTarget = function () {
      var target = _this._target;
      if (target) {
        (0, _touches.removeTouchEvent)(target, 'start', _this._showTooltip);
        (0, _touches.removeTouchEvent)(target, 'end', _this._hideTooltip);
        target.removeEventListener('mouseover', _this._showTooltip);
        target.removeEventListener('mouseleave', _this._hideTooltip);
        target.removeEventListener('keyup', _this._handleKeyUp);
        target.removeEventListener('blur', _this._hideTooltip);
      }
    }, _this._setTarget = function () {
      var container = _this._container;
      var target = _this.props.target;


      _this._unlinkTarget();

      if (typeof target === 'function') {
        target = target(container, _this);
      }
      target = target ? (0, _reactDom.findDOMNode)(target) : container;
      _this._target = target || null;

      if (target) {
        (0, _touches.addTouchEvent)(target, 'start', _this._showTooltip);
        (0, _touches.addTouchEvent)(target, 'end', _this._hideTooltip);
        target.addEventListener('mouseover', _this._showTooltip);
        target.addEventListener('mouseleave', _this._hideTooltip);
        target.addEventListener('keyup', _this._handleKeyUp);
        target.addEventListener('blur', _this._hideTooltip);
      }
    }, _this._setContainers = function (span) {
      if (span) {
        _this._container = _this.props.container(span.parentNode, _this);
      }
    }, _this._stopContextMenu = function (e) {
      e.preventDefault();
      window.removeEventListener('contextmenu', _this._stopContextMenu, true);
      (0, _captureNextEvent2.default)('click');
      _this.setState({ visible: true });
    }, _this._showTooltip = function (e) {
      if (e.type === 'mouseover' && _this._touched) {
        return;
      }

      if (e.type === 'touchstart') {
        _this._touched = true;

        window.addEventListener('contextmenu', _this._stopContextMenu, true);
        return;
      }

      var delay = _this.props.delay;

      if (_this._delayedTimeout) {
        clearTimeout(_this._delayedTimeout);
      }

      if (delay) {
        _this._delayedTimeout = setTimeout(function () {
          _this._delayedTimeout = null;

          _this.setState({ visible: true });
        }, delay);
      } else {
        _this.setState({ visible: true });
      }
    }, _this._hideTooltip = function (e) {
      if (_this._delayedTimeout) {
        clearTimeout(_this._delayedTimeout);
      }

      if (e.type === 'mouseover' && _this._touched) {
        return;
      }

      _this.setState({ visible: false });
    }, _this._handleKeyUp = function (e) {
      if ((e.which || e.keyCode) === _keyCodes.TAB) {
        _this._showTooltip(e);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  TooltipContainer.prototype.componentDidMount = function componentDidMount() {
    this._setTarget();
  };

  TooltipContainer.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.target !== prevProps.target) {
      this._setTarget();
    }
  };

  TooltipContainer.prototype.componentWillUnmount = function componentWillUnmount() {
    this._unlinkTarget();
    this._target = null;

    if (this._delayedTimeout) {
      clearTimeout(this._delayedTimeout);
    }
  };

  TooltipContainer.prototype.render = function render() {
    var visible = this.state.visible;
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        tooltipStyle = _props.tooltipStyle,
        tooltipClassName = _props.tooltipClassName,
        label = _props.label,
        position = _props.position,
        enterTimeout = _props.enterTimeout,
        leaveTimeout = _props.leaveTimeout;


    var tooltip = _react2.default.createElement(
      _Tooltip2.default,
      {
        key: 'tooltip',
        style: tooltipStyle,
        className: tooltipClassName,
        position: position,
        enterTimeout: enterTimeout,
        leaveTimeout: leaveTimeout
      },
      label
    );

    return _react2.default.createElement(
      _TransitionGroup2.default,
      {
        style: style,
        className: (0, _classnames2.default)('md-tooltip-container', className),
        component: 'div'
      },
      _react2.default.createElement('span', { ref: this._setContainers, 'aria-hidden': true }),
      visible ? tooltip : null
    );
  };

  return TooltipContainer;
}(_react.PureComponent);

TooltipContainer.propTypes = {
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  tooltipStyle: _propTypes2.default.object,
  tooltipClassName: _propTypes2.default.string,
  label: _propTypes2.default.node.isRequired,
  position: _Tooltip2.default.propTypes.position,
  delay: _propTypes2.default.number,
  enterTimeout: _Tooltip2.default.propTypes.enterTimeout,
  leaveTimeout: _Tooltip2.default.propTypes.leaveTimeout,
  /**
   * A function that returns a DOM element that will be used as the tooltip's container.
   * A ref to the tooltip's DOM element will be passed into the function.
   */
  container: _propTypes2.default.func,
  /**
   * A component/element the tooltip should be linked to,
   * or a function that returns such a component/element.
   * A ref to the tooltip's container will be passed into the function.
   *
   * By default the tooltip's container will be used as the target.
   */
  target: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func])
};
TooltipContainer.defaultProps = {
  container: getContainer,
  delay: 0
};
exports.default = TooltipContainer;

/***/ }),

/***/ "KNR4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (false) {}

module.exports = warning;


/***/ }),

/***/ "KPH1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.Avatar = undefined;

var _Avatar2 = __webpack_require__("qzSP");

var _Avatar3 = _interopRequireDefault(_Avatar2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Avatar3.default;
exports.Avatar = _Avatar3.default;

/***/ }),

/***/ "KXO5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = isValidClick;

var _keyCodes = __webpack_require__("CNE2");

/**
 * Checks if an event is a valid click event by ignoring
 * any clisk that are not the left mouse button and not
 * clicks that involve the shift key.
 *
 * @param {Object} e - the event to check
 * @return {Boolean} true if the event is valid.
 */
function isValidClick(e) {
  return e.button === _keyCodes.LEFT_MOUSE && !e.shiftKey;
} /** @module utils/EventUtils/isValidClick */

/***/ }),

/***/ "KlUR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "L3SD":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = isOutOfBounds;

var _getScreenSize = __webpack_require__("+l6y");

var _getScreenSize2 = _interopRequireDefault(_getScreenSize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isOutHorizontally(fixedTo, child, threshold) {
  var _fixedTo$getBoundingC = fixedTo.getBoundingClientRect(),
      fixedLeft = _fixedTo$getBoundingC.left,
      fixedRight = _fixedTo$getBoundingC.right;

  var _child$getBoundingCli = child.getBoundingClientRect(),
      childLeft = _child$getBoundingCli.left,
      childRight = _child$getBoundingCli.right;

  var offset = child.offsetWidth * threshold;

  var left = childLeft + offset;
  var right = childRight - offset;

  var screenEdge = childLeft === 0 || (0, _getScreenSize2.default)('Width') === childRight;
  return fixedLeft > left || fixedRight < right || screenEdge;
} /** @module utils/Positioning/isOutOfBounds */

function isOutVertically(fixedTo, child, toggle, threshold) {
  var _fixedTo$getBoundingC2 = fixedTo.getBoundingClientRect(),
      fixedTop = _fixedTo$getBoundingC2.top,
      fixedBottom = _fixedTo$getBoundingC2.bottom;

  var _child$getBoundingCli2 = child.getBoundingClientRect(),
      childTop = _child$getBoundingCli2.top,
      childBottom = _child$getBoundingCli2.bottom;

  var offset = toggle.offsetHeight * threshold;

  var screenEdge = childTop === 0 || (0, _getScreenSize2.default)('Height') === childBottom;
  return fixedTop > childTop + offset || fixedBottom < childTop - offset || screenEdge;
}

/**
 * Checks if the fixedTo object for the Layover component is considered
 * out of bounds relative to the container.
 *
 * @param {Object} fixedTo - The Layover's `fixedTo` prop.
 * @param {Object} child - The Layover's `children` prop as a DOM element.
 * @param {Object} toggle - The Layover's `toggle` prop as a DOM element.
 * @param {number} verticalThreshold - The vertical threshold multiplier to apply.
 * @param {number} horizontalThreshold - The horizontal threshold multiplier to apply.
 * @return {boolean} true if the Layover's `fixedTo` prop is considered out of bounds.
 */
function isOutOfBounds(fixedTo, child, toggle, verticalThreshold, horizontalThreshold) {
  if (fixedTo === window) {
    return false;
  } else if (fixedTo.x || fixedTo.y) {
    var x = fixedTo.x,
        y = fixedTo.y;

    return !!y && isOutVertically(y, child, toggle, verticalThreshold) || !!x && isOutHorizontally(x, child, horizontalThreshold);
  }

  return isOutVertically(fixedTo, child, toggle, verticalThreshold) || isOutHorizontally(fixedTo, child, horizontalThreshold);
}

/***/ }),

/***/ "LB/S":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;

var PropTypes = _interopRequireWildcard(__webpack_require__("W0B4"));

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _reactDom = _interopRequireDefault(__webpack_require__("xARA"));

var _reactLifecyclesCompat = __webpack_require__("NGR8");

var _PropTypes = __webpack_require__("+YGm");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var UNMOUNTED = 'unmounted';
exports.UNMOUNTED = UNMOUNTED;
var EXITED = 'exited';
exports.EXITED = EXITED;
var ENTERING = 'entering';
exports.ENTERING = ENTERING;
var ENTERED = 'entered';
exports.ENTERED = ENTERED;
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 0 },
 *   entered:  { opacity: 1 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

exports.EXITING = EXITING;

var Transition =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  var _proto = Transition.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      transitionGroup: null // allows for nested Transitions

    };
  };

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  }; // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }


  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      var node = _reactDom.default.findDOMNode(this);

      if (nextStatus === ENTERING) {
        this.performEnter(node, mounting);
      } else {
        this.performExit(node);
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(node, mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(node);
      });
      return;
    }

    this.props.onEnter(node, appearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(node, appearing);

      _this2.onTransitionEnd(node, enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(node, appearing);
        });
      });
    });
  };

  _proto.performExit = function performExit(node) {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

    if (!exit) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(node);
      });
      return;
    }

    this.props.onExit(node);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(node);

      _this3.onTransitionEnd(node, timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(node);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
    this.setNextCallback(handler);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      this.props.addEndListener(node, this.nextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children,
        childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]); // filter props for Transtition


    delete childProps.in;
    delete childProps.mountOnEnter;
    delete childProps.unmountOnExit;
    delete childProps.appear;
    delete childProps.enter;
    delete childProps.exit;
    delete childProps.timeout;
    delete childProps.addEndListener;
    delete childProps.onEnter;
    delete childProps.onEntering;
    delete childProps.onEntered;
    delete childProps.onExit;
    delete childProps.onExiting;
    delete childProps.onExited;

    if (typeof children === 'function') {
      return children(status, childProps);
    }

    var child = _react.default.Children.only(children);

    return _react.default.cloneElement(child, childProps);
  };

  return Transition;
}(_react.default.Component);

Transition.contextTypes = {
  transitionGroup: PropTypes.object
};
Transition.childContextTypes = {
  transitionGroup: function transitionGroup() {}
};
Transition.propTypes =  false ? undefined : {};

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = 0;
Transition.EXITED = 1;
Transition.ENTERING = 2;
Transition.ENTERED = 3;
Transition.EXITING = 4;

var _default = (0, _reactLifecyclesCompat.polyfill)(Transition);

exports.default = _default;

/***/ }),

/***/ "LpyP":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__("vdEC");

var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PageSVG;
exports.PageSVGInternal = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _pdfjsDist = _interopRequireDefault(__webpack_require__("g93O"));

var _PageContext = _interopRequireDefault(__webpack_require__("1VGG"));

var _utils = __webpack_require__("YliN");

var _propTypes2 = __webpack_require__("T5tG");

var PageSVGInternal =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(PageSVGInternal, _PureComponent);

  function PageSVGInternal() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, PageSVGInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(PageSVGInternal)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "state", {
      svg: null
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onRenderSuccess", function () {
      _this.renderer = null;
      var _this$props = _this.props,
          onRenderSuccess = _this$props.onRenderSuccess,
          page = _this$props.page,
          scale = _this$props.scale;
      (0, _utils.callIfDefined)(onRenderSuccess, (0, _utils.makePageCallback)(page, scale));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onRenderError", function (error) {
      if ((0, _utils.isCancelException)(error)) {
        return;
      }

      (0, _utils.errorOnDev)(error);
      var onRenderError = _this.props.onRenderError;
      (0, _utils.callIfDefined)(onRenderError, error);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "renderSVG", function () {
      var page = _this.props.page;
      _this.renderer = page.getOperatorList();
      return _this.renderer.then(function (operatorList) {
        var svgGfx = new _pdfjsDist.default.SVGGraphics(page.commonObjs, page.objs);
        _this.renderer = svgGfx.getSVG(operatorList, _this.viewport).then(function (svg) {
          _this.setState({
            svg: svg
          }, _this.onRenderSuccess);
        }).catch(_this.onRenderError);
      }).catch(_this.onRenderError);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "drawPageOnContainer", function (element) {
      var svg = _this.state.svg;

      if (!element || !svg) {
        return;
      } // Append SVG element to the main container, if this hasn't been done already


      if (!element.firstElementChild) {
        element.appendChild(svg);
      }

      var _this$viewport = _this.viewport,
          width = _this$viewport.width,
          height = _this$viewport.height;
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
    });
    return _this;
  }

  (0, _createClass2.default)(PageSVGInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.renderSVG();
    }
    /**
     * Called when a page is rendered successfully.
     */

  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$viewport2 = this.viewport,
          width = _this$viewport2.width,
          height = _this$viewport2.height;
      return _react.default.createElement("div", {
        className: "react-pdf__Page__svg",
        style: {
          display: 'block',
          backgroundColor: 'white',
          overflow: 'hidden',
          width: width,
          height: height,
          userSelect: 'none'
        } // Note: This cannot be shortened, as we need this function to be called with each render.
        ,
        ref: function ref(_ref) {
          return _this2.drawPageOnContainer(_ref);
        }
      });
    }
  }, {
    key: "viewport",
    get: function get() {
      var _this$props2 = this.props,
          page = _this$props2.page,
          rotate = _this$props2.rotate,
          scale = _this$props2.scale;
      return page.getViewport({
        scale: scale,
        rotation: rotate
      });
    }
  }]);
  return PageSVGInternal;
}(_react.PureComponent);

exports.PageSVGInternal = PageSVGInternal;
PageSVGInternal.propTypes = {
  onRenderError: _propTypes.default.func,
  onRenderSuccess: _propTypes.default.func,
  page: _propTypes2.isPage.isRequired,
  rotate: _propTypes2.isRotate,
  scale: _propTypes.default.number
};

function PageSVG(props) {
  return _react.default.createElement(_PageContext.default.Consumer, null, function (context) {
    return _react.default.createElement(PageSVGInternal, (0, _extends2.default)({}, context, props));
  });
}

/***/ }),

/***/ "MDH+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getPagePosition;
/** @module utils/Positioning/getPagePosition */

/**
 * Gets the current page position.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY
 * @param {String} direction - The direction that should be retrieved. This
 *    should be either 'x' or 'y'.
 * @return {number} the position of the direction on the page.
 */
function getPagePosition(direction) {
  var scroll = 'scroll' + (direction === 'x' ? 'Left' : 'Top');
  if (typeof window.pageXOffset !== 'undefined') {
    return window['page' + direction.toUpperCase() + 'Offset'];
  } else if ((document.compatMode || '') === 'CSS1Compat') {
    return document.documentElement[scroll];
  } else {
    return document.body[scroll];
  }
}

/***/ }),

/***/ "MNOf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "MdvH":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _addClass = __webpack_require__("Y7gb");

var _addClass2 = _interopRequireDefault(_addClass);

var _removeClass = __webpack_require__("noPx");

var _removeClass2 = _interopRequireDefault(_removeClass);

var _requestAnimationFrame = __webpack_require__("IsBi");

var _requestAnimationFrame2 = _interopRequireDefault(_requestAnimationFrame);

var _properties = __webpack_require__("hx1s");

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__("xARA");

var _PropTypes = __webpack_require__("8JTt");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var events = [];
if (_properties.transitionEnd) events.push(_properties.transitionEnd);
if (_properties.animationEnd) events.push(_properties.animationEnd);

function addEndListener(node, listener) {
  if (events.length) {
    events.forEach(function (e) {
      return node.addEventListener(e, listener, false);
    });
  } else {
    setTimeout(listener, 0);
  }

  return function () {
    if (!events.length) return;
    events.forEach(function (e) {
      return node.removeEventListener(e, listener, false);
    });
  };
}

var propTypes = {
  children: _propTypes2.default.node,
  name: _PropTypes.nameShape.isRequired,

  // Once we require timeouts to be specified, we can remove the
  // boolean flags (appear etc.) and just accept a number
  // or a bool for the timeout flags (appearTimeout etc.)
  appear: _propTypes2.default.bool,
  enter: _propTypes2.default.bool,
  leave: _propTypes2.default.bool,
  appearTimeout: _propTypes2.default.number,
  enterTimeout: _propTypes2.default.number,
  leaveTimeout: _propTypes2.default.number
};

var CSSTransitionGroupChild = function (_React$Component) {
  _inherits(CSSTransitionGroupChild, _React$Component);

  function CSSTransitionGroupChild() {
    var _temp, _this, _ret;

    _classCallCheck(this, CSSTransitionGroupChild);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.componentWillAppear = function (done) {
      if (_this.props.appear) {
        _this.transition('appear', done, _this.props.appearTimeout);
      } else {
        done();
      }
    }, _this.componentWillEnter = function (done) {
      if (_this.props.enter) {
        _this.transition('enter', done, _this.props.enterTimeout);
      } else {
        done();
      }
    }, _this.componentWillLeave = function (done) {
      if (_this.props.leave) {
        _this.transition('leave', done, _this.props.leaveTimeout);
      } else {
        done();
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  CSSTransitionGroupChild.prototype.componentWillMount = function componentWillMount() {
    this.classNameAndNodeQueue = [];
    this.transitionTimeouts = [];
  };

  CSSTransitionGroupChild.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unmounted = true;

    if (this.timeout) {
      clearTimeout(this.timeout);
    }
    this.transitionTimeouts.forEach(function (timeout) {
      clearTimeout(timeout);
    });

    this.classNameAndNodeQueue.length = 0;
  };

  CSSTransitionGroupChild.prototype.transition = function transition(animationType, finishCallback, timeout) {
    var node = (0, _reactDom.findDOMNode)(this);

    if (!node) {
      if (finishCallback) {
        finishCallback();
      }
      return;
    }

    var className = this.props.name[animationType] || this.props.name + '-' + animationType;
    var activeClassName = this.props.name[animationType + 'Active'] || className + '-active';
    var timer = null;
    var removeListeners = void 0;

    (0, _addClass2.default)(node, className);

    // Need to do this to actually trigger a transition.
    this.queueClassAndNode(activeClassName, node);

    // Clean-up the animation after the specified delay
    var finish = function finish(e) {
      if (e && e.target !== node) {
        return;
      }

      clearTimeout(timer);
      if (removeListeners) removeListeners();

      (0, _removeClass2.default)(node, className);
      (0, _removeClass2.default)(node, activeClassName);

      if (removeListeners) removeListeners();

      // Usually this optional callback is used for informing an owner of
      // a leave animation and telling it to remove the child.
      if (finishCallback) {
        finishCallback();
      }
    };

    if (timeout) {
      timer = setTimeout(finish, timeout);
      this.transitionTimeouts.push(timer);
    } else if (_properties.transitionEnd) {
      removeListeners = addEndListener(node, finish);
    }
  };

  CSSTransitionGroupChild.prototype.queueClassAndNode = function queueClassAndNode(className, node) {
    var _this2 = this;

    this.classNameAndNodeQueue.push({
      className: className,
      node: node
    });

    if (!this.rafHandle) {
      this.rafHandle = (0, _requestAnimationFrame2.default)(function () {
        return _this2.flushClassNameAndNodeQueue();
      });
    }
  };

  CSSTransitionGroupChild.prototype.flushClassNameAndNodeQueue = function flushClassNameAndNodeQueue() {
    if (!this.unmounted) {
      this.classNameAndNodeQueue.forEach(function (obj) {
        // This is for to force a repaint,
        // which is necessary in order to transition styles when adding a class name.
        /* eslint-disable no-unused-expressions */
        obj.node.scrollTop;
        /* eslint-enable no-unused-expressions */
        (0, _addClass2.default)(obj.node, obj.className);
      });
    }
    this.classNameAndNodeQueue.length = 0;
    this.rafHandle = null;
  };

  CSSTransitionGroupChild.prototype.render = function render() {
    var props = _extends({}, this.props);
    delete props.name;
    delete props.appear;
    delete props.enter;
    delete props.leave;
    delete props.appearTimeout;
    delete props.enterTimeout;
    delete props.leaveTimeout;
    delete props.children;
    return _react2.default.cloneElement(_react2.default.Children.only(this.props.children), props);
  };

  return CSSTransitionGroupChild;
}(_react2.default.Component);

CSSTransitionGroupChild.displayName = 'CSSTransitionGroupChild';


CSSTransitionGroupChild.propTypes =  false ? undefined : {};

exports.default = CSSTransitionGroupChild;
module.exports = exports['default'];

/***/ }),

/***/ "MrGi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _AccessibleFakeButton = __webpack_require__("oeXn");

var _AccessibleFakeButton2 = _interopRequireDefault(_AccessibleFakeButton);

var _injectInk = __webpack_require__("A5Qw");

var _injectInk2 = _interopRequireDefault(_injectInk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _injectInk2.default)(_AccessibleFakeButton2.default);

/***/ }),

/***/ "NGR8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyfill", function() { return polyfill; });
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== undefined) {
    this.setState(state);
  }
}

function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== undefined ? state : null;
  }
  // Binding "this" is important for shallow renderer support.
  this.setState(updater.bind(this));
}

function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      prevProps,
      prevState
    );
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;

function polyfill(Component) {
  var prototype = Component.prototype;

  if (!prototype || !prototype.isReactComponent) {
    throw new Error('Can only polyfill class components');
  }

  if (
    typeof Component.getDerivedStateFromProps !== 'function' &&
    typeof prototype.getSnapshotBeforeUpdate !== 'function'
  ) {
    return Component;
  }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === 'function') {
    foundWillMountName = 'componentWillMount';
  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
    foundWillMountName = 'UNSAFE_componentWillMount';
  }
  if (typeof prototype.componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'componentWillReceiveProps';
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
  }
  if (typeof prototype.componentWillUpdate === 'function') {
    foundWillUpdateName = 'componentWillUpdate';
  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
    foundWillUpdateName = 'UNSAFE_componentWillUpdate';
  }
  if (
    foundWillMountName !== null ||
    foundWillReceivePropsName !== null ||
    foundWillUpdateName !== null
  ) {
    var componentName = Component.displayName || Component.name;
    var newApiName =
      typeof Component.getDerivedStateFromProps === 'function'
        ? 'getDerivedStateFromProps()'
        : 'getSnapshotBeforeUpdate()';

    throw Error(
      'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
        componentName +
        ' uses ' +
        newApiName +
        ' but also contains the following legacy lifecycles:' +
        (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
        (foundWillReceivePropsName !== null
          ? '\n  ' + foundWillReceivePropsName
          : '') +
        (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
        '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
        'https://fb.me/react-async-component-lifecycle-hooks'
    );
  }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
  if (typeof Component.getDerivedStateFromProps === 'function') {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
    if (typeof prototype.componentDidUpdate !== 'function') {
      throw new Error(
        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
      );
    }

    prototype.componentWillUpdate = componentWillUpdate;

    var componentDidUpdate = prototype.componentDidUpdate;

    prototype.componentDidUpdate = function componentDidUpdatePolyfill(
      prevProps,
      prevState,
      maybeSnapshot
    ) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
      var snapshot = this.__reactInternalSnapshotFlag
        ? this.__reactInternalSnapshot
        : maybeSnapshot;

      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }

  return Component;
}




/***/ }),

/***/ "NS33":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__("E02R");

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "NToG":
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "NthX":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("eEQR");


/***/ }),

/***/ "O4SF":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__("vdEC");

var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.PageInternal = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__("gki9"));

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _regenerator = _interopRequireDefault(__webpack_require__("NthX"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__("fFdx"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _makeEventProps = _interopRequireDefault(__webpack_require__("1QXF"));

var _mergeClassNames = _interopRequireDefault(__webpack_require__("nZ0h"));

var _DocumentContext = _interopRequireDefault(__webpack_require__("tvHm"));

var _PageContext = _interopRequireDefault(__webpack_require__("1VGG"));

var _Message = _interopRequireDefault(__webpack_require__("pb74"));

var _PageCanvas = _interopRequireDefault(__webpack_require__("GtMC"));

var _PageSVG = _interopRequireDefault(__webpack_require__("LpyP"));

var _TextLayer = _interopRequireDefault(__webpack_require__("4bSW"));

var _AnnotationLayer = _interopRequireDefault(__webpack_require__("yWUr"));

var _utils = __webpack_require__("YliN");

var _propTypes2 = __webpack_require__("T5tG");

var defaultScale = 1.0;

var PageInternal =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(PageInternal, _PureComponent);

  function PageInternal() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, PageInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(PageInternal)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "state", {
      page: null
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadSuccess", function () {
      var _this$props = _this.props,
          onLoadSuccess = _this$props.onLoadSuccess,
          registerPage = _this$props.registerPage;
      var page = _this.state.page;
      (0, _utils.callIfDefined)(onLoadSuccess, (0, _utils.makePageCallback)(page, _this.scale));
      (0, _utils.callIfDefined)(registerPage, _this.pageIndex, _this.ref);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadError", function (error) {
      if ((0, _utils.isCancelException)(error)) {
        return;
      }

      (0, _utils.errorOnDev)(error);
      var onLoadError = _this.props.onLoadError;
      (0, _utils.callIfDefined)(onLoadError, error);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "loadPage",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      var pdf, pageNumber, cancellable, page;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              pdf = _this.props.pdf;
              pageNumber = _this.getPageNumber();

              if (pageNumber) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return");

            case 4:
              _this.setState(function (prevState) {
                if (!prevState.page) {
                  return null;
                }

                return {
                  page: null
                };
              });

              _context.prev = 5;
              cancellable = (0, _utils.makeCancellable)(pdf.getPage(pageNumber));
              _this.runningTask = cancellable;
              _context.next = 10;
              return cancellable.promise;

            case 10:
              page = _context.sent;

              _this.setState({
                page: page
              }, _this.onLoadSuccess);

              _context.next = 18;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](5);

              _this.setState({
                page: false
              });

              _this.onLoadError(_context.t0);

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[5, 14]]);
    })));
    return _this;
  }

  (0, _createClass2.default)(PageInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var pdf = this.props.pdf;

      if (!pdf) {
        throw new Error('Attempted to load a page, but no document was specified.');
      }

      this.loadPage();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var pdf = this.props.pdf;

      if (prevProps.pdf && pdf !== prevProps.pdf || this.getPageNumber() !== this.getPageNumber(prevProps)) {
        var unregisterPage = this.props.unregisterPage;
        (0, _utils.callIfDefined)(unregisterPage, this.getPageIndex(prevProps));
        this.loadPage();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var unregisterPage = this.props.unregisterPage;
      (0, _utils.callIfDefined)(unregisterPage, this.pageIndex);
      (0, _utils.cancelRunningTask)(this.runningTask);
    }
  }, {
    key: "getPageIndex",
    value: function getPageIndex() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

      if ((0, _utils.isProvided)(props.pageNumber)) {
        return props.pageNumber - 1;
      }

      if ((0, _utils.isProvided)(props.pageIndex)) {
        return props.pageIndex;
      }

      return null;
    }
  }, {
    key: "getPageNumber",
    value: function getPageNumber() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

      if ((0, _utils.isProvided)(props.pageNumber)) {
        return props.pageNumber;
      }

      if ((0, _utils.isProvided)(props.pageIndex)) {
        return props.pageIndex + 1;
      }

      return null;
    }
  }, {
    key: "renderMainLayer",
    value: function renderMainLayer() {
      var renderMode = this.props.renderMode;

      switch (renderMode) {
        case 'none':
          return null;

        case 'svg':
          return _react.default.createElement(_PageSVG.default, {
            key: "".concat(this.pageKeyNoScale, "_svg")
          });

        case 'canvas':
        default:
          return _react.default.createElement(_PageCanvas.default, {
            key: "".concat(this.pageKey, "_canvas")
          });
      }
    }
  }, {
    key: "renderTextLayer",
    value: function renderTextLayer() {
      var renderTextLayer = this.props.renderTextLayer;

      if (!renderTextLayer) {
        return null;
      }

      return _react.default.createElement(_TextLayer.default, {
        key: "".concat(this.pageKey, "_text")
      });
    }
  }, {
    key: "renderAnnotationLayer",
    value: function renderAnnotationLayer() {
      var renderAnnotationLayer = this.props.renderAnnotationLayer;

      if (!renderAnnotationLayer) {
        return null;
      }
      /**
       * As of now, PDF.js 2.0.943 returns warnings on unimplemented annotations in SVG mode.
       * Therefore, as a fallback, we render "traditional" AnnotationLayer component.
       */


      return _react.default.createElement(_AnnotationLayer.default, {
        key: "".concat(this.pageKey, "_annotations")
      });
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var children = this.props.children;
      return _react.default.createElement(_PageContext.default.Provider, {
        value: this.childContext
      }, this.renderMainLayer(), this.renderTextLayer(), this.renderAnnotationLayer(), children);
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var pageNumber = this.pageNumber;
      var pdf = this.props.pdf;
      var page = this.state.page;

      if (!pageNumber) {
        var noData = this.props.noData;
        return _react.default.createElement(_Message.default, {
          type: "no-data"
        }, typeof noData === 'function' ? noData() : noData);
      }

      if (pdf === null || page === null) {
        var loading = this.props.loading;
        return _react.default.createElement(_Message.default, {
          type: "loading"
        }, typeof loading === 'function' ? loading() : loading);
      }

      if (pdf === false || page === false) {
        var error = this.props.error;
        return _react.default.createElement(_Message.default, {
          type: "error"
        }, typeof error === 'function' ? error() : error);
      }

      return this.renderChildren();
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var pageNumber = this.pageNumber;
      var className = this.props.className;
      return _react.default.createElement("div", (0, _extends2.default)({
        className: (0, _mergeClassNames.default)('react-pdf__Page', className),
        ref: function ref(_ref2) {
          var inputRef = _this2.props.inputRef;

          if (inputRef) {
            inputRef(_ref2);
          }

          _this2.ref = _ref2;
        },
        style: {
          position: 'relative'
        },
        "data-page-number": pageNumber
      }, this.eventProps), this.renderContent());
    }
  }, {
    key: "childContext",
    get: function get() {
      var page = this.state.page;

      if (!page) {
        return {};
      }

      var _this$props2 = this.props,
          customTextRenderer = _this$props2.customTextRenderer,
          onGetAnnotationsError = _this$props2.onGetAnnotationsError,
          onGetAnnotationsSuccess = _this$props2.onGetAnnotationsSuccess,
          onGetTextError = _this$props2.onGetTextError,
          onGetTextSuccess = _this$props2.onGetTextSuccess,
          onRenderAnnotationLayerError = _this$props2.onRenderAnnotationLayerError,
          onRenderAnnotationLayerSuccess = _this$props2.onRenderAnnotationLayerSuccess,
          onRenderError = _this$props2.onRenderError,
          onRenderSuccess = _this$props2.onRenderSuccess,
          renderInteractiveForms = _this$props2.renderInteractiveForms;
      return {
        customTextRenderer: customTextRenderer,
        onGetAnnotationsError: onGetAnnotationsError,
        onGetAnnotationsSuccess: onGetAnnotationsSuccess,
        onGetTextError: onGetTextError,
        onGetTextSuccess: onGetTextSuccess,
        onRenderAnnotationLayerError: onRenderAnnotationLayerError,
        onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccess,
        onRenderError: onRenderError,
        onRenderSuccess: onRenderSuccess,
        page: page,
        renderInteractiveForms: renderInteractiveForms,
        rotate: this.rotate,
        scale: this.scale
      };
    }
    /**
     * Called when a page is loaded successfully
     */

  }, {
    key: "pageIndex",
    get: function get() {
      return this.getPageIndex();
    }
  }, {
    key: "pageNumber",
    get: function get() {
      return this.getPageNumber();
    }
  }, {
    key: "rotate",
    get: function get() {
      var rotate = this.props.rotate;

      if ((0, _utils.isProvided)(rotate)) {
        return rotate;
      }

      var page = this.state.page;

      if (!page) {
        return null;
      }

      return page.rotate;
    }
  }, {
    key: "scale",
    get: function get() {
      var page = this.state.page;

      if (!page) {
        return null;
      }

      var _this$props3 = this.props,
          scale = _this$props3.scale,
          width = _this$props3.width,
          height = _this$props3.height;
      var rotate = this.rotate; // Be default, we'll render page at 100% * scale width.

      var pageScale = 1; // Passing scale explicitly null would cause the page not to render

      var scaleWithDefault = scale === null ? defaultScale : scale; // If width/height is defined, calculate the scale of the page so it could be of desired width.

      if (width || height) {
        var viewport = page.getViewport({
          scale: 1,
          rotation: rotate
        });
        pageScale = width ? width / viewport.width : height / viewport.height;
      }

      return scaleWithDefault * pageScale;
    }
  }, {
    key: "eventProps",
    get: function get() {
      var _this3 = this;

      return (0, _makeEventProps.default)(this.props, function () {
        var page = _this3.state.page;

        if (!page) {
          return page;
        }

        return (0, _utils.makePageCallback)(page, _this3.scale);
      });
    }
  }, {
    key: "pageKey",
    get: function get() {
      var page = this.state.page;
      return "".concat(page.pageIndex, "@").concat(this.scale, "/").concat(this.rotate);
    }
  }, {
    key: "pageKeyNoScale",
    get: function get() {
      var page = this.state.page;
      return "".concat(page.pageIndex, "/").concat(this.rotate);
    }
  }]);
  return PageInternal;
}(_react.PureComponent);

exports.PageInternal = PageInternal;
PageInternal.defaultProps = {
  error: 'Failed to load the page.',
  loading: 'Loading page…',
  noData: 'No page specified.',
  renderAnnotationLayer: true,
  renderInteractiveForms: false,
  renderMode: 'canvas',
  renderTextLayer: true,
  scale: defaultScale
};
PageInternal.propTypes = (0, _objectSpread2.default)({
  children: _propTypes.default.node,
  className: _propTypes2.isClassName,
  customTextRenderer: _propTypes.default.func,
  error: _propTypes.default.node,
  height: _propTypes.default.number,
  inputRef: _propTypes.default.func,
  loading: _propTypes.default.node,
  noData: _propTypes.default.node,
  onGetTextError: _propTypes.default.func,
  onGetTextSuccess: _propTypes.default.func,
  onLoadError: _propTypes.default.func,
  onLoadSuccess: _propTypes.default.func,
  onRenderError: _propTypes.default.func,
  onRenderSuccess: _propTypes.default.func,
  pageIndex: _propTypes2.isPageIndex,
  pageNumber: _propTypes2.isPageNumber,
  pdf: _propTypes2.isPdf,
  registerPage: _propTypes.default.func,
  renderAnnotationLayer: _propTypes.default.bool,
  renderInteractiveForms: _propTypes.default.bool,
  renderMode: _propTypes2.isRenderMode,
  renderTextLayer: _propTypes.default.bool,
  rotate: _propTypes2.isRotate,
  scale: _propTypes.default.number,
  unregisterPage: _propTypes.default.func,
  width: _propTypes.default.number
}, (0, _propTypes2.eventsProps)());

function Page(props, ref) {
  return _react.default.createElement(_DocumentContext.default.Consumer, null, function (context) {
    return _react.default.createElement(PageInternal, (0, _extends2.default)({
      ref: ref
    }, context, props, {
      // For backwards compatibility
      renderAnnotationLayer: typeof props.renderAnnotationLayer !== 'undefined' ? props.renderAnnotationLayer : props.renderAnnotations
    }));
  });
}

var _default = _react.default.forwardRef(Page);

exports.default = _default;

/***/ }),

/***/ "OaVA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _CSSTransitionGroupTick = __webpack_require__("+5Nw");

var _CSSTransitionGroupTick2 = _interopRequireDefault(_CSSTransitionGroupTick);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Ink = function (_PureComponent) {
  _inherits(Ink, _PureComponent);

  function Ink(props) {
    _classCallCheck(this, Ink);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = {
      active: false,
      expanded: false,
      pulsing: false,
      leaving: false
    };
    return _this;
  }

  Ink.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (!this.props.aborted && nextProps.aborted) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }

      if (this._abort) {
        this._abort();
      }

      this.setState({ active: false, expanding: false, pulsing: false, leaving: false });
    }
  };

  Ink.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  Ink.prototype.componentWillEnter = function componentWillEnter(cb) {
    var _this2 = this;

    if (this.props.aborted) {
      cb();
      return;
    }

    var _props = this.props,
        transitionOverlap = _props.transitionOverlap,
        transitionEnterTimeout = _props.transitionEnterTimeout;

    this._abort = cb;

    this._timeout = setTimeout(function () {
      _this2._timeout = setTimeout(function () {
        _this2._timeout = null;
        _this2._abort = null;

        cb();
      }, transitionEnterTimeout - transitionOverlap);

      _this2.setState({ expanded: true });
    }, _CSSTransitionGroupTick2.default);

    this.setState({ active: true });
  };

  Ink.prototype.componentDidEnter = function componentDidEnter() {
    var _this3 = this;

    if (this.props.pulse) {
      this._timeout = setTimeout(function () {
        _this3._timeout = null;

        _this3.setState({ pulsing: true });
      }, this.props.transitionEnterTimeout);
    }
  };

  Ink.prototype.componentWillLeave = function componentWillLeave(cb) {
    var _this4 = this;

    if (this.props.aborted) {
      cb();
      return;
    }

    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    this._abort = cb;
    this._timeout = setTimeout(function () {
      _this4._timeout = null;

      cb();
    }, this.props.transitionLeaveTimeout);

    this.setState({ pulsing: false, leaving: true });
  };

  Ink.prototype.componentDidLeave = function componentDidLeave() {
    if (!this.props.aborted && this.props.onRemove) {
      this.props.onRemove();
    }
  };

  Ink.prototype.render = function render() {
    var _props2 = this.props,
        style = _props2.style,
        className = _props2.className,
        left = _props2.left,
        top = _props2.top,
        size = _props2.size;
    var _state = this.state,
        active = _state.active,
        expanded = _state.expanded,
        pulsing = _state.pulsing,
        leaving = _state.leaving;


    return _react2.default.createElement('span', {
      style: Object.assign({}, style, {
        left: left,
        top: top,
        height: size,
        width: size
      }),
      className: (0, _classnames2.default)('md-ink', {
        'md-ink--active': active,
        'md-ink--expanded': expanded,
        'md-ink--pulsing': pulsing,
        'md-ink--leaving': leaving
      }, className)
    });
  };

  return Ink;
}(_react.PureComponent);

Ink.propTypes = {
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  aborted: _propTypes2.default.bool,
  onRemove: _propTypes2.default.func,
  left: _propTypes2.default.number.isRequired,
  top: _propTypes2.default.number.isRequired,
  size: _propTypes2.default.number.isRequired,
  transitionOverlap: _propTypes2.default.number.isRequired,
  transitionEnterTimeout: _propTypes2.default.number.isRequired,
  transitionLeaveTimeout: _propTypes2.default.number.isRequired,
  pulse: _propTypes2.default.bool
};
exports.default = Ink;

/***/ }),

/***/ "OqLi":
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "OvAC":
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "OyIr":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.IconButton = exports.FloatingButton = exports.RaisedButton = exports.FlatButton = exports.Button = undefined;

var _Button2 = __webpack_require__("Bff0");

var _Button3 = _interopRequireDefault(_Button2);

var _FlatButton2 = __webpack_require__("VwaL");

var _FlatButton3 = _interopRequireDefault(_FlatButton2);

var _RaisedButton2 = __webpack_require__("5fOt");

var _RaisedButton3 = _interopRequireDefault(_RaisedButton2);

var _FloatingButton2 = __webpack_require__("yALM");

var _FloatingButton3 = _interopRequireDefault(_FloatingButton2);

var _IconButton2 = __webpack_require__("ZVcq");

var _IconButton3 = _interopRequireDefault(_IconButton2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Button3.default;
exports.Button = _Button3.default;
exports.FlatButton = _FlatButton3.default;
exports.RaisedButton = _RaisedButton3.default;
exports.FloatingButton = _FloatingButton3.default;
exports.IconButton = _IconButton3.default;

/***/ }),

/***/ "P1qJ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = isBetween;
/** @module utils/NumberUtils/isBetween */

/**
 * Checks if a number is between a min and maximum (inclusive)
 *
 * @param {Number} num the number to check
 * @param {Number} min the minimum
 * @param {Number} max the maximum
 * @return {Boolean} true if the number is between the min and max (inclusive)
 */
function isBetween(num, min, max) {
  return num >= min && num <= max;
}

/***/ }),

/***/ "PE9J":
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),

/***/ "PioW":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = deprecated;

var _warning = __webpack_require__("YwmR");

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var warned = {};

function deprecated(validator, reason) {
  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    if (props[propName] != null) {
      var messageKey = componentName + '.' + propName;

      (0, _warning2.default)(warned[messageKey], 'The ' + location + ' `' + propFullNameSafe + '` of ' + ('`' + componentNameSafe + '` is deprecated. ' + reason + '.'));

      warned[messageKey] = true;
    }

    for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      args[_key - 5] = arguments[_key];
    }

    return validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
  };
}

/* eslint-disable no-underscore-dangle */
function _resetWarned() {
  warned = {};
}

deprecated._resetWarned = _resetWarned;
/* eslint-enable no-underscore-dangle */

/***/ }),

/***/ "PogH":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = {
  noWobble: { stiffness: 170, damping: 26 }, // the default, if nothing provided
  gentle: { stiffness: 120, damping: 14 },
  wobbly: { stiffness: 180, damping: 12 },
  stiff: { stiffness: 210, damping: 20 }
};
module.exports = exports["default"];

/***/ }),

/***/ "Qatm":
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "QpHq":
/***/ (function(module, exports) {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "Qt3m":
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "RiSW":
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__("PE9J");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;

/***/ }),

/***/ "RoC8":
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "S411":
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "SDJZ":
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "Sj4t":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getTextWidth;
/** @module utils/Positioning/getTextWidth */

var cachedCanvas = void 0;

/**
 * A utility function to measure the width (in px) of any text. It will require a canvas
 * and an element to use to determine the current fonts to apply since different fonts will
 * have different widths.
 *
 * This isn't fully accurate since some browsers handle the calculations a bit differently so
 * they are off by a 0-3px
 *
 * @param {String} text - The text to measure the width
 * @param {HTMLElement} el - The element to use to determine the current font for the text.
 * @param {HTMLElement=} canvas - An optional canvas to use for doing the calculations. If this
 *    is omitted, it will just use the locally created canvas to do the calculations.
 * @return {number} this will either return null if there is a problem calculating the width or
 *    the length (in px) of the text.
 */
function getTextWidth(text, el, canvas) {
  if (!el) {
    return null;
  }

  if (!canvas) {
    if (!cachedCanvas) {
      cachedCanvas = document.createElement('canvas');
    }

    canvas = cachedCanvas;
  }

  var context = canvas.getContext('2d');
  if (!context) {
    // context doesn't exist in testing without complicated mocks
    return null;
  }

  var styles = window.getComputedStyle(el);
  var font = styles.font;
  // Some browsers do not actually supply the font style since they are on an older version of CSSProperties,
  // so the font string needs to be made manually.
  if (!font) {
    // font-style font-variant font-weight font-size/line-height font-family
    var sizing = styles.fontSize + ' / ' + styles.lineHeight + ' ' + styles.fontFamily;
    font = styles.fontStyle + ' ' + styles.fontVariant + ' ' + styles.fontWeight + ' ' + sizing;
  }

  context.font = font;
  return context.measureText(text).width;
}

/***/ }),

/***/ "SjVu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__("xARA");

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _deprecated = __webpack_require__("PioW");

var _deprecated2 = _interopRequireDefault(_deprecated);

var _themeColors = __webpack_require__("VZNk");

var _themeColors2 = _interopRequireDefault(_themeColors);

var _getCollapserStyles = __webpack_require__("HtUH");

var _getCollapserStyles2 = _interopRequireDefault(_getCollapserStyles);

var _getField = __webpack_require__("iouw");

var _getField2 = _interopRequireDefault(_getField);

var _controlled = __webpack_require__("sd4F");

var _controlled2 = _interopRequireDefault(_controlled);

var _keyCodes = __webpack_require__("CNE2");

var _anchorShape = __webpack_require__("gFhn");

var _anchorShape2 = _interopRequireDefault(_anchorShape);

var _fixedToShape = __webpack_require__("wp+c");

var _fixedToShape2 = _interopRequireDefault(_fixedToShape);

var _AccessibleFakeInkedButton = __webpack_require__("MrGi");

var _AccessibleFakeInkedButton2 = _interopRequireDefault(_AccessibleFakeInkedButton);

var _Collapse = __webpack_require__("cp8/");

var _Collapse2 = _interopRequireDefault(_Collapse);

var _Divider = __webpack_require__("lUDM");

var _Divider2 = _interopRequireDefault(_Divider);

var _FontIcon = __webpack_require__("vMIC");

var _FontIcon2 = _interopRequireDefault(_FontIcon);

var _getDeprecatedIcon = __webpack_require__("7c/Y");

var _getDeprecatedIcon2 = _interopRequireDefault(_getDeprecatedIcon);

var _TileAddon = __webpack_require__("2gDV");

var _TileAddon2 = _interopRequireDefault(_TileAddon);

var _ListItemText = __webpack_require__("z10u");

var _ListItemText2 = _interopRequireDefault(_ListItemText);

var _List = __webpack_require__("wvQ6");

var _List2 = _interopRequireDefault(_List);

var _Menu = __webpack_require__("qiae");

var _Menu2 = _interopRequireDefault(_Menu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `ListItem` component is used for rendering a `li` tag with text and optional
 * icons/avatars.
 */
var ListItem = function (_PureComponent) {
  _inherits(ListItem, _PureComponent);

  function ListItem(props) {
    _classCallCheck(this, ListItem);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _initialiseProps.call(_this);

    _this.state = { active: false };

    if (typeof props.isOpen === 'undefined' && typeof props.visible === 'undefined') {
      var defined = function defined(v) {
        return typeof v !== 'undefined';
      };
      var _this$props = _this.props,
          initiallyOpen = _this$props.initiallyOpen,
          defaultOpen = _this$props.defaultOpen,
          defaultVisible = _this$props.defaultVisible;

      var visible = defined(initiallyOpen) ? initiallyOpen : defaultVisible;
      visible = defined(defaultOpen) ? defaultOpen : visible;
      visible = !!visible;

      _this.state.visible = visible;
    }
    return _this;
  }

  ListItem.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.state.active) {
      window.removeEventListener('click', this._handleOutsideClick);
    }

    if (this._touchTimeout) {
      clearTimeout(this._touchTimeout);
    }
  };

  /**
   * A utility function to focus the `AccessibleFakeInkedButton` in the `ListItem` and also
   * inject an ink to indicate focus.
   */


  /**
   * A utility function to blur the `AccessibleFakeInkedButton` in the `ListItem`.
   */


  ListItem.prototype._renderChildrenIfInside = function _renderChildrenIfInside() {
    var _props = this.props,
        children = _props.children,
        renderChildrenOutside = _props.renderChildrenOutside;


    return !renderChildrenOutside ? children : null;
  };

  ListItem.prototype._renderChildrenIfOutside = function _renderChildrenIfOutside() {
    var _props2 = this.props,
        children = _props2.children,
        renderChildrenOutside = _props2.renderChildrenOutside;


    if (renderChildrenOutside) {
      return _react2.default.createElement(
        'div',
        { className: 'md-list-item--flex' },
        _react2.default.createElement(_Divider2.default, { vertical: true, className: 'md-list-item--divider-vertical' }),
        _react2.default.createElement(
          'div',
          { className: 'md-list-item--children-inline' },
          children
        )
      );
    }

    return null;
  };

  ListItem.prototype.render = function render() {
    var _cn;

    var _props3 = this.props,
        style = _props3.style,
        className = _props3.className,
        tileStyle = _props3.tileStyle,
        tileClassName = _props3.tileClassName,
        contentStyle = _props3.contentStyle,
        contentClassName = _props3.contentClassName,
        leftNodeStyle = _props3.leftNodeStyle,
        leftNodeClassName = _props3.leftNodeClassName,
        rightNodeStyle = _props3.rightNodeStyle,
        rightNodeClassName = _props3.rightNodeClassName,
        primaryTextStyle = _props3.primaryTextStyle,
        primaryTextClassName = _props3.primaryTextClassName,
        secondaryTextStyle = _props3.secondaryTextStyle,
        secondaryTextClassName = _props3.secondaryTextClassName,
        nestedListStyle = _props3.nestedListStyle,
        nestedListClassName = _props3.nestedListClassName,
        nestedListHeightRestricted = _props3.nestedListHeightRestricted,
        disabled = _props3.disabled,
        leftIcon = _props3.leftIcon,
        leftAvatar = _props3.leftAvatar,
        inset = _props3.inset,
        rightIcon = _props3.rightIcon,
        rightAvatar = _props3.rightAvatar,
        primaryText = _props3.primaryText,
        secondaryText = _props3.secondaryText,
        threeLines = _props3.threeLines,
        nestedItems = _props3.nestedItems,
        prependNested = _props3.prependNested,
        active = _props3.active,
        activeClassName = _props3.activeClassName,
        activeBoxStyle = _props3.activeBoxStyle,
        activeBoxClassName = _props3.activeBoxClassName,
        animateNestedItems = _props3.animateNestedItems,
        expanderIcon = _props3.expanderIcon,
        expanderLeft = _props3.expanderLeft,
        component = _props3.component,
        ItemComponent = _props3.itemComponent,
        itemProps = _props3.itemProps,
        tileProps = _props3.tileProps,
        passPropsToItem = _props3.passPropsToItem,
        ariaSize = _props3['aria-setsize'],
        ariaPos = _props3['aria-posinset'],
        renderChildrenOutside = _props3.renderChildrenOutside,
        isOpen = _props3.isOpen,
        expanderIconChildren = _props3.expanderIconChildren,
        expanderIconClassName = _props3.expanderIconClassName,
        propVisible = _props3.visible,
        defaultVisible = _props3.defaultVisible,
        itemRef = _props3.itemRef,
        defaultOpen = _props3.defaultOpen,
        initiallyOpen = _props3.initiallyOpen,
        props = _objectWithoutProperties(_props3, ['style', 'className', 'tileStyle', 'tileClassName', 'contentStyle', 'contentClassName', 'leftNodeStyle', 'leftNodeClassName', 'rightNodeStyle', 'rightNodeClassName', 'primaryTextStyle', 'primaryTextClassName', 'secondaryTextStyle', 'secondaryTextClassName', 'nestedListStyle', 'nestedListClassName', 'nestedListHeightRestricted', 'disabled', 'leftIcon', 'leftAvatar', 'inset', 'rightIcon', 'rightAvatar', 'primaryText', 'secondaryText', 'threeLines', 'nestedItems', 'prependNested', 'active', 'activeClassName', 'activeBoxStyle', 'activeBoxClassName', 'animateNestedItems', 'expanderIcon', 'expanderLeft', 'component', 'itemComponent', 'itemProps', 'tileProps', 'passPropsToItem', 'aria-setsize', 'aria-posinset', 'renderChildrenOutside', 'isOpen', 'expanderIconChildren', 'expanderIconClassName', 'visible', 'defaultVisible', 'itemRef', 'defaultOpen', 'initiallyOpen']);

    var _context = this.context,
        cascadingId = _context.cascadingId,
        cascadingMenu = _context.cascadingMenu,
        cascadingAnchor = _context.cascadingAnchor,
        cascadingFixedTo = _context.cascadingFixedTo;

    var visible = (0, _getField2.default)(this.props, this.state, 'visible');
    if (typeof isOpen !== 'undefined') {
      visible = isOpen;
    }

    var leftNode = _react2.default.createElement(_TileAddon2.default, {
      key: 'left-addon',
      style: leftNodeStyle,
      className: leftNodeClassName,
      active: active,
      activeClassName: activeClassName,
      icon: leftIcon,
      avatar: leftAvatar
    });

    var rightNode = _react2.default.createElement(_TileAddon2.default, {
      key: 'right-addon',
      style: rightNodeStyle,
      className: rightNodeClassName,
      active: active,
      activeClassName: activeClassName,
      icon: rightIcon,
      avatar: rightAvatar
    });

    var nestedList = void 0;
    if (nestedItems) {
      if (!cascadingMenu) {
        nestedList = _react2.default.createElement(
          _Collapse2.default,
          { collapsed: !visible, animate: animateNestedItems },
          _react2.default.createElement(
            _List2.default,
            { style: nestedListStyle, className: nestedListClassName },
            nestedItems
          )
        );
      }

      var icon = _react2.default.Children.only((0, _getDeprecatedIcon2.default)(expanderIconClassName, expanderIconChildren, expanderIcon));
      var collapser = _react2.default.createElement(_TileAddon2.default, {
        key: 'expander-addon',
        icon: _react2.default.cloneElement(icon, {
          className: (0, _getCollapserStyles2.default)({ flipped: visible }, icon.props.className)
        }),
        avatar: null
      });

      if (expanderLeft) {
        if (!leftIcon && !leftAvatar) {
          leftNode = collapser;
        }
      } else if (!rightIcon && !rightAvatar) {
        rightNode = collapser;
      }
    }

    var icond = !!leftIcon || !!rightIcon || !!nestedItems;
    var avatard = !!leftAvatar || !!rightAvatar;

    var tile = _react2.default.createElement(
      _AccessibleFakeInkedButton2.default,
      _extends({}, tileProps, passPropsToItem ? undefined : props, {
        component: component,
        __SUPER_SECRET_REF__: this._setTile,
        key: 'tile',
        onClick: this._handleClick,
        onMouseOver: this._handleMouseOver,
        onMouseLeave: this._handleMouseLeave,
        onTouchStart: this._handleTouchStart,
        onTouchEnd: this._handleTouchEnd,
        onKeyDown: this._handleKeyDown,
        onKeyUp: this._handleKeyUp,
        disabled: disabled,
        style: tileStyle,
        className: (0, _classnames2.default)('md-list-tile', {
          'md-list-tile--active': this.state.active && !this._touched,
          'md-list-tile--icon': !secondaryText && icond && !avatard,
          'md-list-tile--avatar': !secondaryText && avatard,
          'md-list-tile--two-lines': secondaryText && !threeLines,
          'md-list-tile--three-lines': secondaryText && threeLines,
          'md-list-item--inset': inset && !leftIcon && !leftAvatar,
          'md-list-item--button-grow': renderChildrenOutside
        }, (0, _themeColors2.default)({ disabled: disabled, text: true }), tileClassName),
        'aria-expanded': nestedList && !cascadingMenu ? visible : null
      }),
      leftNode,
      _react2.default.createElement(_ListItemText2.default, {
        active: active,
        activeClassName: activeClassName,
        disabled: disabled,
        primaryText: primaryText,
        secondaryText: secondaryText,
        threeLines: threeLines,
        style: contentStyle,
        className: (0, _classnames2.default)({
          'md-tile-content--left-icon': leftIcon || expanderLeft && nestedItems,
          'md-tile-content--left-avatar': leftAvatar,
          'md-tile-content--right-padding': rightIcon || rightAvatar
        }, contentClassName),
        primaryTextStyle: primaryTextStyle,
        primaryTextClassName: primaryTextClassName,
        secondaryTextStyle: secondaryTextStyle,
        secondaryTextClassName: secondaryTextClassName
      }),
      rightNode,
      this._renderChildrenIfInside()
    );

    var sharedProps = _extends({}, itemProps, passPropsToItem ? props : undefined, {
      style: Object.assign({}, style, active ? activeBoxStyle : null),
      className: (0, _classnames2.default)('md-list-item', (_cn = {
        'md-list-item--nested-container': nestedItems
      }, _cn[activeBoxClassName] = activeBoxClassName && active, _cn['md-list-item--flex'] = renderChildrenOutside, _cn), className),
      'aria-setsize': ariaSize,
      'aria-posinset': ariaPos,
      ref: this._setContainer
    });
    if (cascadingMenu && nestedItems) {
      return _react2.default.createElement(
        _Menu2.default,
        _extends({
          id: cascadingId,
          visible: visible,
          onClose: this._handleClick,
          toggle: tile,
          block: true,
          simplified: false,
          anchor: cascadingAnchor,
          belowAnchor: null,
          position: _Menu2.default.Positions.BELOW,
          component: ItemComponent,
          listStyle: nestedListStyle,
          listClassName: nestedListClassName,
          listHeightRestricted: nestedListHeightRestricted
        }, sharedProps, {
          fixedTo: cascadingFixedTo
        }),
        nestedItems
      );
    }

    return _react2.default.createElement(
      ItemComponent,
      sharedProps,
      prependNested ? nestedList : null,
      tile,
      this._renderChildrenIfOutside(),
      prependNested ? null : nestedList
    );
  };

  return ListItem;
}(_react.PureComponent);

ListItem.propTypes = {
  /**
   * An optional style to apply to the `li` tag.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply to the `li` tag.
   */
  className: _propTypes2.default.string,

  /**
   * An optional style to apply to the `.md-list-tile`.
   *
   * @see {@link #component}
   */
  tileStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to the `.md-list-tile`.
   *
   * @see {@link #component}
   */
  tileClassName: _propTypes2.default.string,

  /**
   * An optional style to apply to the div that surrounds the `primaryText` and `secondaryText`
   * nodes.
   */
  contentStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to the div that surrounds the `primaryText` and `secondaryText`
   * nodes.
   */
  contentClassName: _propTypes2.default.string,

  /**
   * An optional style to apply to the element that is rendered before content node.
   */
  leftNodeStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to the element that is rendered before content node.
   */
  leftNodeClassName: _propTypes2.default.string,

  /**
   * An optional style to apply to the element that is rendered after content node.
   */
  rightNodeStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to the element that is rendered after content node.
   */
  rightNodeClassName: _propTypes2.default.string,

  /**
   * An optional style to apply to the div surrounding the `primaryText`.
   */
  primaryTextStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to the div surrounding the `primaryText`.
   */
  primaryTextClassName: _propTypes2.default.string,

  /**
   * An optional style to apply to the div surrounding the `secondaryText`.
   */
  secondaryTextStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to the div surrounding the `secondaryText`.
   */
  secondaryTextClassName: _propTypes2.default.string,

  /**
   * An optional style to apply to the nested `List` that gets created when using `nestedItems`.
   */
  nestedListStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to the nested `List` that gets created when using `nestedItems`.
   */
  nestedListClassName: _propTypes2.default.string,

  /**
   * Boolean if the nested `List` in a cascading menu should be restricted.
   */
  nestedListHeightRestricted: _propTypes2.default.bool,

  /**
   * Any additional children to display in the `.md-list-tile`. If you use this prop,
   * you will most likely need to override the `height` for the `.md-list-tile--icon`,
   * `.md-list-tile--avatar`, `.md-list-tile--two-lines`, and/or `.md-list-tile--three-lines`
   * to get it to display correctly unless the children are positioned `absolute`.
   */
  children: _propTypes2.default.node,

  /**
   * Boolean if the `ListItem` is disabled.
   */
  disabled: _propTypes2.default.bool,

  /**
   * An optional tab index for the `.md-list-tile`. If omitted, it will default to the
   * `AccessibleFakeButton`'s `tabIndex` default prop value.
   */
  tabIndex: _propTypes2.default.number,

  /**
   * The primary text to display. This will only be rendered as a single line. Any overflown
   * text will be converted to ellipsis.
   */
  primaryText: _propTypes2.default.node.isRequired,

  /**
   * An optional secondary text to display below the `primaryText`. This can be an additional
   * one or two lines. Like the `primaryText`, and overflown text will be converted to ellipsis.
   *
   * You must set the `threeLines` prop to `true` if you want this to be displayed as two lines.
   */
  secondaryText: _propTypes2.default.node,

  /**
   * An optional `FontIcon` to display to the left of the text.
   */
  leftIcon: _propTypes2.default.node,

  /**
   * An optional `Avatar` to display to the left of the text. If you have a mixed `List` of
   * `FontIcon` and `Avatar`, it is recommended to set the `iconSized` prop on the `Avatar` to
   * `true` so that the `Avatar` will be scaled down to the `FontIcon` size.
   */
  leftAvatar: _propTypes2.default.node,

  /**
   * An optional `FontIcon` to display to the right of the text.
   */
  rightIcon: _propTypes2.default.node,

  /**
   * An optional `Avatar` to display to the right of the text. If you have a mixed `List` of
   * `FontIcon` and `Avatar`, it is recommended to set the `iconSized` prop on the `Avatar` to
   * `true` so that the `Avatar` will be scaled down to the `FontIcon` size.
   */
  rightAvatar: _propTypes2.default.node,

  /**
   * Boolean if the list item should be inset as if there is a `leftIcon` or a `leftAvatar`.
   * This is used for some lists where only a parent contains the icon.
   */
  inset: _propTypes2.default.bool,

  /**
   * Boolean if the `secondaryText` should span two lines instead of one. This will include
   * three lines of text in total when including the `primaryText`.
   */
  threeLines: _propTypes2.default.bool,

  /**
   * The component to render the `.md-list-tile` as. This is mostly useful if you
   * want to use the `ListItem` for navigation and working with the `react-router`'s `Link`
   * component.
   *
   * This prop is **not** the top-most element of the `ListItem` component. To change the
   * top-most element, see the `itemComponent` prop.
   *
   * @see {@link #itemComponent}
   */
  component: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]).isRequired,

  /**
   * The component to render the top-most element of the `ListItem` component. This is the
   * `.md-list-item` and defaults to the `<li>` element.
   *
   * @see {@link #component}
   * @see {@link #itemProps}
   */
  itemComponent: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]).isRequired,

  /**
   * An optional ref callback to get reference to the top-most element of the `ListItem` component.
   * Just like other refs, this will provide null when it unmounts.
   */
  itemRef: _propTypes2.default.func,

  /**
   * An optional list of `ListItem`, `ListItemControl`, `Divider`, or `Subheader` components
   * to render in a nested list. This will inject an expander icon to the right of the text
   * in the `.md-list-tile` that rotates 180 degrees when open.
   *
   * The nested items will be visible once the user clicks on the `ListItem`.
   *
   * @see {@link #visible}
   */
  nestedItems: _propTypes2.default.arrayOf(_propTypes2.default.node),

  /**
   * An optional parameter determining whether `nestedItems` should be placed before or after `ListItemText`
   */
  prependNested: _propTypes2.default.bool,

  /**
   * Boolean if the `nestedItems` are visible by default.
   */
  defaultVisible: _propTypes2.default.bool,

  /**
   * Boolean if the `nestedItems` are visible. This will make the `nestedItems` controlled
   * and require the `onClick` function to be defined.
   *
   * @see {@link #defaultVisible}
   */
  visible: (0, _controlled2.default)(_propTypes2.default.bool, 'onClick', 'defaultVisible'),

  /**
   * An icon to use for the expander icon when there are nested items.
   */
  expanderIcon: _propTypes2.default.element,

  /**
   * Boolean if the expander icon should appear as the left icon instead of the right.
   */
  expanderLeft: _propTypes2.default.bool,

  /**
   * An optional function to call when the `.md-list-tile` is clicked. This is required if the
   * `visible` prop is defined.
   */
  onClick: _propTypes2.default.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `mouseover` event.
   */
  onMouseOver: _propTypes2.default.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `mouseleave` event.
   */
  onMouseLeave: _propTypes2.default.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `touchstart` event.
   */
  onTouchStart: _propTypes2.default.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `touchend` event.
   */
  onTouchEnd: _propTypes2.default.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `keydown` event.
   */
  onKeyDown: _propTypes2.default.func,

  /**
   * An optional function to call when the `.md-list-tile` triggers the `keyup` event.
   */
  onKeyUp: _propTypes2.default.func,

  /**
   * Boolean if the `ListItem` is currently active. This will apply the `activeClassName` prop
   * to the `leftIcon`, `rightIcon`, and the `primaryText`.
   */
  active: _propTypes2.default.bool,

  /**
   * The className to apply to the `leftIcon`, `rightIcon`, and `primaryText` when the `active`
   * prop is `true`.
   */
  activeClassName: _propTypes2.default.string,

  /**
   * An optional style to apply to the top-most element of the `ListItem` component (`.md-list-item`)
   * when the `active` prop is `true`.
   */
  activeBoxStyle: _propTypes2.default.object,

  /**
   * The className to apply to the top-most element of the `ListItem` component (`.md-list-item`)
   * when the `active` prop is `true`.
   */
  activeBoxClassName: _propTypes2.default.string,

  /**
   * Boolean if the nested items should animate when they appear or disappear.
   */
  animateNestedItems: _propTypes2.default.bool,

  /**
   * Boolean if the children should be rendered outside auf the AccessibleFakeButton component.
   */
  renderChildrenOutside: _propTypes2.default.bool,

  /**
   * Defines the number of items in the list. This is only required when all items in the
   * list are not present in the DOM.
   *
   * @see https://www.w3.org/TR/wai-aria/states_and_properties#aria-setsize
   */
  'aria-setsize': _propTypes2.default.number,

  /**
   * Defines the items position in the list. This is only required when all items in the list
   * are not present in the DOM. The custom validation just requires this prop if the `aria-setsize`
   * prop is defined as a helpful reminder.
   *
   * @see https://www.w3.org/TR/wai-aria/states_and_properties#aria-posinset
   */
  'aria-posinset': function ariaPosinset(props, propName) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var validator = _propTypes2.default.number;
    if (typeof props['aria-setsize'] !== 'undefined') {
      validator = validator.isRequired;
    }

    return validator.apply(undefined, [props, propName].concat(args));
  },

  /**
   * Any additional props you would like to supply to the surrounding `<li>` tag for the `ListItem`.
   * By default, all props will be provided to the inner `AccessibleFakeButton`. If the `passPropsToItem`
   * prop is enabled, the remaining props will be provided to the `<li>` tag instead and this prop
   * is probably useless.
   */
  itemProps: _propTypes2.default.object,

  /**
   * Any additional props you would like to add to the inner `AccessibleFakeButton`. By default, all the
   * remaining props will be provided to the `AccessibleFakeButton`, so this prop is probably useless.
   * Enabling the `passPropsToItem` prop will change the default behavior so that the remaining props
   * are provided to the surrounding `<li>` node instead and this prop becomes useful.
   */
  tileProps: _propTypes2.default.object,

  /**
   * All the remaining props should be passed to the surrounding `<li>` node instead of the `AccessibleFakeButton`.
   *
   * > NOTE: This will most likely become the default in the next *major* release. Migration warnings will be added
   * if that is the case.
   */
  passPropsToItem: _propTypes2.default.bool,
  expanderIconChildren: (0, _deprecated2.default)(_propTypes2.default.node, 'Use `expanderIcon` instead'),
  expanderIconClassName: (0, _deprecated2.default)(_propTypes2.default.string, 'Use `expanderIcon` instead'),
  initiallyOpen: (0, _deprecated2.default)(_propTypes2.default.bool, 'Use `defaultVisible` instead'),
  defaultOpen: (0, _deprecated2.default)(_propTypes2.default.bool, 'Use `defaultVisible` instead'),
  isOpen: (0, _deprecated2.default)(_propTypes2.default.bool, 'Use `visible` instead')
};
ListItem.defaultProps = {
  animateNestedItems: true,
  activeClassName: 'md-text--theme-primary',
  component: 'div',
  itemComponent: 'li',
  expanderIcon: _react2.default.createElement(
    _FontIcon2.default,
    null,
    'keyboard_arrow_down'
  ),
  renderChildrenOutside: false
};
ListItem.contextTypes = {
  cascadingId: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
  cascadingMenu: _propTypes2.default.bool,
  cascadingAnchor: _anchorShape2.default,
  cascadingFixedTo: _fixedToShape2.default
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.focus = function () {
    if (_this2._tile) {
      _this2._tile.focus();
    }
  };

  this.blur = function () {
    if (_this2._tile) {
      _this2._tile.blur();
    }
  };

  this._setTile = function (tile) {
    if (tile) {
      _this2._tile = tile;
      _this2._tileNode = (0, _reactDom.findDOMNode)(tile);
    }
  };

  this._setContainer = function (container) {
    var itemRef = _this2.props.itemRef;

    if (container) {
      _this2._container = (0, _reactDom.findDOMNode)(container);
    }
    if (itemRef) {
      itemRef(container ? _this2._container : null);
    }
  };

  this._handleOutsideClick = function (e) {
    if (_this2._container && !_this2._container.contains(e.target)) {
      window.removeEventListener('click', _this2._handleOutsideClick);
      _this2.setState({ active: false });
    }
  };

  this._handleClick = function (e) {
    if (_this2.props.onClick) {
      _this2.props.onClick(e);
    }

    if (typeof _this2.state.visible !== 'undefined') {
      _this2.setState({ visible: !_this2.state.visible });
    }
  };

  this._handleMouseOver = function (e) {
    if (_this2.props.onMouseOver) {
      _this2.props.onMouseOver(e);
    }

    if (!_this2.props.disabled) {
      _this2.setState({ active: true });
    }
  };

  this._handleMouseLeave = function (e) {
    if (_this2.props.onMouseLeave) {
      _this2.props.onMouseLeave(e);
    }

    if (!_this2.props.disabled) {
      _this2.setState({ active: false });
    }
  };

  this._handleTouchStart = function (e) {
    if (_this2.props.onTouchStart) {
      _this2.props.onTouchStart(e);
    }

    _this2._touched = true;

    _this2.setState({ active: true, touchedAt: Date.now() });
  };

  this._handleTouchEnd = function (e) {
    if (_this2.props.onTouchEnd) {
      _this2.props.onTouchEnd(e);
    }

    var time = Date.now() - _this2.state.touchedAt;
    _this2._touchTimeout = setTimeout(function () {
      _this2._touchTimeout = null;

      _this2.setState({ active: false });
    }, time > 450 ? 0 : 450 - time);
  };

  this._handleKeyUp = function (e) {
    if (_this2.props.onKeyUp) {
      _this2.props.onKeyUp(e);
    }

    if ((e.which || e.keyCode) === _keyCodes.TAB) {
      window.addEventListener('click', _this2._handleOutsideClick);
      _this2.setState({ active: true });
    }
  };

  this._handleKeyDown = function (e) {
    if (_this2.props.onKeyDown) {
      _this2.props.onKeyDown(e);
    }

    if ((e.which || e.keyCode) === _keyCodes.TAB) {
      window.removeEventListener('click', _this2._handleOutsideClick);
      _this2.setState({ active: false });
    }
  };
};

exports.default = ListItem;

/***/ }),

/***/ "T1e2":
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "T5tG":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRotate = exports.isRenderMode = exports.isPdf = exports.isPageNumber = exports.isPageIndex = exports.isPage = exports.isLinkTarget = exports.isLinkService = exports.isFile = exports.isClassName = exports.eventsProps = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__("e+GP"));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__("5WRv"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _lodash = _interopRequireDefault(__webpack_require__("p5wU"));

var _makeEventProps = __webpack_require__("1QXF");

var _utils = __webpack_require__("YliN");

var _LinkService = _interopRequireDefault(__webpack_require__("o9tr"));

var eventsProps = (0, _lodash.default)(function () {
  var eventProps = {};
  [].concat((0, _toConsumableArray2.default)(_makeEventProps.mouseEvents), (0, _toConsumableArray2.default)(_makeEventProps.touchEvents), (0, _toConsumableArray2.default)(_makeEventProps.keyboardEvents)).forEach(function (eventName) {
    eventProps[eventName] = _propTypes.default.func;
  });
  return eventProps;
});
exports.eventsProps = eventsProps;
var fileTypes = [_propTypes.default.string, _propTypes.default.instanceOf(ArrayBuffer), _propTypes.default.shape({
  data: _propTypes.default.object,
  httpHeaders: _propTypes.default.object,
  range: _propTypes.default.object,
  url: _propTypes.default.string,
  withCredentials: _propTypes.default.bool
})];

if (typeof File !== 'undefined') {
  fileTypes.push(_propTypes.default.instanceOf(File));
}

if (typeof Blob !== 'undefined') {
  fileTypes.push(_propTypes.default.instanceOf(Blob));
}

var isClassName = _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.arrayOf(_propTypes.default.string)]);

exports.isClassName = isClassName;

var isFile = _propTypes.default.oneOfType(fileTypes);

exports.isFile = isFile;

var isLinkService = _propTypes.default.instanceOf(_LinkService.default);

exports.isLinkService = isLinkService;

var isLinkTarget = _propTypes.default.oneOf(['_self', '_blank', '_parent', '_top']);

exports.isLinkTarget = isLinkTarget;

var isPage = _propTypes.default.shape({
  _transport: _propTypes.default.shape({
    fontLoader: _propTypes.default.object.isRequired
  }).isRequired,
  commonObjs: _propTypes.default.shape({
    _objs: _propTypes.default.object.isRequired
  }).isRequired,
  getAnnotations: _propTypes.default.func.isRequired,
  getTextContent: _propTypes.default.func.isRequired,
  getViewport: _propTypes.default.func.isRequired,
  render: _propTypes.default.func.isRequired
});

exports.isPage = isPage;

var isPageIndex = function isPageIndex(props, propName, componentName) {
  var pageIndex = props[propName],
      pageNumber = props.pageNumber,
      pdf = props.pdf;

  if (!(0, _utils.isDefined)(pdf)) {
    return null;
  }

  if ((0, _utils.isDefined)(pageIndex)) {
    if (typeof pageIndex !== 'number') {
      return new Error("`".concat(propName, "` of type `").concat((0, _typeof2.default)(pageIndex), "` supplied to `").concat(componentName, "`, expected `number`."));
    }

    if (pageIndex < 0) {
      return new Error("Expected `".concat(propName, "` to be greater or equal to 0."));
    }

    var numPages = pdf.numPages;

    if (pageIndex + 1 > numPages) {
      return new Error("Expected `".concat(propName, "` to be less or equal to ").concat(numPages - 1, "."));
    }
  } else if (!(0, _utils.isDefined)(pageNumber)) {
    return new Error("`".concat(propName, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(componentName, "`."));
  } // Everything is fine


  return null;
};

exports.isPageIndex = isPageIndex;

var isPageNumber = function isPageNumber(props, propName, componentName) {
  var pageNumber = props[propName],
      pageIndex = props.pageIndex,
      pdf = props.pdf;

  if (!(0, _utils.isDefined)(pdf)) {
    return null;
  }

  if ((0, _utils.isDefined)(pageNumber)) {
    if (typeof pageNumber !== 'number') {
      return new Error("`".concat(propName, "` of type `").concat((0, _typeof2.default)(pageNumber), "` supplied to `").concat(componentName, "`, expected `number`."));
    }

    if (pageNumber < 1) {
      return new Error("Expected `".concat(propName, "` to be greater or equal to 1."));
    }

    var numPages = pdf.numPages;

    if (pageNumber > numPages) {
      return new Error("Expected `".concat(propName, "` to be less or equal to ").concat(numPages, "."));
    }
  } else if (!(0, _utils.isDefined)(pageIndex)) {
    return new Error("`".concat(propName, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(componentName, "`."));
  } // Everything is fine


  return null;
};

exports.isPageNumber = isPageNumber;

var isPdf = _propTypes.default.oneOfType([_propTypes.default.shape({
  getDestination: _propTypes.default.func.isRequired,
  getOutline: _propTypes.default.func.isRequired,
  getPage: _propTypes.default.func.isRequired,
  numPages: _propTypes.default.number.isRequired
}), _propTypes.default.bool]);

exports.isPdf = isPdf;

var isRenderMode = _propTypes.default.oneOf(['canvas', 'none', 'svg']);

exports.isRenderMode = isRenderMode;

var isRotate = _propTypes.default.oneOf([0, 90, 180, 270]);

exports.isRotate = isRotate;

/***/ }),

/***/ "T9Ud":
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "TGEZ":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

//# sourceMappingURL=performance-now.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("7XVh")))

/***/ }),

/***/ "THQi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "TNjE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _getDisplayName = __webpack_require__("6gdi");

var _getDisplayName2 = _interopRequireDefault(_getDisplayName);

var _TooltipContainer = __webpack_require__("KBKS");

var _TooltipContainer2 = _interopRequireDefault(_TooltipContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Takes any component and injects a tooltip container as a prop. The tooltip container
 * will add event listeners for touch, mouse, and keyboard events so that a tooltip will appear
 * in the ComposedComponent.
 *
 * If the `tooltipLabel` prop is omitted, the tooltip and event listeners will not
 * be included.
 *
 * ```js
 * @param {function} ComposedComponent the component to compose with the tooltip functionality.
 * @return {function} the ComposedComponent with a tooltip.
 * ```
 */
exports.default = function (ComposedComponent) {
  var _class, _temp2;

  return _temp2 = _class = function (_PureComponent) {
    _inherits(TooltipedComponent, _PureComponent);

    function TooltipedComponent() {
      var _temp, _this, _ret;

      _classCallCheck(this, TooltipedComponent);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._composed = null, _this.getComposedComponent = function () {
        return _this._composed;
      }, _this._setComposedComponent = function (component) {
        _this._composed = component;
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    /**
     * Gets the composed component as a ref. This is useful if you need to access the ref of the
     * composed component instead of the `injectTooltip` HOC to use some publicly accessible methods.
     *
     * ```js
     * <SomeTooltippedComponent
     *   ref={tooltipHOC => {
     *     tooltipHOC.getComposedComponent().focus();
     *   }}
     * />
     * ```
     *
     * > NOTE: This can be `null`, so make sure to do a null check before using.
     */


    TooltipedComponent.prototype.render = function render() {
      var _props = this.props,
          tooltipLabel = _props.tooltipLabel,
          tooltipDelay = _props.tooltipDelay,
          tooltipPosition = _props.tooltipPosition,
          tooltipStyle = _props.tooltipStyle,
          tooltipClassName = _props.tooltipClassName,
          tooltipContainerStyle = _props.tooltipContainerStyle,
          tooltipContainerClassName = _props.tooltipContainerClassName,
          tooltipTransitionEnterTimeout = _props.tooltipTransitionEnterTimeout,
          tooltipTransitionLeaveTimeout = _props.tooltipTransitionLeaveTimeout,
          props = _objectWithoutProperties(_props, ['tooltipLabel', 'tooltipDelay', 'tooltipPosition', 'tooltipStyle', 'tooltipClassName', 'tooltipContainerStyle', 'tooltipContainerClassName', 'tooltipTransitionEnterTimeout', 'tooltipTransitionLeaveTimeout']);

      if (tooltipLabel) {
        props.tooltip = _react2.default.createElement(_TooltipContainer2.default, {
          key: 'tooltipContainer',
          label: tooltipLabel,
          delay: tooltipDelay,
          position: tooltipPosition,
          enterTimeout: tooltipTransitionEnterTimeout,
          leaveTimeout: tooltipTransitionLeaveTimeout,
          style: tooltipContainerStyle,
          className: tooltipContainerClassName,
          tooltipStyle: tooltipStyle,
          tooltipClassName: tooltipClassName
        });
      }

      props.ref = this._setComposedComponent;

      return _react2.default.createElement(ComposedComponent, props);
    };

    return TooltipedComponent;
  }(_react.PureComponent), _class.displayName = (0, _getDisplayName2.default)(ComposedComponent, 'Tooltip'), _class.propTypes = {
    /**
     * An optional style to apply to the tooltip container.
     */
    tooltipContainerStyle: _propTypes2.default.object,

    /**
     * An optional className to apply to the tooltip container.
     */
    tooltipContainerClassName: _propTypes2.default.string,

    /**
     * An optional style to apply to the tooltip itself.
     */
    tooltipStyle: _propTypes2.default.object,

    /**
     * An optional className to the tooltip itself.
     */
    tooltipClassName: _propTypes2.default.string,

    /**
     * The tooltip to display. If omitted, the `tooltip` prop will not be injected.
     */
    tooltipLabel: _propTypes2.default.node,

    /**
     * The amount of delay before the tooltip will appear on hover, touch, or keyboard focus.
     */
    tooltipDelay: _TooltipContainer2.default.propTypes.delay,

    /**
     * The position that the tooltip should appear related to the composed component.
     */
    tooltipPosition: _TooltipContainer2.default.propTypes.position,

    /**
     * The transition time for the tooltip appearing.
     */
    tooltipTransitionEnterTimeout: _TooltipContainer2.default.propTypes.enterTimeout,

    /**
     * The transition time for the tooltip disappearing.
     */
    tooltipTransitionLeaveTimeout: _TooltipContainer2.default.propTypes.leaveTimeout
  }, _temp2;
};

/***/ }),

/***/ "TWrC":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("53Ck");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDomTreeShapes = getDomTreeShapes;
exports.findNativeHandler = findNativeHandler;
exports.default = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__("Jg2a"));

var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__("ePj6"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("aDJe"));

var _createClass2 = _interopRequireDefault(__webpack_require__("GALk"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("0aw1"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("OqLi"));

var _inherits2 = _interopRequireDefault(__webpack_require__("n4ZD"));

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _warning = _interopRequireDefault(__webpack_require__("FIWN"));

var _properties = _interopRequireDefault(__webpack_require__("hx1s"));

var _on = _interopRequireDefault(__webpack_require__("3Yb6"));

var _off = _interopRequireDefault(__webpack_require__("EDUi"));

var _reactSwipeableViewsCore = __webpack_require__("Wk0l");

function addEventListenerEnhanced(node, event, handler, options) {
  (0, _on.default)(node, event, handler, options);
  return {
    remove: function remove() {
      (0, _off.default)(node, event, handler, options);
    }
  };
}

var styleInjected = false; // Support old version of iOS and IE 10.
// To be deleted in 2019.

function injectStyle() {
  // Inject once for all the instances
  if (!styleInjected) {
    var style = document.createElement('style');
    style.innerHTML = "\n      .react-swipeable-view-container {\n        display: -webkit-box;\n        display: -ms-flexbox;\n      }\n      .react-swipeable-view-container > div {\n        -ms-flex-negative: 0;\n      }\n    ";

    if (document.body) {
      document.body.appendChild(style);
    }

    styleInjected = true;
  }
}

var styles = {
  container: {
    direction: 'ltr',
    display: 'flex',
    willChange: 'transform'
  },
  slide: {
    width: '100%',
    WebkitFlexShrink: 0,
    flexShrink: 0,
    overflow: 'auto'
  }
};
var axisProperties = {
  root: {
    x: {
      overflowX: 'hidden'
    },
    'x-reverse': {
      overflowX: 'hidden'
    },
    y: {
      overflowY: 'hidden'
    },
    'y-reverse': {
      overflowY: 'hidden'
    }
  },
  flexDirection: {
    x: 'row',
    'x-reverse': 'row-reverse',
    y: 'column',
    'y-reverse': 'column-reverse'
  },
  transform: {
    x: function x(translate) {
      return "translate(".concat(-translate, "%, 0)");
    },
    'x-reverse': function xReverse(translate) {
      return "translate(".concat(translate, "%, 0)");
    },
    y: function y(translate) {
      return "translate(0, ".concat(-translate, "%)");
    },
    'y-reverse': function yReverse(translate) {
      return "translate(0, ".concat(translate, "%)");
    }
  },
  length: {
    x: 'width',
    'x-reverse': 'width',
    y: 'height',
    'y-reverse': 'height'
  },
  rotationMatrix: {
    x: {
      x: [1, 0],
      y: [0, 1]
    },
    'x-reverse': {
      x: [-1, 0],
      y: [0, 1]
    },
    y: {
      x: [0, 1],
      y: [1, 0]
    },
    'y-reverse': {
      x: [0, -1],
      y: [1, 0]
    }
  },
  scrollPosition: {
    x: 'scrollLeft',
    'x-reverse': 'scrollLeft',
    y: 'scrollTop',
    'y-reverse': 'scrollTop'
  },
  scrollLength: {
    x: 'scrollWidth',
    'x-reverse': 'scrollWidth',
    y: 'scrollHeight',
    'y-reverse': 'scrollHeight'
  },
  clientLength: {
    x: 'clientWidth',
    'x-reverse': 'clientWidth',
    y: 'clientHeight',
    'y-reverse': 'clientHeight'
  }
};

function createTransition(property, options) {
  var duration = options.duration,
      easeFunction = options.easeFunction,
      delay = options.delay;
  return "".concat(property, " ").concat(duration, " ").concat(easeFunction, " ").concat(delay);
} // We are using a 2x2 rotation matrix.


function applyRotationMatrix(touch, axis) {
  var rotationMatrix = axisProperties.rotationMatrix[axis];
  return {
    pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,
    pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY
  };
}

function adaptMouse(event) {
  event.touches = [{
    pageX: event.pageX,
    pageY: event.pageY
  }];
  return event;
}

function getDomTreeShapes(element, rootNode) {
  var domTreeShapes = [];

  while (element && element !== rootNode) {
    // We reach a Swipeable View, no need to look higher in the dom tree.
    if (element.hasAttribute('data-swipeable')) {
      break;
    }

    var style = window.getComputedStyle(element);

    if ( // Ignore the scroll children if the element is absolute positioned.
    style.getPropertyValue('position') === 'absolute' || // Ignore the scroll children if the element has an overflowX hidden
    style.getPropertyValue('overflow-x') === 'hidden') {
      domTreeShapes = [];
    } else if (element.clientWidth > 0 && element.scrollWidth > element.clientWidth || element.clientHeight > 0 && element.scrollHeight > element.clientHeight) {
      // Ignore the nodes that have no width.
      // Keep elements with a scroll
      domTreeShapes.push({
        element: element,
        scrollWidth: element.scrollWidth,
        scrollHeight: element.scrollHeight,
        clientWidth: element.clientWidth,
        clientHeight: element.clientHeight,
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      });
    }

    element = element.parentNode;
  }

  return domTreeShapes;
} // We can only have one node at the time claiming ownership for handling the swipe.
// Otherwise, the UX would be confusing.
// That's why we use a singleton here.


var nodeWhoClaimedTheScroll = null;

function findNativeHandler(params) {
  var domTreeShapes = params.domTreeShapes,
      pageX = params.pageX,
      startX = params.startX,
      axis = params.axis;
  return domTreeShapes.some(function (shape) {
    // Determine if we are going backward or forward.
    var goingForward = pageX >= startX;

    if (axis === 'x' || axis === 'y') {
      goingForward = !goingForward;
    }

    var scrollPosition = shape[axisProperties.scrollPosition[axis]];
    var areNotAtStart = scrollPosition > 0;
    var areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];

    if (goingForward && areNotAtEnd || !goingForward && areNotAtStart) {
      nodeWhoClaimedTheScroll = shape.element;
      return true;
    }

    return false;
  });
}

var SwipeableViews =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2.default)(SwipeableViews, _React$Component);

  function SwipeableViews(props) {
    var _this;

    (0, _classCallCheck2.default)(this, SwipeableViews);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SwipeableViews).call(this, props));
    _this.rootNode = null;
    _this.containerNode = null;
    _this.ignoreNextScrollEvents = false;
    _this.viewLength = 0;
    _this.startX = 0;
    _this.lastX = 0;
    _this.vx = 0;
    _this.startY = 0;
    _this.isSwiping = undefined;
    _this.started = false;
    _this.startIndex = 0;
    _this.transitionListener = null;
    _this.touchMoveListener = null;
    _this.activeSlide = null;
    _this.indexCurrent = null;
    _this.firstRenderTimeout = null;

    _this.setRootNode = function (node) {
      _this.rootNode = node;
    };

    _this.setContainerNode = function (node) {
      _this.containerNode = node;
    };

    _this.setActiveSlide = function (node) {
      _this.activeSlide = node;

      _this.updateHeight();
    };

    _this.handleSwipeStart = function (event) {
      var axis = _this.props.axis;
      var touch = applyRotationMatrix(event.touches[0], axis);
      _this.viewLength = _this.rootNode.getBoundingClientRect()[axisProperties.length[axis]];
      _this.startX = touch.pageX;
      _this.lastX = touch.pageX;
      _this.vx = 0;
      _this.startY = touch.pageY;
      _this.isSwiping = undefined;
      _this.started = true;
      var computedStyle = window.getComputedStyle(_this.containerNode);
      var transform = computedStyle.getPropertyValue('-webkit-transform') || computedStyle.getPropertyValue('transform');

      if (transform && transform !== 'none') {
        var transformValues = transform.split('(')[1].split(')')[0].split(',');
        var rootStyle = window.getComputedStyle(_this.rootNode);
        var tranformNormalized = applyRotationMatrix({
          pageX: parseInt(transformValues[4], 10),
          pageY: parseInt(transformValues[5], 10)
        }, axis);
        _this.startIndex = -tranformNormalized.pageX / (_this.viewLength - parseInt(rootStyle.paddingLeft, 10) - parseInt(rootStyle.paddingRight, 10)) || 0;
      }
    };

    _this.handleSwipeMove = function (event) {
      // The touch start event can be cancel.
      // Makes sure we set a starting point.
      if (!_this.started) {
        _this.handleTouchStart(event);

        return;
      } // We are not supposed to hanlde this touch move.


      if (nodeWhoClaimedTheScroll !== null && nodeWhoClaimedTheScroll !== _this.rootNode) {
        return;
      }

      var _this$props = _this.props,
          axis = _this$props.axis,
          children = _this$props.children,
          ignoreNativeScroll = _this$props.ignoreNativeScroll,
          onSwitching = _this$props.onSwitching,
          resistance = _this$props.resistance;
      var touch = applyRotationMatrix(event.touches[0], axis); // We don't know yet.

      if (_this.isSwiping === undefined) {
        var dx = Math.abs(touch.pageX - _this.startX);
        var dy = Math.abs(touch.pageY - _this.startY);
        var isSwiping = dx > dy && dx > _reactSwipeableViewsCore.constant.UNCERTAINTY_THRESHOLD; // We let the parent handle the scroll.

        if (!resistance && (axis === 'y' || axis === 'y-reverse') && (_this.indexCurrent === 0 && _this.startX < touch.pageX || _this.indexCurrent === _react.default.Children.count(_this.props.children) - 1 && _this.startX > touch.pageX)) {
          _this.isSwiping = false;
          return;
        } // We are likely to be swiping, let's prevent the scroll event.


        if (dx > dy) {
          event.preventDefault();
        }

        if (isSwiping === true || dy > _reactSwipeableViewsCore.constant.UNCERTAINTY_THRESHOLD) {
          _this.isSwiping = isSwiping;
          _this.startX = touch.pageX; // Shift the starting point.

          return; // Let's wait the next touch event to move something.
        }
      }

      if (_this.isSwiping !== true) {
        return;
      } // We are swiping, let's prevent the scroll event.


      event.preventDefault(); // Low Pass filter.

      _this.vx = _this.vx * 0.5 + (touch.pageX - _this.lastX) * 0.5;
      _this.lastX = touch.pageX;

      var _computeIndex = (0, _reactSwipeableViewsCore.computeIndex)({
        children: children,
        resistance: resistance,
        pageX: touch.pageX,
        startIndex: _this.startIndex,
        startX: _this.startX,
        viewLength: _this.viewLength
      }),
          index = _computeIndex.index,
          startX = _computeIndex.startX; // Add support for native scroll elements.


      if (nodeWhoClaimedTheScroll === null && !ignoreNativeScroll) {
        var domTreeShapes = getDomTreeShapes(event.target, _this.rootNode);
        var hasFoundNativeHandler = findNativeHandler({
          domTreeShapes: domTreeShapes,
          startX: _this.startX,
          pageX: touch.pageX,
          axis: axis
        }); // We abort the touch move handler.

        if (hasFoundNativeHandler) {
          return;
        }
      } // We are moving toward the edges.


      if (startX) {
        _this.startX = startX;
      } else if (nodeWhoClaimedTheScroll === null) {
        nodeWhoClaimedTheScroll = _this.rootNode;
      }

      _this.setIndexCurrent(index);

      var callback = function callback() {
        if (onSwitching) {
          onSwitching(index, 'move');
        }
      };

      if (_this.state.displaySameSlide || !_this.state.isDragging) {
        _this.setState({
          displaySameSlide: false,
          isDragging: true
        }, callback);
      }

      callback();
    };

    _this.handleSwipeEnd = function () {
      nodeWhoClaimedTheScroll = null; // The touch start event can be cancel.
      // Makes sure that a starting point is set.

      if (!_this.started) {
        return;
      }

      _this.started = false;

      if (_this.isSwiping !== true) {
        return;
      }

      var indexLatest = _this.state.indexLatest;
      var indexCurrent = _this.indexCurrent;
      var delta = indexLatest - indexCurrent;
      var indexNew; // Quick movement

      if (Math.abs(_this.vx) > _this.props.threshold) {
        if (_this.vx > 0) {
          indexNew = Math.floor(indexCurrent);
        } else {
          indexNew = Math.ceil(indexCurrent);
        }
      } else if (Math.abs(delta) > _this.props.hysteresis) {
        // Some hysteresis with indexLatest.
        indexNew = delta > 0 ? Math.floor(indexCurrent) : Math.ceil(indexCurrent);
      } else {
        indexNew = indexLatest;
      }

      var indexMax = _react.default.Children.count(_this.props.children) - 1;

      if (indexNew < 0) {
        indexNew = 0;
      } else if (indexNew > indexMax) {
        indexNew = indexMax;
      }

      _this.setIndexCurrent(indexNew);

      _this.setState({
        indexLatest: indexNew,
        isDragging: false
      }, function () {
        if (_this.props.onSwitching) {
          _this.props.onSwitching(indexNew, 'end');
        }

        if (_this.props.onChangeIndex && indexNew !== indexLatest) {
          _this.props.onChangeIndex(indexNew, indexLatest, {
            reason: 'swipe'
          });
        } // Manually calling handleTransitionEnd in that case as isn't otherwise.


        if (indexCurrent === indexLatest) {
          _this.handleTransitionEnd();
        }
      });
    };

    _this.handleTouchStart = function (event) {
      if (_this.props.onTouchStart) {
        _this.props.onTouchStart(event);
      }

      _this.handleSwipeStart(event);
    };

    _this.handleTouchEnd = function (event) {
      if (_this.props.onTouchEnd) {
        _this.props.onTouchEnd(event);
      }

      _this.handleSwipeEnd(event);
    };

    _this.handleMouseDown = function (event) {
      if (_this.props.onMouseDown) {
        _this.props.onMouseDown(event);
      }

      event.persist();

      _this.handleSwipeStart(adaptMouse(event));
    };

    _this.handleMouseUp = function (event) {
      if (_this.props.onMouseUp) {
        _this.props.onMouseUp(event);
      }

      _this.handleSwipeEnd(adaptMouse(event));
    };

    _this.handleMouseLeave = function (event) {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave(event);
      } // Filter out events


      if (_this.started) {
        _this.handleSwipeEnd(adaptMouse(event));
      }
    };

    _this.handleMouseMove = function (event) {
      if (_this.props.onMouseMove) {
        _this.props.onMouseMove(event);
      } // Filter out events


      if (_this.started) {
        _this.handleSwipeMove(adaptMouse(event));
      }
    };

    _this.handleScroll = function (event) {
      if (_this.props.onScroll) {
        _this.props.onScroll(event);
      } // Ignore events bubbling up.


      if (event.target !== _this.rootNode) {
        return;
      }

      if (_this.ignoreNextScrollEvents) {
        _this.ignoreNextScrollEvents = false;
        return;
      }

      var indexLatest = _this.state.indexLatest;
      var indexNew = Math.ceil(event.target.scrollLeft / event.target.clientWidth) + indexLatest;
      _this.ignoreNextScrollEvents = true; // Reset the scroll position.

      event.target.scrollLeft = 0;

      if (_this.props.onChangeIndex && indexNew !== indexLatest) {
        _this.props.onChangeIndex(indexNew, indexLatest, {
          reason: 'focus'
        });
      }
    };

    _this.updateHeight = function () {
      if (_this.activeSlide !== null) {
        var child = _this.activeSlide.children[0];

        if (child !== undefined && child.offsetHeight !== undefined && _this.state.heightLatest !== child.offsetHeight) {
          _this.setState({
            heightLatest: child.offsetHeight
          });
        }
      }
    };

    if (false) {}

    _this.state = {
      indexLatest: props.index,
      // Set to true as soon as the component is swiping.
      // It's the state counter part of this.isSwiping.
      isDragging: false,
      // Help with SSR logic and lazy loading logic.
      renderOnlyActive: !props.disableLazyLoading,
      heightLatest: 0,
      // Let the render method that we are going to display the same slide than previously.
      displaySameSlide: true
    };

    _this.setIndexCurrent(props.index);

    return _this;
  }

  (0, _createClass2.default)(SwipeableViews, [{
    key: "getChildContext",
    value: function getChildContext() {
      var _this2 = this;

      return {
        swipeableViews: {
          slideUpdateHeight: function slideUpdateHeight() {
            _this2.updateHeight();
          }
        }
      };
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this3 = this;

      // Subscribe to transition end events.
      this.transitionListener = addEventListenerEnhanced(this.containerNode, _properties.default.end, function (event) {
        if (event.target !== _this3.containerNode) {
          return;
        }

        _this3.handleTransitionEnd();
      }); // Block the thread to handle that event.

      this.touchMoveListener = addEventListenerEnhanced(this.rootNode, 'touchmove', function (event) {
        // Handling touch events is disabled.
        if (_this3.props.disabled) {
          return;
        }

        _this3.handleSwipeMove(event);
      }, {
        passive: false
      });

      if (!this.props.disableLazyLoading) {
        this.firstRenderTimeout = setTimeout(function () {
          _this3.setState({
            renderOnlyActive: false
          });
        }, 0);
      }

      injectStyle(); // Send all functions in an object if action param is set.

      if (this.props.action) {
        this.props.action({
          updateHeight: this.updateHeight
        });
      }
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var index = nextProps.index;

      if (typeof index === 'number' && index !== this.props.index) {
        if (false) {}

        this.setIndexCurrent(index);
        this.setState({
          // If true, we are going to change the children. We shoudn't animate it.
          displaySameSlide: (0, _reactSwipeableViewsCore.getDisplaySameSlide)(this.props, nextProps),
          indexLatest: index
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.transitionListener.remove();
      this.touchMoveListener.remove();
      clearTimeout(this.firstRenderTimeout);
    }
  }, {
    key: "setIndexCurrent",
    value: function setIndexCurrent(indexCurrent) {
      if (!this.props.animateTransitions && this.indexCurrent !== indexCurrent) {
        this.handleTransitionEnd();
      }

      this.indexCurrent = indexCurrent;

      if (this.containerNode) {
        var axis = this.props.axis;
        var transform = axisProperties.transform[axis](indexCurrent * 100);
        this.containerNode.style.WebkitTransform = transform;
        this.containerNode.style.transform = transform;
      }
    }
  }, {
    key: "handleTransitionEnd",
    value: function handleTransitionEnd() {
      if (!this.props.onTransitionEnd) {
        return;
      } // Filters out when changing the children


      if (this.state.displaySameSlide) {
        return;
      } // The rest callback is triggered when swiping. It's just noise.
      // We filter it out.


      if (!this.state.isDragging) {
        this.props.onTransitionEnd();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props2 = this.props,
          action = _this$props2.action,
          animateHeight = _this$props2.animateHeight,
          animateTransitions = _this$props2.animateTransitions,
          axis = _this$props2.axis,
          children = _this$props2.children,
          containerStyleProp = _this$props2.containerStyle,
          disabled = _this$props2.disabled,
          disableLazyLoading = _this$props2.disableLazyLoading,
          enableMouseEvents = _this$props2.enableMouseEvents,
          hysteresis = _this$props2.hysteresis,
          ignoreNativeScroll = _this$props2.ignoreNativeScroll,
          index = _this$props2.index,
          onChangeIndex = _this$props2.onChangeIndex,
          onSwitching = _this$props2.onSwitching,
          onTransitionEnd = _this$props2.onTransitionEnd,
          resistance = _this$props2.resistance,
          slideStyleProp = _this$props2.slideStyle,
          slideClassName = _this$props2.slideClassName,
          springConfig = _this$props2.springConfig,
          style = _this$props2.style,
          threshold = _this$props2.threshold,
          other = (0, _objectWithoutProperties2.default)(_this$props2, ["action", "animateHeight", "animateTransitions", "axis", "children", "containerStyle", "disabled", "disableLazyLoading", "enableMouseEvents", "hysteresis", "ignoreNativeScroll", "index", "onChangeIndex", "onSwitching", "onTransitionEnd", "resistance", "slideStyle", "slideClassName", "springConfig", "style", "threshold"]);
      var _this$state = this.state,
          displaySameSlide = _this$state.displaySameSlide,
          heightLatest = _this$state.heightLatest,
          indexLatest = _this$state.indexLatest,
          isDragging = _this$state.isDragging,
          renderOnlyActive = _this$state.renderOnlyActive;
      var touchEvents = !disabled ? {
        onTouchStart: this.handleTouchStart,
        onTouchEnd: this.handleTouchEnd
      } : {};
      var mouseEvents = !disabled && enableMouseEvents ? {
        onMouseDown: this.handleMouseDown,
        onMouseUp: this.handleMouseUp,
        onMouseLeave: this.handleMouseLeave,
        onMouseMove: this.handleMouseMove
      } : {}; // There is no point to animate if we are already providing a height.

       false ? undefined : void 0;
      var slideStyle = (0, _extends2.default)({}, styles.slide, slideStyleProp);
      var transition;
      var WebkitTransition;

      if (isDragging || !animateTransitions || displaySameSlide) {
        transition = 'all 0s ease 0s';
        WebkitTransition = 'all 0s ease 0s';
      } else {
        transition = createTransition('transform', springConfig);
        WebkitTransition = createTransition('-webkit-transform', springConfig);

        if (heightLatest !== 0) {
          var additionalTranstion = ", ".concat(createTransition('height', springConfig));
          transition += additionalTranstion;
          WebkitTransition += additionalTranstion;
        }
      }

      var containerStyle = {
        height: null,
        WebkitFlexDirection: axisProperties.flexDirection[axis],
        flexDirection: axisProperties.flexDirection[axis],
        WebkitTransition: WebkitTransition,
        transition: transition
      }; // Apply the styles for SSR considerations

      if (!renderOnlyActive) {
        var transform = axisProperties.transform[axis](this.indexCurrent * 100);
        containerStyle.WebkitTransform = transform;
        containerStyle.transform = transform;
      }

      if (animateHeight) {
        containerStyle.height = heightLatest;
      }

      return _react.default.createElement("div", (0, _extends2.default)({
        ref: this.setRootNode,
        style: (0, _extends2.default)({}, axisProperties.root[axis], style)
      }, other, touchEvents, mouseEvents, {
        onScroll: this.handleScroll
      }), _react.default.createElement("div", {
        ref: this.setContainerNode,
        style: (0, _extends2.default)({}, containerStyle, styles.container, containerStyleProp),
        className: "react-swipeable-view-container"
      }, _react.default.Children.map(children, function (child, indexChild) {
        if (renderOnlyActive && indexChild !== indexLatest) {
          return null;
        }

         false ? undefined : void 0;
        var ref;
        var hidden = true;

        if (indexChild === indexLatest) {
          hidden = false;

          if (animateHeight) {
            ref = _this4.setActiveSlide;
            slideStyle.overflowY = 'hidden';
          }
        }

        return _react.default.createElement("div", {
          ref: ref,
          style: slideStyle,
          className: slideClassName,
          "aria-hidden": hidden,
          "data-swipeable": "true"
        }, child);
      })));
    }
  }]);
  return SwipeableViews;
}(_react.default.Component); // Added as an ads for people using the React dev tools in production.
// So they know, the tool used to build the awesome UI they
// are looking at/retro engineering.


SwipeableViews.displayName = 'ReactSwipableView';
SwipeableViews.propTypes =  false ? undefined : {};
SwipeableViews.defaultProps = {
  animateHeight: false,
  animateTransitions: true,
  axis: 'x',
  disabled: false,
  disableLazyLoading: false,
  enableMouseEvents: false,
  hysteresis: 0.6,
  ignoreNativeScroll: false,
  index: 0,
  threshold: 5,
  springConfig: {
    duration: '0.35s',
    easeFunction: 'cubic-bezier(0.15, 0.3, 0.25, 1)',
    delay: '0s'
  },
  resistance: false
};
SwipeableViews.childContextTypes = {
  swipeableViews: _propTypes.default.shape({
    slideUpdateHeight: _propTypes.default.func
  })
};
var _default = SwipeableViews;
exports.default = _default;

/***/ }),

/***/ "UKnr":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__("MNOf");
exports.encode = exports.stringify = __webpack_require__("THQi");


/***/ }),

/***/ "UdKW":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v0.15.0
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

Object.defineProperty(exports,"__esModule",{value:!0});var d=void 0,e=void 0,g=void 0,m=void 0,n=void 0;exports.unstable_now=void 0;exports.unstable_forceFrameRate=void 0;
if("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,r=function(){if(null!==p)try{var a=exports.unstable_now();p(!0,a);p=null}catch(b){throw setTimeout(r,0),b;}};exports.unstable_now=function(){return Date.now()};d=function(a){null!==p?setTimeout(d,0,a):(p=a,setTimeout(r,0))};e=function(a,b){q=setTimeout(a,b)};g=function(){clearTimeout(q)};m=function(){return!1};n=exports.unstable_forceFrameRate=function(){}}else{var t=window.performance,u=window.Date,v=window.setTimeout,
w=window.clearTimeout,x=window.requestAnimationFrame,y=window.cancelAnimationFrame;"undefined"!==typeof console&&("function"!==typeof x&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),"function"!==typeof y&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));exports.unstable_now="object"===typeof t&&
"function"===typeof t.now?function(){return t.now()}:function(){return u.now()};var z=!1,A=null,B=-1,C=-1,D=33.33,E=-1,F=-1,G=0,H=!1;m=function(){return exports.unstable_now()>=G};n=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):0<a?(D=Math.floor(1E3/a),H=!0):(D=33.33,H=!1)};var J=function(){if(null!==A){var a=exports.unstable_now(),b=0<G-a;try{A(b,
a)||(A=null)}catch(c){throw I.postMessage(null),c;}}},K=new MessageChannel,I=K.port2;K.port1.onmessage=J;var L=function(a){if(null===A)F=E=-1,z=!1;else{z=!0;x(function(a){w(B);L(a)});var b=function(){G=exports.unstable_now()+D/2;J();B=v(b,3*D)};B=v(b,3*D);if(-1!==E&&.1<a-E){var c=a-E;!H&&-1!==F&&c<D&&F<D&&(D=c<F?F:c,8.33>D&&(D=8.33));F=c}E=a;G=a+D;I.postMessage(null)}};d=function(a){A=a;z||(z=!0,x(function(a){L(a)}))};e=function(a,b){C=v(function(){a(exports.unstable_now())},b)};g=function(){w(C);
C=-1}}var M=null,N=null,O=null,P=3,Q=!1,R=!1,S=!1;
function T(a,b){var c=a.next;if(c===a)M=null;else{a===M&&(M=c);var f=a.previous;f.next=c;c.previous=f}a.next=a.previous=null;c=a.callback;f=P;var l=O;P=a.priorityLevel;O=a;try{var h=a.expirationTime<=b;switch(P){case 1:var k=c(h);break;case 2:k=c(h);break;case 3:k=c(h);break;case 4:k=c(h);break;case 5:k=c(h)}}catch(Z){throw Z;}finally{P=f,O=l}if("function"===typeof k)if(b=a.expirationTime,a.callback=k,null===M)M=a.next=a.previous=a;else{k=null;h=M;do{if(b<=h.expirationTime){k=h;break}h=h.next}while(h!==
M);null===k?k=M:k===M&&(M=a);b=k.previous;b.next=k.previous=a;a.next=k;a.previous=b}}function U(a){if(null!==N&&N.startTime<=a){do{var b=N,c=b.next;if(b===c)N=null;else{N=c;var f=b.previous;f.next=c;c.previous=f}b.next=b.previous=null;V(b,b.expirationTime)}while(null!==N&&N.startTime<=a)}}function W(a){S=!1;U(a);R||(null!==M?(R=!0,d(X)):null!==N&&e(W,N.startTime-a))}
function X(a,b){R=!1;S&&(S=!1,g());U(b);Q=!0;try{if(!a)for(;null!==M&&M.expirationTime<=b;)T(M,b),b=exports.unstable_now(),U(b);else if(null!==M){do T(M,b),b=exports.unstable_now(),U(b);while(null!==M&&!m())}if(null!==M)return!0;null!==N&&e(W,N.startTime-b);return!1}finally{Q=!1}}function Y(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}
function V(a,b){if(null===M)M=a.next=a.previous=a;else{var c=null,f=M;do{if(b<f.expirationTime){c=f;break}f=f.next}while(f!==M);null===c?c=M:c===M&&(M=a);b=c.previous;b.next=c.previous=a;a.next=c;a.previous=b}}var aa=n;exports.unstable_ImmediatePriority=1;exports.unstable_UserBlockingPriority=2;exports.unstable_NormalPriority=3;exports.unstable_IdlePriority=5;exports.unstable_LowPriority=4;
exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=P;P=a;try{return b()}finally{P=c}};exports.unstable_next=function(a){switch(P){case 1:case 2:case 3:var b=3;break;default:b=P}var c=P;P=b;try{return a()}finally{P=c}};
exports.unstable_scheduleCallback=function(a,b,c){var f=exports.unstable_now();if("object"===typeof c&&null!==c){var l=c.delay;l="number"===typeof l&&0<l?f+l:f;c="number"===typeof c.timeout?c.timeout:Y(a)}else c=Y(a),l=f;c=l+c;a={callback:b,priorityLevel:a,startTime:l,expirationTime:c,next:null,previous:null};if(l>f){c=l;if(null===N)N=a.next=a.previous=a;else{b=null;var h=N;do{if(c<h.startTime){b=h;break}h=h.next}while(h!==N);null===b?b=N:b===N&&(N=a);c=b.previous;c.next=b.previous=a;a.next=b;a.previous=
c}null===M&&N===a&&(S?g():S=!0,e(W,l-f))}else V(a,c),R||Q||(R=!0,d(X));return a};exports.unstable_cancelCallback=function(a){var b=a.next;if(null!==b){if(a===b)a===M?M=null:a===N&&(N=null);else{a===M?M=b:a===N&&(N=b);var c=a.previous;c.next=b;b.previous=c}a.next=a.previous=null}};exports.unstable_wrapCallback=function(a){var b=P;return function(){var c=P;P=b;try{return a.apply(this,arguments)}finally{P=c}}};exports.unstable_getCurrentPriorityLevel=function(){return P};
exports.unstable_shouldYield=function(){var a=exports.unstable_now();U(a);return null!==O&&null!==M&&M.startTime<=a&&M.expirationTime<O.expirationTime||m()};exports.unstable_requestPaint=aa;exports.unstable_continueExecution=function(){R||Q||(R=!0,d(X))};exports.unstable_pauseExecution=function(){};exports.unstable_getFirstCallbackNode=function(){return M};


/***/ }),

/***/ "UgH5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Extended version of % with negative integer support.
function mod(n, m) {
  var q = n % m;
  return q < 0 ? q + m : q;
}

var _default = mod;
exports.default = _default;

/***/ }),

/***/ "VNYx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// currently used to initiate the velocity style object to 0


exports.__esModule = true;
exports['default'] = mapToZero;

function mapToZero(obj) {
  var ret = {};
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      ret[key] = 0;
    }
  }
  return ret;
}

module.exports = exports['default'];

/***/ }),

/***/ "VZNk":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = themeColors;

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This is a utility function to apply the different text colors as a class name.
 *
 * @param {Object} options - The options to use to figure out which styles to apply.
 * @param {boolean?} options.text - Boolean if the base text color should attempt to be
 *    applied. This will only be applied if all the other states are not true.
 * @param {boolean?} options.disabled - Boolean if the text should be disabled.
 * @param {boolean?} options.error - Boolean if the error color should attempt to be applied.
 *    This will only be applied if the disabled state is false.
 * @param {boolean?} options.primary - Boolean if the primary color should be applied. This
 *    will only be applied if all the other states are false.
 * @param {boolean?} options.secondary - Boolean if the secondary color should be applied.
 *    This will only be applied if all the other states are false.
 * @param {boolean?} options.inherit - Boolean if the color should be inherited by a parent.
 *    This will only be applied if the error and disabled states are false.
 * @return {String} the class name
 */
function themeColors() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$themeText = _ref.themeText,
      themeText = _ref$themeText === undefined ? true : _ref$themeText,
      _ref$text = _ref.text,
      text = _ref$text === undefined ? false : _ref$text,
      _ref$background = _ref.background,
      background = _ref$background === undefined ? false : _ref$background,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === undefined ? false : _ref$disabled,
      _ref$error = _ref.error,
      error = _ref$error === undefined ? false : _ref$error,
      _ref$hint = _ref.hint,
      hint = _ref$hint === undefined ? false : _ref$hint,
      _ref$primary = _ref.primary,
      primary = _ref$primary === undefined ? false : _ref$primary,
      _ref$secondary = _ref.secondary,
      secondary = _ref$secondary === undefined ? false : _ref$secondary,
      _ref$inherit = _ref.inherit,
      inherit = _ref$inherit === undefined ? false : _ref$inherit,
      _ref$ink = _ref.ink,
      ink = _ref$ink === undefined ? false : _ref$ink,
      _ref$card = _ref.card,
      card = _ref$card === undefined ? false : _ref$card,
      _ref$hover = _ref.hover,
      hover = _ref$hover === undefined ? false : _ref$hover;

  var className = arguments[1];

  var colors = '';
  if (themeText) {
    if (disabled) {
      colors = 'md-text--disabled';
    } else if (error) {
      colors = 'md-text--error';
    } else if (inherit) {
      colors = 'md-text--inherit';
    } else {
      colors = (0, _classnames2.default)({
        'md-text': text && !primary && !secondary && !hint,
        'md-text--secondary': hint,
        'md-text--theme-primary': !hint && primary,
        'md-text--theme-secondary': !hint && secondary,
        'md-ink--primary': ink && primary,
        'md-ink--secondary': ink && secondary
      });
    }
  } else {
    colors = (0, _classnames2.default)({
      'md-background': background && !primary && !secondary && !card,
      'md-background--card': card,
      'md-background--primary': primary,
      'md-background--primary-hover': primary && hover,
      'md-background--secondary': secondary,
      'md-background--secondary-hover': secondary && hover
    });
  }

  return (0, _classnames2.default)(colors, className);
} /** @module utils/themeColors */

/***/ }),

/***/ "VwaL":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _componentDeprecated = __webpack_require__("9/Bt");

var _componentDeprecated2 = _interopRequireDefault(_componentDeprecated);

var _Button = __webpack_require__("Bff0");

var _Button2 = _interopRequireDefault(_Button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FlatButton = function (_PureComponent) {
  _inherits(FlatButton, _PureComponent);

  function FlatButton() {
    _classCallCheck(this, FlatButton);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  FlatButton.prototype.render = function render() {
    return _react2.default.createElement(_Button2.default, _extends({}, this.props, { flat: true }));
  };

  return FlatButton;
}(_react.PureComponent);

FlatButton.propTypes = {
  /**
   * The label to display in the button.
   */
  label: _propTypes2.default.node.isRequired,

  /**
   * An optional className to apply to the button.
   */
  className: _propTypes2.default.string,

  /**
   * Boolean if the icon should be displayed before the label.
   */
  iconBefore: _propTypes2.default.bool,

  /**
   * A `FontIcon` to display in the button. It can be placed before
   * or after the label.
   */
  children: _propTypes2.default.node,

  /**
   * The button type.
   */
  type: _propTypes2.default.string,

  /**
   * Boolean if the button should be styled with the primary color.
   */
  primary: _propTypes2.default.bool,

  /**
   * Boolean if the button should be styled with the secondary color.
   */
  secondary: _propTypes2.default.bool,

  /**
   * Boolean if the button is disabled.
   */
  disabled: _propTypes2.default.bool,

  /**
   * An optional href to convert the button into a link button.
   */
  href: _propTypes2.default.string,

  /**
   * An optional function to call when the button is clicked.
   */
  onClick: _propTypes2.default.func,

  deprecated: (0, _componentDeprecated2.default)('The behavior of the `FlatButton` can be achieved with the `Button` component ' + 'without the additional bundle size. Switch to the `Button` component and add a ' + 'prop `flat`.')
};
FlatButton.defaultProps = {
  type: 'button',
  iconBefore: true
};
exports.default = FlatButton;

/***/ }),

/***/ "Vzoa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// As defined in https://github.com/mozilla/pdf.js/blob/master/src/shared/util.js#L378-L381
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
var _default = PasswordResponses;
exports.default = _default;

/***/ }),

/***/ "W0B4":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("NS33")();
}


/***/ }),

/***/ "WE6Q":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = viewport;

var _getScreenSize = __webpack_require__("+l6y");

var _getScreenSize2 = _interopRequireDefault(_getScreenSize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Determines if an element is still in the viewport. If it is,
 * it will return a `true` boolean. If it is not, it will return
 * an object containing booleans for top, right, bottom, and left
 * where a `false` value will mean it is out of the viewport for that
 * position.
 *
 * @param {Object} el - The element to test.
 * @return {boolean|Object} the results.
 */
function viewport(el) {
  if (!el) {
    return {};
  }

  var rect = el.getBoundingClientRect();
  var top = rect.top >= 0;
  var right = rect.right <= (0, _getScreenSize2.default)('Width');
  var bottom = rect.bottom <= (0, _getScreenSize2.default)('Height');
  var left = rect.left >= 0;

  return top && right && bottom && left || { top: top, right: right, bottom: bottom, left: left };
} /** @module utils/Positioning/viewport */

/***/ }),

/***/ "WI9V":
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "Wk0l":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("Qt3m");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "checkIndexBounds", {
  enumerable: true,
  get: function get() {
    return _checkIndexBounds.default;
  }
});
Object.defineProperty(exports, "computeIndex", {
  enumerable: true,
  get: function get() {
    return _computeIndex.default;
  }
});
Object.defineProperty(exports, "constant", {
  enumerable: true,
  get: function get() {
    return _constant.default;
  }
});
Object.defineProperty(exports, "getDisplaySameSlide", {
  enumerable: true,
  get: function get() {
    return _getDisplaySameSlide.default;
  }
});
Object.defineProperty(exports, "mod", {
  enumerable: true,
  get: function get() {
    return _mod.default;
  }
});

var _checkIndexBounds = _interopRequireDefault(__webpack_require__("oIW1"));

var _computeIndex = _interopRequireDefault(__webpack_require__("vQGw"));

var _constant = _interopRequireDefault(__webpack_require__("EK6g"));

var _getDisplaySameSlide = _interopRequireDefault(__webpack_require__("dHTU"));

var _mod = _interopRequireDefault(__webpack_require__("UgH5"));

/***/ }),

/***/ "WyKr":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__("mXGw");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// CONCATENATED MODULE: ../node_modules/rc-progress/es/enhancer.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var enhancer = function enhancer(WrappedComponent) {
  return (
    /*#__PURE__*/
    function (_WrappedComponent) {
      _inherits(Progress, _WrappedComponent);

      function Progress() {
        _classCallCheck(this, Progress);

        return _possibleConstructorReturn(this, _getPrototypeOf(Progress).apply(this, arguments));
      }

      _createClass(Progress, [{
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          var _this = this;

          var now = Date.now();
          var updated = false;
          Object.keys(this.paths).forEach(function (key) {
            var path = _this.paths[key];

            if (!path) {
              return;
            }

            updated = true;
            var pathStyle = path.style;
            pathStyle.transitionDuration = '.3s, .3s, .3s, .06s';

            if (_this.prevTimeStamp && now - _this.prevTimeStamp < 100) {
              pathStyle.transitionDuration = '0s, 0s';
            }
          });

          if (updated) {
            this.prevTimeStamp = Date.now();
          }
        }
      }, {
        key: "render",
        value: function render() {
          return _get(_getPrototypeOf(Progress.prototype), "render", this).call(this);
        }
      }]);

      return Progress;
    }(WrappedComponent)
  );
};

/* harmony default export */ var es_enhancer = (enhancer);
// EXTERNAL MODULE: ../node_modules/prop-types/index.js
var prop_types = __webpack_require__("W0B4");
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// CONCATENATED MODULE: ../node_modules/rc-progress/es/types.js

var defaultProps = {
  className: '',
  percent: 0,
  prefixCls: 'rc-progress',
  strokeColor: '#2db7f5',
  strokeLinecap: 'round',
  strokeWidth: 1,
  style: {},
  trailColor: '#D9D9D9',
  trailWidth: 1
};
var mixedType = prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]);
var propTypes = {
  className: prop_types_default.a.string,
  percent: prop_types_default.a.oneOfType([mixedType, prop_types_default.a.arrayOf(mixedType)]),
  prefixCls: prop_types_default.a.string,
  strokeColor: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.arrayOf(prop_types_default.a.string), prop_types_default.a.object]),
  strokeLinecap: prop_types_default.a.oneOf(['butt', 'round', 'square']),
  strokeWidth: mixedType,
  style: prop_types_default.a.object,
  trailColor: prop_types_default.a.string,
  trailWidth: mixedType
};
// CONCATENATED MODULE: ../node_modules/rc-progress/es/Line.js
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Line_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Line_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Line_createClass(Constructor, protoProps, staticProps) { if (protoProps) Line_defineProperties(Constructor.prototype, protoProps); if (staticProps) Line_defineProperties(Constructor, staticProps); return Constructor; }

function Line_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Line_assertThisInitialized(self); }

function Line_getPrototypeOf(o) { Line_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Line_getPrototypeOf(o); }

function Line_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Line_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Line_setPrototypeOf(subClass, superClass); }

function Line_setPrototypeOf(o, p) { Line_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Line_setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var Line_Line =
/*#__PURE__*/
function (_Component) {
  Line_inherits(Line, _Component);

  function Line() {
    var _getPrototypeOf2;

    var _this;

    Line_classCallCheck(this, Line);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Line_possibleConstructorReturn(this, (_getPrototypeOf2 = Line_getPrototypeOf(Line)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(Line_assertThisInitialized(_this), "paths", {});

    return _this;
  }

  Line_createClass(Line, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          className = _this$props.className,
          percent = _this$props.percent,
          prefixCls = _this$props.prefixCls,
          strokeColor = _this$props.strokeColor,
          strokeLinecap = _this$props.strokeLinecap,
          strokeWidth = _this$props.strokeWidth,
          style = _this$props.style,
          trailColor = _this$props.trailColor,
          trailWidth = _this$props.trailWidth,
          transition = _this$props.transition,
          restProps = _objectWithoutProperties(_this$props, ["className", "percent", "prefixCls", "strokeColor", "strokeLinecap", "strokeWidth", "style", "trailColor", "trailWidth", "transition"]);

      delete restProps.gapPosition;
      var percentList = Array.isArray(percent) ? percent : [percent];
      var strokeColorList = Array.isArray(strokeColor) ? strokeColor : [strokeColor];
      var center = strokeWidth / 2;
      var right = 100 - strokeWidth / 2;
      var pathString = "M ".concat(strokeLinecap === 'round' ? center : 0, ",").concat(center, "\n           L ").concat(strokeLinecap === 'round' ? right : 100, ",").concat(center);
      var viewBoxString = "0 0 100 ".concat(strokeWidth);
      var stackPtg = 0;
      return react_default.a.createElement("svg", _extends({
        className: "".concat(prefixCls, "-line ").concat(className),
        viewBox: viewBoxString,
        preserveAspectRatio: "none",
        style: style
      }, restProps), react_default.a.createElement("path", {
        className: "".concat(prefixCls, "-line-trail"),
        d: pathString,
        strokeLinecap: strokeLinecap,
        stroke: trailColor,
        strokeWidth: trailWidth || strokeWidth,
        fillOpacity: "0"
      }), percentList.map(function (ptg, index) {
        var pathStyle = {
          strokeDasharray: "".concat(ptg, "px, 100px"),
          strokeDashoffset: "-".concat(stackPtg, "px"),
          transition: transition || 'stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear'
        };
        var color = strokeColorList[index] || strokeColorList[strokeColorList.length - 1];
        stackPtg += ptg;
        return react_default.a.createElement("path", {
          key: index,
          className: "".concat(prefixCls, "-line-path"),
          d: pathString,
          strokeLinecap: strokeLinecap,
          stroke: color,
          strokeWidth: strokeWidth,
          fillOpacity: "0",
          ref: function ref(path) {
            _this2.paths[index] = path;
          },
          style: pathStyle
        });
      }));
    }
  }]);

  return Line;
}(react["Component"]);

Line_Line.propTypes = propTypes;
Line_Line.defaultProps = defaultProps;
/* harmony default export */ var es_Line = (es_enhancer(Line_Line));
// CONCATENATED MODULE: ../node_modules/rc-progress/es/Circle.js
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Circle_defineProperty(target, key, source[key]); }); } return target; }

function Circle_extends() { Circle_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Circle_extends.apply(this, arguments); }

function Circle_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Circle_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Circle_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Circle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Circle_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Circle_createClass(Constructor, protoProps, staticProps) { if (protoProps) Circle_defineProperties(Constructor.prototype, protoProps); if (staticProps) Circle_defineProperties(Constructor, staticProps); return Constructor; }

function Circle_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Circle_assertThisInitialized(self); }

function Circle_getPrototypeOf(o) { Circle_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Circle_getPrototypeOf(o); }

function Circle_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Circle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Circle_setPrototypeOf(subClass, superClass); }

function Circle_setPrototypeOf(o, p) { Circle_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Circle_setPrototypeOf(o, p); }

function Circle_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint react/prop-types: 0 */





function getPathStyles(offset, percent, strokeColor, strokeWidth) {
  var gapDegree = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var gapPosition = arguments.length > 5 ? arguments[5] : undefined;
  var radius = 50 - strokeWidth / 2;
  var beginPositionX = 0;
  var beginPositionY = -radius;
  var endPositionX = 0;
  var endPositionY = -2 * radius;

  switch (gapPosition) {
    case 'left':
      beginPositionX = -radius;
      beginPositionY = 0;
      endPositionX = 2 * radius;
      endPositionY = 0;
      break;

    case 'right':
      beginPositionX = radius;
      beginPositionY = 0;
      endPositionX = -2 * radius;
      endPositionY = 0;
      break;

    case 'bottom':
      beginPositionY = radius;
      endPositionY = 2 * radius;
      break;

    default:
  }

  var pathString = "M 50,50 m ".concat(beginPositionX, ",").concat(beginPositionY, "\n   a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(endPositionX, ",").concat(-endPositionY, "\n   a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(-endPositionX, ",").concat(endPositionY);
  var len = Math.PI * 2 * radius;
  var pathStyle = {
    stroke: strokeColor,
    strokeDasharray: "".concat(percent / 100 * (len - gapDegree), "px ").concat(len, "px"),
    strokeDashoffset: "-".concat(gapDegree / 2 + offset / 100 * (len - gapDegree), "px"),
    transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s' // eslint-disable-line

  };
  return {
    pathString: pathString,
    pathStyle: pathStyle
  };
}

var Circle_Circle =
/*#__PURE__*/
function (_Component) {
  Circle_inherits(Circle, _Component);

  function Circle() {
    var _getPrototypeOf2;

    var _this;

    Circle_classCallCheck(this, Circle);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Circle_possibleConstructorReturn(this, (_getPrototypeOf2 = Circle_getPrototypeOf(Circle)).call.apply(_getPrototypeOf2, [this].concat(args)));

    Circle_defineProperty(Circle_assertThisInitialized(_this), "paths", {});

    return _this;
  }

  Circle_createClass(Circle, [{
    key: "getStokeList",
    value: function getStokeList() {
      var _this2 = this;

      var _this$props = this.props,
          prefixCls = _this$props.prefixCls,
          percent = _this$props.percent,
          strokeColor = _this$props.strokeColor,
          strokeWidth = _this$props.strokeWidth,
          strokeLinecap = _this$props.strokeLinecap,
          gapDegree = _this$props.gapDegree,
          gapPosition = _this$props.gapPosition;
      var percentList = Array.isArray(percent) ? percent : [percent];
      var strokeColorList = Array.isArray(strokeColor) ? strokeColor : [strokeColor];
      var stroke = Object.prototype.toString.call(strokeColor) === '[object Object]' ? 'url(#gradient)' : '';
      var stackPtg = 0;
      return percentList.map(function (ptg, index) {
        var color = strokeColorList[index] || strokeColorList[strokeColorList.length - 1];

        var _getPathStyles = getPathStyles(stackPtg, ptg, color, strokeWidth, gapDegree, gapPosition),
            pathString = _getPathStyles.pathString,
            pathStyle = _getPathStyles.pathStyle;

        stackPtg += ptg;
        return react_default.a.createElement("path", {
          key: index,
          className: "".concat(prefixCls, "-circle-path"),
          d: pathString,
          stroke: stroke,
          strokeLinecap: strokeLinecap,
          strokeWidth: ptg === 0 ? 0 : strokeWidth,
          fillOpacity: "0",
          style: pathStyle,
          ref: function ref(path) {
            _this2.paths[index] = path;
          }
        });
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          prefixCls = _this$props2.prefixCls,
          strokeWidth = _this$props2.strokeWidth,
          trailWidth = _this$props2.trailWidth,
          gapDegree = _this$props2.gapDegree,
          gapPosition = _this$props2.gapPosition,
          trailColor = _this$props2.trailColor,
          strokeLinecap = _this$props2.strokeLinecap,
          style = _this$props2.style,
          className = _this$props2.className,
          strokeColor = _this$props2.strokeColor,
          restProps = Circle_objectWithoutProperties(_this$props2, ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "style", "className", "strokeColor"]);

      var _getPathStyles2 = getPathStyles(0, 100, trailColor, strokeWidth, gapDegree, gapPosition),
          pathString = _getPathStyles2.pathString,
          pathStyle = _getPathStyles2.pathStyle;

      delete restProps.percent;
      var isGradient = Object.prototype.toString.call(strokeColor) === '[object Object]';
      return react_default.a.createElement("svg", Circle_extends({
        className: "".concat(prefixCls, "-circle ").concat(className),
        viewBox: "0 0 100 100",
        style: style
      }, restProps), isGradient && react_default.a.createElement("defs", null, react_default.a.createElement("linearGradient", {
        id: "gradient",
        x1: "100%",
        y1: "0%",
        x2: "0%",
        y2: "0%"
      }, Object.keys(strokeColor).map(function (key, index) {
        return react_default.a.createElement("stop", {
          key: index,
          offset: key,
          stopColor: strokeColor[key]
        });
      }))), react_default.a.createElement("path", {
        className: "".concat(prefixCls, "-circle-trail"),
        d: pathString,
        stroke: trailColor,
        strokeLinecap: strokeLinecap,
        strokeWidth: trailWidth || strokeWidth,
        fillOpacity: "0",
        style: pathStyle
      }), this.getStokeList().reverse());
    }
  }]);

  return Circle;
}(react["Component"]);

Circle_Circle.propTypes = _objectSpread({}, propTypes, {
  gapPosition: prop_types_default.a.oneOf(['top', 'bottom', 'left', 'right'])
});
Circle_Circle.defaultProps = _objectSpread({}, defaultProps, {
  gapPosition: 'top'
});
/* harmony default export */ var es_Circle = (es_enhancer(Circle_Circle));
// CONCATENATED MODULE: ../node_modules/rc-progress/es/index.js
/* concated harmony reexport Line */__webpack_require__.d(__webpack_exports__, "Line", function() { return es_Line; });
/* concated harmony reexport Circle */__webpack_require__.d(__webpack_exports__, "Circle", function() { return es_Circle; });



/* harmony default export */ var es = __webpack_exports__["default"] = ({
  Line: es_Line,
  Circle: es_Circle
});

/***/ }),

/***/ "Wz0F":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "XSm6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _resizeObserverPolyfill = __webpack_require__("iXzu");

var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `ResizeObserver` component is a component hook for the
 * [ResizeObserver](http://rawgit.com/WICG/ResizeObserver/master/index.html)
 * using the [resize-observer-polyfill](https://github.com/que-etc/resize-observer-polyfill)
 * for browsers that don't support it yet.
 *
 * This component displays an empty `span` with `aria-hidden` to allow access to the DOM. By
 * default it will attempt to watch changes on its parent component, but it can be configured
 * to watch any element by using the `target` prop.
 */
var ResizeObserver = function (_PureComponent) {
  _inherits(ResizeObserver, _PureComponent);

  function ResizeObserver() {
    var _temp, _this, _ret;

    _classCallCheck(this, ResizeObserver);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._container = null, _this._target = null, _this._observer = null, _this._height = null, _this._width = null, _this._scrollHeight = null, _this._scrollWidth = null, _this._measure = function (entries) {
      if (!_this._observer || !_this._target) {
        return;
      }

      for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var entry = _ref;

        if (!entry) {
          return;
        }

        var _entry$contentRect = entry.contentRect,
            height = _entry$contentRect.height,
            width = _entry$contentRect.width;
        var _entry$target = entry.target,
            scrollHeight = _entry$target.scrollHeight,
            scrollWidth = _entry$target.scrollWidth;

        if (_this._isHeightChange(height, scrollHeight) || _this._isWidthChange(width, scrollWidth)) {
          _this._height = height;
          _this._width = width;
          _this._scrollHeight = scrollHeight;
          _this._scrollWidth = scrollWidth;
          _this.props.onResize({ height: height, width: width, scrollHeight: scrollHeight, scrollWidth: scrollWidth, el: entry.target });
        }
      }
    }, _this._isHeightChange = function (height, scrollHeight) {
      return _this.props.watchHeight && (height !== _this._height || scrollHeight !== _this._scrollHeight);
    }, _this._isWidthChange = function (width, scrollWidth) {
      return _this.props.watchWidth && (width !== _this._width || scrollWidth !== _this._scrollWidth);
    }, _this._handleRef = function (container) {
      if (container) {
        _this._container = container;
        _this._target = _this._getTarget(container, _this.props.target);
        _this._observer = new _resizeObserverPolyfill2.default(_this._measure);

        if (_this._target) {
          _this._observer.observe(_this._target);
        }
      } else {
        if (_this._observer) {
          _this._observer.disconnect();
        }

        _this._container = null;
        _this._target = null;
        _this._observer = null;
        _this._height = null;
        _this._width = null;
        _this._scrollHeight = null;
        _this._scrollWidth = null;
      }

      if (_this.props.elRef) {
        _this.props.elRef(_this._target);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  ResizeObserver.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var target = this.props.target;

    var nextTarget = nextProps.target;
    if (target === nextTarget) {
      return;
    } else if (nextTarget) {
      if (this._target) {
        this._observer.unobserve(this._target);
      }
      this._target = this._getTarget(this._container, nextTarget);
      this._observer.observe(this._target);
    }
  };

  ResizeObserver.prototype._getTarget = function _getTarget(container, target) {
    if (target === null || target && typeof target !== 'string') {
      return target;
    }

    var t = null;
    if (target) {
      t = document.getElementById(target) || document.querySelector(target);
    } else {
      t = container.parentNode;
    }

    if (!t) {
      throw new Error('An HTMLDOMNode is required as the `ResizeObserver`\'s watch target but none were provided/found. ' + ('Please update the target prop to find a valid node since the provided target is invalid. `' + target + '`.'));
    }

    return t;
  };

  ResizeObserver.prototype.render = function render() {
    var Component = this.props.component;

    return _react2.default.createElement(Component, { ref: this._handleRef, 'aria-hidden': true });
  };

  return ResizeObserver;
}(_react.PureComponent);

ResizeObserver.propTypes = {
  /**
   * Boolean if the height should be watched for the resize target.
   */
  watchHeight: _propTypes2.default.bool,

  /**
   * Boolean if the width should be watched for the resize target.
   */
  watchWidth: _propTypes2.default.bool,

  /**
   * An optional target that should be used for detecting resize events. This can either
   * be a HTMLDOMNode or a string to use with `document.getElementById` or `document.querySelector`.
   *
   * If this prop is not provided and not null, it will default to the parent node of this component.
   * If the provided `target={null}`, the observer will not begin until the `target` is `undefined` or
   * it has been correctly passed a target string or object.
   */
  target: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]),

  /**
   * The component to be rendered as. This should normally just be the default `span`, but there are cases
   * where the component should be switched to something else for valid html.
   */
  component: _propTypes2.default.string,

  /**
   * A function to call when the height or width has been changed and that attribute is being watched.
   * The callback will include the current height, width, scrollHeight and scrollWidth of the target.
   *
   * ```js
   * onResize({
   *   height: nextHeight,
   *   width: nextWidth,
   *   scrollHeight: nextScrollHeight,
   *   scrollWidth: nextScrollWidth,
   *   el: resizeTarget,
   * });
   * ```
   */
  onResize: _propTypes2.default.func.isRequired,

  /**
   * An optional ref callback that will include the `target` or the parent node of the resize observer. Just
   * like other refs, this will provide null when it unmounts.
   *
   * This is really only helpful if you'd like the DOM node for a parent Component without needing to use
   * `ReactDOM.findDOMNode(this)`.
   */
  elRef: _propTypes2.default.func
};
ResizeObserver.defaultProps = {
  watchHeight: false,
  watchWidth: false,
  component: 'span'
};
exports.default = ResizeObserver;

/***/ }),

/***/ "Y7gb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("10o/");

exports.__esModule = true;
exports.default = addClass;

var _hasClass = _interopRequireDefault(__webpack_require__("rKUl"));

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!(0, _hasClass.default)(element, className)) if (typeof element.className === 'string') element.className = element.className + ' ' + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + ' ' + className);
}

module.exports = exports["default"];

/***/ }),

/***/ "YliN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFromFile = exports.isCancelException = exports.makePageCallback = exports.cancelRunningTask = exports.makeCancellable = exports.displayCORSWarning = exports.errorOnDev = exports.warnOnDev = exports.getPixelRatio = exports.callIfDefined = exports.dataURItoUint8Array = exports.isDataURI = exports.isFile = exports.isBlob = exports.isArrayBuffer = exports.isString = exports.isProvided = exports.isDefined = exports.isProduction = exports.isLocalFileSystem = exports.isBrowser = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__("lZXN"));

/**
 * Checks if we're running in a browser environment.
 */
var isBrowser = typeof window !== 'undefined';
/**
 * Checks whether we're running from a local file system.
 */

exports.isBrowser = isBrowser;
var isLocalFileSystem = isBrowser && window.location.protocol === 'file:';
/**
 * Checks whether we're running on a production build or not.
 */

exports.isLocalFileSystem = isLocalFileSystem;
var isProduction = "production" === 'production';
/**
 * Checks whether a variable is defined.
 *
 * @param {*} variable Variable to check
 */

exports.isProduction = isProduction;

var isDefined = function isDefined(variable) {
  return typeof variable !== 'undefined';
};
/**
 * Checks whether a variable is defined and not null.
 *
 * @param {*} variable Variable to check
 */


exports.isDefined = isDefined;

var isProvided = function isProvided(variable) {
  return isDefined(variable) && variable !== null;
};
/**
 * Checkes whether a variable provided is a string.
 *
 * @param {*} variable Variable to check
 */


exports.isProvided = isProvided;

var isString = function isString(variable) {
  return typeof variable === 'string';
};
/**
 * Checks whether a variable provided is an ArrayBuffer.
 *
 * @param {*} variable Variable to check
 */


exports.isString = isString;

var isArrayBuffer = function isArrayBuffer(variable) {
  return variable instanceof ArrayBuffer;
};
/**
 * Checkes whether a variable provided is a Blob.
 *
 * @param {*} variable Variable to check
 */


exports.isArrayBuffer = isArrayBuffer;

var isBlob = function isBlob(variable) {
  if (!isBrowser) {
    throw new Error('Attempted to check if a variable is a Blob on a non-browser environment.');
  }

  return variable instanceof Blob;
};
/**
 * Checkes whether a variable provided is a File.
 *
 * @param {*} variable Variable to check
 */


exports.isBlob = isBlob;

var isFile = function isFile(variable) {
  if (!isBrowser) {
    throw new Error('Attempted to check if a variable is a File on a non-browser environment.');
  }

  return variable instanceof File;
};
/**
 * Checks whether a string provided is a data URI.
 *
 * @param {String} str String to check
 */


exports.isFile = isFile;

var isDataURI = function isDataURI(str) {
  return isString(str) && /^data:/.test(str);
};

exports.isDataURI = isDataURI;

var dataURItoUint8Array = function dataURItoUint8Array(dataURI) {
  if (!isDataURI(dataURI)) {
    throw new Error('dataURItoUint8Array was provided with an argument which is not a valid data URI.');
  }

  var byteString;

  if (dataURI.split(',')[0].indexOf('base64') >= 0) {
    byteString = atob(dataURI.split(',')[1]);
  } else {
    byteString = unescape(dataURI.split(',')[1]);
  }

  var ia = new Uint8Array(byteString.length);

  for (var i = 0; i < byteString.length; i += 1) {
    ia[i] = byteString.charCodeAt(i);
  }

  return ia;
};
/**
 * Calls a function, if it's defined, with specified arguments
 * @param {Function} fn
 * @param {Object} args
 */


exports.dataURItoUint8Array = dataURItoUint8Array;

var callIfDefined = function callIfDefined(fn) {
  if (fn && typeof fn === 'function') {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    fn.apply(void 0, args);
  }
};

exports.callIfDefined = callIfDefined;

var getPixelRatio = function getPixelRatio() {
  return isBrowser && window.devicePixelRatio || 1;
};

exports.getPixelRatio = getPixelRatio;

var consoleOnDev = function consoleOnDev(method) {
  if (!isProduction) {
    var _console;

    for (var _len2 = arguments.length, message = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      message[_key2 - 1] = arguments[_key2];
    }

    // eslint-disable-next-line no-console
    (_console = console)[method].apply(_console, message);
  }
};

var warnOnDev = function warnOnDev() {
  for (var _len3 = arguments.length, message = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    message[_key3] = arguments[_key3];
  }

  return consoleOnDev.apply(void 0, ['warn'].concat(message));
};

exports.warnOnDev = warnOnDev;

var errorOnDev = function errorOnDev() {
  for (var _len4 = arguments.length, message = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    message[_key4] = arguments[_key4];
  }

  return consoleOnDev.apply(void 0, ['error'].concat(message));
};

exports.errorOnDev = errorOnDev;

var displayCORSWarning = function displayCORSWarning() {
  if (isLocalFileSystem) {
    warnOnDev('Loading PDF as base64 strings/URLs might not work on protocols other than HTTP/HTTPS. On Google Chrome, you can use --allow-file-access-from-files flag for debugging purposes.');
  }
};

exports.displayCORSWarning = displayCORSWarning;

var PromiseCancelledException =
/*#__PURE__*/
function (_Error) {
  (0, _inherits2.default)(PromiseCancelledException, _Error);

  function PromiseCancelledException(message, type) {
    var _this;

    (0, _classCallCheck2.default)(this, PromiseCancelledException);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PromiseCancelledException).call(this, message, type));
    _this.name = 'PromiseCancelledException';
    _this.message = message;
    _this.type = type;
    return _this;
  }

  return PromiseCancelledException;
}((0, _wrapNativeSuper2.default)(Error));

var makeCancellable = function makeCancellable(promise) {
  var isCancelled = false;
  var wrappedPromise = new Promise(function (resolve, reject) {
    promise.then(function () {
      return isCancelled ? reject(new PromiseCancelledException('Promise cancelled')) : resolve.apply(void 0, arguments);
    }, function (error) {
      return isCancelled ? reject(new PromiseCancelledException('Promise cancelled')) : reject(error);
    });
  });
  return {
    promise: wrappedPromise,
    cancel: function cancel() {
      isCancelled = true;
    }
  };
};

exports.makeCancellable = makeCancellable;

var cancelRunningTask = function cancelRunningTask(runningTask) {
  if (!runningTask || !runningTask.cancel) {
    return;
  }

  runningTask.cancel();
};

exports.cancelRunningTask = cancelRunningTask;

var makePageCallback = function makePageCallback(page, scale) {
  Object.defineProperty(page, 'width', {
    get: function get() {
      return this.view[2] * scale;
    },
    configurable: true
  });
  Object.defineProperty(page, 'height', {
    get: function get() {
      return this.view[3] * scale;
    },
    configurable: true
  });
  Object.defineProperty(page, 'originalWidth', {
    get: function get() {
      return this.view[2];
    },
    configurable: true
  });
  Object.defineProperty(page, 'originalHeight', {
    get: function get() {
      return this.view[3];
    },
    configurable: true
  });
  return page;
};

exports.makePageCallback = makePageCallback;

var isCancelException = function isCancelException(error) {
  return error.name === 'RenderingCancelledException' || error.name === 'PromiseCancelledException';
};

exports.isCancelException = isCancelException;

var loadFromFile = function loadFromFile(file) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      return resolve(new Uint8Array(reader.result));
    };

    reader.onerror = function (event) {
      switch (event.target.error.code) {
        case event.target.error.NOT_FOUND_ERR:
          return reject(new Error('Error while reading a file: File not found.'));

        case event.target.error.NOT_READABLE_ERR:
          return reject(new Error('Error while reading a file: File not readable.'));

        case event.target.error.SECURITY_ERR:
          return reject(new Error('Error while reading a file: Security error.'));

        case event.target.error.ABORT_ERR:
          return reject(new Error('Error while reading a file: Aborted.'));

        default:
          return reject(new Error('Error while reading a file.'));
      }
    };

    reader.readAsArrayBuffer(file);
    return null;
  });
};

exports.loadFromFile = loadFromFile;

/***/ }),

/***/ "YwmR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (false) {}

module.exports = warning;


/***/ }),

/***/ "Z4DA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = captureNextEvent;
/** @module utils/EventUtils/captureNextEvent */

/**
 * This function will capture the next event and stop propagation during the
 * bubbling cycle of events. This is really only useful if you want to stop
 * the default behavior of chained events.
 *
 * @param {String} type - The event type to capture.
 * @param {Object|func=} target - Either the DOM node to target, a callback function
 *      to call once the event has been captured, or undefined. If this is undefined,
 *      the event will be captured on the window.
 * @param {func=} callback - An optional callback function to call once the event
 *      has been captured.
 */
function captureNextEvent(type, target, callback) {
  var el = typeof target !== 'function' && target ? target : window;
  var cb = typeof target === 'function' ? target : callback;

  var capture = function capture(e) {
    e.stopPropagation();
    if (cb) {
      cb(e);
    }

    el.removeEventListener(type, capture, true);
  };

  el.addEventListener(type, capture, true);
}

/***/ }),

/***/ "ZVcq":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _componentDeprecated = __webpack_require__("9/Bt");

var _componentDeprecated2 = _interopRequireDefault(_componentDeprecated);

var _FontIcon = __webpack_require__("vMIC");

var _FontIcon2 = _interopRequireDefault(_FontIcon);

var _injectTooltip = __webpack_require__("TNjE");

var _injectTooltip2 = _interopRequireDefault(_injectTooltip);

var _Button = __webpack_require__("Bff0");

var _Button2 = _interopRequireDefault(_Button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `IconButton` component automatically includes ink and a tooltip.
 * The tooltip will only be included if the `tooltipLabel` prop is given.
 *
 * Any other props (such as style or event listeners) will also be
 * applied.
 */
var IconButton = function (_PureComponent) {
  _inherits(IconButton, _PureComponent);

  function IconButton() {
    _classCallCheck(this, IconButton);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  IconButton.prototype.render = function render() {
    var _props = this.props,
        iconClassName = _props.iconClassName,
        children = _props.children,
        tooltip = _props.tooltip,
        floating = _props.floating,
        props = _objectWithoutProperties(_props, ['iconClassName', 'children', 'tooltip', 'floating']);

    delete props.tooltipLabel;
    delete props.tooltipPosition;

    return _react2.default.createElement(
      _Button2.default,
      _extends({}, props, { icon: !floating, floating: floating }),
      tooltip,
      _react2.default.createElement(
        _FontIcon2.default,
        { iconClassName: iconClassName },
        children
      )
    );
  };

  return IconButton;
}(_react.PureComponent);

IconButton.propTypes = {
  /**
   * The className to use for rendering the `FontIcon`.
   */
  iconClassName: _propTypes2.default.string,

  /**
   * Any children to use to render the `FontIcon`.
   */
  children: _propTypes2.default.node,

  /**
   * An optional className to apply to the button.
   */
  className: _propTypes2.default.string,

  /**
   * The button type.
   */
  type: _propTypes2.default.string,

  /**
   * Boolean if the button is disabled.
   */
  disabled: _propTypes2.default.bool,

  /**
   * An optional href to convert the button into a link button.
   */
  href: _propTypes2.default.string,

  /**
   * An optional function to call when the button is clicked.
   */
  onClick: _propTypes2.default.func,
  /**
   * Boolean if the IconButton is floating
  floating: PropTypes.bool,
   /**
   * An optional label to use if you would like a tooltip to display
   * on hover or touch hold.
   */
  tooltipLabel: _propTypes2.default.node,

  /**
   * The position that the tooltip should be displayed relative to
   * the button.
   */
  tooltipPosition: _propTypes2.default.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * An optional amount of delay before the tooltip appears.
   */
  tooltipDelay: _propTypes2.default.number,

  // Inject from injectTooltip
  tooltip: _propTypes2.default.node,
  floating: _propTypes2.default.bool,

  deprecated: (0, _componentDeprecated2.default)('The behavior of the `IconButton` can be achieved with the `Button` component ' + 'without the additional bundle size. Switch to the `Button` component and add a ' + 'prop `icon`.')
};
IconButton.defaultProps = {
  type: 'button'
};
exports.default = (0, _injectTooltip2.default)(IconButton);

/***/ }),

/***/ "aDJe":
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "awmu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = isFormPartRole;
/** @module utils/isFormPartRole */

/**
 * A simple utility function to determine if an element has a role that should
 * be used as a form part. This is mostly used for changing the behavior of keyboard
 * events.
 *
 * A form part role is one of the following:
 * - checkbox
 * - radio
 * - listbox
 * - input
 *
 * @param {HTMLElement} el - the element to check.
 * @return {boolean} true if the element is considered an element part of a form.
 */
function isFormPartRole(el) {
  if (!el) {
    return false;
  } else if (el.nodeName === 'INPUT') {
    return true;
  }

  var role = el.getAttribute('role');
  return role === 'checkbox' || role === 'radio' || role === 'listbox';
}

/***/ }),

/***/ "bg2r":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.Divider = undefined;

var _Divider2 = __webpack_require__("lUDM");

var _Divider3 = _interopRequireDefault(_Divider2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Divider3.default;
exports.Divider = _Divider3.default;

/***/ }),

/***/ "cp8/":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__("xARA");

var _reactMotion = __webpack_require__("wMFK");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `Collapse` component is used to animate a single child entering
 * or leaving. This uses the `react-motion` library to animate the height,
 * padding-top, and padding-bottom of an element when the `collapsed` prop
 * changes.
 */
var Collapse = function (_PureComponent) {
  _inherits(Collapse, _PureComponent);

  function Collapse(props) {
    _classCallCheck(this, Collapse);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this._setHeight = function (child) {
      if (_this._child && typeof _this._child.ref === 'function') {
        _this._child.ref(child);
      }

      var height = 0;
      var paddingTop = 0;
      var paddingBottom = 0;
      if (child !== null) {
        var node = (0, _reactDom.findDOMNode)(child);
        var cs = window.getComputedStyle(node);
        height = node.offsetHeight;
        paddingTop = parseInt(cs.getPropertyValue('padding-top'), 10);
        paddingBottom = parseInt(cs.getPropertyValue('padding-bottom'), 10);
      }

      height = Math.max(_this.props.minHeight, height);

      _this.setState({ height: height, paddingTop: paddingTop, paddingBottom: paddingBottom });
    };

    if (!props.collapsed) {
      _this.state = { initialOpen: true };
    } else {
      _this.state = {
        height: props.minHeight,
        paddingTop: 0,
        paddingBottom: 0
      };
    }
    return _this;
  }

  Collapse.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.state.initialOpen && nextProps.collapsed) {
      this.setState({ initialOpen: false });
    }
  };

  Collapse.prototype._spring = function _spring(collapsed, initialOpen, value, config) {
    var min = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    var nextValue = !collapsed ? Math.max(min, value) : min;
    if (initialOpen && !collapsed) {
      return nextValue;
    }

    return (0, _reactMotion.spring)(nextValue, config);
  };

  Collapse.prototype.render = function render() {
    var _this2 = this;

    var _state = this.state,
        height = _state.height,
        paddingTop = _state.paddingTop,
        paddingBottom = _state.paddingBottom,
        initialOpen = _state.initialOpen;
    var _props = this.props,
        children = _props.children,
        collapsed = _props.collapsed,
        defaultStyle = _props.defaultStyle,
        motionStyle = _props.style,
        springConfig = _props.springConfig,
        animate = _props.animate,
        minHeight = _props.minHeight;


    if (!animate) {
      return collapsed ? null : children;
    }

    return _react2.default.createElement(
      _reactMotion.Motion,
      {
        style: _extends({}, motionStyle, {
          height: this._spring(collapsed, initialOpen, height, springConfig, minHeight),
          paddingTop: this._spring(collapsed, initialOpen, paddingTop, springConfig),
          paddingBottom: this._spring(collapsed, initialOpen, paddingBottom, springConfig)
        }),
        defaultStyle: _extends({}, defaultStyle, {
          height: height,
          paddingTop: paddingTop,
          paddingBottom: paddingBottom
        })
      },
      function (style) {
        if (collapsed && !style.height) {
          return null;
        }

        var child = _react.Children.only(children);
        _this2._child = child;
        var nextStyle = child.props.style;
        if (collapsed && (!minHeight || style.height !== minHeight) || style.height !== height) {
          nextStyle = _extends({}, child.props.style, style, {
            overflow: 'hidden'
          });
        }
        return (0, _react.cloneElement)(child, {
          ref: !collapsed ? _this2._setHeight : null,
          style: nextStyle
        });
      }
    );
  };

  return Collapse;
}(_react.PureComponent);

Collapse.propTypes = {
  /**
   * An optional style to merge with the `Motion` style.
   */
  style: _propTypes2.default.object,

  /**
   * An optional default style to merge with the `Motion` default style.
   */
  defaultStyle: _propTypes2.default.object,

  /**
   * Boolean if the children are currently collapsed.
   */
  collapsed: _propTypes2.default.bool.isRequired,

  /**
   * A single child to collapse or expand.
   */
  children: _propTypes2.default.element.isRequired,

  /**
   * The spring config to use for the animation.
   */
  springConfig: _propTypes2.default.object.isRequired,

  /**
   * Boolean if the single child entering or leaving should be animated.
   */
  animate: _propTypes2.default.bool,

  /**
   * The min height to apply for the collapse div.
   */
  minHeight: _propTypes2.default.number.isRequired
};
Collapse.defaultProps = {
  animate: true,
  springConfig: {
    precision: 0.5
  },
  minHeight: 0
};
exports.default = Collapse;

/***/ }),

/***/ "dHTU":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var getDisplaySameSlide = function getDisplaySameSlide(props, nextProps) {
  var displaySameSlide = false;

  if (props.children.length && nextProps.children.length) {
    var oldChildren = props.children[props.index];
    var oldKey = oldChildren ? oldChildren.key : 'empty';

    if (oldKey !== null) {
      var newChildren = nextProps.children[nextProps.index];
      var newKey = newChildren ? newChildren.key : 'empty';

      if (oldKey === newKey) {
        displaySameSlide = true;
      }
    }
  }

  return displaySameSlide;
};

var _default = getDisplaySameSlide;
exports.default = _default;

/***/ }),

/***/ "dSJ2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = invalidIf;
/** @module utils/PropTypes/invalidIf */

/**
 * A custom validator that will throw an error if any of the `ifDefinedProps` are also defined.
 *
 * @param {function} validator - The PropTypes validator to use.
 * @param {String...} ifDefinedProps - any othe rprop names to validate against
 * @return {Error} an error or null
 */
function invalidIf(validator) {
  for (var _len = arguments.length, ifDefinedProps = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    ifDefinedProps[_key - 1] = arguments[_key];
  }

  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    for (var _len2 = arguments.length, args = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      args[_key2 - 5] = arguments[_key2];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (err) {
      return err;
    }

    var defined = typeof props[propName] !== 'undefined' && !!props[propName];
    var othersDefined = ifDefinedProps.filter(function (name) {
      return typeof props[name] !== 'undefined' && !!props[name];
    });
    if (defined && othersDefined.length) {
      var names = '`' + othersDefined.join('`, `') + '`';
      if (othersDefined.length === 1) {
        return new Error('You provided both a `' + propFullNameSafe + '` and ' + names + ' prop to the ' + componentNameSafe + ' ' + 'but only one can be given.');
      }

      return new Error('You provided a `' + propFullNameSafe + '` ' + location + ' to the ' + componentNameSafe + ' when ' + ('the following props were defined: ' + names + '. Either remove the `' + propFullNameSafe + '` ') + 'or use the remove all the other props.');
    }

    return null;
  };
}

/***/ }),

/***/ "e+GP":
/***/ (function(module, exports) {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "eEQR":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "ePj6":
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__("FesL");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;

/***/ }),

/***/ "eef+":
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__("WI9V");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "eqrH":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "etjl":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__("vdEC");

var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OutlineItemInternal = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__("RiSW"));

var _slicedToArray2 = _interopRequireDefault(__webpack_require__("nxTg"));

var _regenerator = _interopRequireDefault(__webpack_require__("NthX"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__("fFdx"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _DocumentContext = _interopRequireDefault(__webpack_require__("tvHm"));

var _OutlineContext = _interopRequireDefault(__webpack_require__("kgVC"));

var _Ref = _interopRequireDefault(__webpack_require__("rhKL"));

var _utils = __webpack_require__("YliN");

var _propTypes2 = __webpack_require__("T5tG");

var OutlineItemInternal =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(OutlineItemInternal, _PureComponent);

  function OutlineItemInternal() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, OutlineItemInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(OutlineItemInternal)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getDestination",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      var _this$props, item, pdf;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$props = _this.props, item = _this$props.item, pdf = _this$props.pdf;

              if ((0, _utils.isDefined)(_this.destination)) {
                _context.next = 9;
                break;
              }

              if (!(typeof item.dest === 'string')) {
                _context.next = 8;
                break;
              }

              _context.next = 5;
              return pdf.getDestination(item.dest);

            case 5:
              _this.destination = _context.sent;
              _context.next = 9;
              break;

            case 8:
              _this.destination = item.dest;

            case 9:
              return _context.abrupt("return", _this.destination);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getPageIndex",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee2() {
      var pdf, destination, _destination, ref;

      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              pdf = _this.props.pdf;

              if ((0, _utils.isDefined)(_this.pageIndex)) {
                _context2.next = 10;
                break;
              }

              _context2.next = 4;
              return _this.getDestination();

            case 4:
              destination = _context2.sent;

              if (!destination) {
                _context2.next = 10;
                break;
              }

              _destination = (0, _slicedToArray2.default)(destination, 1), ref = _destination[0];
              _context2.next = 9;
              return pdf.getPageIndex(new _Ref.default(ref));

            case 9:
              _this.pageIndex = _context2.sent;

            case 10:
              return _context2.abrupt("return", _this.pageIndex);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getPageNumber",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee3() {
      return _regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if ((0, _utils.isDefined)(_this.pageNumber)) {
                _context3.next = 5;
                break;
              }

              _context3.next = 3;
              return _this.getPageIndex();

            case 3:
              _context3.t0 = _context3.sent;
              _this.pageNumber = _context3.t0 + 1;

            case 5:
              return _context3.abrupt("return", _this.pageNumber);

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onClick",
    /*#__PURE__*/
    function () {
      var _ref4 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(event) {
        var onClick, pageIndex, pageNumber;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                onClick = _this.props.onClick;
                event.preventDefault();
                _context4.next = 4;
                return _this.getPageIndex();

              case 4:
                pageIndex = _context4.sent;
                _context4.next = 7;
                return _this.getPageNumber();

              case 7:
                pageNumber = _context4.sent;
                (0, _utils.callIfDefined)(onClick, {
                  pageIndex: pageIndex,
                  pageNumber: pageNumber
                });

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function (_x) {
        return _ref4.apply(this, arguments);
      };
    }());
    return _this;
  }

  (0, _createClass2.default)(OutlineItemInternal, [{
    key: "renderSubitems",
    value: function renderSubitems() {
      var _this$props2 = this.props,
          item = _this$props2.item,
          otherProps = (0, _objectWithoutProperties2.default)(_this$props2, ["item"]);

      if (!item.items || !item.items.length) {
        return null;
      }

      var subitems = item.items;
      return _react.default.createElement("ul", null, subitems.map(function (subitem, subitemIndex) {
        return _react.default.createElement(OutlineItemInternal, (0, _extends2.default)({
          key: typeof subitem.destination === 'string' ? subitem.destination : subitemIndex,
          item: subitem
        }, otherProps));
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var item = this.props.item;
      /* eslint-disable jsx-a11y/anchor-is-valid */

      return _react.default.createElement("li", null, _react.default.createElement("a", {
        href: "#",
        onClick: this.onClick
      }, item.title), this.renderSubitems());
    }
  }]);
  return OutlineItemInternal;
}(_react.PureComponent);

exports.OutlineItemInternal = OutlineItemInternal;

var isDestination = _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.arrayOf(_propTypes.default.any)]);

OutlineItemInternal.propTypes = {
  item: _propTypes.default.shape({
    title: _propTypes.default.string,
    destination: isDestination,
    items: _propTypes.default.arrayOf(_propTypes.default.shape({
      title: _propTypes.default.string,
      destination: isDestination
    }))
  }).isRequired,
  onClick: _propTypes.default.func,
  pdf: _propTypes2.isPdf.isRequired
};

var OutlineItem = function OutlineItem(props) {
  return _react.default.createElement(_DocumentContext.default.Consumer, null, function (documentContext) {
    return _react.default.createElement(_OutlineContext.default.Consumer, null, function (outlineContext) {
      return _react.default.createElement(OutlineItemInternal, (0, _extends2.default)({}, documentContext, outlineContext, props));
    });
  });
};

var _default = OutlineItem;
exports.default = _default;

/***/ }),

/***/ "eut8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _CSSTransitionGroupTick = __webpack_require__("+5Nw");

var _CSSTransitionGroupTick2 = _interopRequireDefault(_CSSTransitionGroupTick);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tooltip = function (_PureComponent) {
  _inherits(Tooltip, _PureComponent);

  function Tooltip(props) {
    _classCallCheck(this, Tooltip);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.state = {
      entering: false,
      leaving: false,
      active: false,
      visible: false
    };

    _this._timeout = null;
    return _this;
  }

  Tooltip.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  Tooltip.prototype.componentWillEnter = function componentWillEnter(cb) {
    var _this2 = this;

    this._timeout = setTimeout(function () {
      _this2._timeout = setTimeout(function () {
        _this2._timeout = null;

        cb();
      }, _this2.props.enterTimeout);
      _this2.setState({ active: true });
    }, _CSSTransitionGroupTick2.default);

    this.setState({ entering: true });
  };

  Tooltip.prototype.componentDidEnter = function componentDidEnter() {
    this.setState({ entering: false, active: false, visible: true });
  };

  Tooltip.prototype.componentWillLeave = function componentWillLeave(cb) {
    var _this3 = this;

    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    this._timeout = setTimeout(function () {
      _this3._timeout = setTimeout(function () {
        _this3._timeout = null;

        cb();
      }, _this3.props.leaveTimeout);

      _this3.setState({ active: true, visible: false });
    }, _CSSTransitionGroupTick2.default);

    this.setState({ leaving: true });
  };

  Tooltip.prototype.render = function render() {
    var _cn;

    var _state = this.state,
        active = _state.active,
        entering = _state.entering,
        leaving = _state.leaving,
        visible = _state.visible;
    var _props = this.props,
        style = _props.style,
        className = _props.className,
        children = _props.children,
        position = _props.position;


    var direction = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical';
    return _react2.default.createElement(
      'span',
      {
        style: style,
        className: (0, _classnames2.default)('md-tooltip md-tooltip--' + position + ' md-tooltip--' + direction, (_cn = {
          'md-tooltip--active': active,
          'md-tooltip--enter': entering,
          'md-tooltip--enter-active': entering && active,
          'md-tooltip--leave': leaving,
          'md-tooltip--leave-active': leaving && active
        }, _cn['md-tooltip--' + position + '-active'] = visible || entering && active, _cn), className)
      },
      children
    );
  };

  return Tooltip;
}(_react.PureComponent);

Tooltip.propTypes = {
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  position: _propTypes2.default.oneOf(['top', 'right', 'bottom', 'left']),
  children: _propTypes2.default.node.isRequired,
  enterTimeout: _propTypes2.default.number,
  leaveTimeout: _propTypes2.default.number
};
Tooltip.defaultProps = {
  position: 'bottom',
  enterTimeout: 150,
  leaveTimeout: 150
};
exports.default = Tooltip;

/***/ }),

/***/ "fFdx":
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "fsLg":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// usage assumption: currentStyle values have already been rendered but it says
// nothing of whether currentStyle is stale (see unreadPropStyle)


exports.__esModule = true;
exports['default'] = shouldStopAnimation;

function shouldStopAnimation(currentStyle, style, currentVelocity) {
  for (var key in style) {
    if (!Object.prototype.hasOwnProperty.call(style, key)) {
      continue;
    }

    if (currentVelocity[key] !== 0) {
      return false;
    }

    var styleValue = typeof style[key] === 'number' ? style[key] : style[key].val;
    // stepper will have already taken care of rounding precision errors, so
    // won't have such thing as 0.9999 !=== 1
    if (currentStyle[key] !== styleValue) {
      return false;
    }
  }

  return true;
}

module.exports = exports['default'];

/***/ }),

/***/ "fzjA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Positions = __webpack_require__("w/sC");

var _Positions2 = _interopRequireDefault(_Positions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _propTypes2.default.oneOfType([_propTypes2.default.oneOf([_Positions2.default.TOP_LEFT, _Positions2.default.TOP_RIGHT, _Positions2.default.BOTTOM_LEFT, _Positions2.default.BOTTOM_RIGHT, _Positions2.default.BELOW]), _propTypes2.default.string]);

/***/ }),

/***/ "g93O":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2018 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__w_pdfjs_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__w_pdfjs_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
/******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__w_pdfjs_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__w_pdfjs_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __w_pdfjs_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__w_pdfjs_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __w_pdfjs_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__w_pdfjs_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__w_pdfjs_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var pdfjsVersion = '2.1.266';
var pdfjsBuild = '81f5835c';

var pdfjsSharedUtil = __w_pdfjs_require__(1);

var pdfjsDisplayAPI = __w_pdfjs_require__(146);

var pdfjsDisplayTextLayer = __w_pdfjs_require__(162);

var pdfjsDisplayAnnotationLayer = __w_pdfjs_require__(163);

var pdfjsDisplayDOMUtils = __w_pdfjs_require__(151);

var pdfjsDisplaySVG = __w_pdfjs_require__(164);

var pdfjsDisplayWorkerOptions = __w_pdfjs_require__(156);

var pdfjsDisplayAPICompatibility = __w_pdfjs_require__(153);

{
  var isNodeJS = __w_pdfjs_require__(4);

  if (isNodeJS()) {
    var PDFNodeStream = __w_pdfjs_require__(165).PDFNodeStream;

    pdfjsDisplayAPI.setPDFNetworkStreamFactory(function (params) {
      return new PDFNodeStream(params);
    });
  } else if (typeof Response !== 'undefined' && 'body' in Response.prototype && typeof ReadableStream !== 'undefined') {
    var PDFFetchStream = __w_pdfjs_require__(168).PDFFetchStream;

    pdfjsDisplayAPI.setPDFNetworkStreamFactory(function (params) {
      return new PDFFetchStream(params);
    });
  } else {
    var PDFNetworkStream = __w_pdfjs_require__(169).PDFNetworkStream;

    pdfjsDisplayAPI.setPDFNetworkStreamFactory(function (params) {
      return new PDFNetworkStream(params);
    });
  }
}
exports.build = pdfjsDisplayAPI.build;
exports.version = pdfjsDisplayAPI.version;
exports.getDocument = pdfjsDisplayAPI.getDocument;
exports.LoopbackPort = pdfjsDisplayAPI.LoopbackPort;
exports.PDFDataRangeTransport = pdfjsDisplayAPI.PDFDataRangeTransport;
exports.PDFWorker = pdfjsDisplayAPI.PDFWorker;
exports.renderTextLayer = pdfjsDisplayTextLayer.renderTextLayer;
exports.AnnotationLayer = pdfjsDisplayAnnotationLayer.AnnotationLayer;
exports.createPromiseCapability = pdfjsSharedUtil.createPromiseCapability;
exports.PasswordResponses = pdfjsSharedUtil.PasswordResponses;
exports.InvalidPDFException = pdfjsSharedUtil.InvalidPDFException;
exports.MissingPDFException = pdfjsSharedUtil.MissingPDFException;
exports.SVGGraphics = pdfjsDisplaySVG.SVGGraphics;
exports.NativeImageDecoding = pdfjsSharedUtil.NativeImageDecoding;
exports.CMapCompressionType = pdfjsSharedUtil.CMapCompressionType;
exports.PermissionFlag = pdfjsSharedUtil.PermissionFlag;
exports.UnexpectedResponseException = pdfjsSharedUtil.UnexpectedResponseException;
exports.OPS = pdfjsSharedUtil.OPS;
exports.VerbosityLevel = pdfjsSharedUtil.VerbosityLevel;
exports.UNSUPPORTED_FEATURES = pdfjsSharedUtil.UNSUPPORTED_FEATURES;
exports.createValidAbsoluteUrl = pdfjsSharedUtil.createValidAbsoluteUrl;
exports.createObjectURL = pdfjsSharedUtil.createObjectURL;
exports.removeNullCharacters = pdfjsSharedUtil.removeNullCharacters;
exports.shadow = pdfjsSharedUtil.shadow;
exports.Util = pdfjsSharedUtil.Util;
exports.ReadableStream = pdfjsSharedUtil.ReadableStream;
exports.URL = pdfjsSharedUtil.URL;
exports.RenderingCancelledException = pdfjsDisplayDOMUtils.RenderingCancelledException;
exports.getFilenameFromUrl = pdfjsDisplayDOMUtils.getFilenameFromUrl;
exports.LinkTarget = pdfjsDisplayDOMUtils.LinkTarget;
exports.addLinkAttributes = pdfjsDisplayDOMUtils.addLinkAttributes;
exports.loadScript = pdfjsDisplayDOMUtils.loadScript;
exports.GlobalWorkerOptions = pdfjsDisplayWorkerOptions.GlobalWorkerOptions;
exports.apiCompatibilityParams = pdfjsDisplayAPICompatibility.apiCompatibilityParams;

/***/ }),
/* 1 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toRomanNumerals = toRomanNumerals;
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createPromiseCapability = createPromiseCapability;
exports.deprecated = deprecated;
exports.getInheritableProperty = getInheritableProperty;
exports.getLookupTableFactory = getLookupTableFactory;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isBool = isBool;
exports.isEmptyObj = isEmptyObj;
exports.isNum = isNum;
exports.isString = isString;
exports.isSpace = isSpace;
exports.isSameOrigin = isSameOrigin;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.isLittleEndian = isLittleEndian;
exports.isEvalSupported = isEvalSupported;
exports.log2 = log2;
exports.readInt8 = readInt8;
exports.readUint16 = readUint16;
exports.readUint32 = readUint32;
exports.removeNullCharacters = removeNullCharacters;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF8String = stringToUTF8String;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;
exports.unreachable = unreachable;
Object.defineProperty(exports, "ReadableStream", {
  enumerable: true,
  get: function get() {
    return _streams_polyfill.ReadableStream;
  }
});
Object.defineProperty(exports, "URL", {
  enumerable: true,
  get: function get() {
    return _url_polyfill.URL;
  }
});
exports.createObjectURL = exports.FormatError = exports.XRefParseException = exports.XRefEntryException = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.NativeImageDecoding = exports.MissingPDFException = exports.MissingDataException = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VerbosityLevel = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = void 0;

__w_pdfjs_require__(2);

var _streams_polyfill = __w_pdfjs_require__(142);

var _url_polyfill = __w_pdfjs_require__(144);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
var NativeImageDecoding = {
  NONE: 'none',
  DECODE: 'decode',
  DISPLAY: 'display'
};
exports.NativeImageDecoding = NativeImageDecoding;
var PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
exports.PermissionFlag = PermissionFlag;
var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
exports.TextRenderingMode = TextRenderingMode;
var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
var AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
exports.AnnotationType = AnnotationType;
var AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
exports.AnnotationFlag = AnnotationFlag;
var AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
exports.AnnotationFieldFlag = AnnotationFieldFlag;
var AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
var StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  JBIG: 5,
  A85: 6,
  AHX: 7,
  CCF: 8,
  RL: 9
};
exports.StreamType = StreamType;
var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};
exports.FontType = FontType;
var VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
var CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
exports.CMapCompressionType = CMapCompressionType;
var OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
exports.OPS = OPS;
var UNSUPPORTED_FEATURES = {
  unknown: 'unknown',
  forms: 'forms',
  javaScript: 'javaScript',
  smask: 'smask',
  shadingPattern: 'shadingPattern',
  font: 'font'
};
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
var verbosity = VerbosityLevel.WARNINGS;

function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}

function getVerbosityLevel() {
  return verbosity;
}

function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log('Info: ' + msg);
  }
}

function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log('Warning: ' + msg);
  }
}

function deprecated(details) {
  console.log('Deprecated API usage: ' + details);
}

function unreachable(msg) {
  throw new Error(msg);
}

function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}

function isSameOrigin(baseUrl, otherUrl) {
  try {
    var base = new _url_polyfill.URL(baseUrl);

    if (!base.origin || base.origin === 'null') {
      return false;
    }
  } catch (e) {
    return false;
  }

  var other = new _url_polyfill.URL(otherUrl, base);
  return base.origin === other.origin;
}

function _isValidProtocol(url) {
  if (!url) {
    return false;
  }

  switch (url.protocol) {
    case 'http:':
    case 'https:':
    case 'ftp:':
    case 'mailto:':
    case 'tel:':
      return true;

    default:
      return false;
  }
}

function createValidAbsoluteUrl(url, baseUrl) {
  if (!url) {
    return null;
  }

  try {
    var absoluteUrl = baseUrl ? new _url_polyfill.URL(url, baseUrl) : new _url_polyfill.URL(url);

    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}

  return null;
}

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value: value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}

function getLookupTableFactory(initializer) {
  var lookup;
  return function () {
    if (initializer) {
      lookup = Object.create(null);
      initializer(lookup);
      initializer = null;
    }

    return lookup;
  };
}

var PasswordException = function PasswordExceptionClosure() {
  function PasswordException(msg, code) {
    this.name = 'PasswordException';
    this.message = msg;
    this.code = code;
  }

  PasswordException.prototype = new Error();
  PasswordException.constructor = PasswordException;
  return PasswordException;
}();

exports.PasswordException = PasswordException;

var UnknownErrorException = function UnknownErrorExceptionClosure() {
  function UnknownErrorException(msg, details) {
    this.name = 'UnknownErrorException';
    this.message = msg;
    this.details = details;
  }

  UnknownErrorException.prototype = new Error();
  UnknownErrorException.constructor = UnknownErrorException;
  return UnknownErrorException;
}();

exports.UnknownErrorException = UnknownErrorException;

var InvalidPDFException = function InvalidPDFExceptionClosure() {
  function InvalidPDFException(msg) {
    this.name = 'InvalidPDFException';
    this.message = msg;
  }

  InvalidPDFException.prototype = new Error();
  InvalidPDFException.constructor = InvalidPDFException;
  return InvalidPDFException;
}();

exports.InvalidPDFException = InvalidPDFException;

var MissingPDFException = function MissingPDFExceptionClosure() {
  function MissingPDFException(msg) {
    this.name = 'MissingPDFException';
    this.message = msg;
  }

  MissingPDFException.prototype = new Error();
  MissingPDFException.constructor = MissingPDFException;
  return MissingPDFException;
}();

exports.MissingPDFException = MissingPDFException;

var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
  function UnexpectedResponseException(msg, status) {
    this.name = 'UnexpectedResponseException';
    this.message = msg;
    this.status = status;
  }

  UnexpectedResponseException.prototype = new Error();
  UnexpectedResponseException.constructor = UnexpectedResponseException;
  return UnexpectedResponseException;
}();

exports.UnexpectedResponseException = UnexpectedResponseException;

var MissingDataException = function MissingDataExceptionClosure() {
  function MissingDataException(begin, end) {
    this.begin = begin;
    this.end = end;
    this.message = 'Missing data [' + begin + ', ' + end + ')';
  }

  MissingDataException.prototype = new Error();
  MissingDataException.prototype.name = 'MissingDataException';
  MissingDataException.constructor = MissingDataException;
  return MissingDataException;
}();

exports.MissingDataException = MissingDataException;

var XRefEntryException = function XRefEntryExceptionClosure() {
  function XRefEntryException(msg) {
    this.message = msg;
  }

  XRefEntryException.prototype = new Error();
  XRefEntryException.prototype.name = 'XRefEntryException';
  XRefEntryException.constructor = XRefEntryException;
  return XRefEntryException;
}();

exports.XRefEntryException = XRefEntryException;

var XRefParseException = function XRefParseExceptionClosure() {
  function XRefParseException(msg) {
    this.message = msg;
  }

  XRefParseException.prototype = new Error();
  XRefParseException.prototype.name = 'XRefParseException';
  XRefParseException.constructor = XRefParseException;
  return XRefParseException;
}();

exports.XRefParseException = XRefParseException;

var FormatError = function FormatErrorClosure() {
  function FormatError(msg) {
    this.message = msg;
  }

  FormatError.prototype = new Error();
  FormatError.prototype.name = 'FormatError';
  FormatError.constructor = FormatError;
  return FormatError;
}();

exports.FormatError = FormatError;

var AbortException = function AbortExceptionClosure() {
  function AbortException(msg) {
    this.name = 'AbortException';
    this.message = msg;
  }

  AbortException.prototype = new Error();
  AbortException.constructor = AbortException;
  return AbortException;
}();

exports.AbortException = AbortException;
var NullCharactersRegExp = /\x00/g;

function removeNullCharacters(str) {
  if (typeof str !== 'string') {
    warn('The argument for removeNullCharacters must be a string.');
    return str;
  }

  return str.replace(NullCharactersRegExp, '');
}

function bytesToString(bytes) {
  assert(bytes !== null && _typeof(bytes) === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;

  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }

  var strBuf = [];

  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }

  return strBuf.join('');
}

function stringToBytes(str) {
  assert(typeof str === 'string', 'Invalid argument for stringToBytes');
  var length = str.length;
  var bytes = new Uint8Array(length);

  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }

  return bytes;
}

function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }

  assert(arr.byteLength !== undefined);
  return arr.byteLength;
}

function arraysToBytes(arr) {
  if (arr.length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }

  var resultLength = 0;
  var i,
      ii = arr.length;
  var item, itemLength;

  for (i = 0; i < ii; i++) {
    item = arr[i];
    itemLength = arrayByteLength(item);
    resultLength += itemLength;
  }

  var pos = 0;
  var data = new Uint8Array(resultLength);

  for (i = 0; i < ii; i++) {
    item = arr[i];

    if (!(item instanceof Uint8Array)) {
      if (typeof item === 'string') {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }

    itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }

  return data;
}

function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}

function log2(x) {
  if (x <= 0) {
    return 0;
  }

  return Math.ceil(Math.log2(x));
}

function readInt8(data, start) {
  return data[start] << 24 >> 24;
}

function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}

function readUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}

function isLittleEndian() {
  var buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  var view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}

function isEvalSupported() {
  try {
    new Function('');
    return true;
  } catch (e) {
    return false;
  }
}

function getInheritableProperty(_ref) {
  var dict = _ref.dict,
      key = _ref.key,
      _ref$getArray = _ref.getArray,
      getArray = _ref$getArray === void 0 ? false : _ref$getArray,
      _ref$stopWhenFound = _ref.stopWhenFound,
      stopWhenFound = _ref$stopWhenFound === void 0 ? true : _ref$stopWhenFound;
  var LOOP_LIMIT = 100;
  var loopCount = 0;
  var values;

  while (dict) {
    var value = getArray ? dict.getArray(key) : dict.get(key);

    if (value !== undefined) {
      if (stopWhenFound) {
        return value;
      }

      if (!values) {
        values = [];
      }

      values.push(value);
    }

    if (++loopCount > LOOP_LIMIT) {
      warn("getInheritableProperty: maximum loop count exceeded for \"".concat(key, "\""));
      break;
    }

    dict = dict.get('Parent');
  }

  return values;
}

var Util = function UtilClosure() {
  function Util() {}

  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];

  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
    rgbBuf[1] = r;
    rgbBuf[3] = g;
    rgbBuf[5] = b;
    return rgbBuf.join('');
  };

  Util.transform = function Util_transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  };

  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };

  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };

  Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  };

  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };

  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  };

  Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
    var transpose = [m[0], m[2], m[1], m[3]];
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };

  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0);

    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }

    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }

    return r;
  };

  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
        result = [];
    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }

    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }

    return result;
  };

  return Util;
}();

exports.Util = Util;
var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];

function toRomanNumerals(number) {
  var lowerCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  assert(Number.isInteger(number) && number > 0, 'The number should be a positive integer.');
  var pos,
      romanBuf = [];

  while (number >= 1000) {
    number -= 1000;
    romanBuf.push('M');
  }

  pos = number / 100 | 0;
  number %= 100;
  romanBuf.push(ROMAN_NUMBER_MAP[pos]);
  pos = number / 10 | 0;
  number %= 10;
  romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
  romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
  var romanStr = romanBuf.join('');
  return lowerCase ? romanStr.toLowerCase() : romanStr;
}

var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];

function stringToPDFString(str) {
  var i,
      n = str.length,
      strBuf = [];

  if (str[0] === '\xFE' && str[1] === '\xFF') {
    for (i = 2; i < n; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
    }
  } else {
    for (i = 0; i < n; ++i) {
      var code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }

  return strBuf.join('');
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}

function isEmptyObj(obj) {
  for (var key in obj) {
    return false;
  }

  return true;
}

function isBool(v) {
  return typeof v === 'boolean';
}

function isNum(v) {
  return typeof v === 'number';
}

function isString(v) {
  return typeof v === 'string';
}

function isArrayBuffer(v) {
  return _typeof(v) === 'object' && v !== null && v.byteLength !== undefined;
}

function isSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0D || ch === 0x0A;
}

function createPromiseCapability() {
  var capability = Object.create(null);
  var isSettled = false;
  Object.defineProperty(capability, 'settled', {
    get: function get() {
      return isSettled;
    }
  });
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = function (data) {
      isSettled = true;
      resolve(data);
    };

    capability.reject = function (reason) {
      isSettled = true;
      reject(reason);
    };
  });
  return capability;
}

var createObjectURL = function createObjectURLClosure() {
  var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  return function createObjectURL(data, contentType) {
    var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!forceDataSchema && _url_polyfill.URL.createObjectURL) {
      var blob = new Blob([data], {
        type: contentType
      });
      return _url_polyfill.URL.createObjectURL(blob);
    }

    var buffer = 'data:' + contentType + ';base64,';

    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xFF;
      var b2 = data[i + 1] & 0xFF;
      var b3 = data[i + 2] & 0xFF;
      var d1 = b1 >> 2,
          d2 = (b1 & 3) << 4 | b2 >> 4;
      var d3 = i + 1 < ii ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
      var d4 = i + 2 < ii ? b3 & 0x3F : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }

    return buffer;
  };
}();

exports.createObjectURL = createObjectURL;

/***/ }),
/* 2 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var globalScope = __w_pdfjs_require__(3);

if (!globalScope._pdfjsCompatibilityChecked) {
  globalScope._pdfjsCompatibilityChecked = true;

  var isNodeJS = __w_pdfjs_require__(4);

  var hasDOM = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object';

  (function checkNodeBtoa() {
    if (globalScope.btoa || !isNodeJS()) {
      return;
    }

    globalScope.btoa = function (chars) {
      return Buffer.from(chars, 'binary').toString('base64');
    };
  })();

  (function checkNodeAtob() {
    if (globalScope.atob || !isNodeJS()) {
      return;
    }

    globalScope.atob = function (input) {
      return Buffer.from(input, 'base64').toString('binary');
    };
  })();

  (function checkChildNodeRemove() {
    if (!hasDOM) {
      return;
    }

    if (typeof Element.prototype.remove !== 'undefined') {
      return;
    }

    Element.prototype.remove = function () {
      if (this.parentNode) {
        this.parentNode.removeChild(this);
      }
    };
  })();

  (function checkDOMTokenListAddRemove() {
    if (!hasDOM || isNodeJS()) {
      return;
    }

    var div = document.createElement('div');
    div.classList.add('testOne', 'testTwo');

    if (div.classList.contains('testOne') === true && div.classList.contains('testTwo') === true) {
      return;
    }

    var OriginalDOMTokenListAdd = DOMTokenList.prototype.add;
    var OriginalDOMTokenListRemove = DOMTokenList.prototype.remove;

    DOMTokenList.prototype.add = function () {
      for (var _len = arguments.length, tokens = new Array(_len), _key = 0; _key < _len; _key++) {
        tokens[_key] = arguments[_key];
      }

      for (var _i = 0; _i < tokens.length; _i++) {
        var token = tokens[_i];
        OriginalDOMTokenListAdd.call(this, token);
      }
    };

    DOMTokenList.prototype.remove = function () {
      for (var _len2 = arguments.length, tokens = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        tokens[_key2] = arguments[_key2];
      }

      for (var _i2 = 0; _i2 < tokens.length; _i2++) {
        var token = tokens[_i2];
        OriginalDOMTokenListRemove.call(this, token);
      }
    };
  })();

  (function checkDOMTokenListToggle() {
    if (!hasDOM || isNodeJS()) {
      return;
    }

    var div = document.createElement('div');

    if (div.classList.toggle('test', 0) === false) {
      return;
    }

    DOMTokenList.prototype.toggle = function (token) {
      var force = arguments.length > 1 ? !!arguments[1] : !this.contains(token);
      return this[force ? 'add' : 'remove'](token), force;
    };
  })();

  (function checkStringStartsWith() {
    if (String.prototype.startsWith) {
      return;
    }

    __w_pdfjs_require__(5);
  })();

  (function checkStringEndsWith() {
    if (String.prototype.endsWith) {
      return;
    }

    __w_pdfjs_require__(35);
  })();

  (function checkStringIncludes() {
    if (String.prototype.includes) {
      return;
    }

    __w_pdfjs_require__(37);
  })();

  (function checkArrayIncludes() {
    if (Array.prototype.includes) {
      return;
    }

    __w_pdfjs_require__(39);
  })();

  (function checkArrayFrom() {
    if (Array.from) {
      return;
    }

    __w_pdfjs_require__(46);
  })();

  (function checkObjectAssign() {
    if (Object.assign) {
      return;
    }

    __w_pdfjs_require__(69);
  })();

  (function checkMathLog2() {
    if (Math.log2) {
      return;
    }

    Math.log2 = __w_pdfjs_require__(74);
  })();

  (function checkNumberIsNaN() {
    if (Number.isNaN) {
      return;
    }

    Number.isNaN = __w_pdfjs_require__(76);
  })();

  (function checkNumberIsInteger() {
    if (Number.isInteger) {
      return;
    }

    Number.isInteger = __w_pdfjs_require__(78);
  })();

  (function checkPromise() {
    if (globalScope.Promise && globalScope.Promise.prototype && globalScope.Promise.prototype.finally) {
      return;
    }

    globalScope.Promise = __w_pdfjs_require__(81);
  })();

  (function checkWeakMap() {
    if (globalScope.WeakMap) {
      return;
    }

    globalScope.WeakMap = __w_pdfjs_require__(101);
  })();

  (function checkWeakSet() {
    if (globalScope.WeakSet) {
      return;
    }

    globalScope.WeakSet = __w_pdfjs_require__(118);
  })();

  (function checkStringCodePointAt() {
    if (String.codePointAt) {
      return;
    }

    String.codePointAt = __w_pdfjs_require__(122);
  })();

  (function checkStringFromCodePoint() {
    if (String.fromCodePoint) {
      return;
    }

    String.fromCodePoint = __w_pdfjs_require__(124);
  })();

  (function checkSymbol() {
    if (globalScope.Symbol) {
      return;
    }

    __w_pdfjs_require__(126);
  })();

  (function checkStringPadStart() {
    if (String.prototype.padStart) {
      return;
    }

    __w_pdfjs_require__(133);
  })();

  (function checkStringPadEnd() {
    if (String.prototype.padEnd) {
      return;
    }

    __w_pdfjs_require__(137);
  })();

  (function checkObjectValues() {
    if (Object.values) {
      return;
    }

    Object.values = __w_pdfjs_require__(139);
  })();
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = typeof window !== 'undefined' && window.Math === Math ? window : typeof global !== 'undefined' && global.Math === Math ? global : typeof self !== 'undefined' && self.Math === Math ? self : {};

/***/ }),
/* 4 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function isNodeJS() {
  return (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process + '' === '[object process]' && !process.versions['nw'];
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(6);

module.exports = __w_pdfjs_require__(9).String.startsWith;

/***/ }),
/* 6 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var toLength = __w_pdfjs_require__(25);

var context = __w_pdfjs_require__(27);

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __w_pdfjs_require__(34)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),
/* 7 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = __w_pdfjs_require__(8);

var core = __w_pdfjs_require__(9);

var hide = __w_pdfjs_require__(10);

var redefine = __w_pdfjs_require__(20);

var ctx = __w_pdfjs_require__(23);

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    own = !IS_FORCED && target && target[key] !== undefined;
    out = (own ? target : source)[key];
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if (target) redefine(target, key, out, type & $export.U);
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core;
$export.F = 1;
$export.G = 2;
$export.S = 4;
$export.P = 8;
$export.B = 16;
$export.W = 32;
$export.U = 64;
$export.R = 128;
module.exports = $export;

/***/ }),
/* 8 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if (typeof __g == 'number') __g = global;

/***/ }),
/* 9 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var core = module.exports = {
  version: '2.6.2'
};
if (typeof __e == 'number') __e = core;

/***/ }),
/* 10 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var dP = __w_pdfjs_require__(11);

var createDesc = __w_pdfjs_require__(19);

module.exports = __w_pdfjs_require__(15) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var anObject = __w_pdfjs_require__(12);

var IE8_DOM_DEFINE = __w_pdfjs_require__(14);

var toPrimitive = __w_pdfjs_require__(18);

var dP = Object.defineProperty;
exports.f = __w_pdfjs_require__(15) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(13);

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (it) {
  return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = !__w_pdfjs_require__(15) && !__w_pdfjs_require__(16)(function () {
  return Object.defineProperty(__w_pdfjs_require__(17)('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),
/* 15 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = !__w_pdfjs_require__(16)(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),
/* 16 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(13);

var document = __w_pdfjs_require__(8).document;

var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(13);

module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = __w_pdfjs_require__(8);

var hide = __w_pdfjs_require__(10);

var has = __w_pdfjs_require__(21);

var SRC = __w_pdfjs_require__(22)('src');

var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__w_pdfjs_require__(9).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 21 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var aFunction = __w_pdfjs_require__(24);

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function () {
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toInteger = __w_pdfjs_require__(26);

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isRegExp = __w_pdfjs_require__(28);

var defined = __w_pdfjs_require__(33);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(13);

var cof = __w_pdfjs_require__(29);

var MATCH = __w_pdfjs_require__(30)('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var store = __w_pdfjs_require__(31)('wks');

var uid = __w_pdfjs_require__(22);

var _Symbol = __w_pdfjs_require__(8).Symbol;

var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 31 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var core = __w_pdfjs_require__(9);

var global = __w_pdfjs_require__(8);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __w_pdfjs_require__(32) ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = false;

/***/ }),
/* 33 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var MATCH = __w_pdfjs_require__(30)('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {}
  }

  return true;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(36);

module.exports = __w_pdfjs_require__(9).String.endsWith;

/***/ }),
/* 36 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var toLength = __w_pdfjs_require__(25);

var context = __w_pdfjs_require__(27);

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __w_pdfjs_require__(34)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),
/* 37 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(38);

module.exports = __w_pdfjs_require__(9).String.includes;

/***/ }),
/* 38 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var context = __w_pdfjs_require__(27);

var INCLUDES = 'includes';
$export($export.P + $export.F * __w_pdfjs_require__(34)(INCLUDES), 'String', {
  includes: function includes(searchString) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),
/* 39 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(40);

module.exports = __w_pdfjs_require__(9).Array.includes;

/***/ }),
/* 40 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var $includes = __w_pdfjs_require__(41)(true);

$export($export.P, 'Array', {
  includes: function includes(el) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__w_pdfjs_require__(45)('includes');

/***/ }),
/* 41 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toIObject = __w_pdfjs_require__(42);

var toLength = __w_pdfjs_require__(25);

var toAbsoluteIndex = __w_pdfjs_require__(44);

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      if (value != value) return true;
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var IObject = __w_pdfjs_require__(43);

var defined = __w_pdfjs_require__(33);

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var cof = __w_pdfjs_require__(29);

module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toInteger = __w_pdfjs_require__(26);

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var UNSCOPABLES = __w_pdfjs_require__(30)('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __w_pdfjs_require__(10)(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(47);

__w_pdfjs_require__(62);

module.exports = __w_pdfjs_require__(9).Array.from;

/***/ }),
/* 47 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $at = __w_pdfjs_require__(48)(true);

__w_pdfjs_require__(49)(String, 'String', function (iterated) {
  this._t = String(iterated);
  this._i = 0;
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),
/* 48 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toInteger = __w_pdfjs_require__(26);

var defined = __w_pdfjs_require__(33);

module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var LIBRARY = __w_pdfjs_require__(32);

var $export = __w_pdfjs_require__(7);

var redefine = __w_pdfjs_require__(20);

var hide = __w_pdfjs_require__(10);

var Iterators = __w_pdfjs_require__(50);

var $iterCreate = __w_pdfjs_require__(51);

var setToStringTag = __w_pdfjs_require__(59);

var getPrototypeOf = __w_pdfjs_require__(60);

var ITERATOR = __w_pdfjs_require__(30)('iterator');

var BUGGY = !([].keys && 'next' in [].keys());
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }

  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  }

  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }

  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = {};

/***/ }),
/* 51 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var create = __w_pdfjs_require__(52);

var descriptor = __w_pdfjs_require__(19);

var setToStringTag = __w_pdfjs_require__(59);

var IteratorPrototype = {};

__w_pdfjs_require__(10)(IteratorPrototype, __w_pdfjs_require__(30)('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var anObject = __w_pdfjs_require__(12);

var dPs = __w_pdfjs_require__(53);

var enumBugKeys = __w_pdfjs_require__(57);

var IE_PROTO = __w_pdfjs_require__(56)('IE_PROTO');

var Empty = function Empty() {};

var PROTOTYPE = 'prototype';

var _createDict = function createDict() {
  var iframe = __w_pdfjs_require__(17)('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __w_pdfjs_require__(58).appendChild(iframe);

  iframe.src = 'javascript:';
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;

  while (i--) {
    delete _createDict[PROTOTYPE][enumBugKeys[i]];
  }

  return _createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    result[IE_PROTO] = O;
  } else result = _createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var dP = __w_pdfjs_require__(11);

var anObject = __w_pdfjs_require__(12);

var getKeys = __w_pdfjs_require__(54);

module.exports = __w_pdfjs_require__(15) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) {
    dP.f(O, P = keys[i++], Properties[P]);
  }

  return O;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $keys = __w_pdfjs_require__(55);

var enumBugKeys = __w_pdfjs_require__(57);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var has = __w_pdfjs_require__(21);

var toIObject = __w_pdfjs_require__(42);

var arrayIndexOf = __w_pdfjs_require__(41)(false);

var IE_PROTO = __w_pdfjs_require__(56)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    if (key != IE_PROTO) has(O, key) && result.push(key);
  }

  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }

  return result;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var shared = __w_pdfjs_require__(31)('keys');

var uid = __w_pdfjs_require__(22);

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),
/* 58 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var document = __w_pdfjs_require__(8).document;

module.exports = document && document.documentElement;

/***/ }),
/* 59 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var def = __w_pdfjs_require__(11).f;

var has = __w_pdfjs_require__(21);

var TAG = __w_pdfjs_require__(30)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var has = __w_pdfjs_require__(21);

var toObject = __w_pdfjs_require__(61);

var IE_PROTO = __w_pdfjs_require__(56)('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var defined = __w_pdfjs_require__(33);

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ctx = __w_pdfjs_require__(23);

var $export = __w_pdfjs_require__(7);

var toObject = __w_pdfjs_require__(61);

var call = __w_pdfjs_require__(63);

var isArrayIter = __w_pdfjs_require__(64);

var toLength = __w_pdfjs_require__(25);

var createProperty = __w_pdfjs_require__(65);

var getIterFn = __w_pdfjs_require__(66);

$export($export.S + $export.F * !__w_pdfjs_require__(68)(function (iter) {
  Array.from(iter);
}), 'Array', {
  from: function from(arrayLike) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),
/* 63 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var anObject = __w_pdfjs_require__(12);

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var Iterators = __w_pdfjs_require__(50);

var ITERATOR = __w_pdfjs_require__(30)('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $defineProperty = __w_pdfjs_require__(11);

var createDesc = __w_pdfjs_require__(19);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var classof = __w_pdfjs_require__(67);

var ITERATOR = __w_pdfjs_require__(30)('iterator');

var Iterators = __w_pdfjs_require__(50);

module.exports = __w_pdfjs_require__(9).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var cof = __w_pdfjs_require__(29);

var TAG = __w_pdfjs_require__(30)('toStringTag');

var ARG = cof(function () {
  return arguments;
}()) == 'Arguments';

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {}
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ITERATOR = __w_pdfjs_require__(30)('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  };

  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {}

  return safe;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(70);

module.exports = __w_pdfjs_require__(9).Object.assign;

/***/ }),
/* 70 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

$export($export.S + $export.F, 'Object', {
  assign: __w_pdfjs_require__(71)
});

/***/ }),
/* 71 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var getKeys = __w_pdfjs_require__(54);

var gOPS = __w_pdfjs_require__(72);

var pIE = __w_pdfjs_require__(73);

var toObject = __w_pdfjs_require__(61);

var IObject = __w_pdfjs_require__(43);

var $assign = Object.assign;
module.exports = !$assign || __w_pdfjs_require__(16)(function () {
  var A = {};
  var B = {};
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }

  return T;
} : $assign;

/***/ }),
/* 72 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 73 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 74 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(75);

module.exports = __w_pdfjs_require__(9).Math.log2;

/***/ }),
/* 75 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),
/* 76 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(77);

module.exports = __w_pdfjs_require__(9).Number.isNaN;

/***/ }),
/* 77 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    return number != number;
  }
});

/***/ }),
/* 78 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(79);

module.exports = __w_pdfjs_require__(9).Number.isInteger;

/***/ }),
/* 79 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

$export($export.S, 'Number', {
  isInteger: __w_pdfjs_require__(80)
});

/***/ }),
/* 80 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(13);

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(82);

__w_pdfjs_require__(47);

__w_pdfjs_require__(83);

__w_pdfjs_require__(86);

__w_pdfjs_require__(99);

__w_pdfjs_require__(100);

module.exports = __w_pdfjs_require__(9).Promise;

/***/ }),
/* 82 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var classof = __w_pdfjs_require__(67);

var test = {};
test[__w_pdfjs_require__(30)('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __w_pdfjs_require__(20)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),
/* 83 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $iterators = __w_pdfjs_require__(84);

var getKeys = __w_pdfjs_require__(54);

var redefine = __w_pdfjs_require__(20);

var global = __w_pdfjs_require__(8);

var hide = __w_pdfjs_require__(10);

var Iterators = __w_pdfjs_require__(50);

var wks = __w_pdfjs_require__(30);

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) {
      if (!proto[key]) redefine(proto, key, $iterators[key], true);
    }
  }
}

/***/ }),
/* 84 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var addToUnscopables = __w_pdfjs_require__(45);

var step = __w_pdfjs_require__(85);

var Iterators = __w_pdfjs_require__(50);

var toIObject = __w_pdfjs_require__(42);

module.exports = __w_pdfjs_require__(49)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated);
  this._i = 0;
  this._k = kind;
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');
Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 85 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var LIBRARY = __w_pdfjs_require__(32);

var global = __w_pdfjs_require__(8);

var ctx = __w_pdfjs_require__(23);

var classof = __w_pdfjs_require__(67);

var $export = __w_pdfjs_require__(7);

var isObject = __w_pdfjs_require__(13);

var aFunction = __w_pdfjs_require__(24);

var anInstance = __w_pdfjs_require__(87);

var forOf = __w_pdfjs_require__(88);

var speciesConstructor = __w_pdfjs_require__(89);

var task = __w_pdfjs_require__(90).set;

var microtask = __w_pdfjs_require__(92)();

var newPromiseCapabilityModule = __w_pdfjs_require__(93);

var perform = __w_pdfjs_require__(94);

var userAgent = __w_pdfjs_require__(95);

var promiseResolve = __w_pdfjs_require__(96);

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function empty() {};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__w_pdfjs_require__(30)('species')] = function (exec) {
      exec(empty, empty);
    };

    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {}
}();

var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function run(reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value);

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) {
      run(chain[i++]);
    }

    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function onUnhandled(promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function isUnhandled(promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise;
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise;

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        };

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e);
  }
};

if (!USE_NATIVE) {
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };

  Internal = function Promise(executor) {
    this._c = [];
    this._a = undefined;
    this._s = 0;
    this._d = false;
    this._v = undefined;
    this._h = 0;
    this._n = false;
  };

  Internal.prototype = __w_pdfjs_require__(97)($Promise.prototype, {
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__w_pdfjs_require__(59)($Promise, PROMISE);

__w_pdfjs_require__(98)(PROMISE);

Wrapper = __w_pdfjs_require__(9)[PROMISE];
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __w_pdfjs_require__(68)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),
/* 87 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ctx = __w_pdfjs_require__(23);

var call = __w_pdfjs_require__(63);

var isArrayIter = __w_pdfjs_require__(64);

var anObject = __w_pdfjs_require__(12);

var toLength = __w_pdfjs_require__(25);

var getIterFn = __w_pdfjs_require__(66);

var BREAK = {};
var RETURN = {};

var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

_exports.BREAK = BREAK;
_exports.RETURN = RETURN;

/***/ }),
/* 89 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var anObject = __w_pdfjs_require__(12);

var aFunction = __w_pdfjs_require__(24);

var SPECIES = __w_pdfjs_require__(30)('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ctx = __w_pdfjs_require__(23);

var invoke = __w_pdfjs_require__(91);

var html = __w_pdfjs_require__(58);

var cel = __w_pdfjs_require__(17);

var global = __w_pdfjs_require__(8);

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function run() {
  var id = +this;

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function listener(event) {
  run.call(event.data);
};

if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    queue[++counter] = function () {
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  };

  if (__w_pdfjs_require__(29)(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(ctx(run, id, 1));
    };
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false);
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = __w_pdfjs_require__(8);

var macrotask = __w_pdfjs_require__(90).set;

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __w_pdfjs_require__(29)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function flush() {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  };

  if (isNode) {
    notify = function notify() {
      process.nextTick(flush);
    };
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    });

    notify = function notify() {
      node.data = toggle = !toggle;
    };
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve(undefined);

    notify = function notify() {
      promise.then(flush);
    };
  } else {
    notify = function notify() {
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var aFunction = __w_pdfjs_require__(24);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = __w_pdfjs_require__(8);

var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

/***/ }),
/* 96 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var anObject = __w_pdfjs_require__(12);

var isObject = __w_pdfjs_require__(13);

var newPromiseCapability = __w_pdfjs_require__(93);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var redefine = __w_pdfjs_require__(20);

module.exports = function (target, src, safe) {
  for (var key in src) {
    redefine(target, key, src[key], safe);
  }

  return target;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = __w_pdfjs_require__(8);

var dP = __w_pdfjs_require__(11);

var DESCRIPTORS = __w_pdfjs_require__(15);

var SPECIES = __w_pdfjs_require__(30)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var core = __w_pdfjs_require__(9);

var global = __w_pdfjs_require__(8);

var speciesConstructor = __w_pdfjs_require__(89);

var promiseResolve = __w_pdfjs_require__(96);

$export($export.P + $export.R, 'Promise', {
  'finally': function _finally(onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),
/* 100 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var newPromiseCapability = __w_pdfjs_require__(93);

var perform = __w_pdfjs_require__(94);

$export($export.S, 'Promise', {
  'try': function _try(callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  }
});

/***/ }),
/* 101 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(82);

__w_pdfjs_require__(83);

__w_pdfjs_require__(102);

__w_pdfjs_require__(114);

__w_pdfjs_require__(116);

module.exports = __w_pdfjs_require__(9).WeakMap;

/***/ }),
/* 102 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var each = __w_pdfjs_require__(103)(0);

var redefine = __w_pdfjs_require__(20);

var meta = __w_pdfjs_require__(107);

var assign = __w_pdfjs_require__(71);

var weak = __w_pdfjs_require__(108);

var isObject = __w_pdfjs_require__(13);

var fails = __w_pdfjs_require__(16);

var validate = __w_pdfjs_require__(109);

var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function wrapper(get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

var $WeakMap = module.exports = __w_pdfjs_require__(110)(WEAK_MAP, wrapper, methods, weak, true, true);

if (fails(function () {
  return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
})) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result;
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ctx = __w_pdfjs_require__(23);

var IObject = __w_pdfjs_require__(43);

var toObject = __w_pdfjs_require__(61);

var toLength = __w_pdfjs_require__(25);

var asc = __w_pdfjs_require__(104);

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);

        if (TYPE) {
          if (IS_MAP) result[index] = res;else if (res) switch (TYPE) {
            case 3:
              return true;

            case 5:
              return val;

            case 6:
              return index;

            case 2:
              result.push(val);
          } else if (IS_EVERY) return false;
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var speciesConstructor = __w_pdfjs_require__(105);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 105 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(13);

var isArray = __w_pdfjs_require__(106);

var SPECIES = __w_pdfjs_require__(30)('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor;
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var cof = __w_pdfjs_require__(29);

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var META = __w_pdfjs_require__(22)('meta');

var isObject = __w_pdfjs_require__(13);

var has = __w_pdfjs_require__(21);

var setDesc = __w_pdfjs_require__(11).f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__w_pdfjs_require__(16)(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function setMeta(it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      w: {}
    }
  });
};

var fastKey = function fastKey(it, create) {
  if (!isObject(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    if (!isExtensible(it)) return 'F';
    if (!create) return 'E';
    setMeta(it);
  }

  return it[META].i;
};

var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    if (!isExtensible(it)) return true;
    if (!create) return false;
    setMeta(it);
  }

  return it[META].w;
};

var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var redefineAll = __w_pdfjs_require__(97);

var getWeak = __w_pdfjs_require__(107).getWeak;

var anObject = __w_pdfjs_require__(12);

var isObject = __w_pdfjs_require__(13);

var anInstance = __w_pdfjs_require__(87);

var forOf = __w_pdfjs_require__(88);

var createArrayMethod = __w_pdfjs_require__(103);

var $has = __w_pdfjs_require__(21);

var validate = __w_pdfjs_require__(109);

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};

var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;
      that._i = id++;
      that._l = undefined;
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      'delete': function _delete(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(13);

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = __w_pdfjs_require__(8);

var $export = __w_pdfjs_require__(7);

var redefine = __w_pdfjs_require__(20);

var redefineAll = __w_pdfjs_require__(97);

var meta = __w_pdfjs_require__(107);

var forOf = __w_pdfjs_require__(88);

var anInstance = __w_pdfjs_require__(87);

var isObject = __w_pdfjs_require__(13);

var fails = __w_pdfjs_require__(16);

var $iterDetect = __w_pdfjs_require__(68);

var setToStringTag = __w_pdfjs_require__(59);

var inheritIfRequired = __w_pdfjs_require__(111);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    });
    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    });
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      var $instance = new C();
      var index = 5;

      while (index--) {
        $instance[ADDER](index, index);
      }

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

/***/ }),
/* 111 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(13);

var setPrototypeOf = __w_pdfjs_require__(112).set;

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(13);

var anObject = __w_pdfjs_require__(12);

var check = function check(O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? function (test, buggy, set) {
    try {
      set = __w_pdfjs_require__(23)(Function.call, __w_pdfjs_require__(113).f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var pIE = __w_pdfjs_require__(73);

var createDesc = __w_pdfjs_require__(19);

var toIObject = __w_pdfjs_require__(42);

var toPrimitive = __w_pdfjs_require__(18);

var has = __w_pdfjs_require__(21);

var IE8_DOM_DEFINE = __w_pdfjs_require__(14);

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __w_pdfjs_require__(15) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {}
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(115)('WeakMap');

/***/ }),
/* 115 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    of: function of() {
      var length = arguments.length;
      var A = new Array(length);

      while (length--) {
        A[length] = arguments[length];
      }

      return new this(A);
    }
  });
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(117)('WeakMap');

/***/ }),
/* 117 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var aFunction = __w_pdfjs_require__(24);

var ctx = __w_pdfjs_require__(23);

var forOf = __w_pdfjs_require__(88);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    from: function from(source) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];

      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }

      return new this(A);
    }
  });
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(82);

__w_pdfjs_require__(83);

__w_pdfjs_require__(119);

__w_pdfjs_require__(120);

__w_pdfjs_require__(121);

module.exports = __w_pdfjs_require__(9).WeakSet;

/***/ }),
/* 119 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var weak = __w_pdfjs_require__(108);

var validate = __w_pdfjs_require__(109);

var WEAK_SET = 'WeakSet';

__w_pdfjs_require__(110)(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),
/* 120 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(115)('WeakSet');

/***/ }),
/* 121 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(117)('WeakSet');

/***/ }),
/* 122 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(123);

module.exports = __w_pdfjs_require__(9).String.codePointAt;

/***/ }),
/* 123 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var $at = __w_pdfjs_require__(48)(false);

$export($export.P, 'String', {
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),
/* 124 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(125);

module.exports = __w_pdfjs_require__(9).String.fromCodePoint;

/***/ }),
/* 125 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var toAbsoluteIndex = __w_pdfjs_require__(44);

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  fromCodePoint: function fromCodePoint(x) {
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),
/* 126 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(127);

__w_pdfjs_require__(82);

module.exports = __w_pdfjs_require__(9).Symbol;

/***/ }),
/* 127 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var global = __w_pdfjs_require__(8);

var has = __w_pdfjs_require__(21);

var DESCRIPTORS = __w_pdfjs_require__(15);

var $export = __w_pdfjs_require__(7);

var redefine = __w_pdfjs_require__(20);

var META = __w_pdfjs_require__(107).KEY;

var $fails = __w_pdfjs_require__(16);

var shared = __w_pdfjs_require__(31);

var setToStringTag = __w_pdfjs_require__(59);

var uid = __w_pdfjs_require__(22);

var wks = __w_pdfjs_require__(30);

var wksExt = __w_pdfjs_require__(128);

var wksDefine = __w_pdfjs_require__(129);

var enumKeys = __w_pdfjs_require__(130);

var isArray = __w_pdfjs_require__(106);

var anObject = __w_pdfjs_require__(12);

var isObject = __w_pdfjs_require__(13);

var toIObject = __w_pdfjs_require__(42);

var toPrimitive = __w_pdfjs_require__(18);

var createDesc = __w_pdfjs_require__(19);

var _create = __w_pdfjs_require__(52);

var gOPNExt = __w_pdfjs_require__(131);

var $GOPD = __w_pdfjs_require__(113);

var $DP = __w_pdfjs_require__(11);

var $keys = __w_pdfjs_require__(54);

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function get() {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
  return _typeof(it) == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) {
    $defineProperty(it, key = keys[i++], P[key]);
  }

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
};

if (!USE_NATIVE) {
  $Symbol = function _Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function $set(value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __w_pdfjs_require__(132).f = gOPNExt.f = $getOwnPropertyNames;
  __w_pdfjs_require__(73).f = $propertyIsEnumerable;
  __w_pdfjs_require__(72).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__w_pdfjs_require__(32)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = 'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  'for': function _for(key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) {
      if (SymbolRegistry[key] === sym) return key;
    }
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  create: $create,
  defineProperty: $defineProperty,
  defineProperties: $defineProperties,
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  getOwnPropertyNames: $getOwnPropertyNames,
  getOwnPropertySymbols: $getOwnPropertySymbols
});
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return;
    if (!isArray(replacer)) replacer = function replacer(key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __w_pdfjs_require__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
setToStringTag($Symbol, 'Symbol');
setToStringTag(Math, 'Math', true);
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 128 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


exports.f = __w_pdfjs_require__(30);

/***/ }),
/* 129 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = __w_pdfjs_require__(8);

var core = __w_pdfjs_require__(9);

var LIBRARY = __w_pdfjs_require__(32);

var wksExt = __w_pdfjs_require__(128);

var defineProperty = __w_pdfjs_require__(11).f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var getKeys = __w_pdfjs_require__(54);

var gOPS = __w_pdfjs_require__(72);

var pIE = __w_pdfjs_require__(73);

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) {
      if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
  }

  return result;
};

/***/ }),
/* 131 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var toIObject = __w_pdfjs_require__(42);

var gOPN = __w_pdfjs_require__(132).f;

var toString = {}.toString;
var windowNames = (typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),
/* 132 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $keys = __w_pdfjs_require__(55);

var hiddenKeys = __w_pdfjs_require__(57).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(134);

module.exports = __w_pdfjs_require__(9).String.padStart;

/***/ }),
/* 134 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var $pad = __w_pdfjs_require__(135);

var userAgent = __w_pdfjs_require__(95);

$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),
/* 135 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toLength = __w_pdfjs_require__(25);

var repeat = __w_pdfjs_require__(136);

var defined = __w_pdfjs_require__(33);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),
/* 136 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toInteger = __w_pdfjs_require__(26);

var defined = __w_pdfjs_require__(33);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) {
    if (n & 1) res += str;
  }

  return res;
};

/***/ }),
/* 137 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(138);

module.exports = __w_pdfjs_require__(9).String.padEnd;

/***/ }),
/* 138 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var $pad = __w_pdfjs_require__(135);

var userAgent = __w_pdfjs_require__(95);

$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),
/* 139 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


__w_pdfjs_require__(140);

module.exports = __w_pdfjs_require__(9).Object.values;

/***/ }),
/* 140 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $export = __w_pdfjs_require__(7);

var $values = __w_pdfjs_require__(141)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var getKeys = __w_pdfjs_require__(54);

var toIObject = __w_pdfjs_require__(42);

var isEnum = __w_pdfjs_require__(73).f;

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      if (isEnum.call(O, key = keys[i++])) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

/***/ }),
/* 142 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


{
  var isReadableStreamSupported = false;

  if (typeof ReadableStream !== 'undefined') {
    try {
      new ReadableStream({
        start: function start(controller) {
          controller.close();
        }
      });
      isReadableStreamSupported = true;
    } catch (e) {}
  }

  if (isReadableStreamSupported) {
    exports.ReadableStream = ReadableStream;
  } else {
    exports.ReadableStream = __w_pdfjs_require__(143).ReadableStream;
  }
}

/***/ }),
/* 143 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

(function (e, a) {
  for (var i in a) {
    e[i] = a[i];
  }
})(exports, function (modules) {
  var installedModules = {};

  function __w_pdfjs_require__(moduleId) {
    if (installedModules[moduleId]) return installedModules[moduleId].exports;
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
    module.l = true;
    return module.exports;
  }

  __w_pdfjs_require__.m = modules;
  __w_pdfjs_require__.c = installedModules;

  __w_pdfjs_require__.i = function (value) {
    return value;
  };

  __w_pdfjs_require__.d = function (exports, name, getter) {
    if (!__w_pdfjs_require__.o(exports, name)) {
      Object.defineProperty(exports, name, {
        configurable: false,
        enumerable: true,
        get: getter
      });
    }
  };

  __w_pdfjs_require__.n = function (module) {
    var getter = module && module.__esModule ? function getDefault() {
      return module['default'];
    } : function getModuleExports() {
      return module;
    };

    __w_pdfjs_require__.d(getter, 'a', getter);

    return getter;
  };

  __w_pdfjs_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };

  __w_pdfjs_require__.p = "";
  return __w_pdfjs_require__(__w_pdfjs_require__.s = 7);
}([function (module, exports, __w_pdfjs_require__) {
  "use strict";

  var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return _typeof2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
  };

  var _require = __w_pdfjs_require__(1),
      assert = _require.assert;

  function IsPropertyKey(argument) {
    return typeof argument === 'string' || (typeof argument === 'undefined' ? 'undefined' : _typeof(argument)) === 'symbol';
  }

  exports.typeIsObject = function (x) {
    return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null || typeof x === 'function';
  };

  exports.createDataProperty = function (o, p, v) {
    assert(exports.typeIsObject(o));
    Object.defineProperty(o, p, {
      value: v,
      writable: true,
      enumerable: true,
      configurable: true
    });
  };

  exports.createArrayFromList = function (elements) {
    return elements.slice();
  };

  exports.ArrayBufferCopy = function (dest, destOffset, src, srcOffset, n) {
    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
  };

  exports.CreateIterResultObject = function (value, done) {
    assert(typeof done === 'boolean');
    var obj = {};
    Object.defineProperty(obj, 'value', {
      value: value,
      enumerable: true,
      writable: true,
      configurable: true
    });
    Object.defineProperty(obj, 'done', {
      value: done,
      enumerable: true,
      writable: true,
      configurable: true
    });
    return obj;
  };

  exports.IsFiniteNonNegativeNumber = function (v) {
    if (Number.isNaN(v)) {
      return false;
    }

    if (v === Infinity) {
      return false;
    }

    if (v < 0) {
      return false;
    }

    return true;
  };

  function Call(F, V, args) {
    if (typeof F !== 'function') {
      throw new TypeError('Argument is not a function');
    }

    return Function.prototype.apply.call(F, V, args);
  }

  exports.InvokeOrNoop = function (O, P, args) {
    assert(O !== undefined);
    assert(IsPropertyKey(P));
    assert(Array.isArray(args));
    var method = O[P];

    if (method === undefined) {
      return undefined;
    }

    return Call(method, O, args);
  };

  exports.PromiseInvokeOrNoop = function (O, P, args) {
    assert(O !== undefined);
    assert(IsPropertyKey(P));
    assert(Array.isArray(args));

    try {
      return Promise.resolve(exports.InvokeOrNoop(O, P, args));
    } catch (returnValueE) {
      return Promise.reject(returnValueE);
    }
  };

  exports.PromiseInvokeOrPerformFallback = function (O, P, args, F, argsF) {
    assert(O !== undefined);
    assert(IsPropertyKey(P));
    assert(Array.isArray(args));
    assert(Array.isArray(argsF));
    var method = void 0;

    try {
      method = O[P];
    } catch (methodE) {
      return Promise.reject(methodE);
    }

    if (method === undefined) {
      return F.apply(null, argsF);
    }

    try {
      return Promise.resolve(Call(method, O, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  exports.TransferArrayBuffer = function (O) {
    return O.slice();
  };

  exports.ValidateAndNormalizeHighWaterMark = function (highWaterMark) {
    highWaterMark = Number(highWaterMark);

    if (Number.isNaN(highWaterMark) || highWaterMark < 0) {
      throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');
    }

    return highWaterMark;
  };

  exports.ValidateAndNormalizeQueuingStrategy = function (size, highWaterMark) {
    if (size !== undefined && typeof size !== 'function') {
      throw new TypeError('size property of a queuing strategy must be a function');
    }

    highWaterMark = exports.ValidateAndNormalizeHighWaterMark(highWaterMark);
    return {
      size: size,
      highWaterMark: highWaterMark
    };
  };
}, function (module, exports, __w_pdfjs_require__) {
  "use strict";

  function rethrowAssertionErrorRejection(e) {
    if (e && e.constructor === AssertionError) {
      setTimeout(function () {
        throw e;
      }, 0);
    }
  }

  function AssertionError(message) {
    this.name = 'AssertionError';
    this.message = message || '';
    this.stack = new Error().stack;
  }

  AssertionError.prototype = Object.create(Error.prototype);
  AssertionError.prototype.constructor = AssertionError;

  function assert(value, message) {
    if (!value) {
      throw new AssertionError(message);
    }
  }

  module.exports = {
    rethrowAssertionErrorRejection: rethrowAssertionErrorRejection,
    AssertionError: AssertionError,
    assert: assert
  };
}, function (module, exports, __w_pdfjs_require__) {
  "use strict";

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _require = __w_pdfjs_require__(0),
      InvokeOrNoop = _require.InvokeOrNoop,
      PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop,
      ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy,
      typeIsObject = _require.typeIsObject;

  var _require2 = __w_pdfjs_require__(1),
      assert = _require2.assert,
      rethrowAssertionErrorRejection = _require2.rethrowAssertionErrorRejection;

  var _require3 = __w_pdfjs_require__(3),
      DequeueValue = _require3.DequeueValue,
      EnqueueValueWithSize = _require3.EnqueueValueWithSize,
      PeekQueueValue = _require3.PeekQueueValue,
      ResetQueue = _require3.ResetQueue;

  var WritableStream = function () {
    function WritableStream() {
      var underlyingSink = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          size = _ref.size,
          _ref$highWaterMark = _ref.highWaterMark,
          highWaterMark = _ref$highWaterMark === undefined ? 1 : _ref$highWaterMark;

      _classCallCheck(this, WritableStream);

      this._state = 'writable';
      this._storedError = undefined;
      this._writer = undefined;
      this._writableStreamController = undefined;
      this._writeRequests = [];
      this._inFlightWriteRequest = undefined;
      this._closeRequest = undefined;
      this._inFlightCloseRequest = undefined;
      this._pendingAbortRequest = undefined;
      this._backpressure = false;
      var type = underlyingSink.type;

      if (type !== undefined) {
        throw new RangeError('Invalid type is specified');
      }

      this._writableStreamController = new WritableStreamDefaultController(this, underlyingSink, size, highWaterMark);

      this._writableStreamController.__startSteps();
    }

    _createClass(WritableStream, [{
      key: 'abort',
      value: function abort(reason) {
        if (IsWritableStream(this) === false) {
          return Promise.reject(streamBrandCheckException('abort'));
        }

        if (IsWritableStreamLocked(this) === true) {
          return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));
        }

        return WritableStreamAbort(this, reason);
      }
    }, {
      key: 'getWriter',
      value: function getWriter() {
        if (IsWritableStream(this) === false) {
          throw streamBrandCheckException('getWriter');
        }

        return AcquireWritableStreamDefaultWriter(this);
      }
    }, {
      key: 'locked',
      get: function get() {
        if (IsWritableStream(this) === false) {
          throw streamBrandCheckException('locked');
        }

        return IsWritableStreamLocked(this);
      }
    }]);

    return WritableStream;
  }();

  module.exports = {
    AcquireWritableStreamDefaultWriter: AcquireWritableStreamDefaultWriter,
    IsWritableStream: IsWritableStream,
    IsWritableStreamLocked: IsWritableStreamLocked,
    WritableStream: WritableStream,
    WritableStreamAbort: WritableStreamAbort,
    WritableStreamDefaultControllerError: WritableStreamDefaultControllerError,
    WritableStreamDefaultWriterCloseWithErrorPropagation: WritableStreamDefaultWriterCloseWithErrorPropagation,
    WritableStreamDefaultWriterRelease: WritableStreamDefaultWriterRelease,
    WritableStreamDefaultWriterWrite: WritableStreamDefaultWriterWrite,
    WritableStreamCloseQueuedOrInFlight: WritableStreamCloseQueuedOrInFlight
  };

  function AcquireWritableStreamDefaultWriter(stream) {
    return new WritableStreamDefaultWriter(stream);
  }

  function IsWritableStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
      return false;
    }

    return true;
  }

  function IsWritableStreamLocked(stream) {
    assert(IsWritableStream(stream) === true, 'IsWritableStreamLocked should only be used on known writable streams');

    if (stream._writer === undefined) {
      return false;
    }

    return true;
  }

  function WritableStreamAbort(stream, reason) {
    var state = stream._state;

    if (state === 'closed') {
      return Promise.resolve(undefined);
    }

    if (state === 'errored') {
      return Promise.reject(stream._storedError);
    }

    var error = new TypeError('Requested to abort');

    if (stream._pendingAbortRequest !== undefined) {
      return Promise.reject(error);
    }

    assert(state === 'writable' || state === 'erroring', 'state must be writable or erroring');
    var wasAlreadyErroring = false;

    if (state === 'erroring') {
      wasAlreadyErroring = true;
      reason = undefined;
    }

    var promise = new Promise(function (resolve, reject) {
      stream._pendingAbortRequest = {
        _resolve: resolve,
        _reject: reject,
        _reason: reason,
        _wasAlreadyErroring: wasAlreadyErroring
      };
    });

    if (wasAlreadyErroring === false) {
      WritableStreamStartErroring(stream, error);
    }

    return promise;
  }

  function WritableStreamAddWriteRequest(stream) {
    assert(IsWritableStreamLocked(stream) === true);
    assert(stream._state === 'writable');
    var promise = new Promise(function (resolve, reject) {
      var writeRequest = {
        _resolve: resolve,
        _reject: reject
      };

      stream._writeRequests.push(writeRequest);
    });
    return promise;
  }

  function WritableStreamDealWithRejection(stream, error) {
    var state = stream._state;

    if (state === 'writable') {
      WritableStreamStartErroring(stream, error);
      return;
    }

    assert(state === 'erroring');
    WritableStreamFinishErroring(stream);
  }

  function WritableStreamStartErroring(stream, reason) {
    assert(stream._storedError === undefined, 'stream._storedError === undefined');
    assert(stream._state === 'writable', 'state must be writable');
    var controller = stream._writableStreamController;
    assert(controller !== undefined, 'controller must not be undefined');
    stream._state = 'erroring';
    stream._storedError = reason;
    var writer = stream._writer;

    if (writer !== undefined) {
      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
    }

    if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {
      WritableStreamFinishErroring(stream);
    }
  }

  function WritableStreamFinishErroring(stream) {
    assert(stream._state === 'erroring', 'stream._state === erroring');
    assert(WritableStreamHasOperationMarkedInFlight(stream) === false, 'WritableStreamHasOperationMarkedInFlight(stream) === false');
    stream._state = 'errored';

    stream._writableStreamController.__errorSteps();

    var storedError = stream._storedError;

    for (var i = 0; i < stream._writeRequests.length; i++) {
      var writeRequest = stream._writeRequests[i];

      writeRequest._reject(storedError);
    }

    stream._writeRequests = [];

    if (stream._pendingAbortRequest === undefined) {
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }

    var abortRequest = stream._pendingAbortRequest;
    stream._pendingAbortRequest = undefined;

    if (abortRequest._wasAlreadyErroring === true) {
      abortRequest._reject(storedError);

      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }

    var promise = stream._writableStreamController.__abortSteps(abortRequest._reason);

    promise.then(function () {
      abortRequest._resolve();

      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    }, function (reason) {
      abortRequest._reject(reason);

      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    });
  }

  function WritableStreamFinishInFlightWrite(stream) {
    assert(stream._inFlightWriteRequest !== undefined);

    stream._inFlightWriteRequest._resolve(undefined);

    stream._inFlightWriteRequest = undefined;
  }

  function WritableStreamFinishInFlightWriteWithError(stream, error) {
    assert(stream._inFlightWriteRequest !== undefined);

    stream._inFlightWriteRequest._reject(error);

    stream._inFlightWriteRequest = undefined;
    assert(stream._state === 'writable' || stream._state === 'erroring');
    WritableStreamDealWithRejection(stream, error);
  }

  function WritableStreamFinishInFlightClose(stream) {
    assert(stream._inFlightCloseRequest !== undefined);

    stream._inFlightCloseRequest._resolve(undefined);

    stream._inFlightCloseRequest = undefined;
    var state = stream._state;
    assert(state === 'writable' || state === 'erroring');

    if (state === 'erroring') {
      stream._storedError = undefined;

      if (stream._pendingAbortRequest !== undefined) {
        stream._pendingAbortRequest._resolve();

        stream._pendingAbortRequest = undefined;
      }
    }

    stream._state = 'closed';
    var writer = stream._writer;

    if (writer !== undefined) {
      defaultWriterClosedPromiseResolve(writer);
    }

    assert(stream._pendingAbortRequest === undefined, 'stream._pendingAbortRequest === undefined');
    assert(stream._storedError === undefined, 'stream._storedError === undefined');
  }

  function WritableStreamFinishInFlightCloseWithError(stream, error) {
    assert(stream._inFlightCloseRequest !== undefined);

    stream._inFlightCloseRequest._reject(error);

    stream._inFlightCloseRequest = undefined;
    assert(stream._state === 'writable' || stream._state === 'erroring');

    if (stream._pendingAbortRequest !== undefined) {
      stream._pendingAbortRequest._reject(error);

      stream._pendingAbortRequest = undefined;
    }

    WritableStreamDealWithRejection(stream, error);
  }

  function WritableStreamCloseQueuedOrInFlight(stream) {
    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
      return false;
    }

    return true;
  }

  function WritableStreamHasOperationMarkedInFlight(stream) {
    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
      return false;
    }

    return true;
  }

  function WritableStreamMarkCloseRequestInFlight(stream) {
    assert(stream._inFlightCloseRequest === undefined);
    assert(stream._closeRequest !== undefined);
    stream._inFlightCloseRequest = stream._closeRequest;
    stream._closeRequest = undefined;
  }

  function WritableStreamMarkFirstWriteRequestInFlight(stream) {
    assert(stream._inFlightWriteRequest === undefined, 'there must be no pending write request');
    assert(stream._writeRequests.length !== 0, 'writeRequests must not be empty');
    stream._inFlightWriteRequest = stream._writeRequests.shift();
  }

  function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
    assert(stream._state === 'errored', '_stream_.[[state]] is `"errored"`');

    if (stream._closeRequest !== undefined) {
      assert(stream._inFlightCloseRequest === undefined);

      stream._closeRequest._reject(stream._storedError);

      stream._closeRequest = undefined;
    }

    var writer = stream._writer;

    if (writer !== undefined) {
      defaultWriterClosedPromiseReject(writer, stream._storedError);

      writer._closedPromise.catch(function () {});
    }
  }

  function WritableStreamUpdateBackpressure(stream, backpressure) {
    assert(stream._state === 'writable');
    assert(WritableStreamCloseQueuedOrInFlight(stream) === false);
    var writer = stream._writer;

    if (writer !== undefined && backpressure !== stream._backpressure) {
      if (backpressure === true) {
        defaultWriterReadyPromiseReset(writer);
      } else {
        assert(backpressure === false);
        defaultWriterReadyPromiseResolve(writer);
      }
    }

    stream._backpressure = backpressure;
  }

  var WritableStreamDefaultWriter = function () {
    function WritableStreamDefaultWriter(stream) {
      _classCallCheck(this, WritableStreamDefaultWriter);

      if (IsWritableStream(stream) === false) {
        throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');
      }

      if (IsWritableStreamLocked(stream) === true) {
        throw new TypeError('This stream has already been locked for exclusive writing by another writer');
      }

      this._ownerWritableStream = stream;
      stream._writer = this;
      var state = stream._state;

      if (state === 'writable') {
        if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {
          defaultWriterReadyPromiseInitialize(this);
        } else {
          defaultWriterReadyPromiseInitializeAsResolved(this);
        }

        defaultWriterClosedPromiseInitialize(this);
      } else if (state === 'erroring') {
        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);

        this._readyPromise.catch(function () {});

        defaultWriterClosedPromiseInitialize(this);
      } else if (state === 'closed') {
        defaultWriterReadyPromiseInitializeAsResolved(this);
        defaultWriterClosedPromiseInitializeAsResolved(this);
      } else {
        assert(state === 'errored', 'state must be errored');
        var storedError = stream._storedError;
        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);

        this._readyPromise.catch(function () {});

        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);

        this._closedPromise.catch(function () {});
      }
    }

    _createClass(WritableStreamDefaultWriter, [{
      key: 'abort',
      value: function abort(reason) {
        if (IsWritableStreamDefaultWriter(this) === false) {
          return Promise.reject(defaultWriterBrandCheckException('abort'));
        }

        if (this._ownerWritableStream === undefined) {
          return Promise.reject(defaultWriterLockException('abort'));
        }

        return WritableStreamDefaultWriterAbort(this, reason);
      }
    }, {
      key: 'close',
      value: function close() {
        if (IsWritableStreamDefaultWriter(this) === false) {
          return Promise.reject(defaultWriterBrandCheckException('close'));
        }

        var stream = this._ownerWritableStream;

        if (stream === undefined) {
          return Promise.reject(defaultWriterLockException('close'));
        }

        if (WritableStreamCloseQueuedOrInFlight(stream) === true) {
          return Promise.reject(new TypeError('cannot close an already-closing stream'));
        }

        return WritableStreamDefaultWriterClose(this);
      }
    }, {
      key: 'releaseLock',
      value: function releaseLock() {
        if (IsWritableStreamDefaultWriter(this) === false) {
          throw defaultWriterBrandCheckException('releaseLock');
        }

        var stream = this._ownerWritableStream;

        if (stream === undefined) {
          return;
        }

        assert(stream._writer !== undefined);
        WritableStreamDefaultWriterRelease(this);
      }
    }, {
      key: 'write',
      value: function write(chunk) {
        if (IsWritableStreamDefaultWriter(this) === false) {
          return Promise.reject(defaultWriterBrandCheckException('write'));
        }

        if (this._ownerWritableStream === undefined) {
          return Promise.reject(defaultWriterLockException('write to'));
        }

        return WritableStreamDefaultWriterWrite(this, chunk);
      }
    }, {
      key: 'closed',
      get: function get() {
        if (IsWritableStreamDefaultWriter(this) === false) {
          return Promise.reject(defaultWriterBrandCheckException('closed'));
        }

        return this._closedPromise;
      }
    }, {
      key: 'desiredSize',
      get: function get() {
        if (IsWritableStreamDefaultWriter(this) === false) {
          throw defaultWriterBrandCheckException('desiredSize');
        }

        if (this._ownerWritableStream === undefined) {
          throw defaultWriterLockException('desiredSize');
        }

        return WritableStreamDefaultWriterGetDesiredSize(this);
      }
    }, {
      key: 'ready',
      get: function get() {
        if (IsWritableStreamDefaultWriter(this) === false) {
          return Promise.reject(defaultWriterBrandCheckException('ready'));
        }

        return this._readyPromise;
      }
    }]);

    return WritableStreamDefaultWriter;
  }();

  function IsWritableStreamDefaultWriter(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
      return false;
    }

    return true;
  }

  function WritableStreamDefaultWriterAbort(writer, reason) {
    var stream = writer._ownerWritableStream;
    assert(stream !== undefined);
    return WritableStreamAbort(stream, reason);
  }

  function WritableStreamDefaultWriterClose(writer) {
    var stream = writer._ownerWritableStream;
    assert(stream !== undefined);
    var state = stream._state;

    if (state === 'closed' || state === 'errored') {
      return Promise.reject(new TypeError('The stream (in ' + state + ' state) is not in the writable state and cannot be closed'));
    }

    assert(state === 'writable' || state === 'erroring');
    assert(WritableStreamCloseQueuedOrInFlight(stream) === false);
    var promise = new Promise(function (resolve, reject) {
      var closeRequest = {
        _resolve: resolve,
        _reject: reject
      };
      stream._closeRequest = closeRequest;
    });

    if (stream._backpressure === true && state === 'writable') {
      defaultWriterReadyPromiseResolve(writer);
    }

    WritableStreamDefaultControllerClose(stream._writableStreamController);
    return promise;
  }

  function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
    var stream = writer._ownerWritableStream;
    assert(stream !== undefined);
    var state = stream._state;

    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {
      return Promise.resolve();
    }

    if (state === 'errored') {
      return Promise.reject(stream._storedError);
    }

    assert(state === 'writable' || state === 'erroring');
    return WritableStreamDefaultWriterClose(writer);
  }

  function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
    if (writer._closedPromiseState === 'pending') {
      defaultWriterClosedPromiseReject(writer, error);
    } else {
      defaultWriterClosedPromiseResetToRejected(writer, error);
    }

    writer._closedPromise.catch(function () {});
  }

  function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
    if (writer._readyPromiseState === 'pending') {
      defaultWriterReadyPromiseReject(writer, error);
    } else {
      defaultWriterReadyPromiseResetToRejected(writer, error);
    }

    writer._readyPromise.catch(function () {});
  }

  function WritableStreamDefaultWriterGetDesiredSize(writer) {
    var stream = writer._ownerWritableStream;
    var state = stream._state;

    if (state === 'errored' || state === 'erroring') {
      return null;
    }

    if (state === 'closed') {
      return 0;
    }

    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
  }

  function WritableStreamDefaultWriterRelease(writer) {
    var stream = writer._ownerWritableStream;
    assert(stream !== undefined);
    assert(stream._writer === writer);
    var releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\'s closedness');
    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
    stream._writer = undefined;
    writer._ownerWritableStream = undefined;
  }

  function WritableStreamDefaultWriterWrite(writer, chunk) {
    var stream = writer._ownerWritableStream;
    assert(stream !== undefined);
    var controller = stream._writableStreamController;
    var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);

    if (stream !== writer._ownerWritableStream) {
      return Promise.reject(defaultWriterLockException('write to'));
    }

    var state = stream._state;

    if (state === 'errored') {
      return Promise.reject(stream._storedError);
    }

    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {
      return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));
    }

    if (state === 'erroring') {
      return Promise.reject(stream._storedError);
    }

    assert(state === 'writable');
    var promise = WritableStreamAddWriteRequest(stream);
    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
    return promise;
  }

  var WritableStreamDefaultController = function () {
    function WritableStreamDefaultController(stream, underlyingSink, size, highWaterMark) {
      _classCallCheck(this, WritableStreamDefaultController);

      if (IsWritableStream(stream) === false) {
        throw new TypeError('WritableStreamDefaultController can only be constructed with a WritableStream instance');
      }

      if (stream._writableStreamController !== undefined) {
        throw new TypeError('WritableStreamDefaultController instances can only be created by the WritableStream constructor');
      }

      this._controlledWritableStream = stream;
      this._underlyingSink = underlyingSink;
      this._queue = undefined;
      this._queueTotalSize = undefined;
      ResetQueue(this);
      this._started = false;
      var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
      this._strategySize = normalizedStrategy.size;
      this._strategyHWM = normalizedStrategy.highWaterMark;
      var backpressure = WritableStreamDefaultControllerGetBackpressure(this);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }

    _createClass(WritableStreamDefaultController, [{
      key: 'error',
      value: function error(e) {
        if (IsWritableStreamDefaultController(this) === false) {
          throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');
        }

        var state = this._controlledWritableStream._state;

        if (state !== 'writable') {
          return;
        }

        WritableStreamDefaultControllerError(this, e);
      }
    }, {
      key: '__abortSteps',
      value: function __abortSteps(reason) {
        return PromiseInvokeOrNoop(this._underlyingSink, 'abort', [reason]);
      }
    }, {
      key: '__errorSteps',
      value: function __errorSteps() {
        ResetQueue(this);
      }
    }, {
      key: '__startSteps',
      value: function __startSteps() {
        var _this = this;

        var startResult = InvokeOrNoop(this._underlyingSink, 'start', [this]);
        var stream = this._controlledWritableStream;
        Promise.resolve(startResult).then(function () {
          assert(stream._state === 'writable' || stream._state === 'erroring');
          _this._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(_this);
        }, function (r) {
          assert(stream._state === 'writable' || stream._state === 'erroring');
          _this._started = true;
          WritableStreamDealWithRejection(stream, r);
        }).catch(rethrowAssertionErrorRejection);
      }
    }]);

    return WritableStreamDefaultController;
  }();

  function WritableStreamDefaultControllerClose(controller) {
    EnqueueValueWithSize(controller, 'close', 0);
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }

  function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
    var strategySize = controller._strategySize;

    if (strategySize === undefined) {
      return 1;
    }

    try {
      return strategySize(chunk);
    } catch (chunkSizeE) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
      return 1;
    }
  }

  function WritableStreamDefaultControllerGetDesiredSize(controller) {
    return controller._strategyHWM - controller._queueTotalSize;
  }

  function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
    var writeRecord = {
      chunk: chunk
    };

    try {
      EnqueueValueWithSize(controller, writeRecord, chunkSize);
    } catch (enqueueE) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
      return;
    }

    var stream = controller._controlledWritableStream;

    if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {
      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }

    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }

  function IsWritableStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSink')) {
      return false;
    }

    return true;
  }

  function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
    var stream = controller._controlledWritableStream;

    if (controller._started === false) {
      return;
    }

    if (stream._inFlightWriteRequest !== undefined) {
      return;
    }

    var state = stream._state;

    if (state === 'closed' || state === 'errored') {
      return;
    }

    if (state === 'erroring') {
      WritableStreamFinishErroring(stream);
      return;
    }

    if (controller._queue.length === 0) {
      return;
    }

    var writeRecord = PeekQueueValue(controller);

    if (writeRecord === 'close') {
      WritableStreamDefaultControllerProcessClose(controller);
    } else {
      WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);
    }
  }

  function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
    if (controller._controlledWritableStream._state === 'writable') {
      WritableStreamDefaultControllerError(controller, error);
    }
  }

  function WritableStreamDefaultControllerProcessClose(controller) {
    var stream = controller._controlledWritableStream;
    WritableStreamMarkCloseRequestInFlight(stream);
    DequeueValue(controller);
    assert(controller._queue.length === 0, 'queue must be empty once the final write record is dequeued');
    var sinkClosePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'close', []);
    sinkClosePromise.then(function () {
      WritableStreamFinishInFlightClose(stream);
    }, function (reason) {
      WritableStreamFinishInFlightCloseWithError(stream, reason);
    }).catch(rethrowAssertionErrorRejection);
  }

  function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
    var stream = controller._controlledWritableStream;
    WritableStreamMarkFirstWriteRequestInFlight(stream);
    var sinkWritePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'write', [chunk, controller]);
    sinkWritePromise.then(function () {
      WritableStreamFinishInFlightWrite(stream);
      var state = stream._state;
      assert(state === 'writable' || state === 'erroring');
      DequeueValue(controller);

      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
      }

      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }, function (reason) {
      WritableStreamFinishInFlightWriteWithError(stream, reason);
    }).catch(rethrowAssertionErrorRejection);
  }

  function WritableStreamDefaultControllerGetBackpressure(controller) {
    var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
    return desiredSize <= 0;
  }

  function WritableStreamDefaultControllerError(controller, error) {
    var stream = controller._controlledWritableStream;
    assert(stream._state === 'writable');
    WritableStreamStartErroring(stream, error);
  }

  function streamBrandCheckException(name) {
    return new TypeError('WritableStream.prototype.' + name + ' can only be used on a WritableStream');
  }

  function defaultWriterBrandCheckException(name) {
    return new TypeError('WritableStreamDefaultWriter.prototype.' + name + ' can only be used on a WritableStreamDefaultWriter');
  }

  function defaultWriterLockException(name) {
    return new TypeError('Cannot ' + name + ' a stream using a released writer');
  }

  function defaultWriterClosedPromiseInitialize(writer) {
    writer._closedPromise = new Promise(function (resolve, reject) {
      writer._closedPromise_resolve = resolve;
      writer._closedPromise_reject = reject;
      writer._closedPromiseState = 'pending';
    });
  }

  function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
    writer._closedPromise = Promise.reject(reason);
    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'rejected';
  }

  function defaultWriterClosedPromiseInitializeAsResolved(writer) {
    writer._closedPromise = Promise.resolve(undefined);
    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'resolved';
  }

  function defaultWriterClosedPromiseReject(writer, reason) {
    assert(writer._closedPromise_resolve !== undefined, 'writer._closedPromise_resolve !== undefined');
    assert(writer._closedPromise_reject !== undefined, 'writer._closedPromise_reject !== undefined');
    assert(writer._closedPromiseState === 'pending', 'writer._closedPromiseState is pending');

    writer._closedPromise_reject(reason);

    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'rejected';
  }

  function defaultWriterClosedPromiseResetToRejected(writer, reason) {
    assert(writer._closedPromise_resolve === undefined, 'writer._closedPromise_resolve === undefined');
    assert(writer._closedPromise_reject === undefined, 'writer._closedPromise_reject === undefined');
    assert(writer._closedPromiseState !== 'pending', 'writer._closedPromiseState is not pending');
    writer._closedPromise = Promise.reject(reason);
    writer._closedPromiseState = 'rejected';
  }

  function defaultWriterClosedPromiseResolve(writer) {
    assert(writer._closedPromise_resolve !== undefined, 'writer._closedPromise_resolve !== undefined');
    assert(writer._closedPromise_reject !== undefined, 'writer._closedPromise_reject !== undefined');
    assert(writer._closedPromiseState === 'pending', 'writer._closedPromiseState is pending');

    writer._closedPromise_resolve(undefined);

    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'resolved';
  }

  function defaultWriterReadyPromiseInitialize(writer) {
    writer._readyPromise = new Promise(function (resolve, reject) {
      writer._readyPromise_resolve = resolve;
      writer._readyPromise_reject = reject;
    });
    writer._readyPromiseState = 'pending';
  }

  function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
    writer._readyPromise = Promise.reject(reason);
    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'rejected';
  }

  function defaultWriterReadyPromiseInitializeAsResolved(writer) {
    writer._readyPromise = Promise.resolve(undefined);
    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'fulfilled';
  }

  function defaultWriterReadyPromiseReject(writer, reason) {
    assert(writer._readyPromise_resolve !== undefined, 'writer._readyPromise_resolve !== undefined');
    assert(writer._readyPromise_reject !== undefined, 'writer._readyPromise_reject !== undefined');

    writer._readyPromise_reject(reason);

    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'rejected';
  }

  function defaultWriterReadyPromiseReset(writer) {
    assert(writer._readyPromise_resolve === undefined, 'writer._readyPromise_resolve === undefined');
    assert(writer._readyPromise_reject === undefined, 'writer._readyPromise_reject === undefined');
    writer._readyPromise = new Promise(function (resolve, reject) {
      writer._readyPromise_resolve = resolve;
      writer._readyPromise_reject = reject;
    });
    writer._readyPromiseState = 'pending';
  }

  function defaultWriterReadyPromiseResetToRejected(writer, reason) {
    assert(writer._readyPromise_resolve === undefined, 'writer._readyPromise_resolve === undefined');
    assert(writer._readyPromise_reject === undefined, 'writer._readyPromise_reject === undefined');
    writer._readyPromise = Promise.reject(reason);
    writer._readyPromiseState = 'rejected';
  }

  function defaultWriterReadyPromiseResolve(writer) {
    assert(writer._readyPromise_resolve !== undefined, 'writer._readyPromise_resolve !== undefined');
    assert(writer._readyPromise_reject !== undefined, 'writer._readyPromise_reject !== undefined');

    writer._readyPromise_resolve(undefined);

    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'fulfilled';
  }
}, function (module, exports, __w_pdfjs_require__) {
  "use strict";

  var _require = __w_pdfjs_require__(0),
      IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber;

  var _require2 = __w_pdfjs_require__(1),
      assert = _require2.assert;

  exports.DequeueValue = function (container) {
    assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: DequeueValue should only be used on containers with [[queue]] and [[queueTotalSize]].');
    assert(container._queue.length > 0, 'Spec-level failure: should never dequeue from an empty queue.');

    var pair = container._queue.shift();

    container._queueTotalSize -= pair.size;

    if (container._queueTotalSize < 0) {
      container._queueTotalSize = 0;
    }

    return pair.value;
  };

  exports.EnqueueValueWithSize = function (container, value, size) {
    assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: EnqueueValueWithSize should only be used on containers with [[queue]] and ' + '[[queueTotalSize]].');
    size = Number(size);

    if (!IsFiniteNonNegativeNumber(size)) {
      throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
    }

    container._queue.push({
      value: value,
      size: size
    });

    container._queueTotalSize += size;
  };

  exports.PeekQueueValue = function (container) {
    assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: PeekQueueValue should only be used on containers with [[queue]] and [[queueTotalSize]].');
    assert(container._queue.length > 0, 'Spec-level failure: should never peek at an empty queue.');
    var pair = container._queue[0];
    return pair.value;
  };

  exports.ResetQueue = function (container) {
    assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: ResetQueue should only be used on containers with [[queue]] and [[queueTotalSize]].');
    container._queue = [];
    container._queueTotalSize = 0;
  };
}, function (module, exports, __w_pdfjs_require__) {
  "use strict";

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _require = __w_pdfjs_require__(0),
      ArrayBufferCopy = _require.ArrayBufferCopy,
      CreateIterResultObject = _require.CreateIterResultObject,
      IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber,
      InvokeOrNoop = _require.InvokeOrNoop,
      PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop,
      TransferArrayBuffer = _require.TransferArrayBuffer,
      ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy,
      ValidateAndNormalizeHighWaterMark = _require.ValidateAndNormalizeHighWaterMark;

  var _require2 = __w_pdfjs_require__(0),
      createArrayFromList = _require2.createArrayFromList,
      createDataProperty = _require2.createDataProperty,
      typeIsObject = _require2.typeIsObject;

  var _require3 = __w_pdfjs_require__(1),
      assert = _require3.assert,
      rethrowAssertionErrorRejection = _require3.rethrowAssertionErrorRejection;

  var _require4 = __w_pdfjs_require__(3),
      DequeueValue = _require4.DequeueValue,
      EnqueueValueWithSize = _require4.EnqueueValueWithSize,
      ResetQueue = _require4.ResetQueue;

  var _require5 = __w_pdfjs_require__(2),
      AcquireWritableStreamDefaultWriter = _require5.AcquireWritableStreamDefaultWriter,
      IsWritableStream = _require5.IsWritableStream,
      IsWritableStreamLocked = _require5.IsWritableStreamLocked,
      WritableStreamAbort = _require5.WritableStreamAbort,
      WritableStreamDefaultWriterCloseWithErrorPropagation = _require5.WritableStreamDefaultWriterCloseWithErrorPropagation,
      WritableStreamDefaultWriterRelease = _require5.WritableStreamDefaultWriterRelease,
      WritableStreamDefaultWriterWrite = _require5.WritableStreamDefaultWriterWrite,
      WritableStreamCloseQueuedOrInFlight = _require5.WritableStreamCloseQueuedOrInFlight;

  var ReadableStream = function () {
    function ReadableStream() {
      var underlyingSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          size = _ref.size,
          highWaterMark = _ref.highWaterMark;

      _classCallCheck(this, ReadableStream);

      this._state = 'readable';
      this._reader = undefined;
      this._storedError = undefined;
      this._disturbed = false;
      this._readableStreamController = undefined;
      var type = underlyingSource.type;
      var typeString = String(type);

      if (typeString === 'bytes') {
        if (highWaterMark === undefined) {
          highWaterMark = 0;
        }

        this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);
      } else if (type === undefined) {
        if (highWaterMark === undefined) {
          highWaterMark = 1;
        }

        this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark);
      } else {
        throw new RangeError('Invalid type is specified');
      }
    }

    _createClass(ReadableStream, [{
      key: 'cancel',
      value: function cancel(reason) {
        if (IsReadableStream(this) === false) {
          return Promise.reject(streamBrandCheckException('cancel'));
        }

        if (IsReadableStreamLocked(this) === true) {
          return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));
        }

        return ReadableStreamCancel(this, reason);
      }
    }, {
      key: 'getReader',
      value: function getReader() {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            mode = _ref2.mode;

        if (IsReadableStream(this) === false) {
          throw streamBrandCheckException('getReader');
        }

        if (mode === undefined) {
          return AcquireReadableStreamDefaultReader(this);
        }

        mode = String(mode);

        if (mode === 'byob') {
          return AcquireReadableStreamBYOBReader(this);
        }

        throw new RangeError('Invalid mode is specified');
      }
    }, {
      key: 'pipeThrough',
      value: function pipeThrough(_ref3, options) {
        var writable = _ref3.writable,
            readable = _ref3.readable;
        var promise = this.pipeTo(writable, options);
        ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);
        return readable;
      }
    }, {
      key: 'pipeTo',
      value: function pipeTo(dest) {
        var _this = this;

        var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            preventClose = _ref4.preventClose,
            preventAbort = _ref4.preventAbort,
            preventCancel = _ref4.preventCancel;

        if (IsReadableStream(this) === false) {
          return Promise.reject(streamBrandCheckException('pipeTo'));
        }

        if (IsWritableStream(dest) === false) {
          return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\'s first argument must be a WritableStream'));
        }

        preventClose = Boolean(preventClose);
        preventAbort = Boolean(preventAbort);
        preventCancel = Boolean(preventCancel);

        if (IsReadableStreamLocked(this) === true) {
          return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
        }

        if (IsWritableStreamLocked(dest) === true) {
          return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
        }

        var reader = AcquireReadableStreamDefaultReader(this);
        var writer = AcquireWritableStreamDefaultWriter(dest);
        var shuttingDown = false;
        var currentWrite = Promise.resolve();
        return new Promise(function (resolve, reject) {
          function pipeLoop() {
            currentWrite = Promise.resolve();

            if (shuttingDown === true) {
              return Promise.resolve();
            }

            return writer._readyPromise.then(function () {
              return ReadableStreamDefaultReaderRead(reader).then(function (_ref5) {
                var value = _ref5.value,
                    done = _ref5.done;

                if (done === true) {
                  return;
                }

                currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(function () {});
              });
            }).then(pipeLoop);
          }

          isOrBecomesErrored(_this, reader._closedPromise, function (storedError) {
            if (preventAbort === false) {
              shutdownWithAction(function () {
                return WritableStreamAbort(dest, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {
            if (preventCancel === false) {
              shutdownWithAction(function () {
                return ReadableStreamCancel(_this, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesClosed(_this, reader._closedPromise, function () {
            if (preventClose === false) {
              shutdownWithAction(function () {
                return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
              });
            } else {
              shutdown();
            }
          });

          if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {
            var destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');

            if (preventCancel === false) {
              shutdownWithAction(function () {
                return ReadableStreamCancel(_this, destClosed);
              }, true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }

          pipeLoop().catch(function (err) {
            currentWrite = Promise.resolve();
            rethrowAssertionErrorRejection(err);
          });

          function waitForWritesToFinish() {
            var oldCurrentWrite = currentWrite;
            return currentWrite.then(function () {
              return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;
            });
          }

          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === 'errored') {
              action(stream._storedError);
            } else {
              promise.catch(action).catch(rethrowAssertionErrorRejection);
            }
          }

          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === 'closed') {
              action();
            } else {
              promise.then(action).catch(rethrowAssertionErrorRejection);
            }
          }

          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown === true) {
              return;
            }

            shuttingDown = true;

            if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {
              waitForWritesToFinish().then(doTheRest);
            } else {
              doTheRest();
            }

            function doTheRest() {
              action().then(function () {
                return finalize(originalIsError, originalError);
              }, function (newError) {
                return finalize(true, newError);
              }).catch(rethrowAssertionErrorRejection);
            }
          }

          function shutdown(isError, error) {
            if (shuttingDown === true) {
              return;
            }

            shuttingDown = true;

            if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {
              waitForWritesToFinish().then(function () {
                return finalize(isError, error);
              }).catch(rethrowAssertionErrorRejection);
            } else {
              finalize(isError, error);
            }
          }

          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);

            if (isError) {
              reject(error);
            } else {
              resolve(undefined);
            }
          }
        });
      }
    }, {
      key: 'tee',
      value: function tee() {
        if (IsReadableStream(this) === false) {
          throw streamBrandCheckException('tee');
        }

        var branches = ReadableStreamTee(this, false);
        return createArrayFromList(branches);
      }
    }, {
      key: 'locked',
      get: function get() {
        if (IsReadableStream(this) === false) {
          throw streamBrandCheckException('locked');
        }

        return IsReadableStreamLocked(this);
      }
    }]);

    return ReadableStream;
  }();

  module.exports = {
    ReadableStream: ReadableStream,
    IsReadableStreamDisturbed: IsReadableStreamDisturbed,
    ReadableStreamDefaultControllerClose: ReadableStreamDefaultControllerClose,
    ReadableStreamDefaultControllerEnqueue: ReadableStreamDefaultControllerEnqueue,
    ReadableStreamDefaultControllerError: ReadableStreamDefaultControllerError,
    ReadableStreamDefaultControllerGetDesiredSize: ReadableStreamDefaultControllerGetDesiredSize
  };

  function AcquireReadableStreamBYOBReader(stream) {
    return new ReadableStreamBYOBReader(stream);
  }

  function AcquireReadableStreamDefaultReader(stream) {
    return new ReadableStreamDefaultReader(stream);
  }

  function IsReadableStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
      return false;
    }

    return true;
  }

  function IsReadableStreamDisturbed(stream) {
    assert(IsReadableStream(stream) === true, 'IsReadableStreamDisturbed should only be used on known readable streams');
    return stream._disturbed;
  }

  function IsReadableStreamLocked(stream) {
    assert(IsReadableStream(stream) === true, 'IsReadableStreamLocked should only be used on known readable streams');

    if (stream._reader === undefined) {
      return false;
    }

    return true;
  }

  function ReadableStreamTee(stream, cloneForBranch2) {
    assert(IsReadableStream(stream) === true);
    assert(typeof cloneForBranch2 === 'boolean');
    var reader = AcquireReadableStreamDefaultReader(stream);
    var teeState = {
      closedOrErrored: false,
      canceled1: false,
      canceled2: false,
      reason1: undefined,
      reason2: undefined
    };
    teeState.promise = new Promise(function (resolve) {
      teeState._resolve = resolve;
    });
    var pull = create_ReadableStreamTeePullFunction();
    pull._reader = reader;
    pull._teeState = teeState;
    pull._cloneForBranch2 = cloneForBranch2;
    var cancel1 = create_ReadableStreamTeeBranch1CancelFunction();
    cancel1._stream = stream;
    cancel1._teeState = teeState;
    var cancel2 = create_ReadableStreamTeeBranch2CancelFunction();
    cancel2._stream = stream;
    cancel2._teeState = teeState;
    var underlyingSource1 = Object.create(Object.prototype);
    createDataProperty(underlyingSource1, 'pull', pull);
    createDataProperty(underlyingSource1, 'cancel', cancel1);
    var branch1Stream = new ReadableStream(underlyingSource1);
    var underlyingSource2 = Object.create(Object.prototype);
    createDataProperty(underlyingSource2, 'pull', pull);
    createDataProperty(underlyingSource2, 'cancel', cancel2);
    var branch2Stream = new ReadableStream(underlyingSource2);
    pull._branch1 = branch1Stream._readableStreamController;
    pull._branch2 = branch2Stream._readableStreamController;

    reader._closedPromise.catch(function (r) {
      if (teeState.closedOrErrored === true) {
        return;
      }

      ReadableStreamDefaultControllerError(pull._branch1, r);
      ReadableStreamDefaultControllerError(pull._branch2, r);
      teeState.closedOrErrored = true;
    });

    return [branch1Stream, branch2Stream];
  }

  function create_ReadableStreamTeePullFunction() {
    function f() {
      var reader = f._reader,
          branch1 = f._branch1,
          branch2 = f._branch2,
          teeState = f._teeState;
      return ReadableStreamDefaultReaderRead(reader).then(function (result) {
        assert(typeIsObject(result));
        var value = result.value;
        var done = result.done;
        assert(typeof done === 'boolean');

        if (done === true && teeState.closedOrErrored === false) {
          if (teeState.canceled1 === false) {
            ReadableStreamDefaultControllerClose(branch1);
          }

          if (teeState.canceled2 === false) {
            ReadableStreamDefaultControllerClose(branch2);
          }

          teeState.closedOrErrored = true;
        }

        if (teeState.closedOrErrored === true) {
          return;
        }

        var value1 = value;
        var value2 = value;

        if (teeState.canceled1 === false) {
          ReadableStreamDefaultControllerEnqueue(branch1, value1);
        }

        if (teeState.canceled2 === false) {
          ReadableStreamDefaultControllerEnqueue(branch2, value2);
        }
      });
    }

    return f;
  }

  function create_ReadableStreamTeeBranch1CancelFunction() {
    function f(reason) {
      var stream = f._stream,
          teeState = f._teeState;
      teeState.canceled1 = true;
      teeState.reason1 = reason;

      if (teeState.canceled2 === true) {
        var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
        var cancelResult = ReadableStreamCancel(stream, compositeReason);

        teeState._resolve(cancelResult);
      }

      return teeState.promise;
    }

    return f;
  }

  function create_ReadableStreamTeeBranch2CancelFunction() {
    function f(reason) {
      var stream = f._stream,
          teeState = f._teeState;
      teeState.canceled2 = true;
      teeState.reason2 = reason;

      if (teeState.canceled1 === true) {
        var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
        var cancelResult = ReadableStreamCancel(stream, compositeReason);

        teeState._resolve(cancelResult);
      }

      return teeState.promise;
    }

    return f;
  }

  function ReadableStreamAddReadIntoRequest(stream) {
    assert(IsReadableStreamBYOBReader(stream._reader) === true);
    assert(stream._state === 'readable' || stream._state === 'closed');
    var promise = new Promise(function (resolve, reject) {
      var readIntoRequest = {
        _resolve: resolve,
        _reject: reject
      };

      stream._reader._readIntoRequests.push(readIntoRequest);
    });
    return promise;
  }

  function ReadableStreamAddReadRequest(stream) {
    assert(IsReadableStreamDefaultReader(stream._reader) === true);
    assert(stream._state === 'readable');
    var promise = new Promise(function (resolve, reject) {
      var readRequest = {
        _resolve: resolve,
        _reject: reject
      };

      stream._reader._readRequests.push(readRequest);
    });
    return promise;
  }

  function ReadableStreamCancel(stream, reason) {
    stream._disturbed = true;

    if (stream._state === 'closed') {
      return Promise.resolve(undefined);
    }

    if (stream._state === 'errored') {
      return Promise.reject(stream._storedError);
    }

    ReadableStreamClose(stream);

    var sourceCancelPromise = stream._readableStreamController.__cancelSteps(reason);

    return sourceCancelPromise.then(function () {
      return undefined;
    });
  }

  function ReadableStreamClose(stream) {
    assert(stream._state === 'readable');
    stream._state = 'closed';
    var reader = stream._reader;

    if (reader === undefined) {
      return undefined;
    }

    if (IsReadableStreamDefaultReader(reader) === true) {
      for (var i = 0; i < reader._readRequests.length; i++) {
        var _resolve = reader._readRequests[i]._resolve;

        _resolve(CreateIterResultObject(undefined, true));
      }

      reader._readRequests = [];
    }

    defaultReaderClosedPromiseResolve(reader);
    return undefined;
  }

  function ReadableStreamError(stream, e) {
    assert(IsReadableStream(stream) === true, 'stream must be ReadableStream');
    assert(stream._state === 'readable', 'state must be readable');
    stream._state = 'errored';
    stream._storedError = e;
    var reader = stream._reader;

    if (reader === undefined) {
      return undefined;
    }

    if (IsReadableStreamDefaultReader(reader) === true) {
      for (var i = 0; i < reader._readRequests.length; i++) {
        var readRequest = reader._readRequests[i];

        readRequest._reject(e);
      }

      reader._readRequests = [];
    } else {
      assert(IsReadableStreamBYOBReader(reader), 'reader must be ReadableStreamBYOBReader');

      for (var _i = 0; _i < reader._readIntoRequests.length; _i++) {
        var readIntoRequest = reader._readIntoRequests[_i];

        readIntoRequest._reject(e);
      }

      reader._readIntoRequests = [];
    }

    defaultReaderClosedPromiseReject(reader, e);

    reader._closedPromise.catch(function () {});
  }

  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
    var reader = stream._reader;
    assert(reader._readIntoRequests.length > 0);

    var readIntoRequest = reader._readIntoRequests.shift();

    readIntoRequest._resolve(CreateIterResultObject(chunk, done));
  }

  function ReadableStreamFulfillReadRequest(stream, chunk, done) {
    var reader = stream._reader;
    assert(reader._readRequests.length > 0);

    var readRequest = reader._readRequests.shift();

    readRequest._resolve(CreateIterResultObject(chunk, done));
  }

  function ReadableStreamGetNumReadIntoRequests(stream) {
    return stream._reader._readIntoRequests.length;
  }

  function ReadableStreamGetNumReadRequests(stream) {
    return stream._reader._readRequests.length;
  }

  function ReadableStreamHasBYOBReader(stream) {
    var reader = stream._reader;

    if (reader === undefined) {
      return false;
    }

    if (IsReadableStreamBYOBReader(reader) === false) {
      return false;
    }

    return true;
  }

  function ReadableStreamHasDefaultReader(stream) {
    var reader = stream._reader;

    if (reader === undefined) {
      return false;
    }

    if (IsReadableStreamDefaultReader(reader) === false) {
      return false;
    }

    return true;
  }

  var ReadableStreamDefaultReader = function () {
    function ReadableStreamDefaultReader(stream) {
      _classCallCheck(this, ReadableStreamDefaultReader);

      if (IsReadableStream(stream) === false) {
        throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');
      }

      if (IsReadableStreamLocked(stream) === true) {
        throw new TypeError('This stream has already been locked for exclusive reading by another reader');
      }

      ReadableStreamReaderGenericInitialize(this, stream);
      this._readRequests = [];
    }

    _createClass(ReadableStreamDefaultReader, [{
      key: 'cancel',
      value: function cancel(reason) {
        if (IsReadableStreamDefaultReader(this) === false) {
          return Promise.reject(defaultReaderBrandCheckException('cancel'));
        }

        if (this._ownerReadableStream === undefined) {
          return Promise.reject(readerLockException('cancel'));
        }

        return ReadableStreamReaderGenericCancel(this, reason);
      }
    }, {
      key: 'read',
      value: function read() {
        if (IsReadableStreamDefaultReader(this) === false) {
          return Promise.reject(defaultReaderBrandCheckException('read'));
        }

        if (this._ownerReadableStream === undefined) {
          return Promise.reject(readerLockException('read from'));
        }

        return ReadableStreamDefaultReaderRead(this);
      }
    }, {
      key: 'releaseLock',
      value: function releaseLock() {
        if (IsReadableStreamDefaultReader(this) === false) {
          throw defaultReaderBrandCheckException('releaseLock');
        }

        if (this._ownerReadableStream === undefined) {
          return;
        }

        if (this._readRequests.length > 0) {
          throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
        }

        ReadableStreamReaderGenericRelease(this);
      }
    }, {
      key: 'closed',
      get: function get() {
        if (IsReadableStreamDefaultReader(this) === false) {
          return Promise.reject(defaultReaderBrandCheckException('closed'));
        }

        return this._closedPromise;
      }
    }]);

    return ReadableStreamDefaultReader;
  }();

  var ReadableStreamBYOBReader = function () {
    function ReadableStreamBYOBReader(stream) {
      _classCallCheck(this, ReadableStreamBYOBReader);

      if (!IsReadableStream(stream)) {
        throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' + 'byte source');
      }

      if (IsReadableByteStreamController(stream._readableStreamController) === false) {
        throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');
      }

      if (IsReadableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive reading by another reader');
      }

      ReadableStreamReaderGenericInitialize(this, stream);
      this._readIntoRequests = [];
    }

    _createClass(ReadableStreamBYOBReader, [{
      key: 'cancel',
      value: function cancel(reason) {
        if (!IsReadableStreamBYOBReader(this)) {
          return Promise.reject(byobReaderBrandCheckException('cancel'));
        }

        if (this._ownerReadableStream === undefined) {
          return Promise.reject(readerLockException('cancel'));
        }

        return ReadableStreamReaderGenericCancel(this, reason);
      }
    }, {
      key: 'read',
      value: function read(view) {
        if (!IsReadableStreamBYOBReader(this)) {
          return Promise.reject(byobReaderBrandCheckException('read'));
        }

        if (this._ownerReadableStream === undefined) {
          return Promise.reject(readerLockException('read from'));
        }

        if (!ArrayBuffer.isView(view)) {
          return Promise.reject(new TypeError('view must be an array buffer view'));
        }

        if (view.byteLength === 0) {
          return Promise.reject(new TypeError('view must have non-zero byteLength'));
        }

        return ReadableStreamBYOBReaderRead(this, view);
      }
    }, {
      key: 'releaseLock',
      value: function releaseLock() {
        if (!IsReadableStreamBYOBReader(this)) {
          throw byobReaderBrandCheckException('releaseLock');
        }

        if (this._ownerReadableStream === undefined) {
          return;
        }

        if (this._readIntoRequests.length > 0) {
          throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
        }

        ReadableStreamReaderGenericRelease(this);
      }
    }, {
      key: 'closed',
      get: function get() {
        if (!IsReadableStreamBYOBReader(this)) {
          return Promise.reject(byobReaderBrandCheckException('closed'));
        }

        return this._closedPromise;
      }
    }]);

    return ReadableStreamBYOBReader;
  }();

  function IsReadableStreamBYOBReader(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
      return false;
    }

    return true;
  }

  function IsReadableStreamDefaultReader(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
      return false;
    }

    return true;
  }

  function ReadableStreamReaderGenericInitialize(reader, stream) {
    reader._ownerReadableStream = stream;
    stream._reader = reader;

    if (stream._state === 'readable') {
      defaultReaderClosedPromiseInitialize(reader);
    } else if (stream._state === 'closed') {
      defaultReaderClosedPromiseInitializeAsResolved(reader);
    } else {
      assert(stream._state === 'errored', 'state must be errored');
      defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);

      reader._closedPromise.catch(function () {});
    }
  }

  function ReadableStreamReaderGenericCancel(reader, reason) {
    var stream = reader._ownerReadableStream;
    assert(stream !== undefined);
    return ReadableStreamCancel(stream, reason);
  }

  function ReadableStreamReaderGenericRelease(reader) {
    assert(reader._ownerReadableStream !== undefined);
    assert(reader._ownerReadableStream._reader === reader);

    if (reader._ownerReadableStream._state === 'readable') {
      defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness'));
    } else {
      defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness'));
    }

    reader._closedPromise.catch(function () {});

    reader._ownerReadableStream._reader = undefined;
    reader._ownerReadableStream = undefined;
  }

  function ReadableStreamBYOBReaderRead(reader, view) {
    var stream = reader._ownerReadableStream;
    assert(stream !== undefined);
    stream._disturbed = true;

    if (stream._state === 'errored') {
      return Promise.reject(stream._storedError);
    }

    return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);
  }

  function ReadableStreamDefaultReaderRead(reader) {
    var stream = reader._ownerReadableStream;
    assert(stream !== undefined);
    stream._disturbed = true;

    if (stream._state === 'closed') {
      return Promise.resolve(CreateIterResultObject(undefined, true));
    }

    if (stream._state === 'errored') {
      return Promise.reject(stream._storedError);
    }

    assert(stream._state === 'readable');
    return stream._readableStreamController.__pullSteps();
  }

  var ReadableStreamDefaultController = function () {
    function ReadableStreamDefaultController(stream, underlyingSource, size, highWaterMark) {
      _classCallCheck(this, ReadableStreamDefaultController);

      if (IsReadableStream(stream) === false) {
        throw new TypeError('ReadableStreamDefaultController can only be constructed with a ReadableStream instance');
      }

      if (stream._readableStreamController !== undefined) {
        throw new TypeError('ReadableStreamDefaultController instances can only be created by the ReadableStream constructor');
      }

      this._controlledReadableStream = stream;
      this._underlyingSource = underlyingSource;
      this._queue = undefined;
      this._queueTotalSize = undefined;
      ResetQueue(this);
      this._started = false;
      this._closeRequested = false;
      this._pullAgain = false;
      this._pulling = false;
      var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
      this._strategySize = normalizedStrategy.size;
      this._strategyHWM = normalizedStrategy.highWaterMark;
      var controller = this;
      var startResult = InvokeOrNoop(underlyingSource, 'start', [this]);
      Promise.resolve(startResult).then(function () {
        controller._started = true;
        assert(controller._pulling === false);
        assert(controller._pullAgain === false);
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }, function (r) {
        ReadableStreamDefaultControllerErrorIfNeeded(controller, r);
      }).catch(rethrowAssertionErrorRejection);
    }

    _createClass(ReadableStreamDefaultController, [{
      key: 'close',
      value: function close() {
        if (IsReadableStreamDefaultController(this) === false) {
          throw defaultControllerBrandCheckException('close');
        }

        if (this._closeRequested === true) {
          throw new TypeError('The stream has already been closed; do not close it again!');
        }

        var state = this._controlledReadableStream._state;

        if (state !== 'readable') {
          throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be closed');
        }

        ReadableStreamDefaultControllerClose(this);
      }
    }, {
      key: 'enqueue',
      value: function enqueue(chunk) {
        if (IsReadableStreamDefaultController(this) === false) {
          throw defaultControllerBrandCheckException('enqueue');
        }

        if (this._closeRequested === true) {
          throw new TypeError('stream is closed or draining');
        }

        var state = this._controlledReadableStream._state;

        if (state !== 'readable') {
          throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be enqueued to');
        }

        return ReadableStreamDefaultControllerEnqueue(this, chunk);
      }
    }, {
      key: 'error',
      value: function error(e) {
        if (IsReadableStreamDefaultController(this) === false) {
          throw defaultControllerBrandCheckException('error');
        }

        var stream = this._controlledReadableStream;

        if (stream._state !== 'readable') {
          throw new TypeError('The stream is ' + stream._state + ' and so cannot be errored');
        }

        ReadableStreamDefaultControllerError(this, e);
      }
    }, {
      key: '__cancelSteps',
      value: function __cancelSteps(reason) {
        ResetQueue(this);
        return PromiseInvokeOrNoop(this._underlyingSource, 'cancel', [reason]);
      }
    }, {
      key: '__pullSteps',
      value: function __pullSteps() {
        var stream = this._controlledReadableStream;

        if (this._queue.length > 0) {
          var chunk = DequeueValue(this);

          if (this._closeRequested === true && this._queue.length === 0) {
            ReadableStreamClose(stream);
          } else {
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }

          return Promise.resolve(CreateIterResultObject(chunk, false));
        }

        var pendingPromise = ReadableStreamAddReadRequest(stream);
        ReadableStreamDefaultControllerCallPullIfNeeded(this);
        return pendingPromise;
      }
    }, {
      key: 'desiredSize',
      get: function get() {
        if (IsReadableStreamDefaultController(this) === false) {
          throw defaultControllerBrandCheckException('desiredSize');
        }

        return ReadableStreamDefaultControllerGetDesiredSize(this);
      }
    }]);

    return ReadableStreamDefaultController;
  }();

  function IsReadableStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSource')) {
      return false;
    }

    return true;
  }

  function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
    var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);

    if (shouldPull === false) {
      return undefined;
    }

    if (controller._pulling === true) {
      controller._pullAgain = true;
      return undefined;
    }

    assert(controller._pullAgain === false);
    controller._pulling = true;
    var pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, 'pull', [controller]);
    pullPromise.then(function () {
      controller._pulling = false;

      if (controller._pullAgain === true) {
        controller._pullAgain = false;
        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }

      return undefined;
    }, function (e) {
      ReadableStreamDefaultControllerErrorIfNeeded(controller, e);
    }).catch(rethrowAssertionErrorRejection);
    return undefined;
  }

  function ReadableStreamDefaultControllerShouldCallPull(controller) {
    var stream = controller._controlledReadableStream;

    if (stream._state === 'closed' || stream._state === 'errored') {
      return false;
    }

    if (controller._closeRequested === true) {
      return false;
    }

    if (controller._started === false) {
      return false;
    }

    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
      return true;
    }

    var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);

    if (desiredSize > 0) {
      return true;
    }

    return false;
  }

  function ReadableStreamDefaultControllerClose(controller) {
    var stream = controller._controlledReadableStream;
    assert(controller._closeRequested === false);
    assert(stream._state === 'readable');
    controller._closeRequested = true;

    if (controller._queue.length === 0) {
      ReadableStreamClose(stream);
    }
  }

  function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
    var stream = controller._controlledReadableStream;
    assert(controller._closeRequested === false);
    assert(stream._state === 'readable');

    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
      ReadableStreamFulfillReadRequest(stream, chunk, false);
    } else {
      var chunkSize = 1;

      if (controller._strategySize !== undefined) {
        var strategySize = controller._strategySize;

        try {
          chunkSize = strategySize(chunk);
        } catch (chunkSizeE) {
          ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          throw chunkSizeE;
        }
      }

      try {
        EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
        ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
        throw enqueueE;
      }
    }

    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    return undefined;
  }

  function ReadableStreamDefaultControllerError(controller, e) {
    var stream = controller._controlledReadableStream;
    assert(stream._state === 'readable');
    ResetQueue(controller);
    ReadableStreamError(stream, e);
  }

  function ReadableStreamDefaultControllerErrorIfNeeded(controller, e) {
    if (controller._controlledReadableStream._state === 'readable') {
      ReadableStreamDefaultControllerError(controller, e);
    }
  }

  function ReadableStreamDefaultControllerGetDesiredSize(controller) {
    var stream = controller._controlledReadableStream;
    var state = stream._state;

    if (state === 'errored') {
      return null;
    }

    if (state === 'closed') {
      return 0;
    }

    return controller._strategyHWM - controller._queueTotalSize;
  }

  var ReadableStreamBYOBRequest = function () {
    function ReadableStreamBYOBRequest(controller, view) {
      _classCallCheck(this, ReadableStreamBYOBRequest);

      this._associatedReadableByteStreamController = controller;
      this._view = view;
    }

    _createClass(ReadableStreamBYOBRequest, [{
      key: 'respond',
      value: function respond(bytesWritten) {
        if (IsReadableStreamBYOBRequest(this) === false) {
          throw byobRequestBrandCheckException('respond');
        }

        if (this._associatedReadableByteStreamController === undefined) {
          throw new TypeError('This BYOB request has been invalidated');
        }

        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
      }
    }, {
      key: 'respondWithNewView',
      value: function respondWithNewView(view) {
        if (IsReadableStreamBYOBRequest(this) === false) {
          throw byobRequestBrandCheckException('respond');
        }

        if (this._associatedReadableByteStreamController === undefined) {
          throw new TypeError('This BYOB request has been invalidated');
        }

        if (!ArrayBuffer.isView(view)) {
          throw new TypeError('You can only respond with array buffer views');
        }

        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
      }
    }, {
      key: 'view',
      get: function get() {
        return this._view;
      }
    }]);

    return ReadableStreamBYOBRequest;
  }();

  var ReadableByteStreamController = function () {
    function ReadableByteStreamController(stream, underlyingByteSource, highWaterMark) {
      _classCallCheck(this, ReadableByteStreamController);

      if (IsReadableStream(stream) === false) {
        throw new TypeError('ReadableByteStreamController can only be constructed with a ReadableStream instance given ' + 'a byte source');
      }

      if (stream._readableStreamController !== undefined) {
        throw new TypeError('ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte ' + 'source');
      }

      this._controlledReadableStream = stream;
      this._underlyingByteSource = underlyingByteSource;
      this._pullAgain = false;
      this._pulling = false;
      ReadableByteStreamControllerClearPendingPullIntos(this);
      this._queue = this._queueTotalSize = undefined;
      ResetQueue(this);
      this._closeRequested = false;
      this._started = false;
      this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);
      var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;

      if (autoAllocateChunkSize !== undefined) {
        if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {
          throw new RangeError('autoAllocateChunkSize must be a positive integer');
        }
      }

      this._autoAllocateChunkSize = autoAllocateChunkSize;
      this._pendingPullIntos = [];
      var controller = this;
      var startResult = InvokeOrNoop(underlyingByteSource, 'start', [this]);
      Promise.resolve(startResult).then(function () {
        controller._started = true;
        assert(controller._pulling === false);
        assert(controller._pullAgain === false);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }, function (r) {
        if (stream._state === 'readable') {
          ReadableByteStreamControllerError(controller, r);
        }
      }).catch(rethrowAssertionErrorRejection);
    }

    _createClass(ReadableByteStreamController, [{
      key: 'close',
      value: function close() {
        if (IsReadableByteStreamController(this) === false) {
          throw byteStreamControllerBrandCheckException('close');
        }

        if (this._closeRequested === true) {
          throw new TypeError('The stream has already been closed; do not close it again!');
        }

        var state = this._controlledReadableStream._state;

        if (state !== 'readable') {
          throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be closed');
        }

        ReadableByteStreamControllerClose(this);
      }
    }, {
      key: 'enqueue',
      value: function enqueue(chunk) {
        if (IsReadableByteStreamController(this) === false) {
          throw byteStreamControllerBrandCheckException('enqueue');
        }

        if (this._closeRequested === true) {
          throw new TypeError('stream is closed or draining');
        }

        var state = this._controlledReadableStream._state;

        if (state !== 'readable') {
          throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be enqueued to');
        }

        if (!ArrayBuffer.isView(chunk)) {
          throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');
        }

        ReadableByteStreamControllerEnqueue(this, chunk);
      }
    }, {
      key: 'error',
      value: function error(e) {
        if (IsReadableByteStreamController(this) === false) {
          throw byteStreamControllerBrandCheckException('error');
        }

        var stream = this._controlledReadableStream;

        if (stream._state !== 'readable') {
          throw new TypeError('The stream is ' + stream._state + ' and so cannot be errored');
        }

        ReadableByteStreamControllerError(this, e);
      }
    }, {
      key: '__cancelSteps',
      value: function __cancelSteps(reason) {
        if (this._pendingPullIntos.length > 0) {
          var firstDescriptor = this._pendingPullIntos[0];
          firstDescriptor.bytesFilled = 0;
        }

        ResetQueue(this);
        return PromiseInvokeOrNoop(this._underlyingByteSource, 'cancel', [reason]);
      }
    }, {
      key: '__pullSteps',
      value: function __pullSteps() {
        var stream = this._controlledReadableStream;
        assert(ReadableStreamHasDefaultReader(stream) === true);

        if (this._queueTotalSize > 0) {
          assert(ReadableStreamGetNumReadRequests(stream) === 0);

          var entry = this._queue.shift();

          this._queueTotalSize -= entry.byteLength;
          ReadableByteStreamControllerHandleQueueDrain(this);
          var view = void 0;

          try {
            view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
          } catch (viewE) {
            return Promise.reject(viewE);
          }

          return Promise.resolve(CreateIterResultObject(view, false));
        }

        var autoAllocateChunkSize = this._autoAllocateChunkSize;

        if (autoAllocateChunkSize !== undefined) {
          var buffer = void 0;

          try {
            buffer = new ArrayBuffer(autoAllocateChunkSize);
          } catch (bufferE) {
            return Promise.reject(bufferE);
          }

          var pullIntoDescriptor = {
            buffer: buffer,
            byteOffset: 0,
            byteLength: autoAllocateChunkSize,
            bytesFilled: 0,
            elementSize: 1,
            ctor: Uint8Array,
            readerType: 'default'
          };

          this._pendingPullIntos.push(pullIntoDescriptor);
        }

        var promise = ReadableStreamAddReadRequest(stream);
        ReadableByteStreamControllerCallPullIfNeeded(this);
        return promise;
      }
    }, {
      key: 'byobRequest',
      get: function get() {
        if (IsReadableByteStreamController(this) === false) {
          throw byteStreamControllerBrandCheckException('byobRequest');
        }

        if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {
          var firstDescriptor = this._pendingPullIntos[0];
          var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          this._byobRequest = new ReadableStreamBYOBRequest(this, view);
        }

        return this._byobRequest;
      }
    }, {
      key: 'desiredSize',
      get: function get() {
        if (IsReadableByteStreamController(this) === false) {
          throw byteStreamControllerBrandCheckException('desiredSize');
        }

        return ReadableByteStreamControllerGetDesiredSize(this);
      }
    }]);

    return ReadableByteStreamController;
  }();

  function IsReadableByteStreamController(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_underlyingByteSource')) {
      return false;
    }

    return true;
  }

  function IsReadableStreamBYOBRequest(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
      return false;
    }

    return true;
  }

  function ReadableByteStreamControllerCallPullIfNeeded(controller) {
    var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);

    if (shouldPull === false) {
      return undefined;
    }

    if (controller._pulling === true) {
      controller._pullAgain = true;
      return undefined;
    }

    assert(controller._pullAgain === false);
    controller._pulling = true;
    var pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, 'pull', [controller]);
    pullPromise.then(function () {
      controller._pulling = false;

      if (controller._pullAgain === true) {
        controller._pullAgain = false;
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
    }, function (e) {
      if (controller._controlledReadableStream._state === 'readable') {
        ReadableByteStreamControllerError(controller, e);
      }
    }).catch(rethrowAssertionErrorRejection);
    return undefined;
  }

  function ReadableByteStreamControllerClearPendingPullIntos(controller) {
    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    controller._pendingPullIntos = [];
  }

  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
    assert(stream._state !== 'errored', 'state must not be errored');
    var done = false;

    if (stream._state === 'closed') {
      assert(pullIntoDescriptor.bytesFilled === 0);
      done = true;
    }

    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);

    if (pullIntoDescriptor.readerType === 'default') {
      ReadableStreamFulfillReadRequest(stream, filledView, done);
    } else {
      assert(pullIntoDescriptor.readerType === 'byob');
      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
    }
  }

  function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
    var bytesFilled = pullIntoDescriptor.bytesFilled;
    var elementSize = pullIntoDescriptor.elementSize;
    assert(bytesFilled <= pullIntoDescriptor.byteLength);
    assert(bytesFilled % elementSize === 0);
    return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
  }

  function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
    controller._queue.push({
      buffer: buffer,
      byteOffset: byteOffset,
      byteLength: byteLength
    });

    controller._queueTotalSize += byteLength;
  }

  function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
    var elementSize = pullIntoDescriptor.elementSize;
    var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
    var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
    var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
    var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
    var totalBytesToCopyRemaining = maxBytesToCopy;
    var ready = false;

    if (maxAlignedBytes > currentAlignedBytes) {
      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
      ready = true;
    }

    var queue = controller._queue;

    while (totalBytesToCopyRemaining > 0) {
      var headOfQueue = queue[0];
      var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
      var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);

      if (headOfQueue.byteLength === bytesToCopy) {
        queue.shift();
      } else {
        headOfQueue.byteOffset += bytesToCopy;
        headOfQueue.byteLength -= bytesToCopy;
      }

      controller._queueTotalSize -= bytesToCopy;
      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
      totalBytesToCopyRemaining -= bytesToCopy;
    }

    if (ready === false) {
      assert(controller._queueTotalSize === 0, 'queue must be empty');
      assert(pullIntoDescriptor.bytesFilled > 0);
      assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);
    }

    return ready;
  }

  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
    assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);
    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    pullIntoDescriptor.bytesFilled += size;
  }

  function ReadableByteStreamControllerHandleQueueDrain(controller) {
    assert(controller._controlledReadableStream._state === 'readable');

    if (controller._queueTotalSize === 0 && controller._closeRequested === true) {
      ReadableStreamClose(controller._controlledReadableStream);
    } else {
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
  }

  function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
    if (controller._byobRequest === undefined) {
      return;
    }

    controller._byobRequest._associatedReadableByteStreamController = undefined;
    controller._byobRequest._view = undefined;
    controller._byobRequest = undefined;
  }

  function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
    assert(controller._closeRequested === false);

    while (controller._pendingPullIntos.length > 0) {
      if (controller._queueTotalSize === 0) {
        return;
      }

      var pullIntoDescriptor = controller._pendingPullIntos[0];

      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);
      }
    }
  }

  function ReadableByteStreamControllerPullInto(controller, view) {
    var stream = controller._controlledReadableStream;
    var elementSize = 1;

    if (view.constructor !== DataView) {
      elementSize = view.constructor.BYTES_PER_ELEMENT;
    }

    var ctor = view.constructor;
    var pullIntoDescriptor = {
      buffer: view.buffer,
      byteOffset: view.byteOffset,
      byteLength: view.byteLength,
      bytesFilled: 0,
      elementSize: elementSize,
      ctor: ctor,
      readerType: 'byob'
    };

    if (controller._pendingPullIntos.length > 0) {
      pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);

      controller._pendingPullIntos.push(pullIntoDescriptor);

      return ReadableStreamAddReadIntoRequest(stream);
    }

    if (stream._state === 'closed') {
      var emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
      return Promise.resolve(CreateIterResultObject(emptyView, true));
    }

    if (controller._queueTotalSize > 0) {
      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        ReadableByteStreamControllerHandleQueueDrain(controller);
        return Promise.resolve(CreateIterResultObject(filledView, false));
      }

      if (controller._closeRequested === true) {
        var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
        ReadableByteStreamControllerError(controller, e);
        return Promise.reject(e);
      }
    }

    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);

    controller._pendingPullIntos.push(pullIntoDescriptor);

    var promise = ReadableStreamAddReadIntoRequest(stream);
    ReadableByteStreamControllerCallPullIfNeeded(controller);
    return promise;
  }

  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
    assert(firstDescriptor.bytesFilled === 0, 'bytesFilled must be 0');
    var stream = controller._controlledReadableStream;

    if (ReadableStreamHasBYOBReader(stream) === true) {
      while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
        var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
      }
    }
  }

  function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
      throw new RangeError('bytesWritten out of range');
    }

    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);

    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
      return;
    }

    ReadableByteStreamControllerShiftPendingPullInto(controller);
    var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;

    if (remainderSize > 0) {
      var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
    }

    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
    pullIntoDescriptor.bytesFilled -= remainderSize;
    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);
    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  }

  function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
    var firstDescriptor = controller._pendingPullIntos[0];
    var stream = controller._controlledReadableStream;

    if (stream._state === 'closed') {
      if (bytesWritten !== 0) {
        throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
      }

      ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
    } else {
      assert(stream._state === 'readable');
      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
    }
  }

  function ReadableByteStreamControllerShiftPendingPullInto(controller) {
    var descriptor = controller._pendingPullIntos.shift();

    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    return descriptor;
  }

  function ReadableByteStreamControllerShouldCallPull(controller) {
    var stream = controller._controlledReadableStream;

    if (stream._state !== 'readable') {
      return false;
    }

    if (controller._closeRequested === true) {
      return false;
    }

    if (controller._started === false) {
      return false;
    }

    if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
      return true;
    }

    if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
      return true;
    }

    if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {
      return true;
    }

    return false;
  }

  function ReadableByteStreamControllerClose(controller) {
    var stream = controller._controlledReadableStream;
    assert(controller._closeRequested === false);
    assert(stream._state === 'readable');

    if (controller._queueTotalSize > 0) {
      controller._closeRequested = true;
      return;
    }

    if (controller._pendingPullIntos.length > 0) {
      var firstPendingPullInto = controller._pendingPullIntos[0];

      if (firstPendingPullInto.bytesFilled > 0) {
        var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
        ReadableByteStreamControllerError(controller, e);
        throw e;
      }
    }

    ReadableStreamClose(stream);
  }

  function ReadableByteStreamControllerEnqueue(controller, chunk) {
    var stream = controller._controlledReadableStream;
    assert(controller._closeRequested === false);
    assert(stream._state === 'readable');
    var buffer = chunk.buffer;
    var byteOffset = chunk.byteOffset;
    var byteLength = chunk.byteLength;
    var transferredBuffer = TransferArrayBuffer(buffer);

    if (ReadableStreamHasDefaultReader(stream) === true) {
      if (ReadableStreamGetNumReadRequests(stream) === 0) {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      } else {
        assert(controller._queue.length === 0);
        var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
        ReadableStreamFulfillReadRequest(stream, transferredView, false);
      }
    } else if (ReadableStreamHasBYOBReader(stream) === true) {
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    } else {
      assert(IsReadableStreamLocked(stream) === false, 'stream must not be locked');
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    }
  }

  function ReadableByteStreamControllerError(controller, e) {
    var stream = controller._controlledReadableStream;
    assert(stream._state === 'readable');
    ReadableByteStreamControllerClearPendingPullIntos(controller);
    ResetQueue(controller);
    ReadableStreamError(stream, e);
  }

  function ReadableByteStreamControllerGetDesiredSize(controller) {
    var stream = controller._controlledReadableStream;
    var state = stream._state;

    if (state === 'errored') {
      return null;
    }

    if (state === 'closed') {
      return 0;
    }

    return controller._strategyHWM - controller._queueTotalSize;
  }

  function ReadableByteStreamControllerRespond(controller, bytesWritten) {
    bytesWritten = Number(bytesWritten);

    if (IsFiniteNonNegativeNumber(bytesWritten) === false) {
      throw new RangeError('bytesWritten must be a finite');
    }

    assert(controller._pendingPullIntos.length > 0);
    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
  }

  function ReadableByteStreamControllerRespondWithNewView(controller, view) {
    assert(controller._pendingPullIntos.length > 0);
    var firstDescriptor = controller._pendingPullIntos[0];

    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
      throw new RangeError('The region specified by view does not match byobRequest');
    }

    if (firstDescriptor.byteLength !== view.byteLength) {
      throw new RangeError('The buffer of view has different capacity than byobRequest');
    }

    firstDescriptor.buffer = view.buffer;
    ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
  }

  function streamBrandCheckException(name) {
    return new TypeError('ReadableStream.prototype.' + name + ' can only be used on a ReadableStream');
  }

  function readerLockException(name) {
    return new TypeError('Cannot ' + name + ' a stream using a released reader');
  }

  function defaultReaderBrandCheckException(name) {
    return new TypeError('ReadableStreamDefaultReader.prototype.' + name + ' can only be used on a ReadableStreamDefaultReader');
  }

  function defaultReaderClosedPromiseInitialize(reader) {
    reader._closedPromise = new Promise(function (resolve, reject) {
      reader._closedPromise_resolve = resolve;
      reader._closedPromise_reject = reject;
    });
  }

  function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
    reader._closedPromise = Promise.reject(reason);
    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }

  function defaultReaderClosedPromiseInitializeAsResolved(reader) {
    reader._closedPromise = Promise.resolve(undefined);
    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }

  function defaultReaderClosedPromiseReject(reader, reason) {
    assert(reader._closedPromise_resolve !== undefined);
    assert(reader._closedPromise_reject !== undefined);

    reader._closedPromise_reject(reason);

    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }

  function defaultReaderClosedPromiseResetToRejected(reader, reason) {
    assert(reader._closedPromise_resolve === undefined);
    assert(reader._closedPromise_reject === undefined);
    reader._closedPromise = Promise.reject(reason);
  }

  function defaultReaderClosedPromiseResolve(reader) {
    assert(reader._closedPromise_resolve !== undefined);
    assert(reader._closedPromise_reject !== undefined);

    reader._closedPromise_resolve(undefined);

    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }

  function byobReaderBrandCheckException(name) {
    return new TypeError('ReadableStreamBYOBReader.prototype.' + name + ' can only be used on a ReadableStreamBYOBReader');
  }

  function defaultControllerBrandCheckException(name) {
    return new TypeError('ReadableStreamDefaultController.prototype.' + name + ' can only be used on a ReadableStreamDefaultController');
  }

  function byobRequestBrandCheckException(name) {
    return new TypeError('ReadableStreamBYOBRequest.prototype.' + name + ' can only be used on a ReadableStreamBYOBRequest');
  }

  function byteStreamControllerBrandCheckException(name) {
    return new TypeError('ReadableByteStreamController.prototype.' + name + ' can only be used on a ReadableByteStreamController');
  }

  function ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {
    try {
      Promise.prototype.then.call(promise, undefined, function () {});
    } catch (e) {}
  }
}, function (module, exports, __w_pdfjs_require__) {
  "use strict";

  var transformStream = __w_pdfjs_require__(6);

  var readableStream = __w_pdfjs_require__(4);

  var writableStream = __w_pdfjs_require__(2);

  exports.TransformStream = transformStream.TransformStream;
  exports.ReadableStream = readableStream.ReadableStream;
  exports.IsReadableStreamDisturbed = readableStream.IsReadableStreamDisturbed;
  exports.ReadableStreamDefaultControllerClose = readableStream.ReadableStreamDefaultControllerClose;
  exports.ReadableStreamDefaultControllerEnqueue = readableStream.ReadableStreamDefaultControllerEnqueue;
  exports.ReadableStreamDefaultControllerError = readableStream.ReadableStreamDefaultControllerError;
  exports.ReadableStreamDefaultControllerGetDesiredSize = readableStream.ReadableStreamDefaultControllerGetDesiredSize;
  exports.AcquireWritableStreamDefaultWriter = writableStream.AcquireWritableStreamDefaultWriter;
  exports.IsWritableStream = writableStream.IsWritableStream;
  exports.IsWritableStreamLocked = writableStream.IsWritableStreamLocked;
  exports.WritableStream = writableStream.WritableStream;
  exports.WritableStreamAbort = writableStream.WritableStreamAbort;
  exports.WritableStreamDefaultControllerError = writableStream.WritableStreamDefaultControllerError;
  exports.WritableStreamDefaultWriterCloseWithErrorPropagation = writableStream.WritableStreamDefaultWriterCloseWithErrorPropagation;
  exports.WritableStreamDefaultWriterRelease = writableStream.WritableStreamDefaultWriterRelease;
  exports.WritableStreamDefaultWriterWrite = writableStream.WritableStreamDefaultWriterWrite;
}, function (module, exports, __w_pdfjs_require__) {
  "use strict";

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _require = __w_pdfjs_require__(1),
      assert = _require.assert;

  var _require2 = __w_pdfjs_require__(0),
      InvokeOrNoop = _require2.InvokeOrNoop,
      PromiseInvokeOrPerformFallback = _require2.PromiseInvokeOrPerformFallback,
      PromiseInvokeOrNoop = _require2.PromiseInvokeOrNoop,
      typeIsObject = _require2.typeIsObject;

  var _require3 = __w_pdfjs_require__(4),
      ReadableStream = _require3.ReadableStream,
      ReadableStreamDefaultControllerClose = _require3.ReadableStreamDefaultControllerClose,
      ReadableStreamDefaultControllerEnqueue = _require3.ReadableStreamDefaultControllerEnqueue,
      ReadableStreamDefaultControllerError = _require3.ReadableStreamDefaultControllerError,
      ReadableStreamDefaultControllerGetDesiredSize = _require3.ReadableStreamDefaultControllerGetDesiredSize;

  var _require4 = __w_pdfjs_require__(2),
      WritableStream = _require4.WritableStream,
      WritableStreamDefaultControllerError = _require4.WritableStreamDefaultControllerError;

  function TransformStreamCloseReadable(transformStream) {
    if (transformStream._errored === true) {
      throw new TypeError('TransformStream is already errored');
    }

    if (transformStream._readableClosed === true) {
      throw new TypeError('Readable side is already closed');
    }

    TransformStreamCloseReadableInternal(transformStream);
  }

  function TransformStreamEnqueueToReadable(transformStream, chunk) {
    if (transformStream._errored === true) {
      throw new TypeError('TransformStream is already errored');
    }

    if (transformStream._readableClosed === true) {
      throw new TypeError('Readable side is already closed');
    }

    var controller = transformStream._readableController;

    try {
      ReadableStreamDefaultControllerEnqueue(controller, chunk);
    } catch (e) {
      transformStream._readableClosed = true;
      TransformStreamErrorIfNeeded(transformStream, e);
      throw transformStream._storedError;
    }

    var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
    var maybeBackpressure = desiredSize <= 0;

    if (maybeBackpressure === true && transformStream._backpressure === false) {
      TransformStreamSetBackpressure(transformStream, true);
    }
  }

  function TransformStreamError(transformStream, e) {
    if (transformStream._errored === true) {
      throw new TypeError('TransformStream is already errored');
    }

    TransformStreamErrorInternal(transformStream, e);
  }

  function TransformStreamCloseReadableInternal(transformStream) {
    assert(transformStream._errored === false);
    assert(transformStream._readableClosed === false);

    try {
      ReadableStreamDefaultControllerClose(transformStream._readableController);
    } catch (e) {
      assert(false);
    }

    transformStream._readableClosed = true;
  }

  function TransformStreamErrorIfNeeded(transformStream, e) {
    if (transformStream._errored === false) {
      TransformStreamErrorInternal(transformStream, e);
    }
  }

  function TransformStreamErrorInternal(transformStream, e) {
    assert(transformStream._errored === false);
    transformStream._errored = true;
    transformStream._storedError = e;

    if (transformStream._writableDone === false) {
      WritableStreamDefaultControllerError(transformStream._writableController, e);
    }

    if (transformStream._readableClosed === false) {
      ReadableStreamDefaultControllerError(transformStream._readableController, e);
    }
  }

  function TransformStreamReadableReadyPromise(transformStream) {
    assert(transformStream._backpressureChangePromise !== undefined, '_backpressureChangePromise should have been initialized');

    if (transformStream._backpressure === false) {
      return Promise.resolve();
    }

    assert(transformStream._backpressure === true, '_backpressure should have been initialized');
    return transformStream._backpressureChangePromise;
  }

  function TransformStreamSetBackpressure(transformStream, backpressure) {
    assert(transformStream._backpressure !== backpressure, 'TransformStreamSetBackpressure() should be called only when backpressure is changed');

    if (transformStream._backpressureChangePromise !== undefined) {
      transformStream._backpressureChangePromise_resolve(backpressure);
    }

    transformStream._backpressureChangePromise = new Promise(function (resolve) {
      transformStream._backpressureChangePromise_resolve = resolve;
    });

    transformStream._backpressureChangePromise.then(function (resolution) {
      assert(resolution !== backpressure, '_backpressureChangePromise should be fulfilled only when backpressure is changed');
    });

    transformStream._backpressure = backpressure;
  }

  function TransformStreamDefaultTransform(chunk, transformStreamController) {
    var transformStream = transformStreamController._controlledTransformStream;
    TransformStreamEnqueueToReadable(transformStream, chunk);
    return Promise.resolve();
  }

  function TransformStreamTransform(transformStream, chunk) {
    assert(transformStream._errored === false);
    assert(transformStream._transforming === false);
    assert(transformStream._backpressure === false);
    transformStream._transforming = true;
    var transformer = transformStream._transformer;
    var controller = transformStream._transformStreamController;
    var transformPromise = PromiseInvokeOrPerformFallback(transformer, 'transform', [chunk, controller], TransformStreamDefaultTransform, [chunk, controller]);
    return transformPromise.then(function () {
      transformStream._transforming = false;
      return TransformStreamReadableReadyPromise(transformStream);
    }, function (e) {
      TransformStreamErrorIfNeeded(transformStream, e);
      return Promise.reject(e);
    });
  }

  function IsTransformStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
      return false;
    }

    return true;
  }

  function IsTransformStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
      return false;
    }

    return true;
  }

  var TransformStreamSink = function () {
    function TransformStreamSink(transformStream, startPromise) {
      _classCallCheck(this, TransformStreamSink);

      this._transformStream = transformStream;
      this._startPromise = startPromise;
    }

    _createClass(TransformStreamSink, [{
      key: 'start',
      value: function start(c) {
        var transformStream = this._transformStream;
        transformStream._writableController = c;
        return this._startPromise.then(function () {
          return TransformStreamReadableReadyPromise(transformStream);
        });
      }
    }, {
      key: 'write',
      value: function write(chunk) {
        var transformStream = this._transformStream;
        return TransformStreamTransform(transformStream, chunk);
      }
    }, {
      key: 'abort',
      value: function abort() {
        var transformStream = this._transformStream;
        transformStream._writableDone = true;
        TransformStreamErrorInternal(transformStream, new TypeError('Writable side aborted'));
      }
    }, {
      key: 'close',
      value: function close() {
        var transformStream = this._transformStream;
        assert(transformStream._transforming === false);
        transformStream._writableDone = true;
        var flushPromise = PromiseInvokeOrNoop(transformStream._transformer, 'flush', [transformStream._transformStreamController]);
        return flushPromise.then(function () {
          if (transformStream._errored === true) {
            return Promise.reject(transformStream._storedError);
          }

          if (transformStream._readableClosed === false) {
            TransformStreamCloseReadableInternal(transformStream);
          }

          return Promise.resolve();
        }).catch(function (r) {
          TransformStreamErrorIfNeeded(transformStream, r);
          return Promise.reject(transformStream._storedError);
        });
      }
    }]);

    return TransformStreamSink;
  }();

  var TransformStreamSource = function () {
    function TransformStreamSource(transformStream, startPromise) {
      _classCallCheck(this, TransformStreamSource);

      this._transformStream = transformStream;
      this._startPromise = startPromise;
    }

    _createClass(TransformStreamSource, [{
      key: 'start',
      value: function start(c) {
        var transformStream = this._transformStream;
        transformStream._readableController = c;
        return this._startPromise.then(function () {
          assert(transformStream._backpressureChangePromise !== undefined, '_backpressureChangePromise should have been initialized');

          if (transformStream._backpressure === true) {
            return Promise.resolve();
          }

          assert(transformStream._backpressure === false, '_backpressure should have been initialized');
          return transformStream._backpressureChangePromise;
        });
      }
    }, {
      key: 'pull',
      value: function pull() {
        var transformStream = this._transformStream;
        assert(transformStream._backpressure === true, 'pull() should be never called while _backpressure is false');
        assert(transformStream._backpressureChangePromise !== undefined, '_backpressureChangePromise should have been initialized');
        TransformStreamSetBackpressure(transformStream, false);
        return transformStream._backpressureChangePromise;
      }
    }, {
      key: 'cancel',
      value: function cancel() {
        var transformStream = this._transformStream;
        transformStream._readableClosed = true;
        TransformStreamErrorInternal(transformStream, new TypeError('Readable side canceled'));
      }
    }]);

    return TransformStreamSource;
  }();

  var TransformStreamDefaultController = function () {
    function TransformStreamDefaultController(transformStream) {
      _classCallCheck(this, TransformStreamDefaultController);

      if (IsTransformStream(transformStream) === false) {
        throw new TypeError('TransformStreamDefaultController can only be ' + 'constructed with a TransformStream instance');
      }

      if (transformStream._transformStreamController !== undefined) {
        throw new TypeError('TransformStreamDefaultController instances can ' + 'only be created by the TransformStream constructor');
      }

      this._controlledTransformStream = transformStream;
    }

    _createClass(TransformStreamDefaultController, [{
      key: 'enqueue',
      value: function enqueue(chunk) {
        if (IsTransformStreamDefaultController(this) === false) {
          throw defaultControllerBrandCheckException('enqueue');
        }

        TransformStreamEnqueueToReadable(this._controlledTransformStream, chunk);
      }
    }, {
      key: 'close',
      value: function close() {
        if (IsTransformStreamDefaultController(this) === false) {
          throw defaultControllerBrandCheckException('close');
        }

        TransformStreamCloseReadable(this._controlledTransformStream);
      }
    }, {
      key: 'error',
      value: function error(reason) {
        if (IsTransformStreamDefaultController(this) === false) {
          throw defaultControllerBrandCheckException('error');
        }

        TransformStreamError(this._controlledTransformStream, reason);
      }
    }, {
      key: 'desiredSize',
      get: function get() {
        if (IsTransformStreamDefaultController(this) === false) {
          throw defaultControllerBrandCheckException('desiredSize');
        }

        var transformStream = this._controlledTransformStream;
        var readableController = transformStream._readableController;
        return ReadableStreamDefaultControllerGetDesiredSize(readableController);
      }
    }]);

    return TransformStreamDefaultController;
  }();

  var TransformStream = function () {
    function TransformStream() {
      var transformer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, TransformStream);

      this._transformer = transformer;
      var readableStrategy = transformer.readableStrategy,
          writableStrategy = transformer.writableStrategy;
      this._transforming = false;
      this._errored = false;
      this._storedError = undefined;
      this._writableController = undefined;
      this._readableController = undefined;
      this._transformStreamController = undefined;
      this._writableDone = false;
      this._readableClosed = false;
      this._backpressure = undefined;
      this._backpressureChangePromise = undefined;
      this._backpressureChangePromise_resolve = undefined;
      this._transformStreamController = new TransformStreamDefaultController(this);
      var startPromise_resolve = void 0;
      var startPromise = new Promise(function (resolve) {
        startPromise_resolve = resolve;
      });
      var source = new TransformStreamSource(this, startPromise);
      this._readable = new ReadableStream(source, readableStrategy);
      var sink = new TransformStreamSink(this, startPromise);
      this._writable = new WritableStream(sink, writableStrategy);
      assert(this._writableController !== undefined);
      assert(this._readableController !== undefined);
      var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(this._readableController);
      TransformStreamSetBackpressure(this, desiredSize <= 0);
      var transformStream = this;
      var startResult = InvokeOrNoop(transformer, 'start', [transformStream._transformStreamController]);
      startPromise_resolve(startResult);
      startPromise.catch(function (e) {
        if (transformStream._errored === false) {
          transformStream._errored = true;
          transformStream._storedError = e;
        }
      });
    }

    _createClass(TransformStream, [{
      key: 'readable',
      get: function get() {
        if (IsTransformStream(this) === false) {
          throw streamBrandCheckException('readable');
        }

        return this._readable;
      }
    }, {
      key: 'writable',
      get: function get() {
        if (IsTransformStream(this) === false) {
          throw streamBrandCheckException('writable');
        }

        return this._writable;
      }
    }]);

    return TransformStream;
  }();

  module.exports = {
    TransformStream: TransformStream
  };

  function defaultControllerBrandCheckException(name) {
    return new TypeError('TransformStreamDefaultController.prototype.' + name + ' can only be used on a TransformStreamDefaultController');
  }

  function streamBrandCheckException(name) {
    return new TypeError('TransformStream.prototype.' + name + ' can only be used on a TransformStream');
  }
}, function (module, exports, __w_pdfjs_require__) {
  module.exports = __w_pdfjs_require__(5);
}]));

/***/ }),
/* 144 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

{
  var isURLSupported = false;

  try {
    if (typeof URL === 'function' && _typeof(URL.prototype) === 'object' && 'origin' in URL.prototype) {
      var u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      isURLSupported = u.href === 'http://a/c%20d';
    }
  } catch (ex) {}

  if (isURLSupported) {
    exports.URL = URL;
  } else {
    var PolyfillURL = __w_pdfjs_require__(145).URL;

    var OriginalURL = __w_pdfjs_require__(3).URL;

    if (OriginalURL) {
      PolyfillURL.createObjectURL = function (blob) {
        return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
      };

      PolyfillURL.revokeObjectURL = function (url) {
        OriginalURL.revokeObjectURL(url);
      };
    }

    exports.URL = PolyfillURL;
  }
}

/***/ }),
/* 145 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


(function URLConstructorClosure() {
  'use strict';

  var relative = Object.create(null);
  relative['ftp'] = 21;
  relative['file'] = 0;
  relative['gopher'] = 70;
  relative['http'] = 80;
  relative['https'] = 443;
  relative['ws'] = 80;
  relative['wss'] = 443;
  var relativePathDotMapping = Object.create(null);
  relativePathDotMapping['%2e'] = '.';
  relativePathDotMapping['.%2e'] = '..';
  relativePathDotMapping['%2e.'] = '..';
  relativePathDotMapping['%2e%2e'] = '..';

  function isRelativeScheme(scheme) {
    return relative[scheme] !== undefined;
  }

  function invalid() {
    clear.call(this);
    this._isInvalid = true;
  }

  function IDNAToASCII(h) {
    if (h === '') {
      invalid.call(this);
    }

    return h.toLowerCase();
  }

  function percentEscape(c) {
    var unicode = c.charCodeAt(0);

    if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) === -1) {
      return c;
    }

    return encodeURIComponent(c);
  }

  function percentEscapeQuery(c) {
    var unicode = c.charCodeAt(0);

    if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) === -1) {
      return c;
    }

    return encodeURIComponent(c);
  }

  var EOF,
      ALPHA = /[a-zA-Z]/,
      ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;

  function parse(input, stateOverride, base) {
    function err(message) {
      errors.push(message);
    }

    var state = stateOverride || 'scheme start',
        cursor = 0,
        buffer = '',
        seenAt = false,
        seenBracket = false,
        errors = [];

    loop: while ((input[cursor - 1] !== EOF || cursor === 0) && !this._isInvalid) {
      var c = input[cursor];

      switch (state) {
        case 'scheme start':
          if (c && ALPHA.test(c)) {
            buffer += c.toLowerCase();
            state = 'scheme';
          } else if (!stateOverride) {
            buffer = '';
            state = 'no scheme';
            continue;
          } else {
            err('Invalid scheme.');
            break loop;
          }

          break;

        case 'scheme':
          if (c && ALPHANUMERIC.test(c)) {
            buffer += c.toLowerCase();
          } else if (c === ':') {
            this._scheme = buffer;
            buffer = '';

            if (stateOverride) {
              break loop;
            }

            if (isRelativeScheme(this._scheme)) {
              this._isRelative = true;
            }

            if (this._scheme === 'file') {
              state = 'relative';
            } else if (this._isRelative && base && base._scheme === this._scheme) {
              state = 'relative or authority';
            } else if (this._isRelative) {
              state = 'authority first slash';
            } else {
              state = 'scheme data';
            }
          } else if (!stateOverride) {
            buffer = '';
            cursor = 0;
            state = 'no scheme';
            continue;
          } else if (c === EOF) {
            break loop;
          } else {
            err('Code point not allowed in scheme: ' + c);
            break loop;
          }

          break;

        case 'scheme data':
          if (c === '?') {
            this._query = '?';
            state = 'query';
          } else if (c === '#') {
            this._fragment = '#';
            state = 'fragment';
          } else {
            if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
              this._schemeData += percentEscape(c);
            }
          }

          break;

        case 'no scheme':
          if (!base || !isRelativeScheme(base._scheme)) {
            err('Missing scheme.');
            invalid.call(this);
          } else {
            state = 'relative';
            continue;
          }

          break;

        case 'relative or authority':
          if (c === '/' && input[cursor + 1] === '/') {
            state = 'authority ignore slashes';
          } else {
            err('Expected /, got: ' + c);
            state = 'relative';
            continue;
          }

          break;

        case 'relative':
          this._isRelative = true;

          if (this._scheme !== 'file') {
            this._scheme = base._scheme;
          }

          if (c === EOF) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = base._query;
            this._username = base._username;
            this._password = base._password;
            break loop;
          } else if (c === '/' || c === '\\') {
            if (c === '\\') {
              err('\\ is an invalid code point.');
            }

            state = 'relative slash';
          } else if (c === '?') {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = '?';
            this._username = base._username;
            this._password = base._password;
            state = 'query';
          } else if (c === '#') {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = base._query;
            this._fragment = '#';
            this._username = base._username;
            this._password = base._password;
            state = 'fragment';
          } else {
            var nextC = input[cursor + 1];
            var nextNextC = input[cursor + 2];

            if (this._scheme !== 'file' || !ALPHA.test(c) || nextC !== ':' && nextC !== '|' || nextNextC !== EOF && nextNextC !== '/' && nextNextC !== '\\' && nextNextC !== '?' && nextNextC !== '#') {
              this._host = base._host;
              this._port = base._port;
              this._username = base._username;
              this._password = base._password;
              this._path = base._path.slice();

              this._path.pop();
            }

            state = 'relative path';
            continue;
          }

          break;

        case 'relative slash':
          if (c === '/' || c === '\\') {
            if (c === '\\') {
              err('\\ is an invalid code point.');
            }

            if (this._scheme === 'file') {
              state = 'file host';
            } else {
              state = 'authority ignore slashes';
            }
          } else {
            if (this._scheme !== 'file') {
              this._host = base._host;
              this._port = base._port;
              this._username = base._username;
              this._password = base._password;
            }

            state = 'relative path';
            continue;
          }

          break;

        case 'authority first slash':
          if (c === '/') {
            state = 'authority second slash';
          } else {
            err('Expected \'/\', got: ' + c);
            state = 'authority ignore slashes';
            continue;
          }

          break;

        case 'authority second slash':
          state = 'authority ignore slashes';

          if (c !== '/') {
            err('Expected \'/\', got: ' + c);
            continue;
          }

          break;

        case 'authority ignore slashes':
          if (c !== '/' && c !== '\\') {
            state = 'authority';
            continue;
          } else {
            err('Expected authority, got: ' + c);
          }

          break;

        case 'authority':
          if (c === '@') {
            if (seenAt) {
              err('@ already seen.');
              buffer += '%40';
            }

            seenAt = true;

            for (var i = 0; i < buffer.length; i++) {
              var cp = buffer[i];

              if (cp === '\t' || cp === '\n' || cp === '\r') {
                err('Invalid whitespace in authority.');
                continue;
              }

              if (cp === ':' && this._password === null) {
                this._password = '';
                continue;
              }

              var tempC = percentEscape(cp);

              if (this._password !== null) {
                this._password += tempC;
              } else {
                this._username += tempC;
              }
            }

            buffer = '';
          } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
            cursor -= buffer.length;
            buffer = '';
            state = 'host';
            continue;
          } else {
            buffer += c;
          }

          break;

        case 'file host':
          if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
            if (buffer.length === 2 && ALPHA.test(buffer[0]) && (buffer[1] === ':' || buffer[1] === '|')) {
              state = 'relative path';
            } else if (buffer.length === 0) {
              state = 'relative path start';
            } else {
              this._host = IDNAToASCII.call(this, buffer);
              buffer = '';
              state = 'relative path start';
            }

            continue;
          } else if (c === '\t' || c === '\n' || c === '\r') {
            err('Invalid whitespace in file host.');
          } else {
            buffer += c;
          }

          break;

        case 'host':
        case 'hostname':
          if (c === ':' && !seenBracket) {
            this._host = IDNAToASCII.call(this, buffer);
            buffer = '';
            state = 'port';

            if (stateOverride === 'hostname') {
              break loop;
            }
          } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
            this._host = IDNAToASCII.call(this, buffer);
            buffer = '';
            state = 'relative path start';

            if (stateOverride) {
              break loop;
            }

            continue;
          } else if (c !== '\t' && c !== '\n' && c !== '\r') {
            if (c === '[') {
              seenBracket = true;
            } else if (c === ']') {
              seenBracket = false;
            }

            buffer += c;
          } else {
            err('Invalid code point in host/hostname: ' + c);
          }

          break;

        case 'port':
          if (/[0-9]/.test(c)) {
            buffer += c;
          } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#' || stateOverride) {
            if (buffer !== '') {
              var temp = parseInt(buffer, 10);

              if (temp !== relative[this._scheme]) {
                this._port = temp + '';
              }

              buffer = '';
            }

            if (stateOverride) {
              break loop;
            }

            state = 'relative path start';
            continue;
          } else if (c === '\t' || c === '\n' || c === '\r') {
            err('Invalid code point in port: ' + c);
          } else {
            invalid.call(this);
          }

          break;

        case 'relative path start':
          if (c === '\\') {
            err('\'\\\' not allowed in path.');
          }

          state = 'relative path';

          if (c !== '/' && c !== '\\') {
            continue;
          }

          break;

        case 'relative path':
          if (c === EOF || c === '/' || c === '\\' || !stateOverride && (c === '?' || c === '#')) {
            if (c === '\\') {
              err('\\ not allowed in relative path.');
            }

            var tmp;

            if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
              buffer = tmp;
            }

            if (buffer === '..') {
              this._path.pop();

              if (c !== '/' && c !== '\\') {
                this._path.push('');
              }
            } else if (buffer === '.' && c !== '/' && c !== '\\') {
              this._path.push('');
            } else if (buffer !== '.') {
              if (this._scheme === 'file' && this._path.length === 0 && buffer.length === 2 && ALPHA.test(buffer[0]) && buffer[1] === '|') {
                buffer = buffer[0] + ':';
              }

              this._path.push(buffer);
            }

            buffer = '';

            if (c === '?') {
              this._query = '?';
              state = 'query';
            } else if (c === '#') {
              this._fragment = '#';
              state = 'fragment';
            }
          } else if (c !== '\t' && c !== '\n' && c !== '\r') {
            buffer += percentEscape(c);
          }

          break;

        case 'query':
          if (!stateOverride && c === '#') {
            this._fragment = '#';
            state = 'fragment';
          } else if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
            this._query += percentEscapeQuery(c);
          }

          break;

        case 'fragment':
          if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
            this._fragment += c;
          }

          break;
      }

      cursor++;
    }
  }

  function clear() {
    this._scheme = '';
    this._schemeData = '';
    this._username = '';
    this._password = null;
    this._host = '';
    this._port = '';
    this._path = [];
    this._query = '';
    this._fragment = '';
    this._isInvalid = false;
    this._isRelative = false;
  }

  function JURL(url, base) {
    if (base !== undefined && !(base instanceof JURL)) {
      base = new JURL(String(base));
    }

    this._url = url;
    clear.call(this);
    var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
    parse.call(this, input, null, base);
  }

  JURL.prototype = {
    toString: function toString() {
      return this.href;
    },

    get href() {
      if (this._isInvalid) {
        return this._url;
      }

      var authority = '';

      if (this._username !== '' || this._password !== null) {
        authority = this._username + (this._password !== null ? ':' + this._password : '') + '@';
      }

      return this.protocol + (this._isRelative ? '//' + authority + this.host : '') + this.pathname + this._query + this._fragment;
    },

    set href(value) {
      clear.call(this);
      parse.call(this, value);
    },

    get protocol() {
      return this._scheme + ':';
    },

    set protocol(value) {
      if (this._isInvalid) {
        return;
      }

      parse.call(this, value + ':', 'scheme start');
    },

    get host() {
      return this._isInvalid ? '' : this._port ? this._host + ':' + this._port : this._host;
    },

    set host(value) {
      if (this._isInvalid || !this._isRelative) {
        return;
      }

      parse.call(this, value, 'host');
    },

    get hostname() {
      return this._host;
    },

    set hostname(value) {
      if (this._isInvalid || !this._isRelative) {
        return;
      }

      parse.call(this, value, 'hostname');
    },

    get port() {
      return this._port;
    },

    set port(value) {
      if (this._isInvalid || !this._isRelative) {
        return;
      }

      parse.call(this, value, 'port');
    },

    get pathname() {
      return this._isInvalid ? '' : this._isRelative ? '/' + this._path.join('/') : this._schemeData;
    },

    set pathname(value) {
      if (this._isInvalid || !this._isRelative) {
        return;
      }

      this._path = [];
      parse.call(this, value, 'relative path start');
    },

    get search() {
      return this._isInvalid || !this._query || this._query === '?' ? '' : this._query;
    },

    set search(value) {
      if (this._isInvalid || !this._isRelative) {
        return;
      }

      this._query = '?';

      if (value[0] === '?') {
        value = value.slice(1);
      }

      parse.call(this, value, 'query');
    },

    get hash() {
      return this._isInvalid || !this._fragment || this._fragment === '#' ? '' : this._fragment;
    },

    set hash(value) {
      if (this._isInvalid) {
        return;
      }

      this._fragment = '#';

      if (value[0] === '#') {
        value = value.slice(1);
      }

      parse.call(this, value, 'fragment');
    },

    get origin() {
      var host;

      if (this._isInvalid || !this._scheme) {
        return '';
      }

      switch (this._scheme) {
        case 'data':
        case 'file':
        case 'javascript':
        case 'mailto':
          return 'null';

        case 'blob':
          try {
            return new JURL(this._schemeData).origin || 'null';
          } catch (_) {}

          return 'null';
      }

      host = this.host;

      if (!host) {
        return '';
      }

      return this._scheme + '://' + host;
    }

  };
  exports.URL = JURL;
})();

/***/ }),
/* 146 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDocument = getDocument;
exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
exports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(147));

var _util = __w_pdfjs_require__(1);

var _dom_utils = __w_pdfjs_require__(151);

var _font_loader = __w_pdfjs_require__(152);

var _api_compatibility = __w_pdfjs_require__(153);

var _canvas = __w_pdfjs_require__(154);

var _global_scope = _interopRequireDefault(__w_pdfjs_require__(3));

var _worker_options = __w_pdfjs_require__(156);

var _message_handler = __w_pdfjs_require__(157);

var _metadata = __w_pdfjs_require__(158);

var _transport_stream = __w_pdfjs_require__(160);

var _webgl = __w_pdfjs_require__(161);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var DEFAULT_RANGE_CHUNK_SIZE = 65536;
var isWorkerDisabled = false;
var fallbackWorkerSrc;
var fakeWorkerFilesLoader = null;
{
  var useRequireEnsure = false;

  if (typeof window === 'undefined') {
    isWorkerDisabled = true;

    if (false) {}

    useRequireEnsure = true;
  } else if (true) {
    useRequireEnsure = true;
  }

  if (typeof requirejs !== 'undefined' && requirejs.toUrl) {
    fallbackWorkerSrc = requirejs.toUrl('pdfjs-dist/build/pdf.worker.js');
  }

  var dynamicLoaderSupported = typeof requirejs !== 'undefined' && requirejs.load;
  fakeWorkerFilesLoader = useRequireEnsure ? function () {
    return new Promise(function (resolve, reject) {
      __webpack_require__.e(/* require.ensure | pdfjsWorker */ 4).then((function () {
        try {
          var worker;
          worker = __webpack_require__("Ox6R");
          resolve(worker.WorkerMessageHandler);
        } catch (ex) {
          reject(ex);
        }
      }).bind(null, __webpack_require__)).catch(reject);
    });
  } : dynamicLoaderSupported ? function () {
    return new Promise(function (resolve, reject) {
      requirejs(['pdfjs-dist/build/pdf.worker'], function (worker) {
        try {
          resolve(worker.WorkerMessageHandler);
        } catch (ex) {
          reject(ex);
        }
      }, reject);
    });
  } : null;

  if (!fallbackWorkerSrc && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && 'currentScript' in document) {
    var pdfjsFilePath = document.currentScript && document.currentScript.src;

    if (pdfjsFilePath) {
      fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, '.worker$1$2');
    }
  }
}
var createPDFNetworkStream;

function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
  createPDFNetworkStream = pdfNetworkStreamFactory;
}

function getDocument(src) {
  var task = new PDFDocumentLoadingTask();
  var source;

  if (typeof src === 'string') {
    source = {
      url: src
    };
  } else if ((0, _util.isArrayBuffer)(src)) {
    source = {
      data: src
    };
  } else if (src instanceof PDFDataRangeTransport) {
    source = {
      range: src
    };
  } else {
    if (_typeof(src) !== 'object') {
      throw new Error('Invalid parameter in getDocument, ' + 'need either Uint8Array, string or a parameter object');
    }

    if (!src.url && !src.data && !src.range) {
      throw new Error('Invalid parameter object: need either .data, .range or .url');
    }

    source = src;
  }

  var params = Object.create(null);
  var rangeTransport = null,
      worker = null;

  for (var key in source) {
    if (key === 'url' && typeof window !== 'undefined') {
      params[key] = new _util.URL(source[key], window.location).href;
      continue;
    } else if (key === 'range') {
      rangeTransport = source[key];
      continue;
    } else if (key === 'worker') {
      worker = source[key];
      continue;
    } else if (key === 'data' && !(source[key] instanceof Uint8Array)) {
      var pdfBytes = source[key];

      if (typeof pdfBytes === 'string') {
        params[key] = (0, _util.stringToBytes)(pdfBytes);
      } else if (_typeof(pdfBytes) === 'object' && pdfBytes !== null && !isNaN(pdfBytes.length)) {
        params[key] = new Uint8Array(pdfBytes);
      } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
        params[key] = new Uint8Array(pdfBytes);
      } else {
        throw new Error('Invalid PDF binary data: either typed array, ' + 'string or array-like object is expected in the ' + 'data property.');
      }

      continue;
    }

    params[key] = source[key];
  }

  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
  params.CMapReaderFactory = params.CMapReaderFactory || _dom_utils.DOMCMapReaderFactory;
  params.ignoreErrors = params.stopAtErrors !== true;
  params.pdfBug = params.pdfBug === true;
  var NativeImageDecoderValues = Object.values(_util.NativeImageDecoding);

  if (params.nativeImageDecoderSupport === undefined || !NativeImageDecoderValues.includes(params.nativeImageDecoderSupport)) {
    params.nativeImageDecoderSupport = _api_compatibility.apiCompatibilityParams.nativeImageDecoderSupport || _util.NativeImageDecoding.DECODE;
  }

  if (!Number.isInteger(params.maxImageSize)) {
    params.maxImageSize = -1;
  }

  if (typeof params.isEvalSupported !== 'boolean') {
    params.isEvalSupported = true;
  }

  if (typeof params.disableFontFace !== 'boolean') {
    params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
  }

  if (typeof params.disableRange !== 'boolean') {
    params.disableRange = false;
  }

  if (typeof params.disableStream !== 'boolean') {
    params.disableStream = false;
  }

  if (typeof params.disableAutoFetch !== 'boolean') {
    params.disableAutoFetch = false;
  }

  if (typeof params.disableCreateObjectURL !== 'boolean') {
    params.disableCreateObjectURL = _api_compatibility.apiCompatibilityParams.disableCreateObjectURL || false;
  }

  (0, _util.setVerbosityLevel)(params.verbosity);

  if (!worker) {
    var workerParams = {
      postMessageTransfers: params.postMessageTransfers,
      verbosity: params.verbosity,
      port: _worker_options.GlobalWorkerOptions.workerPort
    };
    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
    task._worker = worker;
  }

  var docId = task.docId;
  worker.promise.then(function () {
    if (task.destroyed) {
      throw new Error('Loading aborted');
    }

    return _fetchDocument(worker, params, rangeTransport, docId).then(function (workerId) {
      if (task.destroyed) {
        throw new Error('Loading aborted');
      }

      var networkStream;

      if (rangeTransport) {
        networkStream = new _transport_stream.PDFDataTransportStream({
          length: params.length,
          initialData: params.initialData,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        }, rangeTransport);
      } else if (!params.data) {
        networkStream = createPDFNetworkStream({
          url: params.url,
          length: params.length,
          httpHeaders: params.httpHeaders,
          withCredentials: params.withCredentials,
          rangeChunkSize: params.rangeChunkSize,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        });
      }

      var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
      messageHandler.postMessageTransfers = worker.postMessageTransfers;
      var transport = new WorkerTransport(messageHandler, task, networkStream, params);
      task._transport = transport;
      messageHandler.send('Ready', null);
    });
  }).catch(task._capability.reject);
  return task;
}

function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
  if (worker.destroyed) {
    return Promise.reject(new Error('Worker was destroyed'));
  }

  if (pdfDataRangeTransport) {
    source.length = pdfDataRangeTransport.length;
    source.initialData = pdfDataRangeTransport.initialData;
  }

  return worker.messageHandler.sendWithPromise('GetDocRequest', {
    docId: docId,
    apiVersion: '2.1.266',
    source: {
      data: source.data,
      url: source.url,
      password: source.password,
      disableAutoFetch: source.disableAutoFetch,
      rangeChunkSize: source.rangeChunkSize,
      length: source.length
    },
    maxImageSize: source.maxImageSize,
    disableFontFace: source.disableFontFace,
    disableCreateObjectURL: source.disableCreateObjectURL,
    postMessageTransfers: worker.postMessageTransfers,
    docBaseUrl: source.docBaseUrl,
    nativeImageDecoderSupport: source.nativeImageDecoderSupport,
    ignoreErrors: source.ignoreErrors,
    isEvalSupported: source.isEvalSupported
  }).then(function (workerId) {
    if (worker.destroyed) {
      throw new Error('Worker was destroyed');
    }

    return workerId;
  });
}

var PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
  var nextDocumentId = 0;

  var PDFDocumentLoadingTask =
  /*#__PURE__*/
  function () {
    function PDFDocumentLoadingTask() {
      _classCallCheck(this, PDFDocumentLoadingTask);

      this._capability = (0, _util.createPromiseCapability)();
      this._transport = null;
      this._worker = null;
      this.docId = 'd' + nextDocumentId++;
      this.destroyed = false;
      this.onPassword = null;
      this.onProgress = null;
      this.onUnsupportedFeature = null;
    }

    _createClass(PDFDocumentLoadingTask, [{
      key: "destroy",
      value: function destroy() {
        var _this = this;

        this.destroyed = true;
        var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
        return transportDestroyed.then(function () {
          _this._transport = null;

          if (_this._worker) {
            _this._worker.destroy();

            _this._worker = null;
          }
        });
      }
    }, {
      key: "then",
      value: function then(onFulfilled, onRejected) {
        (0, _util.deprecated)('PDFDocumentLoadingTask.then method, ' + 'use the `promise` getter instead.');
        return this.promise.then.apply(this.promise, arguments);
      }
    }, {
      key: "promise",
      get: function get() {
        return this._capability.promise;
      }
    }]);

    return PDFDocumentLoadingTask;
  }();

  return PDFDocumentLoadingTask;
}();

var PDFDataRangeTransport =
/*#__PURE__*/
function () {
  function PDFDataRangeTransport(length, initialData) {
    _classCallCheck(this, PDFDataRangeTransport);

    this.length = length;
    this.initialData = initialData;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._readyCapability = (0, _util.createPromiseCapability)();
  }

  _createClass(PDFDataRangeTransport, [{
    key: "addRangeListener",
    value: function addRangeListener(listener) {
      this._rangeListeners.push(listener);
    }
  }, {
    key: "addProgressListener",
    value: function addProgressListener(listener) {
      this._progressListeners.push(listener);
    }
  }, {
    key: "addProgressiveReadListener",
    value: function addProgressiveReadListener(listener) {
      this._progressiveReadListeners.push(listener);
    }
  }, {
    key: "onDataRange",
    value: function onDataRange(begin, chunk) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._rangeListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var listener = _step.value;
          listener(begin, chunk);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "onDataProgress",
    value: function onDataProgress(loaded) {
      var _this2 = this;

      this._readyCapability.promise.then(function () {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _this2._progressListeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var listener = _step2.value;
            listener(loaded);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      });
    }
  }, {
    key: "onDataProgressiveRead",
    value: function onDataProgressiveRead(chunk) {
      var _this3 = this;

      this._readyCapability.promise.then(function () {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _this3._progressiveReadListeners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var listener = _step3.value;
            listener(chunk);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      });
    }
  }, {
    key: "transportReady",
    value: function transportReady() {
      this._readyCapability.resolve();
    }
  }, {
    key: "requestDataRange",
    value: function requestDataRange(begin, end) {
      (0, _util.unreachable)('Abstract method PDFDataRangeTransport.requestDataRange');
    }
  }, {
    key: "abort",
    value: function abort() {}
  }]);

  return PDFDataRangeTransport;
}();

exports.PDFDataRangeTransport = PDFDataRangeTransport;

var PDFDocumentProxy =
/*#__PURE__*/
function () {
  function PDFDocumentProxy(pdfInfo, transport, loadingTask) {
    _classCallCheck(this, PDFDocumentProxy);

    this.loadingTask = loadingTask;
    this._pdfInfo = pdfInfo;
    this._transport = transport;
  }

  _createClass(PDFDocumentProxy, [{
    key: "getPage",
    value: function getPage(pageNumber) {
      return this._transport.getPage(pageNumber);
    }
  }, {
    key: "getPageIndex",
    value: function getPageIndex(ref) {
      return this._transport.getPageIndex(ref);
    }
  }, {
    key: "getDestinations",
    value: function getDestinations() {
      return this._transport.getDestinations();
    }
  }, {
    key: "getDestination",
    value: function getDestination(id) {
      return this._transport.getDestination(id);
    }
  }, {
    key: "getPageLabels",
    value: function getPageLabels() {
      return this._transport.getPageLabels();
    }
  }, {
    key: "getPageMode",
    value: function getPageMode() {
      return this._transport.getPageMode();
    }
  }, {
    key: "getOpenActionDestination",
    value: function getOpenActionDestination() {
      return this._transport.getOpenActionDestination();
    }
  }, {
    key: "getAttachments",
    value: function getAttachments() {
      return this._transport.getAttachments();
    }
  }, {
    key: "getJavaScript",
    value: function getJavaScript() {
      return this._transport.getJavaScript();
    }
  }, {
    key: "getOutline",
    value: function getOutline() {
      return this._transport.getOutline();
    }
  }, {
    key: "getPermissions",
    value: function getPermissions() {
      return this._transport.getPermissions();
    }
  }, {
    key: "getMetadata",
    value: function getMetadata() {
      return this._transport.getMetadata();
    }
  }, {
    key: "getData",
    value: function getData() {
      return this._transport.getData();
    }
  }, {
    key: "getDownloadInfo",
    value: function getDownloadInfo() {
      return this._transport.downloadInfoCapability.promise;
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this._transport.getStats();
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      this._transport.startCleanup();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      return this.loadingTask.destroy();
    }
  }, {
    key: "numPages",
    get: function get() {
      return this._pdfInfo.numPages;
    }
  }, {
    key: "fingerprint",
    get: function get() {
      return this._pdfInfo.fingerprint;
    }
  }, {
    key: "loadingParams",
    get: function get() {
      return this._transport.loadingParams;
    }
  }]);

  return PDFDocumentProxy;
}();

exports.PDFDocumentProxy = PDFDocumentProxy;

var PDFPageProxy =
/*#__PURE__*/
function () {
  function PDFPageProxy(pageIndex, pageInfo, transport) {
    var pdfBug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    _classCallCheck(this, PDFPageProxy);

    this.pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._transport = transport;
    this._stats = pdfBug ? new _dom_utils.StatTimer() : _dom_utils.DummyStatTimer;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this.cleanupAfterRender = false;
    this.pendingCleanup = false;
    this.intentStates = Object.create(null);
    this.destroyed = false;
  }

  _createClass(PDFPageProxy, [{
    key: "getViewport",
    value: function getViewport() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          scale = _ref.scale,
          _ref$rotation = _ref.rotation,
          rotation = _ref$rotation === void 0 ? this.rotate : _ref$rotation,
          _ref$dontFlip = _ref.dontFlip,
          dontFlip = _ref$dontFlip === void 0 ? false : _ref$dontFlip;

      if (arguments.length > 1 || typeof arguments[0] === 'number') {
        (0, _util.deprecated)('getViewport is called with obsolete arguments.');
        scale = arguments[0];
        rotation = typeof arguments[1] === 'number' ? arguments[1] : this.rotate;
        dontFlip = typeof arguments[2] === 'boolean' ? arguments[2] : false;
      }

      return new _dom_utils.PageViewport({
        viewBox: this.view,
        scale: scale,
        rotation: rotation,
        dontFlip: dontFlip
      });
    }
  }, {
    key: "getAnnotations",
    value: function getAnnotations() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$intent = _ref2.intent,
          intent = _ref2$intent === void 0 ? null : _ref2$intent;

      if (!this.annotationsPromise || this.annotationsIntent !== intent) {
        this.annotationsPromise = this._transport.getAnnotations(this.pageIndex, intent);
        this.annotationsIntent = intent;
      }

      return this.annotationsPromise;
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _this4 = this;

      var canvasContext = _ref3.canvasContext,
          viewport = _ref3.viewport,
          _ref3$intent = _ref3.intent,
          intent = _ref3$intent === void 0 ? 'display' : _ref3$intent,
          _ref3$enableWebGL = _ref3.enableWebGL,
          enableWebGL = _ref3$enableWebGL === void 0 ? false : _ref3$enableWebGL,
          _ref3$renderInteracti = _ref3.renderInteractiveForms,
          renderInteractiveForms = _ref3$renderInteracti === void 0 ? false : _ref3$renderInteracti,
          _ref3$transform = _ref3.transform,
          transform = _ref3$transform === void 0 ? null : _ref3$transform,
          _ref3$imageLayer = _ref3.imageLayer,
          imageLayer = _ref3$imageLayer === void 0 ? null : _ref3$imageLayer,
          _ref3$canvasFactory = _ref3.canvasFactory,
          canvasFactory = _ref3$canvasFactory === void 0 ? null : _ref3$canvasFactory,
          _ref3$background = _ref3.background,
          background = _ref3$background === void 0 ? null : _ref3$background;
      var stats = this._stats;
      stats.time('Overall');
      this.pendingCleanup = false;
      var renderingIntent = intent === 'print' ? 'print' : 'display';
      var canvasFactoryInstance = canvasFactory || new _dom_utils.DOMCanvasFactory();
      var webGLContext = new _webgl.WebGLContext({
        enable: enableWebGL
      });

      if (!this.intentStates[renderingIntent]) {
        this.intentStates[renderingIntent] = Object.create(null);
      }

      var intentState = this.intentStates[renderingIntent];

      if (!intentState.displayReadyCapability) {
        intentState.receivingOperatorList = true;
        intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
        intentState.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false
        };
        stats.time('Page Request');

        this._transport.messageHandler.send('RenderPageRequest', {
          pageIndex: this.pageNumber - 1,
          intent: renderingIntent,
          renderInteractiveForms: renderInteractiveForms === true
        });
      }

      var complete = function complete(error) {
        var i = intentState.renderTasks.indexOf(internalRenderTask);

        if (i >= 0) {
          intentState.renderTasks.splice(i, 1);
        }

        if (_this4.cleanupAfterRender) {
          _this4.pendingCleanup = true;
        }

        _this4._tryCleanup();

        if (error) {
          internalRenderTask.capability.reject(error);
        } else {
          internalRenderTask.capability.resolve();
        }

        stats.timeEnd('Rendering');
        stats.timeEnd('Overall');
      };

      var internalRenderTask = new InternalRenderTask({
        callback: complete,
        params: {
          canvasContext: canvasContext,
          viewport: viewport,
          transform: transform,
          imageLayer: imageLayer,
          background: background
        },
        objs: this.objs,
        commonObjs: this.commonObjs,
        operatorList: intentState.operatorList,
        pageNumber: this.pageNumber,
        canvasFactory: canvasFactoryInstance,
        webGLContext: webGLContext,
        useRequestAnimationFrame: renderingIntent !== 'print',
        pdfBug: this._pdfBug
      });

      if (!intentState.renderTasks) {
        intentState.renderTasks = [];
      }

      intentState.renderTasks.push(internalRenderTask);
      var renderTask = internalRenderTask.task;
      intentState.displayReadyCapability.promise.then(function (transparency) {
        if (_this4.pendingCleanup) {
          complete();
          return;
        }

        stats.time('Rendering');
        internalRenderTask.initializeGraphics(transparency);
        internalRenderTask.operatorListChanged();
      }).catch(complete);
      return renderTask;
    }
  }, {
    key: "getOperatorList",
    value: function getOperatorList() {
      function operatorListChanged() {
        if (intentState.operatorList.lastChunk) {
          intentState.opListReadCapability.resolve(intentState.operatorList);
          var i = intentState.renderTasks.indexOf(opListTask);

          if (i >= 0) {
            intentState.renderTasks.splice(i, 1);
          }
        }
      }

      var renderingIntent = 'oplist';

      if (!this.intentStates[renderingIntent]) {
        this.intentStates[renderingIntent] = Object.create(null);
      }

      var intentState = this.intentStates[renderingIntent];
      var opListTask;

      if (!intentState.opListReadCapability) {
        opListTask = {};
        opListTask.operatorListChanged = operatorListChanged;
        intentState.receivingOperatorList = true;
        intentState.opListReadCapability = (0, _util.createPromiseCapability)();
        intentState.renderTasks = [];
        intentState.renderTasks.push(opListTask);
        intentState.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false
        };

        this._stats.time('Page Request');

        this._transport.messageHandler.send('RenderPageRequest', {
          pageIndex: this.pageIndex,
          intent: renderingIntent
        });
      }

      return intentState.opListReadCapability.promise;
    }
  }, {
    key: "streamTextContent",
    value: function streamTextContent() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$normalizeWhites = _ref4.normalizeWhitespace,
          normalizeWhitespace = _ref4$normalizeWhites === void 0 ? false : _ref4$normalizeWhites,
          _ref4$disableCombineT = _ref4.disableCombineTextItems,
          disableCombineTextItems = _ref4$disableCombineT === void 0 ? false : _ref4$disableCombineT;

      var TEXT_CONTENT_CHUNK_SIZE = 100;
      return this._transport.messageHandler.sendWithStream('GetTextContent', {
        pageIndex: this.pageNumber - 1,
        normalizeWhitespace: normalizeWhitespace === true,
        combineTextItems: disableCombineTextItems !== true
      }, {
        highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
        size: function size(textContent) {
          return textContent.items.length;
        }
      });
    }
  }, {
    key: "getTextContent",
    value: function getTextContent() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var readableStream = this.streamTextContent(params);
      return new Promise(function (resolve, reject) {
        function pump() {
          reader.read().then(function (_ref5) {
            var _textContent$items;

            var value = _ref5.value,
                done = _ref5.done;

            if (done) {
              resolve(textContent);
              return;
            }

            Object.assign(textContent.styles, value.styles);

            (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));

            pump();
          }, reject);
        }

        var reader = readableStream.getReader();
        var textContent = {
          items: [],
          styles: Object.create(null)
        };
        pump();
      });
    }
  }, {
    key: "_destroy",
    value: function _destroy() {
      this.destroyed = true;
      this._transport.pageCache[this.pageIndex] = null;
      var waitOn = [];
      Object.keys(this.intentStates).forEach(function (intent) {
        if (intent === 'oplist') {
          return;
        }

        var intentState = this.intentStates[intent];
        intentState.renderTasks.forEach(function (renderTask) {
          var renderCompleted = renderTask.capability.promise.catch(function () {});
          waitOn.push(renderCompleted);
          renderTask.cancel();
        });
      }, this);
      this.objs.clear();
      this.annotationsPromise = null;
      this.pendingCleanup = false;
      return Promise.all(waitOn);
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.pendingCleanup = true;

      this._tryCleanup(resetStats);
    }
  }, {
    key: "_tryCleanup",
    value: function _tryCleanup() {
      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!this.pendingCleanup || Object.keys(this.intentStates).some(function (intent) {
        var intentState = this.intentStates[intent];
        return intentState.renderTasks.length !== 0 || intentState.receivingOperatorList;
      }, this)) {
        return;
      }

      Object.keys(this.intentStates).forEach(function (intent) {
        delete this.intentStates[intent];
      }, this);
      this.objs.clear();
      this.annotationsPromise = null;

      if (resetStats && this._stats instanceof _dom_utils.StatTimer) {
        this._stats = new _dom_utils.StatTimer();
      }

      this.pendingCleanup = false;
    }
  }, {
    key: "_startRenderPage",
    value: function _startRenderPage(transparency, intent) {
      var intentState = this.intentStates[intent];

      if (intentState.displayReadyCapability) {
        intentState.displayReadyCapability.resolve(transparency);
      }
    }
  }, {
    key: "_renderPageChunk",
    value: function _renderPageChunk(operatorListChunk, intent) {
      var intentState = this.intentStates[intent];

      for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {
        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
        intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
      }

      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;

      for (var _i = 0; _i < intentState.renderTasks.length; _i++) {
        intentState.renderTasks[_i].operatorListChanged();
      }

      if (operatorListChunk.lastChunk) {
        intentState.receivingOperatorList = false;

        this._tryCleanup();
      }
    }
  }, {
    key: "pageNumber",
    get: function get() {
      return this.pageIndex + 1;
    }
  }, {
    key: "rotate",
    get: function get() {
      return this._pageInfo.rotate;
    }
  }, {
    key: "ref",
    get: function get() {
      return this._pageInfo.ref;
    }
  }, {
    key: "userUnit",
    get: function get() {
      return this._pageInfo.userUnit;
    }
  }, {
    key: "view",
    get: function get() {
      return this._pageInfo.view;
    }
  }, {
    key: "stats",
    get: function get() {
      return this._stats instanceof _dom_utils.StatTimer ? this._stats : null;
    }
  }]);

  return PDFPageProxy;
}();

exports.PDFPageProxy = PDFPageProxy;

var LoopbackPort =
/*#__PURE__*/
function () {
  function LoopbackPort() {
    var defer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    _classCallCheck(this, LoopbackPort);

    this._listeners = [];
    this._defer = defer;
    this._deferred = Promise.resolve(undefined);
  }

  _createClass(LoopbackPort, [{
    key: "postMessage",
    value: function postMessage(obj, transfers) {
      var _this5 = this;

      function cloneValue(value) {
        if (_typeof(value) !== 'object' || value === null) {
          return value;
        }

        if (cloned.has(value)) {
          return cloned.get(value);
        }

        var buffer, result;

        if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
          var transferable = transfers && transfers.includes(buffer);

          if (value === buffer) {
            result = value;
          } else if (transferable) {
            result = new value.constructor(buffer, value.byteOffset, value.byteLength);
          } else {
            result = new value.constructor(value);
          }

          cloned.set(value, result);
          return result;
        }

        result = Array.isArray(value) ? [] : {};
        cloned.set(value, result);

        for (var i in value) {
          var desc = void 0,
              p = value;

          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
            p = Object.getPrototypeOf(p);
          }

          if (typeof desc.value === 'undefined' || typeof desc.value === 'function') {
            continue;
          }

          result[i] = cloneValue(desc.value);
        }

        return result;
      }

      if (!this._defer) {
        this._listeners.forEach(function (listener) {
          listener.call(this, {
            data: obj
          });
        }, this);

        return;
      }

      var cloned = new WeakMap();
      var e = {
        data: cloneValue(obj)
      };

      this._deferred.then(function () {
        _this5._listeners.forEach(function (listener) {
          listener.call(this, e);
        }, _this5);
      });
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(name, listener) {
      this._listeners.push(listener);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(name, listener) {
      var i = this._listeners.indexOf(listener);

      this._listeners.splice(i, 1);
    }
  }, {
    key: "terminate",
    value: function terminate() {
      this._listeners = [];
    }
  }]);

  return LoopbackPort;
}();

exports.LoopbackPort = LoopbackPort;

var PDFWorker = function PDFWorkerClosure() {
  var pdfWorkerPorts = new WeakMap();
  var nextFakeWorkerId = 0;
  var fakeWorkerFilesLoadedCapability;

  function _getWorkerSrc() {
    if (_worker_options.GlobalWorkerOptions.workerSrc) {
      return _worker_options.GlobalWorkerOptions.workerSrc;
    }

    if (typeof fallbackWorkerSrc !== 'undefined') {
      return fallbackWorkerSrc;
    }

    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }

  function getMainThreadWorkerMessageHandler() {
    try {
      if (typeof window !== 'undefined') {
        return window.pdfjsWorker && window.pdfjsWorker.WorkerMessageHandler;
      }
    } catch (ex) {}

    return null;
  }

  function setupFakeWorkerGlobal() {
    if (fakeWorkerFilesLoadedCapability) {
      return fakeWorkerFilesLoadedCapability.promise;
    }

    fakeWorkerFilesLoadedCapability = (0, _util.createPromiseCapability)();
    var mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();

    if (mainWorkerMessageHandler) {
      fakeWorkerFilesLoadedCapability.resolve(mainWorkerMessageHandler);
      return fakeWorkerFilesLoadedCapability.promise;
    }

    var loader = fakeWorkerFilesLoader || function () {
      return (0, _dom_utils.loadScript)(_getWorkerSrc()).then(function () {
        return window.pdfjsWorker.WorkerMessageHandler;
      });
    };

    loader().then(fakeWorkerFilesLoadedCapability.resolve, fakeWorkerFilesLoadedCapability.reject);
    return fakeWorkerFilesLoadedCapability.promise;
  }

  function createCDNWrapper(url) {
    var wrapper = 'importScripts(\'' + url + '\');';
    return _util.URL.createObjectURL(new Blob([wrapper]));
  }

  var PDFWorker =
  /*#__PURE__*/
  function () {
    function PDFWorker() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$name = _ref6.name,
          name = _ref6$name === void 0 ? null : _ref6$name,
          _ref6$port = _ref6.port,
          port = _ref6$port === void 0 ? null : _ref6$port,
          _ref6$postMessageTran = _ref6.postMessageTransfers,
          postMessageTransfers = _ref6$postMessageTran === void 0 ? true : _ref6$postMessageTran,
          _ref6$verbosity = _ref6.verbosity,
          verbosity = _ref6$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref6$verbosity;

      _classCallCheck(this, PDFWorker);

      if (port && pdfWorkerPorts.has(port)) {
        throw new Error('Cannot use more than one PDFWorker per port');
      }

      this.name = name;
      this.destroyed = false;
      this.postMessageTransfers = postMessageTransfers !== false;
      this.verbosity = verbosity;
      this._readyCapability = (0, _util.createPromiseCapability)();
      this._port = null;
      this._webWorker = null;
      this._messageHandler = null;

      if (port) {
        pdfWorkerPorts.set(port, this);

        this._initializeFromPort(port);

        return;
      }

      this._initialize();
    }

    _createClass(PDFWorker, [{
      key: "_initializeFromPort",
      value: function _initializeFromPort(port) {
        this._port = port;
        this._messageHandler = new _message_handler.MessageHandler('main', 'worker', port);

        this._messageHandler.on('ready', function () {});

        this._readyCapability.resolve();
      }
    }, {
      key: "_initialize",
      value: function _initialize() {
        var _this6 = this;

        if (typeof Worker !== 'undefined' && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
          var workerSrc = _getWorkerSrc();

          try {
            if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
              workerSrc = createCDNWrapper(new _util.URL(workerSrc, window.location).href);
            }

            var worker = new Worker(workerSrc);
            var messageHandler = new _message_handler.MessageHandler('main', 'worker', worker);

            var terminateEarly = function terminateEarly() {
              worker.removeEventListener('error', onWorkerError);
              messageHandler.destroy();
              worker.terminate();

              if (_this6.destroyed) {
                _this6._readyCapability.reject(new Error('Worker was destroyed'));
              } else {
                _this6._setupFakeWorker();
              }
            };

            var onWorkerError = function onWorkerError() {
              if (!_this6._webWorker) {
                terminateEarly();
              }
            };

            worker.addEventListener('error', onWorkerError);
            messageHandler.on('test', function (data) {
              worker.removeEventListener('error', onWorkerError);

              if (_this6.destroyed) {
                terminateEarly();
                return;
              }

              if (data && data.supportTypedArray) {
                _this6._messageHandler = messageHandler;
                _this6._port = worker;
                _this6._webWorker = worker;

                if (!data.supportTransfers) {
                  _this6.postMessageTransfers = false;
                }

                _this6._readyCapability.resolve();

                messageHandler.send('configure', {
                  verbosity: _this6.verbosity
                });
              } else {
                _this6._setupFakeWorker();

                messageHandler.destroy();
                worker.terminate();
              }
            });
            messageHandler.on('ready', function (data) {
              worker.removeEventListener('error', onWorkerError);

              if (_this6.destroyed) {
                terminateEarly();
                return;
              }

              try {
                sendTest();
              } catch (e) {
                _this6._setupFakeWorker();
              }
            });

            var sendTest = function sendTest() {
              var testObj = new Uint8Array([_this6.postMessageTransfers ? 255 : 0]);

              try {
                messageHandler.send('test', testObj, [testObj.buffer]);
              } catch (ex) {
                (0, _util.info)('Cannot use postMessage transfers');
                testObj[0] = 0;
                messageHandler.send('test', testObj);
              }
            };

            sendTest();
            return;
          } catch (e) {
            (0, _util.info)('The worker has been disabled.');
          }
        }

        this._setupFakeWorker();
      }
    }, {
      key: "_setupFakeWorker",
      value: function _setupFakeWorker() {
        var _this7 = this;

        if (!isWorkerDisabled) {
          (0, _util.warn)('Setting up fake worker.');
          isWorkerDisabled = true;
        }

        setupFakeWorkerGlobal().then(function (WorkerMessageHandler) {
          if (_this7.destroyed) {
            _this7._readyCapability.reject(new Error('Worker was destroyed'));

            return;
          }

          var port = new LoopbackPort();
          _this7._port = port;
          var id = 'fake' + nextFakeWorkerId++;
          var workerHandler = new _message_handler.MessageHandler(id + '_worker', id, port);
          WorkerMessageHandler.setup(workerHandler, port);
          var messageHandler = new _message_handler.MessageHandler(id, id + '_worker', port);
          _this7._messageHandler = messageHandler;

          _this7._readyCapability.resolve();
        }).catch(function (reason) {
          _this7._readyCapability.reject(new Error("Setting up fake worker failed: \"".concat(reason.message, "\".")));
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.destroyed = true;

        if (this._webWorker) {
          this._webWorker.terminate();

          this._webWorker = null;
        }

        pdfWorkerPorts.delete(this._port);
        this._port = null;

        if (this._messageHandler) {
          this._messageHandler.destroy();

          this._messageHandler = null;
        }
      }
    }, {
      key: "promise",
      get: function get() {
        return this._readyCapability.promise;
      }
    }, {
      key: "port",
      get: function get() {
        return this._port;
      }
    }, {
      key: "messageHandler",
      get: function get() {
        return this._messageHandler;
      }
    }], [{
      key: "fromPort",
      value: function fromPort(params) {
        if (!params || !params.port) {
          throw new Error('PDFWorker.fromPort - invalid method signature.');
        }

        if (pdfWorkerPorts.has(params.port)) {
          return pdfWorkerPorts.get(params.port);
        }

        return new PDFWorker(params);
      }
    }, {
      key: "getWorkerSrc",
      value: function getWorkerSrc() {
        return _getWorkerSrc();
      }
    }]);

    return PDFWorker;
  }();

  return PDFWorker;
}();

exports.PDFWorker = PDFWorker;

var WorkerTransport =
/*#__PURE__*/
function () {
  function WorkerTransport(messageHandler, loadingTask, networkStream, params) {
    _classCallCheck(this, WorkerTransport);

    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new _font_loader.FontLoader({
      docId: loadingTask.docId,
      onUnsupportedFeature: this._onUnsupportedFeature.bind(this)
    });
    this._params = params;
    this.CMapReaderFactory = new params.CMapReaderFactory({
      baseUrl: params.cMapUrl,
      isCompressed: params.cMapPacked
    });
    this.destroyed = false;
    this.destroyCapability = null;
    this._passwordCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.pageCache = [];
    this.pagePromises = [];
    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
    this.setupMessageHandler();
  }

  _createClass(WorkerTransport, [{
    key: "destroy",
    value: function destroy() {
      var _this8 = this;

      if (this.destroyCapability) {
        return this.destroyCapability.promise;
      }

      this.destroyed = true;
      this.destroyCapability = (0, _util.createPromiseCapability)();

      if (this._passwordCapability) {
        this._passwordCapability.reject(new Error('Worker was destroyed during onPassword callback'));
      }

      var waitOn = [];
      this.pageCache.forEach(function (page) {
        if (page) {
          waitOn.push(page._destroy());
        }
      });
      this.pageCache = [];
      this.pagePromises = [];
      var terminated = this.messageHandler.sendWithPromise('Terminate', null);
      waitOn.push(terminated);
      Promise.all(waitOn).then(function () {
        _this8.fontLoader.clear();

        if (_this8._networkStream) {
          _this8._networkStream.cancelAllRequests();
        }

        if (_this8.messageHandler) {
          _this8.messageHandler.destroy();

          _this8.messageHandler = null;
        }

        _this8.destroyCapability.resolve();
      }, this.destroyCapability.reject);
      return this.destroyCapability.promise;
    }
  }, {
    key: "setupMessageHandler",
    value: function setupMessageHandler() {
      var messageHandler = this.messageHandler,
          loadingTask = this.loadingTask;
      messageHandler.on('GetReader', function (data, sink) {
        var _this9 = this;

        (0, _util.assert)(this._networkStream);
        this._fullReader = this._networkStream.getFullReader();

        this._fullReader.onProgress = function (evt) {
          _this9._lastProgress = {
            loaded: evt.loaded,
            total: evt.total
          };
        };

        sink.onPull = function () {
          _this9._fullReader.read().then(function (_ref7) {
            var value = _ref7.value,
                done = _ref7.done;

            if (done) {
              sink.close();
              return;
            }

            (0, _util.assert)((0, _util.isArrayBuffer)(value));
            sink.enqueue(new Uint8Array(value), 1, [value]);
          }).catch(function (reason) {
            sink.error(reason);
          });
        };

        sink.onCancel = function (reason) {
          _this9._fullReader.cancel(reason);
        };
      }, this);
      messageHandler.on('ReaderHeadersReady', function (data) {
        var _this10 = this;

        var headersCapability = (0, _util.createPromiseCapability)();
        var fullReader = this._fullReader;
        fullReader.headersReady.then(function () {
          if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
            if (_this10._lastProgress && loadingTask.onProgress) {
              loadingTask.onProgress(_this10._lastProgress);
            }

            fullReader.onProgress = function (evt) {
              if (loadingTask.onProgress) {
                loadingTask.onProgress({
                  loaded: evt.loaded,
                  total: evt.total
                });
              }
            };
          }

          headersCapability.resolve({
            isStreamingSupported: fullReader.isStreamingSupported,
            isRangeSupported: fullReader.isRangeSupported,
            contentLength: fullReader.contentLength
          });
        }, headersCapability.reject);
        return headersCapability.promise;
      }, this);
      messageHandler.on('GetRangeReader', function (data, sink) {
        (0, _util.assert)(this._networkStream);

        var rangeReader = this._networkStream.getRangeReader(data.begin, data.end);

        sink.onPull = function () {
          rangeReader.read().then(function (_ref8) {
            var value = _ref8.value,
                done = _ref8.done;

            if (done) {
              sink.close();
              return;
            }

            (0, _util.assert)((0, _util.isArrayBuffer)(value));
            sink.enqueue(new Uint8Array(value), 1, [value]);
          }).catch(function (reason) {
            sink.error(reason);
          });
        };

        sink.onCancel = function (reason) {
          rangeReader.cancel(reason);
        };
      }, this);
      messageHandler.on('GetDoc', function (_ref9) {
        var pdfInfo = _ref9.pdfInfo;
        this.numPages = pdfInfo.numPages;
        this.pdfDocument = new PDFDocumentProxy(pdfInfo, this, loadingTask);

        loadingTask._capability.resolve(this.pdfDocument);
      }, this);
      messageHandler.on('PasswordRequest', function (exception) {
        var _this11 = this;

        this._passwordCapability = (0, _util.createPromiseCapability)();

        if (loadingTask.onPassword) {
          var updatePassword = function updatePassword(password) {
            _this11._passwordCapability.resolve({
              password: password
            });
          };

          try {
            loadingTask.onPassword(updatePassword, exception.code);
          } catch (ex) {
            this._passwordCapability.reject(ex);
          }
        } else {
          this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
        }

        return this._passwordCapability.promise;
      }, this);
      messageHandler.on('PasswordException', function (exception) {
        loadingTask._capability.reject(new _util.PasswordException(exception.message, exception.code));
      }, this);
      messageHandler.on('InvalidPDF', function (exception) {
        loadingTask._capability.reject(new _util.InvalidPDFException(exception.message));
      }, this);
      messageHandler.on('MissingPDF', function (exception) {
        loadingTask._capability.reject(new _util.MissingPDFException(exception.message));
      }, this);
      messageHandler.on('UnexpectedResponse', function (exception) {
        loadingTask._capability.reject(new _util.UnexpectedResponseException(exception.message, exception.status));
      }, this);
      messageHandler.on('UnknownError', function (exception) {
        loadingTask._capability.reject(new _util.UnknownErrorException(exception.message, exception.details));
      }, this);
      messageHandler.on('DataLoaded', function (data) {
        if (loadingTask.onProgress) {
          loadingTask.onProgress({
            loaded: data.length,
            total: data.length
          });
        }

        this.downloadInfoCapability.resolve(data);
      }, this);
      messageHandler.on('StartRenderPage', function (data) {
        if (this.destroyed) {
          return;
        }

        var page = this.pageCache[data.pageIndex];

        page._stats.timeEnd('Page Request');

        page._startRenderPage(data.transparency, data.intent);
      }, this);
      messageHandler.on('RenderPageChunk', function (data) {
        if (this.destroyed) {
          return;
        }

        var page = this.pageCache[data.pageIndex];

        page._renderPageChunk(data.operatorList, data.intent);
      }, this);
      messageHandler.on('commonobj', function (data) {
        var _this12 = this;

        if (this.destroyed) {
          return;
        }

        var _data = _slicedToArray(data, 3),
            id = _data[0],
            type = _data[1],
            exportedData = _data[2];

        if (this.commonObjs.has(id)) {
          return;
        }

        switch (type) {
          case 'Font':
            var params = this._params;

            if ('error' in exportedData) {
              var exportedError = exportedData.error;
              (0, _util.warn)("Error during font loading: ".concat(exportedError));
              this.commonObjs.resolve(id, exportedError);
              break;
            }

            var fontRegistry = null;

            if (params.pdfBug && _global_scope.default.FontInspector && _global_scope.default.FontInspector.enabled) {
              fontRegistry = {
                registerFont: function registerFont(font, url) {
                  _global_scope.default['FontInspector'].fontAdded(font, url);
                }
              };
            }

            var font = new _font_loader.FontFaceObject(exportedData, {
              isEvalSupported: params.isEvalSupported,
              disableFontFace: params.disableFontFace,
              ignoreErrors: params.ignoreErrors,
              onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
              fontRegistry: fontRegistry
            });
            this.fontLoader.bind(font).then(function () {
              _this12.commonObjs.resolve(id, font);
            }, function (reason) {
              messageHandler.sendWithPromise('FontFallback', {
                id: id
              }).finally(function () {
                _this12.commonObjs.resolve(id, font);
              });
            });
            break;

          case 'FontPath':
            this.commonObjs.resolve(id, exportedData);
            break;

          default:
            throw new Error("Got unknown common object type ".concat(type));
        }
      }, this);
      messageHandler.on('obj', function (data) {
        if (this.destroyed) {
          return;
        }

        var _data2 = _slicedToArray(data, 4),
            id = _data2[0],
            pageIndex = _data2[1],
            type = _data2[2],
            imageData = _data2[3];

        var pageProxy = this.pageCache[pageIndex];

        if (pageProxy.objs.has(id)) {
          return;
        }

        switch (type) {
          case 'JpegStream':
            return new Promise(function (resolve, reject) {
              var img = new Image();

              img.onload = function () {
                resolve(img);
              };

              img.onerror = function () {
                reject(new Error('Error during JPEG image loading'));
              };

              img.src = imageData;
            }).then(function (img) {
              pageProxy.objs.resolve(id, img);
            });

          case 'Image':
            pageProxy.objs.resolve(id, imageData);
            var MAX_IMAGE_SIZE_TO_STORE = 8000000;

            if (imageData && 'data' in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {
              pageProxy.cleanupAfterRender = true;
            }

            break;

          default:
            throw new Error("Got unknown object type ".concat(type));
        }
      }, this);
      messageHandler.on('DocProgress', function (data) {
        if (this.destroyed) {
          return;
        }

        if (loadingTask.onProgress) {
          loadingTask.onProgress({
            loaded: data.loaded,
            total: data.total
          });
        }
      }, this);
      messageHandler.on('PageError', function (data) {
        if (this.destroyed) {
          return;
        }

        var page = this.pageCache[data.pageNum - 1];
        var intentState = page.intentStates[data.intent];

        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(data.error);
        } else {
          throw new Error(data.error);
        }

        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;

          for (var i = 0; i < intentState.renderTasks.length; i++) {
            intentState.renderTasks[i].operatorListChanged();
          }
        }
      }, this);
      messageHandler.on('UnsupportedFeature', this._onUnsupportedFeature, this);
      messageHandler.on('JpegDecode', function (data) {
        if (this.destroyed) {
          return Promise.reject(new Error('Worker was destroyed'));
        }

        if (typeof document === 'undefined') {
          return Promise.reject(new Error('"document" is not defined.'));
        }

        var _data3 = _slicedToArray(data, 2),
            imageUrl = _data3[0],
            components = _data3[1];

        if (components !== 3 && components !== 1) {
          return Promise.reject(new Error('Only 3 components or 1 component can be returned'));
        }

        return new Promise(function (resolve, reject) {
          var img = new Image();

          img.onload = function () {
            var width = img.width;
            var height = img.height;
            var size = width * height;
            var rgbaLength = size * 4;
            var buf = new Uint8ClampedArray(size * components);
            var tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = width;
            tmpCanvas.height = height;
            var tmpCtx = tmpCanvas.getContext('2d');
            tmpCtx.drawImage(img, 0, 0);
            var data = tmpCtx.getImageData(0, 0, width, height).data;

            if (components === 3) {
              for (var i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {
                buf[j] = data[i];
                buf[j + 1] = data[i + 1];
                buf[j + 2] = data[i + 2];
              }
            } else if (components === 1) {
              for (var _i2 = 0, _j = 0; _i2 < rgbaLength; _i2 += 4, _j++) {
                buf[_j] = data[_i2];
              }
            }

            resolve({
              data: buf,
              width: width,
              height: height
            });
          };

          img.onerror = function () {
            reject(new Error('JpegDecode failed to load image'));
          };

          img.src = imageUrl;
        });
      }, this);
      messageHandler.on('FetchBuiltInCMap', function (data) {
        if (this.destroyed) {
          return Promise.reject(new Error('Worker was destroyed'));
        }

        return this.CMapReaderFactory.fetch({
          name: data.name
        });
      }, this);
    }
  }, {
    key: "_onUnsupportedFeature",
    value: function _onUnsupportedFeature(_ref10) {
      var featureId = _ref10.featureId;

      if (this.destroyed) {
        return;
      }

      if (this.loadingTask.onUnsupportedFeature) {
        this.loadingTask.onUnsupportedFeature(featureId);
      }
    }
  }, {
    key: "getData",
    value: function getData() {
      return this.messageHandler.sendWithPromise('GetData', null);
    }
  }, {
    key: "getPage",
    value: function getPage(pageNumber) {
      var _this13 = this;

      if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this.numPages) {
        return Promise.reject(new Error('Invalid page request'));
      }

      var pageIndex = pageNumber - 1;

      if (pageIndex in this.pagePromises) {
        return this.pagePromises[pageIndex];
      }

      var promise = this.messageHandler.sendWithPromise('GetPage', {
        pageIndex: pageIndex
      }).then(function (pageInfo) {
        if (_this13.destroyed) {
          throw new Error('Transport destroyed');
        }

        var page = new PDFPageProxy(pageIndex, pageInfo, _this13, _this13._params.pdfBug);
        _this13.pageCache[pageIndex] = page;
        return page;
      });
      this.pagePromises[pageIndex] = promise;
      return promise;
    }
  }, {
    key: "getPageIndex",
    value: function getPageIndex(ref) {
      return this.messageHandler.sendWithPromise('GetPageIndex', {
        ref: ref
      }).catch(function (reason) {
        return Promise.reject(new Error(reason));
      });
    }
  }, {
    key: "getAnnotations",
    value: function getAnnotations(pageIndex, intent) {
      return this.messageHandler.sendWithPromise('GetAnnotations', {
        pageIndex: pageIndex,
        intent: intent
      });
    }
  }, {
    key: "getDestinations",
    value: function getDestinations() {
      return this.messageHandler.sendWithPromise('GetDestinations', null);
    }
  }, {
    key: "getDestination",
    value: function getDestination(id) {
      if (typeof id !== 'string') {
        return Promise.reject(new Error('Invalid destination request.'));
      }

      return this.messageHandler.sendWithPromise('GetDestination', {
        id: id
      });
    }
  }, {
    key: "getPageLabels",
    value: function getPageLabels() {
      return this.messageHandler.sendWithPromise('GetPageLabels', null);
    }
  }, {
    key: "getPageMode",
    value: function getPageMode() {
      return this.messageHandler.sendWithPromise('GetPageMode', null);
    }
  }, {
    key: "getOpenActionDestination",
    value: function getOpenActionDestination() {
      return this.messageHandler.sendWithPromise('getOpenActionDestination', null);
    }
  }, {
    key: "getAttachments",
    value: function getAttachments() {
      return this.messageHandler.sendWithPromise('GetAttachments', null);
    }
  }, {
    key: "getJavaScript",
    value: function getJavaScript() {
      return this.messageHandler.sendWithPromise('GetJavaScript', null);
    }
  }, {
    key: "getOutline",
    value: function getOutline() {
      return this.messageHandler.sendWithPromise('GetOutline', null);
    }
  }, {
    key: "getPermissions",
    value: function getPermissions() {
      return this.messageHandler.sendWithPromise('GetPermissions', null);
    }
  }, {
    key: "getMetadata",
    value: function getMetadata() {
      var _this14 = this;

      return this.messageHandler.sendWithPromise('GetMetadata', null).then(function (results) {
        return {
          info: results[0],
          metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
          contentDispositionFilename: _this14._fullReader ? _this14._fullReader.filename : null
        };
      });
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.messageHandler.sendWithPromise('GetStats', null);
    }
  }, {
    key: "startCleanup",
    value: function startCleanup() {
      var _this15 = this;

      this.messageHandler.sendWithPromise('Cleanup', null).then(function () {
        for (var i = 0, ii = _this15.pageCache.length; i < ii; i++) {
          var page = _this15.pageCache[i];

          if (page) {
            page.cleanup();
          }
        }

        _this15.commonObjs.clear();

        _this15.fontLoader.clear();
      });
    }
  }, {
    key: "loadingParams",
    get: function get() {
      var params = this._params;
      return (0, _util.shadow)(this, 'loadingParams', {
        disableAutoFetch: params.disableAutoFetch,
        disableCreateObjectURL: params.disableCreateObjectURL,
        disableFontFace: params.disableFontFace,
        nativeImageDecoderSupport: params.nativeImageDecoderSupport
      });
    }
  }]);

  return WorkerTransport;
}();

var PDFObjects =
/*#__PURE__*/
function () {
  function PDFObjects() {
    _classCallCheck(this, PDFObjects);

    this._objs = Object.create(null);
  }

  _createClass(PDFObjects, [{
    key: "_ensureObj",
    value: function _ensureObj(objId) {
      if (this._objs[objId]) {
        return this._objs[objId];
      }

      return this._objs[objId] = {
        capability: (0, _util.createPromiseCapability)(),
        data: null,
        resolved: false
      };
    }
  }, {
    key: "get",
    value: function get(objId) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (callback) {
        this._ensureObj(objId).capability.promise.then(callback);

        return null;
      }

      var obj = this._objs[objId];

      if (!obj || !obj.resolved) {
        throw new Error("Requesting object that isn't resolved yet ".concat(objId, "."));
      }

      return obj.data;
    }
  }, {
    key: "has",
    value: function has(objId) {
      var obj = this._objs[objId];
      return obj ? obj.resolved : false;
    }
  }, {
    key: "resolve",
    value: function resolve(objId, data) {
      var obj = this._ensureObj(objId);

      obj.resolved = true;
      obj.data = data;
      obj.capability.resolve(data);
    }
  }, {
    key: "clear",
    value: function clear() {
      this._objs = Object.create(null);
    }
  }]);

  return PDFObjects;
}();

var RenderTask =
/*#__PURE__*/
function () {
  function RenderTask(internalRenderTask) {
    _classCallCheck(this, RenderTask);

    this._internalRenderTask = internalRenderTask;
    this.onContinue = null;
  }

  _createClass(RenderTask, [{
    key: "cancel",
    value: function cancel() {
      this._internalRenderTask.cancel();
    }
  }, {
    key: "then",
    value: function then(onFulfilled, onRejected) {
      (0, _util.deprecated)('RenderTask.then method, use the `promise` getter instead.');
      return this.promise.then.apply(this.promise, arguments);
    }
  }, {
    key: "promise",
    get: function get() {
      return this._internalRenderTask.capability.promise;
    }
  }]);

  return RenderTask;
}();

var InternalRenderTask = function InternalRenderTaskClosure() {
  var canvasInRendering = new WeakSet();

  var InternalRenderTask =
  /*#__PURE__*/
  function () {
    function InternalRenderTask(_ref11) {
      var callback = _ref11.callback,
          params = _ref11.params,
          objs = _ref11.objs,
          commonObjs = _ref11.commonObjs,
          operatorList = _ref11.operatorList,
          pageNumber = _ref11.pageNumber,
          canvasFactory = _ref11.canvasFactory,
          webGLContext = _ref11.webGLContext,
          _ref11$useRequestAnim = _ref11.useRequestAnimationFrame,
          useRequestAnimationFrame = _ref11$useRequestAnim === void 0 ? false : _ref11$useRequestAnim,
          _ref11$pdfBug = _ref11.pdfBug,
          pdfBug = _ref11$pdfBug === void 0 ? false : _ref11$pdfBug;

      _classCallCheck(this, InternalRenderTask);

      this.callback = callback;
      this.params = params;
      this.objs = objs;
      this.commonObjs = commonObjs;
      this.operatorListIdx = null;
      this.operatorList = operatorList;
      this.pageNumber = pageNumber;
      this.canvasFactory = canvasFactory;
      this.webGLContext = webGLContext;
      this._pdfBug = pdfBug;
      this.running = false;
      this.graphicsReadyCallback = null;
      this.graphicsReady = false;
      this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== 'undefined';
      this.cancelled = false;
      this.capability = (0, _util.createPromiseCapability)();
      this.task = new RenderTask(this);
      this._continueBound = this._continue.bind(this);
      this._scheduleNextBound = this._scheduleNext.bind(this);
      this._nextBound = this._next.bind(this);
      this._canvas = params.canvasContext.canvas;
    }

    _createClass(InternalRenderTask, [{
      key: "initializeGraphics",
      value: function initializeGraphics() {
        var transparency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (this.cancelled) {
          return;
        }

        if (this._canvas) {
          if (canvasInRendering.has(this._canvas)) {
            throw new Error('Cannot use the same canvas during multiple render() operations. ' + 'Use different canvas or ensure previous operations were ' + 'cancelled or completed.');
          }

          canvasInRendering.add(this._canvas);
        }

        if (this._pdfBug && _global_scope.default.StepperManager && _global_scope.default.StepperManager.enabled) {
          this.stepper = _global_scope.default.StepperManager.create(this.pageNumber - 1);
          this.stepper.init(this.operatorList);
          this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
        }

        var _this$params = this.params,
            canvasContext = _this$params.canvasContext,
            viewport = _this$params.viewport,
            transform = _this$params.transform,
            imageLayer = _this$params.imageLayer,
            background = _this$params.background;
        this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer);
        this.gfx.beginDrawing({
          transform: transform,
          viewport: viewport,
          transparency: transparency,
          background: background
        });
        this.operatorListIdx = 0;
        this.graphicsReady = true;

        if (this.graphicsReadyCallback) {
          this.graphicsReadyCallback();
        }
      }
    }, {
      key: "cancel",
      value: function cancel() {
        var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        this.running = false;
        this.cancelled = true;

        if (this.gfx) {
          this.gfx.endDrawing();
        }

        if (this._canvas) {
          canvasInRendering.delete(this._canvas);
        }

        this.callback(error || new _dom_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this.pageNumber), 'canvas'));
      }
    }, {
      key: "operatorListChanged",
      value: function operatorListChanged() {
        if (!this.graphicsReady) {
          if (!this.graphicsReadyCallback) {
            this.graphicsReadyCallback = this._continueBound;
          }

          return;
        }

        if (this.stepper) {
          this.stepper.updateOperatorList(this.operatorList);
        }

        if (this.running) {
          return;
        }

        this._continue();
      }
    }, {
      key: "_continue",
      value: function _continue() {
        this.running = true;

        if (this.cancelled) {
          return;
        }

        if (this.task.onContinue) {
          this.task.onContinue(this._scheduleNextBound);
        } else {
          this._scheduleNext();
        }
      }
    }, {
      key: "_scheduleNext",
      value: function _scheduleNext() {
        var _this16 = this;

        if (this._useRequestAnimationFrame) {
          window.requestAnimationFrame(function () {
            _this16._nextBound().catch(_this16.cancel.bind(_this16));
          });
        } else {
          Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this));
        }
      }
    }, {
      key: "_next",
      value: function () {
        var _next2 = _asyncToGenerator(
        /*#__PURE__*/
        _regenerator.default.mark(function _callee() {
          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!this.cancelled) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return");

                case 2:
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;

                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing();

                      if (this._canvas) {
                        canvasInRendering.delete(this._canvas);
                      }

                      this.callback();
                    }
                  }

                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function _next() {
          return _next2.apply(this, arguments);
        }

        return _next;
      }()
    }]);

    return InternalRenderTask;
  }();

  return InternalRenderTask;
}();

var version = '2.1.266';
exports.version = version;
var build = '81f5835c';
exports.build = build;

/***/ }),
/* 147 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = __w_pdfjs_require__(148);

/***/ }),
/* 148 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g = function () {
  return this || (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self;
}() || Function("return this")();

var hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
var oldRuntime = hadRuntime && g.regeneratorRuntime;
g.regeneratorRuntime = undefined;
module.exports = __w_pdfjs_require__(149);

if (hadRuntime) {
  g.regeneratorRuntime = oldRuntime;
} else {
  try {
    delete g.regeneratorRuntime;
  } catch (e) {
    g.regeneratorRuntime = undefined;
  }
}

/***/ }),
/* 149 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined;
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = ( false ? undefined : _typeof(module)) === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      module.exports = runtime;
    }

    return;
  }

  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);
    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap;

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator;

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      context[delegate.resultName] = info.value;
      context.next = delegate.nextLoc;

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      return info;
    }

    context.delegate = null;
    return ContinueSentinel;
  }

  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator";

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse();
    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}(function () {
  return this || (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self;
}() || Function("return this")());
/* WEBPACK VAR INJECTION */}.call(this, __w_pdfjs_require__(150)(module)))

/***/ }),
/* 150 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = [];
    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 151 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addLinkAttributes = addLinkAttributes;
exports.getFilenameFromUrl = getFilenameFromUrl;
exports.loadScript = loadScript;
exports.DummyStatTimer = exports.StatTimer = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.LinkTarget = exports.RenderingCancelledException = exports.PageViewport = void 0;

var _util = __w_pdfjs_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DEFAULT_LINK_REL = 'noopener noreferrer nofollow';
exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
var SVG_NS = 'http://www.w3.org/2000/svg';

var DOMCanvasFactory =
/*#__PURE__*/
function () {
  function DOMCanvasFactory() {
    _classCallCheck(this, DOMCanvasFactory);
  }

  _createClass(DOMCanvasFactory, [{
    key: "create",
    value: function create(width, height) {
      if (width <= 0 || height <= 0) {
        throw new Error('invalid canvas size');
      }

      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.width = width;
      canvas.height = height;
      return {
        canvas: canvas,
        context: context
      };
    }
  }, {
    key: "reset",
    value: function reset(canvasAndContext, width, height) {
      if (!canvasAndContext.canvas) {
        throw new Error('canvas is not specified');
      }

      if (width <= 0 || height <= 0) {
        throw new Error('invalid canvas size');
      }

      canvasAndContext.canvas.width = width;
      canvasAndContext.canvas.height = height;
    }
  }, {
    key: "destroy",
    value: function destroy(canvasAndContext) {
      if (!canvasAndContext.canvas) {
        throw new Error('canvas is not specified');
      }

      canvasAndContext.canvas.width = 0;
      canvasAndContext.canvas.height = 0;
      canvasAndContext.canvas = null;
      canvasAndContext.context = null;
    }
  }]);

  return DOMCanvasFactory;
}();

exports.DOMCanvasFactory = DOMCanvasFactory;

var DOMCMapReaderFactory =
/*#__PURE__*/
function () {
  function DOMCMapReaderFactory(_ref) {
    var _ref$baseUrl = _ref.baseUrl,
        baseUrl = _ref$baseUrl === void 0 ? null : _ref$baseUrl,
        _ref$isCompressed = _ref.isCompressed,
        isCompressed = _ref$isCompressed === void 0 ? false : _ref$isCompressed;

    _classCallCheck(this, DOMCMapReaderFactory);

    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }

  _createClass(DOMCMapReaderFactory, [{
    key: "fetch",
    value: function fetch(_ref2) {
      var _this = this;

      var name = _ref2.name;

      if (!this.baseUrl) {
        return Promise.reject(new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.'));
      }

      if (!name) {
        return Promise.reject(new Error('CMap name must be specified.'));
      }

      return new Promise(function (resolve, reject) {
        var url = _this.baseUrl + name + (_this.isCompressed ? '.bcmap' : '');
        var request = new XMLHttpRequest();
        request.open('GET', url, true);

        if (_this.isCompressed) {
          request.responseType = 'arraybuffer';
        }

        request.onreadystatechange = function () {
          if (request.readyState !== XMLHttpRequest.DONE) {
            return;
          }

          if (request.status === 200 || request.status === 0) {
            var data;

            if (_this.isCompressed && request.response) {
              data = new Uint8Array(request.response);
            } else if (!_this.isCompressed && request.responseText) {
              data = (0, _util.stringToBytes)(request.responseText);
            }

            if (data) {
              resolve({
                cMapData: data,
                compressionType: _this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE
              });
              return;
            }
          }

          reject(new Error('Unable to load ' + (_this.isCompressed ? 'binary ' : '') + 'CMap at: ' + url));
        };

        request.send(null);
      });
    }
  }]);

  return DOMCMapReaderFactory;
}();

exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

var DOMSVGFactory =
/*#__PURE__*/
function () {
  function DOMSVGFactory() {
    _classCallCheck(this, DOMSVGFactory);
  }

  _createClass(DOMSVGFactory, [{
    key: "create",
    value: function create(width, height) {
      (0, _util.assert)(width > 0 && height > 0, 'Invalid SVG dimensions');
      var svg = document.createElementNS(SVG_NS, 'svg:svg');
      svg.setAttribute('version', '1.1');
      svg.setAttribute('width', width + 'px');
      svg.setAttribute('height', height + 'px');
      svg.setAttribute('preserveAspectRatio', 'none');
      svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);
      return svg;
    }
  }, {
    key: "createElement",
    value: function createElement(type) {
      (0, _util.assert)(typeof type === 'string', 'Invalid SVG element type');
      return document.createElementNS(SVG_NS, type);
    }
  }]);

  return DOMSVGFactory;
}();

exports.DOMSVGFactory = DOMSVGFactory;

var PageViewport =
/*#__PURE__*/
function () {
  function PageViewport(_ref3) {
    var viewBox = _ref3.viewBox,
        scale = _ref3.scale,
        rotation = _ref3.rotation,
        _ref3$offsetX = _ref3.offsetX,
        offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX,
        _ref3$offsetY = _ref3.offsetY,
        offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY,
        _ref3$dontFlip = _ref3.dontFlip,
        dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;

    _classCallCheck(this, PageViewport);

    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;

    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;

      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;

      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;

      default:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
    }

    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }

    var offsetCanvasX, offsetCanvasY;
    var width, height;

    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }

    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }

  _createClass(PageViewport, [{
    key: "clone",
    value: function clone() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$scale = _ref4.scale,
          scale = _ref4$scale === void 0 ? this.scale : _ref4$scale,
          _ref4$rotation = _ref4.rotation,
          rotation = _ref4$rotation === void 0 ? this.rotation : _ref4$rotation,
          _ref4$dontFlip = _ref4.dontFlip,
          dontFlip = _ref4$dontFlip === void 0 ? false : _ref4$dontFlip;

      return new PageViewport({
        viewBox: this.viewBox.slice(),
        scale: scale,
        rotation: rotation,
        offsetX: this.offsetX,
        offsetY: this.offsetY,
        dontFlip: dontFlip
      });
    }
  }, {
    key: "convertToViewportPoint",
    value: function convertToViewportPoint(x, y) {
      return _util.Util.applyTransform([x, y], this.transform);
    }
  }, {
    key: "convertToViewportRectangle",
    value: function convertToViewportRectangle(rect) {
      var tl = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

      var br = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

      return [tl[0], tl[1], br[0], br[1]];
    }
  }, {
    key: "convertToPdfPoint",
    value: function convertToPdfPoint(x, y) {
      return _util.Util.applyInverseTransform([x, y], this.transform);
    }
  }]);

  return PageViewport;
}();

exports.PageViewport = PageViewport;

var RenderingCancelledException = function RenderingCancelledException() {
  function RenderingCancelledException(msg, type) {
    this.message = msg;
    this.type = type;
  }

  RenderingCancelledException.prototype = new Error();
  RenderingCancelledException.prototype.name = 'RenderingCancelledException';
  RenderingCancelledException.constructor = RenderingCancelledException;
  return RenderingCancelledException;
}();

exports.RenderingCancelledException = RenderingCancelledException;
var LinkTarget = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
exports.LinkTarget = LinkTarget;
var LinkTargetStringMap = ['', '_self', '_blank', '_parent', '_top'];

function addLinkAttributes(link) {
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      url = _ref5.url,
      target = _ref5.target,
      rel = _ref5.rel;

  link.href = link.title = url ? (0, _util.removeNullCharacters)(url) : '';

  if (url) {
    var LinkTargetValues = Object.values(LinkTarget);
    var targetIndex = LinkTargetValues.includes(target) ? target : LinkTarget.NONE;
    link.target = LinkTargetStringMap[targetIndex];
    link.rel = typeof rel === 'string' ? rel : DEFAULT_LINK_REL;
  }
}

function getFilenameFromUrl(url) {
  var anchor = url.indexOf('#');
  var query = url.indexOf('?');
  var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
  return url.substring(url.lastIndexOf('/', end) + 1, end);
}

var StatTimer =
/*#__PURE__*/
function () {
  function StatTimer() {
    var enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    _classCallCheck(this, StatTimer);

    this.enabled = !!enable;
    this.started = Object.create(null);
    this.times = [];
  }

  _createClass(StatTimer, [{
    key: "time",
    value: function time(name) {
      if (!this.enabled) {
        return;
      }

      if (name in this.started) {
        (0, _util.warn)('Timer is already running for ' + name);
      }

      this.started[name] = Date.now();
    }
  }, {
    key: "timeEnd",
    value: function timeEnd(name) {
      if (!this.enabled) {
        return;
      }

      if (!(name in this.started)) {
        (0, _util.warn)('Timer has not been started for ' + name);
      }

      this.times.push({
        'name': name,
        'start': this.started[name],
        'end': Date.now()
      });
      delete this.started[name];
    }
  }, {
    key: "toString",
    value: function toString() {
      var times = this.times;
      var out = '',
          longest = 0;

      for (var i = 0, ii = times.length; i < ii; ++i) {
        var name = times[i]['name'];

        if (name.length > longest) {
          longest = name.length;
        }
      }

      for (var _i = 0, _ii = times.length; _i < _ii; ++_i) {
        var span = times[_i];
        var duration = span.end - span.start;
        out += "".concat(span['name'].padEnd(longest), " ").concat(duration, "ms\n");
      }

      return out;
    }
  }]);

  return StatTimer;
}();

exports.StatTimer = StatTimer;

var DummyStatTimer =
/*#__PURE__*/
function () {
  function DummyStatTimer() {
    _classCallCheck(this, DummyStatTimer);

    (0, _util.unreachable)('Cannot initialize DummyStatTimer.');
  }

  _createClass(DummyStatTimer, null, [{
    key: "time",
    value: function time(name) {}
  }, {
    key: "timeEnd",
    value: function timeEnd(name) {}
  }, {
    key: "toString",
    value: function toString() {
      return '';
    }
  }]);

  return DummyStatTimer;
}();

exports.DummyStatTimer = DummyStatTimer;

function loadScript(src) {
  return new Promise(function (resolve, reject) {
    var script = document.createElement('script');
    script.src = src;
    script.onload = resolve;

    script.onerror = function () {
      reject(new Error("Cannot load script at: ".concat(script.src)));
    };

    (document.head || document.documentElement).appendChild(script);
  });
}

/***/ }),
/* 152 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FontLoader = exports.FontFaceObject = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(147));

var _util = __w_pdfjs_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var BaseFontLoader =
/*#__PURE__*/
function () {
  function BaseFontLoader(_ref) {
    var docId = _ref.docId,
        onUnsupportedFeature = _ref.onUnsupportedFeature;

    _classCallCheck(this, BaseFontLoader);

    if (this.constructor === BaseFontLoader) {
      (0, _util.unreachable)('Cannot initialize BaseFontLoader.');
    }

    this.docId = docId;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this.nativeFontFaces = [];
    this.styleElement = null;
  }

  _createClass(BaseFontLoader, [{
    key: "addNativeFontFace",
    value: function addNativeFontFace(nativeFontFace) {
      this.nativeFontFaces.push(nativeFontFace);
      document.fonts.add(nativeFontFace);
    }
  }, {
    key: "insertRule",
    value: function insertRule(rule) {
      var styleElement = this.styleElement;

      if (!styleElement) {
        styleElement = this.styleElement = document.createElement('style');
        styleElement.id = "PDFJS_FONT_STYLE_TAG_".concat(this.docId);
        document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);
      }

      var styleSheet = styleElement.sheet;
      styleSheet.insertRule(rule, styleSheet.cssRules.length);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.nativeFontFaces.forEach(function (nativeFontFace) {
        document.fonts.delete(nativeFontFace);
      });
      this.nativeFontFaces.length = 0;

      if (this.styleElement) {
        this.styleElement.remove();
        this.styleElement = null;
      }
    }
  }, {
    key: "bind",
    value: function () {
      var _bind = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(font) {
        var _this = this;

        var nativeFontFace, rule;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(font.attached || font.missingFile)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                font.attached = true;

                if (!this.isFontLoadingAPISupported) {
                  _context.next = 19;
                  break;
                }

                nativeFontFace = font.createNativeFontFace();

                if (!nativeFontFace) {
                  _context.next = 18;
                  break;
                }

                this.addNativeFontFace(nativeFontFace);
                _context.prev = 7;
                _context.next = 10;
                return nativeFontFace.loaded;

              case 10:
                _context.next = 18;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](7);

                this._onUnsupportedFeature({
                  featureId: _util.UNSUPPORTED_FEATURES.font
                });

                (0, _util.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(_context.t0, "'."));
                font.disableFontFace = true;
                throw _context.t0;

              case 18:
                return _context.abrupt("return");

              case 19:
                rule = font.createFontFaceRule();

                if (!rule) {
                  _context.next = 25;
                  break;
                }

                this.insertRule(rule);

                if (!this.isSyncFontLoadingSupported) {
                  _context.next = 24;
                  break;
                }

                return _context.abrupt("return");

              case 24:
                return _context.abrupt("return", new Promise(function (resolve) {
                  var request = _this._queueLoadingCallback(resolve);

                  _this._prepareFontLoadEvent([rule], [font], request);
                }));

              case 25:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[7, 12]]);
      }));

      function bind(_x) {
        return _bind.apply(this, arguments);
      }

      return bind;
    }()
  }, {
    key: "_queueLoadingCallback",
    value: function _queueLoadingCallback(callback) {
      (0, _util.unreachable)('Abstract method `_queueLoadingCallback`.');
    }
  }, {
    key: "_prepareFontLoadEvent",
    value: function _prepareFontLoadEvent(rules, fontsToLoad, request) {
      (0, _util.unreachable)('Abstract method `_prepareFontLoadEvent`.');
    }
  }, {
    key: "isFontLoadingAPISupported",
    get: function get() {
      (0, _util.unreachable)('Abstract method `isFontLoadingAPISupported`.');
    }
  }, {
    key: "isSyncFontLoadingSupported",
    get: function get() {
      (0, _util.unreachable)('Abstract method `isSyncFontLoadingSupported`.');
    }
  }, {
    key: "_loadTestFont",
    get: function get() {
      (0, _util.unreachable)('Abstract method `_loadTestFont`.');
    }
  }]);

  return BaseFontLoader;
}();

var FontLoader;
exports.FontLoader = FontLoader;
{
  exports.FontLoader = FontLoader =
  /*#__PURE__*/
  function (_BaseFontLoader) {
    _inherits(GenericFontLoader, _BaseFontLoader);

    function GenericFontLoader(docId) {
      var _this2;

      _classCallCheck(this, GenericFontLoader);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(GenericFontLoader).call(this, docId));
      _this2.loadingContext = {
        requests: [],
        nextRequestId: 0
      };
      _this2.loadTestFontId = 0;
      return _this2;
    }

    _createClass(GenericFontLoader, [{
      key: "_queueLoadingCallback",
      value: function _queueLoadingCallback(callback) {
        function completeRequest() {
          (0, _util.assert)(!request.done, 'completeRequest() cannot be called twice.');
          request.done = true;

          while (context.requests.length > 0 && context.requests[0].done) {
            var otherRequest = context.requests.shift();
            setTimeout(otherRequest.callback, 0);
          }
        }

        var context = this.loadingContext;
        var request = {
          id: "pdfjs-font-loading-".concat(context.nextRequestId++),
          done: false,
          complete: completeRequest,
          callback: callback
        };
        context.requests.push(request);
        return request;
      }
    }, {
      key: "_prepareFontLoadEvent",
      value: function _prepareFontLoadEvent(rules, fonts, request) {
        function int32(data, offset) {
          return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
        }

        function spliceString(s, offset, remove, insert) {
          var chunk1 = s.substring(0, offset);
          var chunk2 = s.substring(offset + remove);
          return chunk1 + insert + chunk2;
        }

        var i, ii;
        var canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        var ctx = canvas.getContext('2d');
        var called = 0;

        function isFontReady(name, callback) {
          called++;

          if (called > 30) {
            (0, _util.warn)('Load test font never loaded.');
            callback();
            return;
          }

          ctx.font = '30px ' + name;
          ctx.fillText('.', 0, 20);
          var imageData = ctx.getImageData(0, 0, 1, 1);

          if (imageData.data[3] > 0) {
            callback();
            return;
          }

          setTimeout(isFontReady.bind(null, name, callback));
        }

        var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++);
        var data = this._loadTestFont;
        var COMMENT_OFFSET = 976;
        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
        var CFF_CHECKSUM_OFFSET = 16;
        var XXXX_VALUE = 0x58585858;
        var checksum = int32(data, CFF_CHECKSUM_OFFSET);

        for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
          checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
        }

        if (i < loadTestFontId.length) {
          checksum = checksum - XXXX_VALUE + int32(loadTestFontId + 'XXX', i) | 0;
        }

        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
        var url = "url(data:font/opentype;base64,".concat(btoa(data), ");");
        var rule = "@font-face {font-family:\"".concat(loadTestFontId, "\";src:").concat(url, "}");
        this.insertRule(rule);
        var names = [];

        for (i = 0, ii = fonts.length; i < ii; i++) {
          names.push(fonts[i].loadedName);
        }

        names.push(loadTestFontId);
        var div = document.createElement('div');
        div.setAttribute('style', 'visibility: hidden;' + 'width: 10px; height: 10px;' + 'position: absolute; top: 0px; left: 0px;');

        for (i = 0, ii = names.length; i < ii; ++i) {
          var span = document.createElement('span');
          span.textContent = 'Hi';
          span.style.fontFamily = names[i];
          div.appendChild(span);
        }

        document.body.appendChild(div);
        isFontReady(loadTestFontId, function () {
          document.body.removeChild(div);
          request.complete();
        });
      }
    }, {
      key: "isFontLoadingAPISupported",
      get: function get() {
        var supported = typeof document !== 'undefined' && !!document.fonts;

        if (supported && typeof navigator !== 'undefined') {
          var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

          if (m && m[1] < 63) {
            supported = false;
          }
        }

        return (0, _util.shadow)(this, 'isFontLoadingAPISupported', supported);
      }
    }, {
      key: "isSyncFontLoadingSupported",
      get: function get() {
        var supported = false;

        if (typeof navigator === 'undefined') {
          supported = true;
        } else {
          var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

          if (m && m[1] >= 14) {
            supported = true;
          }
        }

        return (0, _util.shadow)(this, 'isSyncFontLoadingSupported', supported);
      }
    }, {
      key: "_loadTestFont",
      get: function get() {
        var getLoadTestFont = function getLoadTestFont() {
          return atob('T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA' + 'FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA' + 'ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA' + 'AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1' + 'AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD' + '6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM' + 'AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D' + 'IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA' + 'AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA' + 'AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB' + 'AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY' + 'AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA' + 'AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA' + 'AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC' + 'AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3' + 'Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj' + 'FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==');
        };

        return (0, _util.shadow)(this, '_loadTestFont', getLoadTestFont());
      }
    }]);

    return GenericFontLoader;
  }(BaseFontLoader);
}
var IsEvalSupportedCached = {
  get value() {
    return (0, _util.shadow)(this, 'value', (0, _util.isEvalSupported)());
  }

};

var FontFaceObject =
/*#__PURE__*/
function () {
  function FontFaceObject(translatedData, _ref2) {
    var _ref2$isEvalSupported = _ref2.isEvalSupported,
        isEvalSupported = _ref2$isEvalSupported === void 0 ? true : _ref2$isEvalSupported,
        _ref2$disableFontFace = _ref2.disableFontFace,
        disableFontFace = _ref2$disableFontFace === void 0 ? false : _ref2$disableFontFace,
        _ref2$ignoreErrors = _ref2.ignoreErrors,
        ignoreErrors = _ref2$ignoreErrors === void 0 ? false : _ref2$ignoreErrors,
        _ref2$onUnsupportedFe = _ref2.onUnsupportedFeature,
        onUnsupportedFeature = _ref2$onUnsupportedFe === void 0 ? null : _ref2$onUnsupportedFe,
        _ref2$fontRegistry = _ref2.fontRegistry,
        fontRegistry = _ref2$fontRegistry === void 0 ? null : _ref2$fontRegistry;

    _classCallCheck(this, FontFaceObject);

    this.compiledGlyphs = Object.create(null);

    for (var i in translatedData) {
      this[i] = translatedData[i];
    }

    this.isEvalSupported = isEvalSupported !== false;
    this.disableFontFace = disableFontFace === true;
    this.ignoreErrors = ignoreErrors === true;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this.fontRegistry = fontRegistry;
  }

  _createClass(FontFaceObject, [{
    key: "createNativeFontFace",
    value: function createNativeFontFace() {
      if (!this.data || this.disableFontFace) {
        return null;
      }

      var nativeFontFace = new FontFace(this.loadedName, this.data, {});

      if (this.fontRegistry) {
        this.fontRegistry.registerFont(this);
      }

      return nativeFontFace;
    }
  }, {
    key: "createFontFaceRule",
    value: function createFontFaceRule() {
      if (!this.data || this.disableFontFace) {
        return null;
      }

      var data = (0, _util.bytesToString)(new Uint8Array(this.data));
      var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");");
      var rule = "@font-face {font-family:\"".concat(this.loadedName, "\";src:").concat(url, "}");

      if (this.fontRegistry) {
        this.fontRegistry.registerFont(this, url);
      }

      return rule;
    }
  }, {
    key: "getPathGenerator",
    value: function getPathGenerator(objs, character) {
      if (this.compiledGlyphs[character] !== undefined) {
        return this.compiledGlyphs[character];
      }

      var cmds, current;

      try {
        cmds = objs.get(this.loadedName + '_path_' + character);
      } catch (ex) {
        if (!this.ignoreErrors) {
          throw ex;
        }

        if (this._onUnsupportedFeature) {
          this._onUnsupportedFeature({
            featureId: _util.UNSUPPORTED_FEATURES.font
          });
        }

        (0, _util.warn)("getPathGenerator - ignoring character: \"".concat(ex, "\"."));
        return this.compiledGlyphs[character] = function (c, size) {};
      }

      if (this.isEvalSupported && IsEvalSupportedCached.value) {
        var args,
            js = '';

        for (var i = 0, ii = cmds.length; i < ii; i++) {
          current = cmds[i];

          if (current.args !== undefined) {
            args = current.args.join(',');
          } else {
            args = '';
          }

          js += 'c.' + current.cmd + '(' + args + ');\n';
        }

        return this.compiledGlyphs[character] = new Function('c', 'size', js);
      }

      return this.compiledGlyphs[character] = function (c, size) {
        for (var _i = 0, _ii = cmds.length; _i < _ii; _i++) {
          current = cmds[_i];

          if (current.cmd === 'scale') {
            current.args = [size, -size];
          }

          c[current.cmd].apply(c, current.args);
        }
      };
    }
  }]);

  return FontFaceObject;
}();

exports.FontFaceObject = FontFaceObject;

/***/ }),
/* 153 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var compatibilityParams = Object.create(null);
{
  var isNodeJS = __w_pdfjs_require__(4);

  var userAgent = typeof navigator !== 'undefined' && navigator.userAgent || '';
  var isIE = /Trident/.test(userAgent);
  var isIOSChrome = /CriOS/.test(userAgent);

  (function checkOnBlobSupport() {
    if (isIE || isIOSChrome) {
      compatibilityParams.disableCreateObjectURL = true;
    }
  })();

  (function checkFontFaceAndImage() {
    if (isNodeJS()) {
      compatibilityParams.disableFontFace = true;
      compatibilityParams.nativeImageDecoderSupport = 'none';
    }
  })();
}
exports.apiCompatibilityParams = Object.freeze(compatibilityParams);

/***/ }),
/* 154 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CanvasGraphics = void 0;

var _util = __w_pdfjs_require__(1);

var _pattern_helper = __w_pdfjs_require__(155);

var MIN_FONT_SIZE = 16;
var MAX_FONT_SIZE = 100;
var MAX_GROUP_SIZE = 4096;
var MIN_WIDTH_FACTOR = 0.65;
var COMPILE_TYPE3_GLYPHS = true;
var MAX_SIZE_TO_COMPILE = 1000;
var FULL_CHUNK_HEIGHT = 16;
var IsLittleEndianCached = {
  get value() {
    return (0, _util.shadow)(IsLittleEndianCached, 'value', (0, _util.isLittleEndian)());
  }

};

function addContextCurrentTransform(ctx) {
  if (!ctx.mozCurrentTransform) {
    ctx._originalSave = ctx.save;
    ctx._originalRestore = ctx.restore;
    ctx._originalRotate = ctx.rotate;
    ctx._originalScale = ctx.scale;
    ctx._originalTranslate = ctx.translate;
    ctx._originalTransform = ctx.transform;
    ctx._originalSetTransform = ctx.setTransform;
    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
    ctx._transformStack = [];
    Object.defineProperty(ctx, 'mozCurrentTransform', {
      get: function getCurrentTransform() {
        return this._transformMatrix;
      }
    });
    Object.defineProperty(ctx, 'mozCurrentTransformInverse', {
      get: function getCurrentTransformInverse() {
        var m = this._transformMatrix;
        var a = m[0],
            b = m[1],
            c = m[2],
            d = m[3],
            e = m[4],
            f = m[5];
        var ad_bc = a * d - b * c;
        var bc_ad = b * c - a * d;
        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
      }
    });

    ctx.save = function ctxSave() {
      var old = this._transformMatrix;

      this._transformStack.push(old);

      this._transformMatrix = old.slice(0, 6);

      this._originalSave();
    };

    ctx.restore = function ctxRestore() {
      var prev = this._transformStack.pop();

      if (prev) {
        this._transformMatrix = prev;

        this._originalRestore();
      }
    };

    ctx.translate = function ctxTranslate(x, y) {
      var m = this._transformMatrix;
      m[4] = m[0] * x + m[2] * y + m[4];
      m[5] = m[1] * x + m[3] * y + m[5];

      this._originalTranslate(x, y);
    };

    ctx.scale = function ctxScale(x, y) {
      var m = this._transformMatrix;
      m[0] = m[0] * x;
      m[1] = m[1] * x;
      m[2] = m[2] * y;
      m[3] = m[3] * y;

      this._originalScale(x, y);
    };

    ctx.transform = function ctxTransform(a, b, c, d, e, f) {
      var m = this._transformMatrix;
      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];

      ctx._originalTransform(a, b, c, d, e, f);
    };

    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
      this._transformMatrix = [a, b, c, d, e, f];

      ctx._originalSetTransform(a, b, c, d, e, f);
    };

    ctx.rotate = function ctxRotate(angle) {
      var cosValue = Math.cos(angle);
      var sinValue = Math.sin(angle);
      var m = this._transformMatrix;
      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];

      this._originalRotate(angle);
    };
  }
}

var CachedCanvases = function CachedCanvasesClosure() {
  function CachedCanvases(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = Object.create(null);
  }

  CachedCanvases.prototype = {
    getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
      var canvasEntry;

      if (this.cache[id] !== undefined) {
        canvasEntry = this.cache[id];
        this.canvasFactory.reset(canvasEntry, width, height);
        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        canvasEntry = this.canvasFactory.create(width, height);
        this.cache[id] = canvasEntry;
      }

      if (trackTransform) {
        addContextCurrentTransform(canvasEntry.context);
      }

      return canvasEntry;
    },
    clear: function clear() {
      for (var id in this.cache) {
        var canvasEntry = this.cache[id];
        this.canvasFactory.destroy(canvasEntry);
        delete this.cache[id];
      }
    }
  };
  return CachedCanvases;
}();

function compileType3Glyph(imgData) {
  var POINT_TO_PROCESS_LIMIT = 1000;
  var width = imgData.width,
      height = imgData.height;
  var i,
      j,
      j0,
      width1 = width + 1;
  var points = new Uint8Array(width1 * (height + 1));
  var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
  var lineSize = width + 7 & ~7,
      data0 = imgData.data;
  var data = new Uint8Array(lineSize * height),
      pos = 0,
      ii;

  for (i = 0, ii = data0.length; i < ii; i++) {
    var mask = 128,
        elem = data0[i];

    while (mask > 0) {
      data[pos++] = elem & mask ? 0 : 255;
      mask >>= 1;
    }
  }

  var count = 0;
  pos = 0;

  if (data[pos] !== 0) {
    points[0] = 1;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j] = data[pos] ? 2 : 1;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j] = 2;
    ++count;
  }

  for (i = 1; i < height; i++) {
    pos = i * lineSize;
    j0 = i * width1;

    if (data[pos - lineSize] !== data[pos]) {
      points[j0] = data[pos] ? 1 : 8;
      ++count;
    }

    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

    for (j = 1; j < width; j++) {
      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

      if (POINT_TYPES[sum]) {
        points[j0 + j] = POINT_TYPES[sum];
        ++count;
      }

      pos++;
    }

    if (data[pos - lineSize] !== data[pos]) {
      points[j0 + j] = data[pos] ? 2 : 4;
      ++count;
    }

    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }
  }

  pos = lineSize * (height - 1);
  j0 = i * width1;

  if (data[pos] !== 0) {
    points[j0] = 8;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j0 + j] = data[pos] ? 4 : 8;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j0 + j] = 4;
    ++count;
  }

  if (count > POINT_TO_PROCESS_LIMIT) {
    return null;
  }

  var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
  var outlines = [];

  for (i = 0; count && i <= height; i++) {
    var p = i * width1;
    var end = p + width;

    while (p < end && !points[p]) {
      p++;
    }

    if (p === end) {
      continue;
    }

    var coords = [p % width1, i];
    var type = points[p],
        p0 = p,
        pp;

    do {
      var step = steps[type];

      do {
        p += step;
      } while (!points[p]);

      pp = points[p];

      if (pp !== 5 && pp !== 10) {
        type = pp;
        points[p] = 0;
      } else {
        type = pp & 0x33 * type >> 4;
        points[p] &= type >> 2 | type << 2;
      }

      coords.push(p % width1);
      coords.push(p / width1 | 0);
      --count;
    } while (p0 !== p);

    outlines.push(coords);
    --i;
  }

  var drawOutline = function drawOutline(c) {
    c.save();
    c.scale(1 / width, -1 / height);
    c.translate(0, -height);
    c.beginPath();

    for (var i = 0, ii = outlines.length; i < ii; i++) {
      var o = outlines[i];
      c.moveTo(o[0], o[1]);

      for (var j = 2, jj = o.length; j < jj; j += 2) {
        c.lineTo(o[j], o[j + 1]);
      }
    }

    c.fill();
    c.beginPath();
    c.restore();
  };

  return drawOutline;
}

var CanvasExtraState = function CanvasExtraStateClosure() {
  function CanvasExtraState() {
    this.alphaIsShape = false;
    this.fontSize = 0;
    this.fontSizeScale = 1;
    this.textMatrix = _util.IDENTITY_MATRIX;
    this.textMatrixScale = 1;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.textRise = 0;
    this.fillColor = '#000000';
    this.strokeColor = '#000000';
    this.patternFill = false;
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.activeSMask = null;
    this.resumeSMaskCtx = null;
  }

  CanvasExtraState.prototype = {
    clone: function CanvasExtraState_clone() {
      return Object.create(this);
    },
    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
      this.x = x;
      this.y = y;
    }
  };
  return CanvasExtraState;
}();

var CanvasGraphics = function CanvasGraphicsClosure() {
  var EXECUTION_TIME = 15;
  var EXECUTION_STEPS = 10;

  function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer) {
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState();
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.webGLContext = webGLContext;
    this.imageLayer = imageLayer;
    this.groupStack = [];
    this.processingType3 = null;
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);

    if (canvasCtx) {
      addContextCurrentTransform(canvasCtx);
    }

    this._cachedGetSinglePixelWidth = null;
  }

  function putBinaryImageData(ctx, imgData) {
    if (typeof ImageData !== 'undefined' && imgData instanceof ImageData) {
      ctx.putImageData(imgData, 0, 0);
      return;
    }

    var height = imgData.height,
        width = imgData.width;
    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    var srcPos = 0,
        destPos;
    var src = imgData.data;
    var dest = chunkImgData.data;
    var i, j, thisChunkHeight, elemsInThisChunk;

    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
      var srcLength = src.byteLength;
      var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
      var dest32DataLength = dest32.length;
      var fullSrcDiff = width + 7 >> 3;
      var white = 0xFFFFFFFF;
      var black = IsLittleEndianCached.value ? 0xFF000000 : 0x000000FF;

      for (i = 0; i < totalChunks; i++) {
        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
        destPos = 0;

        for (j = 0; j < thisChunkHeight; j++) {
          var srcDiff = srcLength - srcPos;
          var k = 0;
          var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
          var kEndUnrolled = kEnd & ~7;
          var mask = 0;
          var srcByte = 0;

          for (; k < kEndUnrolled; k += 8) {
            srcByte = src[srcPos++];
            dest32[destPos++] = srcByte & 128 ? white : black;
            dest32[destPos++] = srcByte & 64 ? white : black;
            dest32[destPos++] = srcByte & 32 ? white : black;
            dest32[destPos++] = srcByte & 16 ? white : black;
            dest32[destPos++] = srcByte & 8 ? white : black;
            dest32[destPos++] = srcByte & 4 ? white : black;
            dest32[destPos++] = srcByte & 2 ? white : black;
            dest32[destPos++] = srcByte & 1 ? white : black;
          }

          for (; k < kEnd; k++) {
            if (mask === 0) {
              srcByte = src[srcPos++];
              mask = 128;
            }

            dest32[destPos++] = srcByte & mask ? white : black;
            mask >>= 1;
          }
        }

        while (destPos < dest32DataLength) {
          dest32[destPos++] = 0;
        }

        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
      }
    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
      j = 0;
      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

      for (i = 0; i < fullChunks; i++) {
        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
        srcPos += elemsInThisChunk;
        ctx.putImageData(chunkImgData, 0, j);
        j += FULL_CHUNK_HEIGHT;
      }

      if (i < totalChunks) {
        elemsInThisChunk = width * partialChunkHeight * 4;
        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
        ctx.putImageData(chunkImgData, 0, j);
      }
    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
      thisChunkHeight = FULL_CHUNK_HEIGHT;
      elemsInThisChunk = width * thisChunkHeight;

      for (i = 0; i < totalChunks; i++) {
        if (i >= fullChunks) {
          thisChunkHeight = partialChunkHeight;
          elemsInThisChunk = width * thisChunkHeight;
        }

        destPos = 0;

        for (j = elemsInThisChunk; j--;) {
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = 255;
        }

        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
      }
    } else {
      throw new Error("bad image kind: ".concat(imgData.kind));
    }
  }

  function putBinaryImageMask(ctx, imgData) {
    var height = imgData.height,
        width = imgData.width;
    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    var srcPos = 0;
    var src = imgData.data;
    var dest = chunkImgData.data;

    for (var i = 0; i < totalChunks; i++) {
      var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      var destPos = 3;

      for (var j = 0; j < thisChunkHeight; j++) {
        var mask = 0;

        for (var k = 0; k < width; k++) {
          if (!mask) {
            var elem = src[srcPos++];
            mask = 128;
          }

          dest[destPos] = elem & mask ? 0 : 255;
          destPos += 4;
          mask >>= 1;
        }
      }

      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  }

  function copyCtxState(sourceCtx, destCtx) {
    var properties = ['strokeStyle', 'fillStyle', 'fillRule', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'miterLimit', 'globalCompositeOperation', 'font'];

    for (var i = 0, ii = properties.length; i < ii; i++) {
      var property = properties[i];

      if (sourceCtx[property] !== undefined) {
        destCtx[property] = sourceCtx[property];
      }
    }

    if (sourceCtx.setLineDash !== undefined) {
      destCtx.setLineDash(sourceCtx.getLineDash());
      destCtx.lineDashOffset = sourceCtx.lineDashOffset;
    }
  }

  function resetCtxToDefault(ctx) {
    ctx.strokeStyle = '#000000';
    ctx.fillStyle = '#000000';
    ctx.fillRule = 'nonzero';
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.miterLimit = 10;
    ctx.globalCompositeOperation = 'source-over';
    ctx.font = '10px sans-serif';

    if (ctx.setLineDash !== undefined) {
      ctx.setLineDash([]);
      ctx.lineDashOffset = 0;
    }
  }

  function composeSMaskBackdrop(bytes, r0, g0, b0) {
    var length = bytes.length;

    for (var i = 3; i < length; i += 4) {
      var alpha = bytes[i];

      if (alpha === 0) {
        bytes[i - 3] = r0;
        bytes[i - 2] = g0;
        bytes[i - 1] = b0;
      } else if (alpha < 255) {
        var alpha_ = 255 - alpha;
        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
      }
    }
  }

  function composeSMaskAlpha(maskData, layerData, transferMap) {
    var length = maskData.length;
    var scale = 1 / 255;

    for (var i = 3; i < length; i += 4) {
      var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
      layerData[i] = layerData[i] * alpha * scale | 0;
    }
  }

  function composeSMaskLuminosity(maskData, layerData, transferMap) {
    var length = maskData.length;

    for (var i = 3; i < length; i += 4) {
      var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
    }
  }

  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
    var hasBackdrop = !!backdrop;
    var r0 = hasBackdrop ? backdrop[0] : 0;
    var g0 = hasBackdrop ? backdrop[1] : 0;
    var b0 = hasBackdrop ? backdrop[2] : 0;
    var composeFn;

    if (subtype === 'Luminosity') {
      composeFn = composeSMaskLuminosity;
    } else {
      composeFn = composeSMaskAlpha;
    }

    var PIXELS_TO_PROCESS = 1048576;
    var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

    for (var row = 0; row < height; row += chunkSize) {
      var chunkHeight = Math.min(chunkSize, height - row);
      var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
      var layerData = layerCtx.getImageData(0, row, width, chunkHeight);

      if (hasBackdrop) {
        composeSMaskBackdrop(maskData.data, r0, g0, b0);
      }

      composeFn(maskData.data, layerData.data, transferMap);
      maskCtx.putImageData(layerData, 0, row);
    }
  }

  function composeSMask(ctx, smask, layerCtx, webGLContext) {
    var mask = smask.canvas;
    var maskCtx = smask.context;
    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
    var backdrop = smask.backdrop || null;

    if (!smask.transferMap && webGLContext.isEnabled) {
      var composed = webGLContext.composeSMask({
        layer: layerCtx.canvas,
        mask: mask,
        properties: {
          subtype: smask.subtype,
          backdrop: backdrop
        }
      });
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(composed, smask.offsetX, smask.offsetY);
      return;
    }

    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
    ctx.drawImage(mask, 0, 0);
  }

  var LINE_CAP_STYLES = ['butt', 'round', 'square'];
  var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
  var NORMAL_CLIP = {};
  var EO_CLIP = {};
  CanvasGraphics.prototype = {
    beginDrawing: function beginDrawing(_ref) {
      var transform = _ref.transform,
          viewport = _ref.viewport,
          _ref$transparency = _ref.transparency,
          transparency = _ref$transparency === void 0 ? false : _ref$transparency,
          _ref$background = _ref.background,
          background = _ref$background === void 0 ? null : _ref$background;
      var width = this.ctx.canvas.width;
      var height = this.ctx.canvas.height;
      this.ctx.save();
      this.ctx.fillStyle = background || 'rgb(255, 255, 255)';
      this.ctx.fillRect(0, 0, width, height);
      this.ctx.restore();

      if (transparency) {
        var transparentCanvas = this.cachedCanvases.getCanvas('transparent', width, height, true);
        this.compositeCtx = this.ctx;
        this.transparentCanvas = transparentCanvas.canvas;
        this.ctx = transparentCanvas.context;
        this.ctx.save();
        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
      }

      this.ctx.save();
      resetCtxToDefault(this.ctx);

      if (transform) {
        this.ctx.transform.apply(this.ctx, transform);
      }

      this.ctx.transform.apply(this.ctx, viewport.transform);
      this.baseTransform = this.ctx.mozCurrentTransform.slice();

      if (this.imageLayer) {
        this.imageLayer.beginLayout();
      }
    },
    executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
      var argsArray = operatorList.argsArray;
      var fnArray = operatorList.fnArray;
      var i = executionStartIdx || 0;
      var argsArrayLen = argsArray.length;

      if (argsArrayLen === i) {
        return i;
      }

      var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === 'function';
      var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
      var steps = 0;
      var commonObjs = this.commonObjs;
      var objs = this.objs;
      var fnId;

      while (true) {
        if (stepper !== undefined && i === stepper.nextBreakPoint) {
          stepper.breakIt(i, continueCallback);
          return i;
        }

        fnId = fnArray[i];

        if (fnId !== _util.OPS.dependency) {
          this[fnId].apply(this, argsArray[i]);
        } else {
          var deps = argsArray[i];

          for (var n = 0, nn = deps.length; n < nn; n++) {
            var depObjId = deps[n];
            var common = depObjId[0] === 'g' && depObjId[1] === '_';
            var objsPool = common ? commonObjs : objs;

            if (!objsPool.has(depObjId)) {
              objsPool.get(depObjId, continueCallback);
              return i;
            }
          }
        }

        i++;

        if (i === argsArrayLen) {
          return i;
        }

        if (chunkOperations && ++steps > EXECUTION_STEPS) {
          if (Date.now() > endTime) {
            continueCallback();
            return i;
          }

          steps = 0;
        }
      }
    },
    endDrawing: function CanvasGraphics_endDrawing() {
      if (this.current.activeSMask !== null) {
        this.endSMaskGroup();
      }

      this.ctx.restore();

      if (this.transparentCanvas) {
        this.ctx = this.compositeCtx;
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.drawImage(this.transparentCanvas, 0, 0);
        this.ctx.restore();
        this.transparentCanvas = null;
      }

      this.cachedCanvases.clear();
      this.webGLContext.clear();

      if (this.imageLayer) {
        this.imageLayer.endLayout();
      }
    },
    setLineWidth: function CanvasGraphics_setLineWidth(width) {
      this.current.lineWidth = width;
      this.ctx.lineWidth = width;
    },
    setLineCap: function CanvasGraphics_setLineCap(style) {
      this.ctx.lineCap = LINE_CAP_STYLES[style];
    },
    setLineJoin: function CanvasGraphics_setLineJoin(style) {
      this.ctx.lineJoin = LINE_JOIN_STYLES[style];
    },
    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
      this.ctx.miterLimit = limit;
    },
    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
      var ctx = this.ctx;

      if (ctx.setLineDash !== undefined) {
        ctx.setLineDash(dashArray);
        ctx.lineDashOffset = dashPhase;
      }
    },
    setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {},
    setFlatness: function CanvasGraphics_setFlatness(flatness) {},
    setGState: function CanvasGraphics_setGState(states) {
      for (var i = 0, ii = states.length; i < ii; i++) {
        var state = states[i];
        var key = state[0];
        var value = state[1];

        switch (key) {
          case 'LW':
            this.setLineWidth(value);
            break;

          case 'LC':
            this.setLineCap(value);
            break;

          case 'LJ':
            this.setLineJoin(value);
            break;

          case 'ML':
            this.setMiterLimit(value);
            break;

          case 'D':
            this.setDash(value[0], value[1]);
            break;

          case 'RI':
            this.setRenderingIntent(value);
            break;

          case 'FL':
            this.setFlatness(value);
            break;

          case 'Font':
            this.setFont(value[0], value[1]);
            break;

          case 'CA':
            this.current.strokeAlpha = state[1];
            break;

          case 'ca':
            this.current.fillAlpha = state[1];
            this.ctx.globalAlpha = state[1];
            break;

          case 'BM':
            this.ctx.globalCompositeOperation = value;
            break;

          case 'SMask':
            if (this.current.activeSMask) {
              if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                this.suspendSMaskGroup();
              } else {
                this.endSMaskGroup();
              }
            }

            this.current.activeSMask = value ? this.tempSMask : null;

            if (this.current.activeSMask) {
              this.beginSMaskGroup();
            }

            this.tempSMask = null;
            break;
        }
      }
    },
    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
      var activeSMask = this.current.activeSMask;
      var drawnWidth = activeSMask.canvas.width;
      var drawnHeight = activeSMask.canvas.height;
      var cacheId = 'smaskGroupAt' + this.groupLevel;
      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
      var currentCtx = this.ctx;
      var currentTransform = currentCtx.mozCurrentTransform;
      this.ctx.save();
      var groupCtx = scratchCanvas.context;
      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
      groupCtx.transform.apply(groupCtx, currentTransform);
      activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
      copyCtxState(currentCtx, groupCtx);
      this.ctx = groupCtx;
      this.setGState([['BM', 'source-over'], ['ca', 1], ['CA', 1]]);
      this.groupStack.push(currentCtx);
      this.groupLevel++;
    },
    suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
      var groupCtx = this.ctx;
      this.groupLevel--;
      this.ctx = this.groupStack.pop();
      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
      this.ctx.restore();
      this.ctx.save();
      copyCtxState(groupCtx, this.ctx);
      this.current.resumeSMaskCtx = groupCtx;

      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

      this.ctx.transform.apply(this.ctx, deltaTransform);
      groupCtx.save();
      groupCtx.setTransform(1, 0, 0, 1, 0, 0);
      groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
      groupCtx.restore();
    },
    resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {
      var groupCtx = this.current.resumeSMaskCtx;
      var currentCtx = this.ctx;
      this.ctx = groupCtx;
      this.groupStack.push(currentCtx);
      this.groupLevel++;
    },
    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
      var groupCtx = this.ctx;
      this.groupLevel--;
      this.ctx = this.groupStack.pop();
      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
      this.ctx.restore();
      copyCtxState(groupCtx, this.ctx);

      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

      this.ctx.transform.apply(this.ctx, deltaTransform);
    },
    save: function CanvasGraphics_save() {
      this.ctx.save();
      var old = this.current;
      this.stateStack.push(old);
      this.current = old.clone();
      this.current.resumeSMaskCtx = null;
    },
    restore: function CanvasGraphics_restore() {
      if (this.current.resumeSMaskCtx) {
        this.resumeSMaskGroup();
      }

      if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
        this.endSMaskGroup();
      }

      if (this.stateStack.length !== 0) {
        this.current = this.stateStack.pop();
        this.ctx.restore();
        this.pendingClip = null;
        this._cachedGetSinglePixelWidth = null;
      }
    },
    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
      this.ctx.transform(a, b, c, d, e, f);
      this._cachedGetSinglePixelWidth = null;
    },
    constructPath: function CanvasGraphics_constructPath(ops, args) {
      var ctx = this.ctx;
      var current = this.current;
      var x = current.x,
          y = current.y;

      for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
        switch (ops[i] | 0) {
          case _util.OPS.rectangle:
            x = args[j++];
            y = args[j++];
            var width = args[j++];
            var height = args[j++];

            if (width === 0) {
              width = this.getSinglePixelWidth();
            }

            if (height === 0) {
              height = this.getSinglePixelWidth();
            }

            var xw = x + width;
            var yh = y + height;
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(xw, y);
            this.ctx.lineTo(xw, yh);
            this.ctx.lineTo(x, yh);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            break;

          case _util.OPS.moveTo:
            x = args[j++];
            y = args[j++];
            ctx.moveTo(x, y);
            break;

          case _util.OPS.lineTo:
            x = args[j++];
            y = args[j++];
            ctx.lineTo(x, y);
            break;

          case _util.OPS.curveTo:
            x = args[j + 4];
            y = args[j + 5];
            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
            j += 6;
            break;

          case _util.OPS.curveTo2:
            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
            x = args[j + 2];
            y = args[j + 3];
            j += 4;
            break;

          case _util.OPS.curveTo3:
            x = args[j + 2];
            y = args[j + 3];
            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
            j += 4;
            break;

          case _util.OPS.closePath:
            ctx.closePath();
            break;
        }
      }

      current.setCurrentPoint(x, y);
    },
    closePath: function CanvasGraphics_closePath() {
      this.ctx.closePath();
    },
    stroke: function CanvasGraphics_stroke(consumePath) {
      consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
      var ctx = this.ctx;
      var strokeColor = this.current.strokeColor;
      ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);
      ctx.globalAlpha = this.current.strokeAlpha;

      if (strokeColor && strokeColor.hasOwnProperty('type') && strokeColor.type === 'Pattern') {
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.stroke();
      }

      if (consumePath) {
        this.consumePath();
      }

      ctx.globalAlpha = this.current.fillAlpha;
    },
    closeStroke: function CanvasGraphics_closeStroke() {
      this.closePath();
      this.stroke();
    },
    fill: function CanvasGraphics_fill(consumePath) {
      consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
      var ctx = this.ctx;
      var fillColor = this.current.fillColor;
      var isPatternFill = this.current.patternFill;
      var needRestore = false;

      if (isPatternFill) {
        ctx.save();

        if (this.baseTransform) {
          ctx.setTransform.apply(ctx, this.baseTransform);
        }

        ctx.fillStyle = fillColor.getPattern(ctx, this);
        needRestore = true;
      }

      if (this.pendingEOFill) {
        ctx.fill('evenodd');
        this.pendingEOFill = false;
      } else {
        ctx.fill();
      }

      if (needRestore) {
        ctx.restore();
      }

      if (consumePath) {
        this.consumePath();
      }
    },
    eoFill: function CanvasGraphics_eoFill() {
      this.pendingEOFill = true;
      this.fill();
    },
    fillStroke: function CanvasGraphics_fillStroke() {
      this.fill(false);
      this.stroke(false);
      this.consumePath();
    },
    eoFillStroke: function CanvasGraphics_eoFillStroke() {
      this.pendingEOFill = true;
      this.fillStroke();
    },
    closeFillStroke: function CanvasGraphics_closeFillStroke() {
      this.closePath();
      this.fillStroke();
    },
    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
      this.pendingEOFill = true;
      this.closePath();
      this.fillStroke();
    },
    endPath: function CanvasGraphics_endPath() {
      this.consumePath();
    },
    clip: function CanvasGraphics_clip() {
      this.pendingClip = NORMAL_CLIP;
    },
    eoClip: function CanvasGraphics_eoClip() {
      this.pendingClip = EO_CLIP;
    },
    beginText: function CanvasGraphics_beginText() {
      this.current.textMatrix = _util.IDENTITY_MATRIX;
      this.current.textMatrixScale = 1;
      this.current.x = this.current.lineX = 0;
      this.current.y = this.current.lineY = 0;
    },
    endText: function CanvasGraphics_endText() {
      var paths = this.pendingTextPaths;
      var ctx = this.ctx;

      if (paths === undefined) {
        ctx.beginPath();
        return;
      }

      ctx.save();
      ctx.beginPath();

      for (var i = 0; i < paths.length; i++) {
        var path = paths[i];
        ctx.setTransform.apply(ctx, path.transform);
        ctx.translate(path.x, path.y);
        path.addToPath(ctx, path.fontSize);
      }

      ctx.restore();
      ctx.clip();
      ctx.beginPath();
      delete this.pendingTextPaths;
    },
    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
      this.current.charSpacing = spacing;
    },
    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
      this.current.wordSpacing = spacing;
    },
    setHScale: function CanvasGraphics_setHScale(scale) {
      this.current.textHScale = scale / 100;
    },
    setLeading: function CanvasGraphics_setLeading(leading) {
      this.current.leading = -leading;
    },
    setFont: function CanvasGraphics_setFont(fontRefName, size) {
      var fontObj = this.commonObjs.get(fontRefName);
      var current = this.current;

      if (!fontObj) {
        throw new Error("Can't find font for ".concat(fontRefName));
      }

      current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;

      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
        (0, _util.warn)('Invalid font matrix for font ' + fontRefName);
      }

      if (size < 0) {
        size = -size;
        current.fontDirection = -1;
      } else {
        current.fontDirection = 1;
      }

      this.current.font = fontObj;
      this.current.fontSize = size;

      if (fontObj.isType3Font) {
        return;
      }

      var name = fontObj.loadedName || 'sans-serif';
      var bold = fontObj.black ? '900' : fontObj.bold ? 'bold' : 'normal';
      var italic = fontObj.italic ? 'italic' : 'normal';
      var typeface = "\"".concat(name, "\", ").concat(fontObj.fallbackName);
      var browserFontSize = size < MIN_FONT_SIZE ? MIN_FONT_SIZE : size > MAX_FONT_SIZE ? MAX_FONT_SIZE : size;
      this.current.fontSizeScale = size / browserFontSize;
      this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface);
    },
    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
      this.current.textRenderingMode = mode;
    },
    setTextRise: function CanvasGraphics_setTextRise(rise) {
      this.current.textRise = rise;
    },
    moveText: function CanvasGraphics_moveText(x, y) {
      this.current.x = this.current.lineX += x;
      this.current.y = this.current.lineY += y;
    },
    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
      this.setLeading(-y);
      this.moveText(x, y);
    },
    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
      this.current.textMatrix = [a, b, c, d, e, f];
      this.current.textMatrixScale = Math.sqrt(a * a + b * b);
      this.current.x = this.current.lineX = 0;
      this.current.y = this.current.lineY = 0;
    },
    nextLine: function CanvasGraphics_nextLine() {
      this.moveText(0, this.current.leading);
    },
    paintChar: function paintChar(character, x, y, patternTransform) {
      var ctx = this.ctx;
      var current = this.current;
      var font = current.font;
      var textRenderingMode = current.textRenderingMode;
      var fontSize = current.fontSize / current.fontSizeScale;
      var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
      var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
      var patternFill = current.patternFill && font.data;
      var addToPath;

      if (font.disableFontFace || isAddToPathSet || patternFill) {
        addToPath = font.getPathGenerator(this.commonObjs, character);
      }

      if (font.disableFontFace || patternFill) {
        ctx.save();
        ctx.translate(x, y);
        ctx.beginPath();
        addToPath(ctx, fontSize);

        if (patternTransform) {
          ctx.setTransform.apply(ctx, patternTransform);
        }

        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.fill();
        }

        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.stroke();
        }

        ctx.restore();
      } else {
        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.fillText(character, x, y);
        }

        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.strokeText(character, x, y);
        }
      }

      if (isAddToPathSet) {
        var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
        paths.push({
          transform: ctx.mozCurrentTransform,
          x: x,
          y: y,
          fontSize: fontSize,
          addToPath: addToPath
        });
      }
    },

    get isFontSubpixelAAEnabled() {
      var ctx = this.canvasFactory.create(10, 10).context;
      ctx.scale(1.5, 1);
      ctx.fillText('I', 0, 10);
      var data = ctx.getImageData(0, 0, 10, 10).data;
      var enabled = false;

      for (var i = 3; i < data.length; i += 4) {
        if (data[i] > 0 && data[i] < 255) {
          enabled = true;
          break;
        }
      }

      return (0, _util.shadow)(this, 'isFontSubpixelAAEnabled', enabled);
    },

    showText: function CanvasGraphics_showText(glyphs) {
      var current = this.current;
      var font = current.font;

      if (font.isType3Font) {
        return this.showType3Text(glyphs);
      }

      var fontSize = current.fontSize;

      if (fontSize === 0) {
        return;
      }

      var ctx = this.ctx;
      var fontSizeScale = current.fontSizeScale;
      var charSpacing = current.charSpacing;
      var wordSpacing = current.wordSpacing;
      var fontDirection = current.fontDirection;
      var textHScale = current.textHScale * fontDirection;
      var glyphsLength = glyphs.length;
      var vertical = font.vertical;
      var spacingDir = vertical ? 1 : -1;
      var defaultVMetrics = font.defaultVMetrics;
      var widthAdvanceScale = fontSize * current.fontMatrix[0];
      var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
      ctx.save();
      var patternTransform;

      if (current.patternFill) {
        ctx.save();
        var pattern = current.fillColor.getPattern(ctx, this);
        patternTransform = ctx.mozCurrentTransform;
        ctx.restore();
        ctx.fillStyle = pattern;
      }

      ctx.transform.apply(ctx, current.textMatrix);
      ctx.translate(current.x, current.y + current.textRise);

      if (fontDirection > 0) {
        ctx.scale(textHScale, -1);
      } else {
        ctx.scale(textHScale, 1);
      }

      var lineWidth = current.lineWidth;
      var scale = current.textMatrixScale;

      if (scale === 0 || lineWidth === 0) {
        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          this._cachedGetSinglePixelWidth = null;
          lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
        }
      } else {
        lineWidth /= scale;
      }

      if (fontSizeScale !== 1.0) {
        ctx.scale(fontSizeScale, fontSizeScale);
        lineWidth /= fontSizeScale;
      }

      ctx.lineWidth = lineWidth;
      var x = 0,
          i;

      for (i = 0; i < glyphsLength; ++i) {
        var glyph = glyphs[i];

        if ((0, _util.isNum)(glyph)) {
          x += spacingDir * glyph * fontSize / 1000;
          continue;
        }

        var restoreNeeded = false;
        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        var character = glyph.fontChar;
        var accent = glyph.accent;
        var scaledX, scaledY, scaledAccentX, scaledAccentY;
        var width = glyph.width;

        if (vertical) {
          var vmetric, vx, vy;
          vmetric = glyph.vmetric || defaultVMetrics;
          vx = glyph.vmetric ? vmetric[1] : width * 0.5;
          vx = -vx * widthAdvanceScale;
          vy = vmetric[2] * widthAdvanceScale;
          width = vmetric ? -vmetric[0] : width;
          scaledX = vx / fontSizeScale;
          scaledY = (x + vy) / fontSizeScale;
        } else {
          scaledX = x / fontSizeScale;
          scaledY = 0;
        }

        if (font.remeasure && width > 0) {
          var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
            var characterScaleX = width / measuredWidth;
            restoreNeeded = true;
            ctx.save();
            ctx.scale(characterScaleX, 1);
            scaledX /= characterScaleX;
          } else if (width !== measuredWidth) {
            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
          }
        }

        if (glyph.isInFont || font.missingFile) {
          if (simpleFillText && !accent) {
            ctx.fillText(character, scaledX, scaledY);
          } else {
            this.paintChar(character, scaledX, scaledY, patternTransform);

            if (accent) {
              scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
              scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
            }
          }
        }

        var charWidth = width * widthAdvanceScale + spacing * fontDirection;
        x += charWidth;

        if (restoreNeeded) {
          ctx.restore();
        }
      }

      if (vertical) {
        current.y -= x * textHScale;
      } else {
        current.x += x * textHScale;
      }

      ctx.restore();
    },
    showType3Text: function CanvasGraphics_showType3Text(glyphs) {
      var ctx = this.ctx;
      var current = this.current;
      var font = current.font;
      var fontSize = current.fontSize;
      var fontDirection = current.fontDirection;
      var spacingDir = font.vertical ? 1 : -1;
      var charSpacing = current.charSpacing;
      var wordSpacing = current.wordSpacing;
      var textHScale = current.textHScale * fontDirection;
      var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      var glyphsLength = glyphs.length;
      var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
      var i, glyph, width, spacingLength;

      if (isTextInvisible || fontSize === 0) {
        return;
      }

      this._cachedGetSinglePixelWidth = null;
      ctx.save();
      ctx.transform.apply(ctx, current.textMatrix);
      ctx.translate(current.x, current.y);
      ctx.scale(textHScale, fontDirection);

      for (i = 0; i < glyphsLength; ++i) {
        glyph = glyphs[i];

        if ((0, _util.isNum)(glyph)) {
          spacingLength = spacingDir * glyph * fontSize / 1000;
          this.ctx.translate(spacingLength, 0);
          current.x += spacingLength * textHScale;
          continue;
        }

        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        var operatorList = font.charProcOperatorList[glyph.operatorListId];

        if (!operatorList) {
          (0, _util.warn)("Type3 character \"".concat(glyph.operatorListId, "\" is not available."));
          continue;
        }

        this.processingType3 = glyph;
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform.apply(ctx, fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();

        var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

        width = transformed[0] * fontSize + spacing;
        ctx.translate(width, 0);
        current.x += width * textHScale;
      }

      ctx.restore();
      this.processingType3 = null;
    },
    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},
    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
      this.ctx.rect(llx, lly, urx - llx, ury - lly);
      this.clip();
      this.endPath();
    },
    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
      var _this = this;

      var pattern;

      if (IR[0] === 'TilingPattern') {
        var color = IR[1];
        var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
        var canvasGraphicsFactory = {
          createCanvasGraphics: function createCanvasGraphics(ctx) {
            return new CanvasGraphics(ctx, _this.commonObjs, _this.objs, _this.canvasFactory, _this.webGLContext);
          }
        };
        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
      } else {
        pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
      }

      return pattern;
    },
    setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
      this.current.strokeColor = this.getColorN_Pattern(arguments);
    },
    setFillColorN: function CanvasGraphics_setFillColorN() {
      this.current.fillColor = this.getColorN_Pattern(arguments);
      this.current.patternFill = true;
    },
    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
      var color = _util.Util.makeCssRgb(r, g, b);

      this.ctx.strokeStyle = color;
      this.current.strokeColor = color;
    },
    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
      var color = _util.Util.makeCssRgb(r, g, b);

      this.ctx.fillStyle = color;
      this.current.fillColor = color;
      this.current.patternFill = false;
    },
    shadingFill: function CanvasGraphics_shadingFill(patternIR) {
      var ctx = this.ctx;
      this.save();
      var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
      ctx.fillStyle = pattern.getPattern(ctx, this, true);
      var inv = ctx.mozCurrentTransformInverse;

      if (inv) {
        var canvas = ctx.canvas;
        var width = canvas.width;
        var height = canvas.height;

        var bl = _util.Util.applyTransform([0, 0], inv);

        var br = _util.Util.applyTransform([0, height], inv);

        var ul = _util.Util.applyTransform([width, 0], inv);

        var ur = _util.Util.applyTransform([width, height], inv);

        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
      } else {
        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
      }

      this.restore();
    },
    beginInlineImage: function CanvasGraphics_beginInlineImage() {
      (0, _util.unreachable)('Should not call beginInlineImage');
    },
    beginImageData: function CanvasGraphics_beginImageData() {
      (0, _util.unreachable)('Should not call beginImageData');
    },
    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
      this.save();
      this.baseTransformStack.push(this.baseTransform);

      if (Array.isArray(matrix) && matrix.length === 6) {
        this.transform.apply(this, matrix);
      }

      this.baseTransform = this.ctx.mozCurrentTransform;

      if (bbox) {
        var width = bbox[2] - bbox[0];
        var height = bbox[3] - bbox[1];
        this.ctx.rect(bbox[0], bbox[1], width, height);
        this.clip();
        this.endPath();
      }
    },
    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
      this.restore();
      this.baseTransform = this.baseTransformStack.pop();
    },
    beginGroup: function CanvasGraphics_beginGroup(group) {
      this.save();
      var currentCtx = this.ctx;

      if (!group.isolated) {
        (0, _util.info)('TODO: Support non-isolated groups.');
      }

      if (group.knockout) {
        (0, _util.warn)('Knockout groups not supported.');
      }

      var currentTransform = currentCtx.mozCurrentTransform;

      if (group.matrix) {
        currentCtx.transform.apply(currentCtx, group.matrix);
      }

      if (!group.bbox) {
        throw new Error('Bounding box is required.');
      }

      var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);

      var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
      bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
      var offsetX = Math.floor(bounds[0]);
      var offsetY = Math.floor(bounds[1]);
      var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
      var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
      var scaleX = 1,
          scaleY = 1;

      if (drawnWidth > MAX_GROUP_SIZE) {
        scaleX = drawnWidth / MAX_GROUP_SIZE;
        drawnWidth = MAX_GROUP_SIZE;
      }

      if (drawnHeight > MAX_GROUP_SIZE) {
        scaleY = drawnHeight / MAX_GROUP_SIZE;
        drawnHeight = MAX_GROUP_SIZE;
      }

      var cacheId = 'groupAt' + this.groupLevel;

      if (group.smask) {
        cacheId += '_smask_' + this.smaskCounter++ % 2;
      }

      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
      var groupCtx = scratchCanvas.context;
      groupCtx.scale(1 / scaleX, 1 / scaleY);
      groupCtx.translate(-offsetX, -offsetY);
      groupCtx.transform.apply(groupCtx, currentTransform);

      if (group.smask) {
        this.smaskStack.push({
          canvas: scratchCanvas.canvas,
          context: groupCtx,
          offsetX: offsetX,
          offsetY: offsetY,
          scaleX: scaleX,
          scaleY: scaleY,
          subtype: group.smask.subtype,
          backdrop: group.smask.backdrop,
          transferMap: group.smask.transferMap || null,
          startTransformInverse: null
        });
      } else {
        currentCtx.setTransform(1, 0, 0, 1, 0, 0);
        currentCtx.translate(offsetX, offsetY);
        currentCtx.scale(scaleX, scaleY);
      }

      copyCtxState(currentCtx, groupCtx);
      this.ctx = groupCtx;
      this.setGState([['BM', 'source-over'], ['ca', 1], ['CA', 1]]);
      this.groupStack.push(currentCtx);
      this.groupLevel++;
      this.current.activeSMask = null;
    },
    endGroup: function CanvasGraphics_endGroup(group) {
      this.groupLevel--;
      var groupCtx = this.ctx;
      this.ctx = this.groupStack.pop();

      if (this.ctx.imageSmoothingEnabled !== undefined) {
        this.ctx.imageSmoothingEnabled = false;
      } else {
        this.ctx.mozImageSmoothingEnabled = false;
      }

      if (group.smask) {
        this.tempSMask = this.smaskStack.pop();
      } else {
        this.ctx.drawImage(groupCtx.canvas, 0, 0);
      }

      this.restore();
    },
    beginAnnotations: function CanvasGraphics_beginAnnotations() {
      this.save();

      if (this.baseTransform) {
        this.ctx.setTransform.apply(this.ctx, this.baseTransform);
      }
    },
    endAnnotations: function CanvasGraphics_endAnnotations() {
      this.restore();
    },
    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
      this.save();
      resetCtxToDefault(this.ctx);
      this.current = new CanvasExtraState();

      if (Array.isArray(rect) && rect.length === 4) {
        var width = rect[2] - rect[0];
        var height = rect[3] - rect[1];
        this.ctx.rect(rect[0], rect[1], width, height);
        this.clip();
        this.endPath();
      }

      this.transform.apply(this, transform);
      this.transform.apply(this, matrix);
    },
    endAnnotation: function CanvasGraphics_endAnnotation() {
      this.restore();
    },
    paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
      var domImage = this.objs.get(objId);

      if (!domImage) {
        (0, _util.warn)('Dependent image isn\'t ready yet');
        return;
      }

      this.save();
      var ctx = this.ctx;
      ctx.scale(1 / w, -1 / h);
      ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);

      if (this.imageLayer) {
        var currentTransform = ctx.mozCurrentTransformInverse;
        var position = this.getCanvasPosition(0, 0);
        this.imageLayer.appendImage({
          objId: objId,
          left: position[0],
          top: position[1],
          width: w / currentTransform[0],
          height: h / currentTransform[3]
        });
      }

      this.restore();
    },
    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
      var ctx = this.ctx;
      var width = img.width,
          height = img.height;
      var fillColor = this.current.fillColor;
      var isPatternFill = this.current.patternFill;
      var glyph = this.processingType3;

      if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
          glyph.compiled = compileType3Glyph({
            data: img.data,
            width: width,
            height: height
          });
        } else {
          glyph.compiled = null;
        }
      }

      if (glyph && glyph.compiled) {
        glyph.compiled(ctx);
        return;
      }

      var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
      var maskCtx = maskCanvas.context;
      maskCtx.save();
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = 'source-in';
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      this.paintInlineImageXObject(maskCanvas.canvas);
    },
    paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {
      var width = imgData.width;
      var height = imgData.height;
      var fillColor = this.current.fillColor;
      var isPatternFill = this.current.patternFill;
      var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
      var maskCtx = maskCanvas.context;
      maskCtx.save();
      putBinaryImageMask(maskCtx, imgData);
      maskCtx.globalCompositeOperation = 'source-in';
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      var ctx = this.ctx;

      for (var i = 0, ii = positions.length; i < ii; i += 2) {
        ctx.save();
        ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);
        ctx.scale(1, -1);
        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
        ctx.restore();
      }
    },
    paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
      var ctx = this.ctx;
      var fillColor = this.current.fillColor;
      var isPatternFill = this.current.patternFill;

      for (var i = 0, ii = images.length; i < ii; i++) {
        var image = images[i];
        var width = image.width,
            height = image.height;
        var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
        var maskCtx = maskCanvas.context;
        maskCtx.save();
        putBinaryImageMask(maskCtx, image);
        maskCtx.globalCompositeOperation = 'source-in';
        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
        maskCtx.fillRect(0, 0, width, height);
        maskCtx.restore();
        ctx.save();
        ctx.transform.apply(ctx, image.transform);
        ctx.scale(1, -1);
        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
        ctx.restore();
      }
    },
    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
      var imgData = this.objs.get(objId);

      if (!imgData) {
        (0, _util.warn)('Dependent image isn\'t ready yet');
        return;
      }

      this.paintInlineImageXObject(imgData);
    },
    paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
      var imgData = this.objs.get(objId);

      if (!imgData) {
        (0, _util.warn)('Dependent image isn\'t ready yet');
        return;
      }

      var width = imgData.width;
      var height = imgData.height;
      var map = [];

      for (var i = 0, ii = positions.length; i < ii; i += 2) {
        map.push({
          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
          x: 0,
          y: 0,
          w: width,
          h: height
        });
      }

      this.paintInlineImageXObjectGroup(imgData, map);
    },
    paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
      var width = imgData.width;
      var height = imgData.height;
      var ctx = this.ctx;
      this.save();
      ctx.scale(1 / width, -1 / height);
      var currentTransform = ctx.mozCurrentTransformInverse;
      var a = currentTransform[0],
          b = currentTransform[1];
      var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
      var c = currentTransform[2],
          d = currentTransform[3];
      var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
      var imgToPaint, tmpCanvas;

      if (typeof HTMLElement === 'function' && imgData instanceof HTMLElement || !imgData.data) {
        imgToPaint = imgData;
      } else {
        tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', width, height);
        var tmpCtx = tmpCanvas.context;
        putBinaryImageData(tmpCtx, imgData);
        imgToPaint = tmpCanvas.canvas;
      }

      var paintWidth = width,
          paintHeight = height;
      var tmpCanvasId = 'prescale1';

      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
        var newWidth = paintWidth,
            newHeight = paintHeight;

        if (widthScale > 2 && paintWidth > 1) {
          newWidth = Math.ceil(paintWidth / 2);
          widthScale /= paintWidth / newWidth;
        }

        if (heightScale > 2 && paintHeight > 1) {
          newHeight = Math.ceil(paintHeight / 2);
          heightScale /= paintHeight / newHeight;
        }

        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
        tmpCtx = tmpCanvas.context;
        tmpCtx.clearRect(0, 0, newWidth, newHeight);
        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
        imgToPaint = tmpCanvas.canvas;
        paintWidth = newWidth;
        paintHeight = newHeight;
        tmpCanvasId = tmpCanvasId === 'prescale1' ? 'prescale2' : 'prescale1';
      }

      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);

      if (this.imageLayer) {
        var position = this.getCanvasPosition(0, -height);
        this.imageLayer.appendImage({
          imgData: imgData,
          left: position[0],
          top: position[1],
          width: width / currentTransform[0],
          height: height / currentTransform[3]
        });
      }

      this.restore();
    },
    paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
      var ctx = this.ctx;
      var w = imgData.width;
      var h = imgData.height;
      var tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', w, h);
      var tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);

      for (var i = 0, ii = map.length; i < ii; i++) {
        var entry = map[i];
        ctx.save();
        ctx.transform.apply(ctx, entry.transform);
        ctx.scale(1, -1);
        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

        if (this.imageLayer) {
          var position = this.getCanvasPosition(entry.x, entry.y);
          this.imageLayer.appendImage({
            imgData: imgData,
            left: position[0],
            top: position[1],
            width: w,
            height: h
          });
        }

        ctx.restore();
      }
    },
    paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
      this.ctx.fillRect(0, 0, 1, 1);
    },
    paintXObject: function CanvasGraphics_paintXObject() {
      (0, _util.warn)('Unsupported \'paintXObject\' command.');
    },
    markPoint: function CanvasGraphics_markPoint(tag) {},
    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},
    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {},
    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {},
    endMarkedContent: function CanvasGraphics_endMarkedContent() {},
    beginCompat: function CanvasGraphics_beginCompat() {},
    endCompat: function CanvasGraphics_endCompat() {},
    consumePath: function CanvasGraphics_consumePath() {
      var ctx = this.ctx;

      if (this.pendingClip) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip('evenodd');
        } else {
          ctx.clip();
        }

        this.pendingClip = null;
      }

      ctx.beginPath();
    },
    getSinglePixelWidth: function getSinglePixelWidth(scale) {
      if (this._cachedGetSinglePixelWidth === null) {
        var inverse = this.ctx.mozCurrentTransformInverse;
        this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));
      }

      return this._cachedGetSinglePixelWidth;
    },
    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
      var transform = this.ctx.mozCurrentTransform;
      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
    }
  };

  for (var op in _util.OPS) {
    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
  }

  return CanvasGraphics;
}();

exports.CanvasGraphics = CanvasGraphics;

/***/ }),
/* 155 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShadingPatternFromIR = getShadingPatternFromIR;
exports.TilingPattern = void 0;

var _util = __w_pdfjs_require__(1);

var ShadingIRs = {};
ShadingIRs.RadialAxial = {
  fromIR: function RadialAxial_fromIR(raw) {
    var type = raw[1];
    var colorStops = raw[2];
    var p0 = raw[3];
    var p1 = raw[4];
    var r0 = raw[5];
    var r1 = raw[6];
    return {
      type: 'Pattern',
      getPattern: function RadialAxial_getPattern(ctx) {
        var grad;

        if (type === 'axial') {
          grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
        } else if (type === 'radial') {
          grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
        }

        for (var i = 0, ii = colorStops.length; i < ii; ++i) {
          var c = colorStops[i];
          grad.addColorStop(c[0], c[1]);
        }

        return grad;
      }
    };
  }
};

var createMeshCanvas = function createMeshCanvasClosure() {
  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
    var coords = context.coords,
        colors = context.colors;
    var bytes = data.data,
        rowSize = data.width * 4;
    var tmp;

    if (coords[p1 + 1] > coords[p2 + 1]) {
      tmp = p1;
      p1 = p2;
      p2 = tmp;
      tmp = c1;
      c1 = c2;
      c2 = tmp;
    }

    if (coords[p2 + 1] > coords[p3 + 1]) {
      tmp = p2;
      p2 = p3;
      p3 = tmp;
      tmp = c2;
      c2 = c3;
      c3 = tmp;
    }

    if (coords[p1 + 1] > coords[p2 + 1]) {
      tmp = p1;
      p1 = p2;
      p2 = tmp;
      tmp = c1;
      c1 = c2;
      c2 = tmp;
    }

    var x1 = (coords[p1] + context.offsetX) * context.scaleX;
    var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
    var x2 = (coords[p2] + context.offsetX) * context.scaleX;
    var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
    var x3 = (coords[p3] + context.offsetX) * context.scaleX;
    var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

    if (y1 >= y3) {
      return;
    }

    var c1r = colors[c1],
        c1g = colors[c1 + 1],
        c1b = colors[c1 + 2];
    var c2r = colors[c2],
        c2g = colors[c2 + 1],
        c2b = colors[c2 + 2];
    var c3r = colors[c3],
        c3g = colors[c3 + 1],
        c3b = colors[c3 + 2];
    var minY = Math.round(y1),
        maxY = Math.round(y3);
    var xa, car, cag, cab;
    var xb, cbr, cbg, cbb;
    var k;

    for (var y = minY; y <= maxY; y++) {
      if (y < y2) {
        k = y < y1 ? 0 : y1 === y2 ? 1 : (y1 - y) / (y1 - y2);
        xa = x1 - (x1 - x2) * k;
        car = c1r - (c1r - c2r) * k;
        cag = c1g - (c1g - c2g) * k;
        cab = c1b - (c1b - c2b) * k;
      } else {
        k = y > y3 ? 1 : y2 === y3 ? 0 : (y2 - y) / (y2 - y3);
        xa = x2 - (x2 - x3) * k;
        car = c2r - (c2r - c3r) * k;
        cag = c2g - (c2g - c3g) * k;
        cab = c2b - (c2b - c3b) * k;
      }

      k = y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3);
      xb = x1 - (x1 - x3) * k;
      cbr = c1r - (c1r - c3r) * k;
      cbg = c1g - (c1g - c3g) * k;
      cbb = c1b - (c1b - c3b) * k;
      var x1_ = Math.round(Math.min(xa, xb));
      var x2_ = Math.round(Math.max(xa, xb));
      var j = rowSize * y + x1_ * 4;

      for (var x = x1_; x <= x2_; x++) {
        k = (xa - x) / (xa - xb);
        k = k < 0 ? 0 : k > 1 ? 1 : k;
        bytes[j++] = car - (car - cbr) * k | 0;
        bytes[j++] = cag - (cag - cbg) * k | 0;
        bytes[j++] = cab - (cab - cbb) * k | 0;
        bytes[j++] = 255;
      }
    }
  }

  function drawFigure(data, figure, context) {
    var ps = figure.coords;
    var cs = figure.colors;
    var i, ii;

    switch (figure.type) {
      case 'lattice':
        var verticesPerRow = figure.verticesPerRow;
        var rows = Math.floor(ps.length / verticesPerRow) - 1;
        var cols = verticesPerRow - 1;

        for (i = 0; i < rows; i++) {
          var q = i * verticesPerRow;

          for (var j = 0; j < cols; j++, q++) {
            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
          }
        }

        break;

      case 'triangles':
        for (i = 0, ii = ps.length; i < ii; i += 3) {
          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
        }

        break;

      default:
        throw new Error('illegal figure');
    }
  }

  function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
    var EXPECTED_SCALE = 1.1;
    var MAX_PATTERN_SIZE = 3000;
    var BORDER_SIZE = 2;
    var offsetX = Math.floor(bounds[0]);
    var offsetY = Math.floor(bounds[1]);
    var boundsWidth = Math.ceil(bounds[2]) - offsetX;
    var boundsHeight = Math.ceil(bounds[3]) - offsetY;
    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    var scaleX = boundsWidth / width;
    var scaleY = boundsHeight / height;
    var context = {
      coords: coords,
      colors: colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    var paddedWidth = width + BORDER_SIZE * 2;
    var paddedHeight = height + BORDER_SIZE * 2;
    var canvas, tmpCanvas, i, ii;

    if (webGLContext.isEnabled) {
      canvas = webGLContext.drawFigures({
        width: width,
        height: height,
        backgroundColor: backgroundColor,
        figures: figures,
        context: context
      });
      tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);
      tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
      canvas = tmpCanvas.canvas;
    } else {
      tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);
      var tmpCtx = tmpCanvas.context;
      var data = tmpCtx.createImageData(width, height);

      if (backgroundColor) {
        var bytes = data.data;

        for (i = 0, ii = bytes.length; i < ii; i += 4) {
          bytes[i] = backgroundColor[0];
          bytes[i + 1] = backgroundColor[1];
          bytes[i + 2] = backgroundColor[2];
          bytes[i + 3] = 255;
        }
      }

      for (i = 0; i < figures.length; i++) {
        drawFigure(data, figures[i], context);
      }

      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
      canvas = tmpCanvas.canvas;
    }

    return {
      canvas: canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  return createMeshCanvas;
}();

ShadingIRs.Mesh = {
  fromIR: function Mesh_fromIR(raw) {
    var coords = raw[2];
    var colors = raw[3];
    var figures = raw[4];
    var bounds = raw[5];
    var matrix = raw[6];
    var background = raw[8];
    return {
      type: 'Pattern',
      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
        var scale;

        if (shadingFill) {
          scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
        } else {
          scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

          if (matrix) {
            var matrixScale = _util.Util.singularValueDecompose2dScale(matrix);

            scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
          }
        }

        var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);

        if (!shadingFill) {
          ctx.setTransform.apply(ctx, owner.baseTransform);

          if (matrix) {
            ctx.transform.apply(ctx, matrix);
          }
        }

        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
        return ctx.createPattern(temporaryPatternCanvas.canvas, 'no-repeat');
      }
    };
  }
};
ShadingIRs.Dummy = {
  fromIR: function Dummy_fromIR() {
    return {
      type: 'Pattern',
      getPattern: function Dummy_fromIR_getPattern() {
        return 'hotpink';
      }
    };
  }
};

function getShadingPatternFromIR(raw) {
  var shadingIR = ShadingIRs[raw[0]];

  if (!shadingIR) {
    throw new Error("Unknown IR type: ".concat(raw[0]));
  }

  return shadingIR.fromIR(raw);
}

var TilingPattern = function TilingPatternClosure() {
  var PaintType = {
    COLORED: 1,
    UNCOLORED: 2
  };
  var MAX_PATTERN_SIZE = 3000;

  function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
    this.operatorList = IR[2];
    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.color = color;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
    this.type = 'Pattern';
    this.ctx = ctx;
  }

  TilingPattern.prototype = {
    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
      var operatorList = this.operatorList;
      var bbox = this.bbox;
      var xstep = this.xstep;
      var ystep = this.ystep;
      var paintType = this.paintType;
      var tilingType = this.tilingType;
      var color = this.color;
      var canvasGraphicsFactory = this.canvasGraphicsFactory;
      (0, _util.info)('TilingType: ' + tilingType);
      var x0 = bbox[0],
          y0 = bbox[1],
          x1 = bbox[2],
          y1 = bbox[3];
      var topLeft = [x0, y0];
      var botRight = [x0 + xstep, y0 + ystep];
      var width = botRight[0] - topLeft[0];
      var height = botRight[1] - topLeft[1];

      var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

      var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

      var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
      width = Math.min(Math.ceil(Math.abs(width * combinedScale[0])), MAX_PATTERN_SIZE);
      height = Math.min(Math.ceil(Math.abs(height * combinedScale[1])), MAX_PATTERN_SIZE);
      var tmpCanvas = owner.cachedCanvases.getCanvas('pattern', width, height, true);
      var tmpCtx = tmpCanvas.context;
      var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
      graphics.groupLevel = owner.groupLevel;
      this.setFillAndStrokeStyleToContext(graphics, paintType, color);
      this.setScale(width, height, xstep, ystep);
      this.transformToScale(graphics);
      var tmpTranslate = [1, 0, 0, 1, -topLeft[0], -topLeft[1]];
      graphics.transform.apply(graphics, tmpTranslate);
      this.clipBbox(graphics, bbox, x0, y0, x1, y1);
      graphics.executeOperatorList(operatorList);
      return tmpCanvas.canvas;
    },
    setScale: function TilingPattern_setScale(width, height, xstep, ystep) {
      this.scale = [width / xstep, height / ystep];
    },
    transformToScale: function TilingPattern_transformToScale(graphics) {
      var scale = this.scale;
      var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];
      graphics.transform.apply(graphics, tmpScale);
    },
    scaleToContext: function TilingPattern_scaleToContext() {
      var scale = this.scale;
      this.ctx.scale(1 / scale[0], 1 / scale[1]);
    },
    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
      if (Array.isArray(bbox) && bbox.length === 4) {
        var bboxWidth = x1 - x0;
        var bboxHeight = y1 - y0;
        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
        graphics.clip();
        graphics.endPath();
      }
    },
    setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
      var context = graphics.ctx,
          current = graphics.current;

      switch (paintType) {
        case PaintType.COLORED:
          var ctx = this.ctx;
          context.fillStyle = ctx.fillStyle;
          context.strokeStyle = ctx.strokeStyle;
          current.fillColor = ctx.fillStyle;
          current.strokeColor = ctx.strokeStyle;
          break;

        case PaintType.UNCOLORED:
          var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]);

          context.fillStyle = cssColor;
          context.strokeStyle = cssColor;
          current.fillColor = cssColor;
          current.strokeColor = cssColor;
          break;

        default:
          throw new _util.FormatError("Unsupported paint type: ".concat(paintType));
      }
    },
    getPattern: function TilingPattern_getPattern(ctx, owner) {
      var temporaryPatternCanvas = this.createPatternCanvas(owner);
      ctx = this.ctx;
      ctx.setTransform.apply(ctx, this.baseTransform);
      ctx.transform.apply(ctx, this.matrix);
      this.scaleToContext();
      return ctx.createPattern(temporaryPatternCanvas, 'repeat');
    }
  };
  return TilingPattern;
}();

exports.TilingPattern = TilingPattern;

/***/ }),
/* 156 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GlobalWorkerOptions = void 0;
var GlobalWorkerOptions = Object.create(null);
exports.GlobalWorkerOptions = GlobalWorkerOptions;
GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? '' : GlobalWorkerOptions.workerSrc;

/***/ }),
/* 157 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageHandler = MessageHandler;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(147));

var _util = __w_pdfjs_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function resolveCall(_x, _x2) {
  return _resolveCall.apply(this, arguments);
}

function _resolveCall() {
  _resolveCall = _asyncToGenerator(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(fn, args) {
    var thisArg,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            thisArg = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;

            if (fn) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return");

          case 3:
            return _context.abrupt("return", fn.apply(thisArg, args));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _resolveCall.apply(this, arguments);
}

function wrapReason(reason) {
  if (_typeof(reason) !== 'object') {
    return reason;
  }

  switch (reason.name) {
    case 'AbortException':
      return new _util.AbortException(reason.message);

    case 'MissingPDFException':
      return new _util.MissingPDFException(reason.message);

    case 'UnexpectedResponseException':
      return new _util.UnexpectedResponseException(reason.message, reason.status);

    default:
      return new _util.UnknownErrorException(reason.message, reason.details);
  }
}

function makeReasonSerializable(reason) {
  if (!(reason instanceof Error) || reason instanceof _util.AbortException || reason instanceof _util.MissingPDFException || reason instanceof _util.UnexpectedResponseException || reason instanceof _util.UnknownErrorException) {
    return reason;
  }

  return new _util.UnknownErrorException(reason.message, reason.toString());
}

function resolveOrReject(capability, success, reason) {
  if (success) {
    capability.resolve();
  } else {
    capability.reject(reason);
  }
}

function finalize(promise) {
  return Promise.resolve(promise).catch(function () {});
}

function MessageHandler(sourceName, targetName, comObj) {
  var _this = this;

  this.sourceName = sourceName;
  this.targetName = targetName;
  this.comObj = comObj;
  this.callbackId = 1;
  this.streamId = 1;
  this.postMessageTransfers = true;
  this.streamSinks = Object.create(null);
  this.streamControllers = Object.create(null);
  var callbacksCapabilities = this.callbacksCapabilities = Object.create(null);
  var ah = this.actionHandler = Object.create(null);

  this._onComObjOnMessage = function (event) {
    var data = event.data;

    if (data.targetName !== _this.sourceName) {
      return;
    }

    if (data.stream) {
      _this._processStreamMessage(data);
    } else if (data.isReply) {
      var callbackId = data.callbackId;

      if (data.callbackId in callbacksCapabilities) {
        var callback = callbacksCapabilities[callbackId];
        delete callbacksCapabilities[callbackId];

        if ('error' in data) {
          callback.reject(wrapReason(data.error));
        } else {
          callback.resolve(data.data);
        }
      } else {
        throw new Error("Cannot resolve callback ".concat(callbackId));
      }
    } else if (data.action in ah) {
      var action = ah[data.action];

      if (data.callbackId) {
        var _sourceName = _this.sourceName;
        var _targetName = data.sourceName;
        Promise.resolve().then(function () {
          return action[0].call(action[1], data.data);
        }).then(function (result) {
          comObj.postMessage({
            sourceName: _sourceName,
            targetName: _targetName,
            isReply: true,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: _sourceName,
            targetName: _targetName,
            isReply: true,
            callbackId: data.callbackId,
            error: makeReasonSerializable(reason)
          });
        });
      } else if (data.streamId) {
        _this._createStreamSink(data);
      } else {
        action[0].call(action[1], data.data);
      }
    } else {
      throw new Error("Unknown action from worker: ".concat(data.action));
    }
  };

  comObj.addEventListener('message', this._onComObjOnMessage);
}

MessageHandler.prototype = {
  on: function on(actionName, handler, scope) {
    var ah = this.actionHandler;

    if (ah[actionName]) {
      throw new Error("There is already an actionName called \"".concat(actionName, "\""));
    }

    ah[actionName] = [handler, scope];
  },
  send: function send(actionName, data, transfers) {
    var message = {
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data: data
    };
    this.postMessage(message, transfers);
  },
  sendWithPromise: function sendWithPromise(actionName, data, transfers) {
    var callbackId = this.callbackId++;
    var message = {
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data: data,
      callbackId: callbackId
    };
    var capability = (0, _util.createPromiseCapability)();
    this.callbacksCapabilities[callbackId] = capability;

    try {
      this.postMessage(message, transfers);
    } catch (e) {
      capability.reject(e);
    }

    return capability.promise;
  },
  sendWithStream: function sendWithStream(actionName, data, queueingStrategy, transfers) {
    var _this2 = this;

    var streamId = this.streamId++;
    var sourceName = this.sourceName;
    var targetName = this.targetName;
    return new _util.ReadableStream({
      start: function start(controller) {
        var startCapability = (0, _util.createPromiseCapability)();
        _this2.streamControllers[streamId] = {
          controller: controller,
          startCall: startCapability,
          isClosed: false
        };

        _this2.postMessage({
          sourceName: sourceName,
          targetName: targetName,
          action: actionName,
          streamId: streamId,
          data: data,
          desiredSize: controller.desiredSize
        });

        return startCapability.promise;
      },
      pull: function pull(controller) {
        var pullCapability = (0, _util.createPromiseCapability)();
        _this2.streamControllers[streamId].pullCall = pullCapability;

        _this2.postMessage({
          sourceName: sourceName,
          targetName: targetName,
          stream: 'pull',
          streamId: streamId,
          desiredSize: controller.desiredSize
        });

        return pullCapability.promise;
      },
      cancel: function cancel(reason) {
        var cancelCapability = (0, _util.createPromiseCapability)();
        _this2.streamControllers[streamId].cancelCall = cancelCapability;
        _this2.streamControllers[streamId].isClosed = true;

        _this2.postMessage({
          sourceName: sourceName,
          targetName: targetName,
          stream: 'cancel',
          reason: reason,
          streamId: streamId
        });

        return cancelCapability.promise;
      }
    }, queueingStrategy);
  },
  _createStreamSink: function _createStreamSink(data) {
    var _this3 = this;

    var self = this;
    var action = this.actionHandler[data.action];
    var streamId = data.streamId;
    var desiredSize = data.desiredSize;
    var sourceName = this.sourceName;
    var targetName = data.sourceName;
    var capability = (0, _util.createPromiseCapability)();

    var sendStreamRequest = function sendStreamRequest(_ref) {
      var stream = _ref.stream,
          chunk = _ref.chunk,
          transfers = _ref.transfers,
          success = _ref.success,
          reason = _ref.reason;

      _this3.postMessage({
        sourceName: sourceName,
        targetName: targetName,
        stream: stream,
        streamId: streamId,
        chunk: chunk,
        success: success,
        reason: reason
      }, transfers);
    };

    var streamSink = {
      enqueue: function enqueue(chunk) {
        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var transfers = arguments.length > 2 ? arguments[2] : undefined;

        if (this.isCancelled) {
          return;
        }

        var lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;

        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = (0, _util.createPromiseCapability)();
          this.ready = this.sinkCapability.promise;
        }

        sendStreamRequest({
          stream: 'enqueue',
          chunk: chunk,
          transfers: transfers
        });
      },
      close: function close() {
        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        sendStreamRequest({
          stream: 'close'
        });
        delete self.streamSinks[streamId];
      },
      error: function error(reason) {
        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        sendStreamRequest({
          stream: 'error',
          reason: reason
        });
      },
      sinkCapability: capability,
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    resolveCall(action[0], [data.data, streamSink], action[1]).then(function () {
      sendStreamRequest({
        stream: 'start_complete',
        success: true
      });
    }, function (reason) {
      sendStreamRequest({
        stream: 'start_complete',
        success: false,
        reason: reason
      });
    });
  },
  _processStreamMessage: function _processStreamMessage(data) {
    var _this4 = this;

    var sourceName = this.sourceName;
    var targetName = data.sourceName;
    var streamId = data.streamId;

    var sendStreamResponse = function sendStreamResponse(_ref2) {
      var stream = _ref2.stream,
          success = _ref2.success,
          reason = _ref2.reason;

      _this4.comObj.postMessage({
        sourceName: sourceName,
        targetName: targetName,
        stream: stream,
        success: success,
        streamId: streamId,
        reason: reason
      });
    };

    var deleteStreamController = function deleteStreamController() {
      Promise.all([_this4.streamControllers[data.streamId].startCall, _this4.streamControllers[data.streamId].pullCall, _this4.streamControllers[data.streamId].cancelCall].map(function (capability) {
        return capability && finalize(capability.promise);
      })).then(function () {
        delete _this4.streamControllers[data.streamId];
      });
    };

    switch (data.stream) {
      case 'start_complete':
        resolveOrReject(this.streamControllers[data.streamId].startCall, data.success, wrapReason(data.reason));
        break;

      case 'pull_complete':
        resolveOrReject(this.streamControllers[data.streamId].pullCall, data.success, wrapReason(data.reason));
        break;

      case 'pull':
        if (!this.streamSinks[data.streamId]) {
          sendStreamResponse({
            stream: 'pull_complete',
            success: true
          });
          break;
        }

        if (this.streamSinks[data.streamId].desiredSize <= 0 && data.desiredSize > 0) {
          this.streamSinks[data.streamId].sinkCapability.resolve();
        }

        this.streamSinks[data.streamId].desiredSize = data.desiredSize;
        resolveCall(this.streamSinks[data.streamId].onPull).then(function () {
          sendStreamResponse({
            stream: 'pull_complete',
            success: true
          });
        }, function (reason) {
          sendStreamResponse({
            stream: 'pull_complete',
            success: false,
            reason: reason
          });
        });
        break;

      case 'enqueue':
        (0, _util.assert)(this.streamControllers[data.streamId], 'enqueue should have stream controller');

        if (!this.streamControllers[data.streamId].isClosed) {
          this.streamControllers[data.streamId].controller.enqueue(data.chunk);
        }

        break;

      case 'close':
        (0, _util.assert)(this.streamControllers[data.streamId], 'close should have stream controller');

        if (this.streamControllers[data.streamId].isClosed) {
          break;
        }

        this.streamControllers[data.streamId].isClosed = true;
        this.streamControllers[data.streamId].controller.close();
        deleteStreamController();
        break;

      case 'error':
        (0, _util.assert)(this.streamControllers[data.streamId], 'error should have stream controller');
        this.streamControllers[data.streamId].controller.error(wrapReason(data.reason));
        deleteStreamController();
        break;

      case 'cancel_complete':
        resolveOrReject(this.streamControllers[data.streamId].cancelCall, data.success, wrapReason(data.reason));
        deleteStreamController();
        break;

      case 'cancel':
        if (!this.streamSinks[data.streamId]) {
          break;
        }

        resolveCall(this.streamSinks[data.streamId].onCancel, [wrapReason(data.reason)]).then(function () {
          sendStreamResponse({
            stream: 'cancel_complete',
            success: true
          });
        }, function (reason) {
          sendStreamResponse({
            stream: 'cancel_complete',
            success: false,
            reason: reason
          });
        });
        this.streamSinks[data.streamId].sinkCapability.reject(wrapReason(data.reason));
        this.streamSinks[data.streamId].isCancelled = true;
        delete this.streamSinks[data.streamId];
        break;

      default:
        throw new Error('Unexpected stream case');
    }
  },
  postMessage: function postMessage(message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  },
  destroy: function destroy() {
    this.comObj.removeEventListener('message', this._onComObjOnMessage);
  }
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Metadata = void 0;

var _util = __w_pdfjs_require__(1);

var _xml_parser = __w_pdfjs_require__(159);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Metadata =
/*#__PURE__*/
function () {
  function Metadata(data) {
    _classCallCheck(this, Metadata);

    (0, _util.assert)(typeof data === 'string', 'Metadata: input is not a string');
    data = this._repair(data);
    var parser = new _xml_parser.SimpleXMLParser();
    var xmlDocument = parser.parseFromString(data);
    this._metadata = Object.create(null);

    if (xmlDocument) {
      this._parse(xmlDocument);
    }
  }

  _createClass(Metadata, [{
    key: "_repair",
    value: function _repair(data) {
      return data.replace(/^([^<]+)/, '').replace(/>\\376\\377([^<]+)/g, function (all, codes) {
        var bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {
          return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
        }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {
          switch (name) {
            case 'amp':
              return '&';

            case 'apos':
              return '\'';

            case 'gt':
              return '>';

            case 'lt':
              return '<';

            case 'quot':
              return '\"';
          }

          throw new Error("_repair: ".concat(name, " isn't defined."));
        });
        var chars = '';

        for (var i = 0, ii = bytes.length; i < ii; i += 2) {
          var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);

          if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
            chars += String.fromCharCode(code);
          } else {
            chars += '&#x' + (0x10000 + code).toString(16).substring(1) + ';';
          }
        }

        return '>' + chars;
      });
    }
  }, {
    key: "_parse",
    value: function _parse(xmlDocument) {
      var rdf = xmlDocument.documentElement;

      if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
        rdf = rdf.firstChild;

        while (rdf && rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
          rdf = rdf.nextSibling;
        }
      }

      var nodeName = rdf ? rdf.nodeName.toLowerCase() : null;

      if (!rdf || nodeName !== 'rdf:rdf' || !rdf.hasChildNodes()) {
        return;
      }

      var children = rdf.childNodes;

      for (var i = 0, ii = children.length; i < ii; i++) {
        var desc = children[i];

        if (desc.nodeName.toLowerCase() !== 'rdf:description') {
          continue;
        }

        for (var j = 0, jj = desc.childNodes.length; j < jj; j++) {
          if (desc.childNodes[j].nodeName.toLowerCase() !== '#text') {
            var entry = desc.childNodes[j];
            var name = entry.nodeName.toLowerCase();
            this._metadata[name] = entry.textContent.trim();
          }
        }
      }
    }
  }, {
    key: "get",
    value: function get(name) {
      var data = this._metadata[name];
      return typeof data !== 'undefined' ? data : null;
    }
  }, {
    key: "getAll",
    value: function getAll() {
      return this._metadata;
    }
  }, {
    key: "has",
    value: function has(name) {
      return typeof this._metadata[name] !== 'undefined';
    }
  }]);

  return Metadata;
}();

exports.Metadata = Metadata;

/***/ }),
/* 159 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SimpleXMLParser = void 0;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var XMLParserErrorCode = {
  NoError: 0,
  EndOfDocument: -1,
  UnterminatedCdat: -2,
  UnterminatedXmlDeclaration: -3,
  UnterminatedDoctypeDeclaration: -4,
  UnterminatedComment: -5,
  MalformedElement: -6,
  OutOfMemory: -7,
  UnterminatedAttributeValue: -8,
  UnterminatedElement: -9,
  ElementNeverBegun: -10
};

function isWhitespace(s, index) {
  var ch = s[index];
  return ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t';
}

function isWhitespaceString(s) {
  for (var i = 0, ii = s.length; i < ii; i++) {
    if (!isWhitespace(s, i)) {
      return false;
    }
  }

  return true;
}

var XMLParserBase =
/*#__PURE__*/
function () {
  function XMLParserBase() {
    _classCallCheck(this, XMLParserBase);
  }

  _createClass(XMLParserBase, [{
    key: "_resolveEntities",
    value: function _resolveEntities(s) {
      var _this = this;

      return s.replace(/&([^;]+);/g, function (all, entity) {
        if (entity.substring(0, 2) === '#x') {
          return String.fromCharCode(parseInt(entity.substring(2), 16));
        } else if (entity.substring(0, 1) === '#') {
          return String.fromCharCode(parseInt(entity.substring(1), 10));
        }

        switch (entity) {
          case 'lt':
            return '<';

          case 'gt':
            return '>';

          case 'amp':
            return '&';

          case 'quot':
            return '\"';
        }

        return _this.onResolveEntity(entity);
      });
    }
  }, {
    key: "_parseContent",
    value: function _parseContent(s, start) {
      var pos = start,
          name,
          attributes = [];

      function skipWs() {
        while (pos < s.length && isWhitespace(s, pos)) {
          ++pos;
        }
      }

      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '>' && s[pos] !== '/') {
        ++pos;
      }

      name = s.substring(start, pos);
      skipWs();

      while (pos < s.length && s[pos] !== '>' && s[pos] !== '/' && s[pos] !== '?') {
        skipWs();
        var attrName = '',
            attrValue = '';

        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '=') {
          attrName += s[pos];
          ++pos;
        }

        skipWs();

        if (s[pos] !== '=') {
          return null;
        }

        ++pos;
        skipWs();
        var attrEndChar = s[pos];

        if (attrEndChar !== '\"' && attrEndChar !== '\'') {
          return null;
        }

        var attrEndIndex = s.indexOf(attrEndChar, ++pos);

        if (attrEndIndex < 0) {
          return null;
        }

        attrValue = s.substring(pos, attrEndIndex);
        attributes.push({
          name: attrName,
          value: this._resolveEntities(attrValue)
        });
        pos = attrEndIndex + 1;
        skipWs();
      }

      return {
        name: name,
        attributes: attributes,
        parsed: pos - start
      };
    }
  }, {
    key: "_parseProcessingInstruction",
    value: function _parseProcessingInstruction(s, start) {
      var pos = start,
          name,
          value;

      function skipWs() {
        while (pos < s.length && isWhitespace(s, pos)) {
          ++pos;
        }
      }

      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '>' && s[pos] !== '/') {
        ++pos;
      }

      name = s.substring(start, pos);
      skipWs();
      var attrStart = pos;

      while (pos < s.length && (s[pos] !== '?' || s[pos + 1] !== '>')) {
        ++pos;
      }

      value = s.substring(attrStart, pos);
      return {
        name: name,
        value: value,
        parsed: pos - start
      };
    }
  }, {
    key: "parseXml",
    value: function parseXml(s) {
      var i = 0;

      while (i < s.length) {
        var ch = s[i];
        var j = i;

        if (ch === '<') {
          ++j;
          var ch2 = s[j];
          var q = void 0;

          switch (ch2) {
            case '/':
              ++j;
              q = s.indexOf('>', j);

              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedElement);
                return;
              }

              this.onEndElement(s.substring(j, q));
              j = q + 1;
              break;

            case '?':
              ++j;

              var pi = this._parseProcessingInstruction(s, j);

              if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== '?>') {
                this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                return;
              }

              this.onPi(pi.name, pi.value);
              j += pi.parsed + 2;
              break;

            case '!':
              if (s.substring(j + 1, j + 3) === '--') {
                q = s.indexOf('-->', j + 3);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedComment);
                  return;
                }

                this.onComment(s.substring(j + 3, q));
                j = q + 3;
              } else if (s.substring(j + 1, j + 8) === '[CDATA[') {
                q = s.indexOf(']]>', j + 8);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedCdat);
                  return;
                }

                this.onCdata(s.substring(j + 8, q));
                j = q + 3;
              } else if (s.substring(j + 1, j + 8) === 'DOCTYPE') {
                var q2 = s.indexOf('[', j + 8);
                var complexDoctype = false;
                q = s.indexOf('>', j + 8);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                  return;
                }

                if (q2 > 0 && q > q2) {
                  q = s.indexOf(']>', j + 8);

                  if (q < 0) {
                    this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                    return;
                  }

                  complexDoctype = true;
                }

                var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                this.onDoctype(doctypeContent);
                j = q + (complexDoctype ? 2 : 1);
              } else {
                this.onError(XMLParserErrorCode.MalformedElement);
                return;
              }

              break;

            default:
              var content = this._parseContent(s, j);

              if (content === null) {
                this.onError(XMLParserErrorCode.MalformedElement);
                return;
              }

              var isClosed = false;

              if (s.substring(j + content.parsed, j + content.parsed + 2) === '/>') {
                isClosed = true;
              } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== '>') {
                this.onError(XMLParserErrorCode.UnterminatedElement);
                return;
              }

              this.onBeginElement(content.name, content.attributes, isClosed);
              j += content.parsed + (isClosed ? 2 : 1);
              break;
          }
        } else {
          while (j < s.length && s[j] !== '<') {
            j++;
          }

          var text = s.substring(i, j);
          this.onText(this._resolveEntities(text));
        }

        i = j;
      }
    }
  }, {
    key: "onResolveEntity",
    value: function onResolveEntity(name) {
      return "&".concat(name, ";");
    }
  }, {
    key: "onPi",
    value: function onPi(name, value) {}
  }, {
    key: "onComment",
    value: function onComment(text) {}
  }, {
    key: "onCdata",
    value: function onCdata(text) {}
  }, {
    key: "onDoctype",
    value: function onDoctype(doctypeContent) {}
  }, {
    key: "onText",
    value: function onText(text) {}
  }, {
    key: "onBeginElement",
    value: function onBeginElement(name, attributes, isEmpty) {}
  }, {
    key: "onEndElement",
    value: function onEndElement(name) {}
  }, {
    key: "onError",
    value: function onError(code) {}
  }]);

  return XMLParserBase;
}();

var SimpleDOMNode =
/*#__PURE__*/
function () {
  function SimpleDOMNode(nodeName, nodeValue) {
    _classCallCheck(this, SimpleDOMNode);

    this.nodeName = nodeName;
    this.nodeValue = nodeValue;
    Object.defineProperty(this, 'parentNode', {
      value: null,
      writable: true
    });
  }

  _createClass(SimpleDOMNode, [{
    key: "hasChildNodes",
    value: function hasChildNodes() {
      return this.childNodes && this.childNodes.length > 0;
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.childNodes && this.childNodes[0];
    }
  }, {
    key: "nextSibling",
    get: function get() {
      var childNodes = this.parentNode.childNodes;

      if (!childNodes) {
        return undefined;
      }

      var index = childNodes.indexOf(this);

      if (index === -1) {
        return undefined;
      }

      return childNodes[index + 1];
    }
  }, {
    key: "textContent",
    get: function get() {
      if (!this.childNodes) {
        return this.nodeValue || '';
      }

      return this.childNodes.map(function (child) {
        return child.textContent;
      }).join('');
    }
  }]);

  return SimpleDOMNode;
}();

var SimpleXMLParser =
/*#__PURE__*/
function (_XMLParserBase) {
  _inherits(SimpleXMLParser, _XMLParserBase);

  function SimpleXMLParser() {
    var _this2;

    _classCallCheck(this, SimpleXMLParser);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(SimpleXMLParser).call(this));
    _this2._currentFragment = null;
    _this2._stack = null;
    _this2._errorCode = XMLParserErrorCode.NoError;
    return _this2;
  }

  _createClass(SimpleXMLParser, [{
    key: "parseFromString",
    value: function parseFromString(data) {
      this._currentFragment = [];
      this._stack = [];
      this._errorCode = XMLParserErrorCode.NoError;
      this.parseXml(data);

      if (this._errorCode !== XMLParserErrorCode.NoError) {
        return undefined;
      }

      var _this$_currentFragmen = _slicedToArray(this._currentFragment, 1),
          documentElement = _this$_currentFragmen[0];

      if (!documentElement) {
        return undefined;
      }

      return {
        documentElement: documentElement
      };
    }
  }, {
    key: "onResolveEntity",
    value: function onResolveEntity(name) {
      switch (name) {
        case 'apos':
          return '\'';
      }

      return _get(_getPrototypeOf(SimpleXMLParser.prototype), "onResolveEntity", this).call(this, name);
    }
  }, {
    key: "onText",
    value: function onText(text) {
      if (isWhitespaceString(text)) {
        return;
      }

      var node = new SimpleDOMNode('#text', text);

      this._currentFragment.push(node);
    }
  }, {
    key: "onCdata",
    value: function onCdata(text) {
      var node = new SimpleDOMNode('#text', text);

      this._currentFragment.push(node);
    }
  }, {
    key: "onBeginElement",
    value: function onBeginElement(name, attributes, isEmpty) {
      var node = new SimpleDOMNode(name);
      node.childNodes = [];

      this._currentFragment.push(node);

      if (isEmpty) {
        return;
      }

      this._stack.push(this._currentFragment);

      this._currentFragment = node.childNodes;
    }
  }, {
    key: "onEndElement",
    value: function onEndElement(name) {
      this._currentFragment = this._stack.pop() || [];
      var lastElement = this._currentFragment[this._currentFragment.length - 1];

      if (!lastElement) {
        return;
      }

      for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
        lastElement.childNodes[i].parentNode = lastElement;
      }
    }
  }, {
    key: "onError",
    value: function onError(code) {
      this._errorCode = code;
    }
  }]);

  return SimpleXMLParser;
}(XMLParserBase);

exports.SimpleXMLParser = SimpleXMLParser;

/***/ }),
/* 160 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFDataTransportStream = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(147));

var _util = __w_pdfjs_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var PDFDataTransportStream = function PDFDataTransportStreamClosure() {
  function PDFDataTransportStream(params, pdfDataRangeTransport) {
    var _this = this;

    (0, _util.assert)(pdfDataRangeTransport);
    this._queuedChunks = [];
    var initialData = params.initialData;

    if (initialData && initialData.length > 0) {
      var buffer = new Uint8Array(initialData).buffer;

      this._queuedChunks.push(buffer);
    }

    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !params.disableStream;
    this._isRangeSupported = !params.disableRange;
    this._contentLength = params.length;
    this._fullRequestReader = null;
    this._rangeReaders = [];

    this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {
      _this._onReceiveData({
        begin: begin,
        chunk: chunk
      });
    });

    this._pdfDataRangeTransport.addProgressListener(function (loaded) {
      _this._onProgress({
        loaded: loaded
      });
    });

    this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {
      _this._onReceiveData({
        chunk: chunk
      });
    });

    this._pdfDataRangeTransport.transportReady();
  }

  PDFDataTransportStream.prototype = {
    _onReceiveData: function PDFDataTransportStream_onReceiveData(args) {
      var buffer = new Uint8Array(args.chunk).buffer;

      if (args.begin === undefined) {
        if (this._fullRequestReader) {
          this._fullRequestReader._enqueue(buffer);
        } else {
          this._queuedChunks.push(buffer);
        }
      } else {
        var found = this._rangeReaders.some(function (rangeReader) {
          if (rangeReader._begin !== args.begin) {
            return false;
          }

          rangeReader._enqueue(buffer);

          return true;
        });

        (0, _util.assert)(found);
      }
    },
    _onProgress: function PDFDataTransportStream_onDataProgress(evt) {
      if (this._rangeReaders.length > 0) {
        var firstReader = this._rangeReaders[0];

        if (firstReader.onProgress) {
          firstReader.onProgress({
            loaded: evt.loaded
          });
        }
      }
    },
    _removeRangeReader: function PDFDataTransportStream_removeRangeReader(reader) {
      var i = this._rangeReaders.indexOf(reader);

      if (i >= 0) {
        this._rangeReaders.splice(i, 1);
      }
    },
    getFullReader: function PDFDataTransportStream_getFullReader() {
      (0, _util.assert)(!this._fullRequestReader);
      var queuedChunks = this._queuedChunks;
      this._queuedChunks = null;
      return new PDFDataTransportStreamReader(this, queuedChunks);
    },
    getRangeReader: function PDFDataTransportStream_getRangeReader(begin, end) {
      var reader = new PDFDataTransportStreamRangeReader(this, begin, end);

      this._pdfDataRangeTransport.requestDataRange(begin, end);

      this._rangeReaders.push(reader);

      return reader;
    },
    cancelAllRequests: function PDFDataTransportStream_cancelAllRequests(reason) {
      if (this._fullRequestReader) {
        this._fullRequestReader.cancel(reason);
      }

      var readers = this._rangeReaders.slice(0);

      readers.forEach(function (rangeReader) {
        rangeReader.cancel(reason);
      });

      this._pdfDataRangeTransport.abort();
    }
  };

  function PDFDataTransportStreamReader(stream, queuedChunks) {
    this._stream = stream;
    this._done = false;
    this._filename = null;
    this._queuedChunks = queuedChunks || [];
    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }

  PDFDataTransportStreamReader.prototype = {
    _enqueue: function PDFDataTransportStreamReader_enqueue(chunk) {
      if (this._done) {
        return;
      }

      if (this._requests.length > 0) {
        var requestCapability = this._requests.shift();

        requestCapability.resolve({
          value: chunk,
          done: false
        });
        return;
      }

      this._queuedChunks.push(chunk);
    },

    get headersReady() {
      return this._headersReady;
    },

    get filename() {
      return this._filename;
    },

    get isRangeSupported() {
      return this._stream._isRangeSupported;
    },

    get isStreamingSupported() {
      return this._stream._isStreamingSupported;
    },

    get contentLength() {
      return this._stream._contentLength;
    },

    read: function () {
      var _read = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        var chunk, requestCapability;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this._queuedChunks.length > 0)) {
                  _context.next = 3;
                  break;
                }

                chunk = this._queuedChunks.shift();
                return _context.abrupt("return", {
                  value: chunk,
                  done: false
                });

              case 3:
                if (!this._done) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", {
                  value: undefined,
                  done: true
                });

              case 5:
                requestCapability = (0, _util.createPromiseCapability)();

                this._requests.push(requestCapability);

                return _context.abrupt("return", requestCapability.promise);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function read() {
        return _read.apply(this, arguments);
      }

      return read;
    }(),
    cancel: function PDFDataTransportStreamReader_cancel(reason) {
      this._done = true;

      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });

      this._requests = [];
    }
  };

  function PDFDataTransportStreamRangeReader(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }

  PDFDataTransportStreamRangeReader.prototype = {
    _enqueue: function PDFDataTransportStreamRangeReader_enqueue(chunk) {
      if (this._done) {
        return;
      }

      if (this._requests.length === 0) {
        this._queuedChunk = chunk;
      } else {
        var requestsCapability = this._requests.shift();

        requestsCapability.resolve({
          value: chunk,
          done: false
        });

        this._requests.forEach(function (requestCapability) {
          requestCapability.resolve({
            value: undefined,
            done: true
          });
        });

        this._requests = [];
      }

      this._done = true;

      this._stream._removeRangeReader(this);
    },

    get isStreamingSupported() {
      return false;
    },

    read: function () {
      var _read2 = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var chunk, requestCapability;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._queuedChunk) {
                  _context2.next = 4;
                  break;
                }

                chunk = this._queuedChunk;
                this._queuedChunk = null;
                return _context2.abrupt("return", {
                  value: chunk,
                  done: false
                });

              case 4:
                if (!this._done) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", {
                  value: undefined,
                  done: true
                });

              case 6:
                requestCapability = (0, _util.createPromiseCapability)();

                this._requests.push(requestCapability);

                return _context2.abrupt("return", requestCapability.promise);

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function read() {
        return _read2.apply(this, arguments);
      }

      return read;
    }(),
    cancel: function PDFDataTransportStreamRangeReader_cancel(reason) {
      this._done = true;

      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });

      this._requests = [];

      this._stream._removeRangeReader(this);
    }
  };
  return PDFDataTransportStream;
}();

exports.PDFDataTransportStream = PDFDataTransportStream;

/***/ }),
/* 161 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebGLContext = void 0;

var _util = __w_pdfjs_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var WebGLContext =
/*#__PURE__*/
function () {
  function WebGLContext(_ref) {
    var _ref$enable = _ref.enable,
        enable = _ref$enable === void 0 ? false : _ref$enable;

    _classCallCheck(this, WebGLContext);

    this._enabled = enable === true;
  }

  _createClass(WebGLContext, [{
    key: "composeSMask",
    value: function composeSMask(_ref2) {
      var layer = _ref2.layer,
          mask = _ref2.mask,
          properties = _ref2.properties;
      return WebGLUtils.composeSMask(layer, mask, properties);
    }
  }, {
    key: "drawFigures",
    value: function drawFigures(_ref3) {
      var width = _ref3.width,
          height = _ref3.height,
          backgroundColor = _ref3.backgroundColor,
          figures = _ref3.figures,
          context = _ref3.context;
      return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
    }
  }, {
    key: "clear",
    value: function clear() {
      WebGLUtils.cleanup();
    }
  }, {
    key: "isEnabled",
    get: function get() {
      var enabled = this._enabled;

      if (enabled) {
        enabled = WebGLUtils.tryInitGL();
      }

      return (0, _util.shadow)(this, 'isEnabled', enabled);
    }
  }]);

  return WebGLContext;
}();

exports.WebGLContext = WebGLContext;

var WebGLUtils = function WebGLUtilsClosure() {
  function loadShader(gl, code, shaderType) {
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, code);
    gl.compileShader(shader);
    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    if (!compiled) {
      var errorMsg = gl.getShaderInfoLog(shader);
      throw new Error('Error during shader compilation: ' + errorMsg);
    }

    return shader;
  }

  function createVertexShader(gl, code) {
    return loadShader(gl, code, gl.VERTEX_SHADER);
  }

  function createFragmentShader(gl, code) {
    return loadShader(gl, code, gl.FRAGMENT_SHADER);
  }

  function createProgram(gl, shaders) {
    var program = gl.createProgram();

    for (var i = 0, ii = shaders.length; i < ii; ++i) {
      gl.attachShader(program, shaders[i]);
    }

    gl.linkProgram(program);
    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);

    if (!linked) {
      var errorMsg = gl.getProgramInfoLog(program);
      throw new Error('Error during program linking: ' + errorMsg);
    }

    return program;
  }

  function createTexture(gl, image, textureId) {
    gl.activeTexture(textureId);
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    return texture;
  }

  var currentGL, currentCanvas;

  function generateGL() {
    if (currentGL) {
      return;
    }

    currentCanvas = document.createElement('canvas');
    currentGL = currentCanvas.getContext('webgl', {
      premultipliedalpha: false
    });
  }

  var smaskVertexShaderCode = '\
  attribute vec2 a_position;                                    \
  attribute vec2 a_texCoord;                                    \
                                                                \
  uniform vec2 u_resolution;                                    \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_texCoord = a_texCoord;                                    \
  }                                                             ';
  var smaskFragmentShaderCode = '\
  precision mediump float;                                      \
                                                                \
  uniform vec4 u_backdrop;                                      \
  uniform int u_subtype;                                        \
  uniform sampler2D u_image;                                    \
  uniform sampler2D u_mask;                                     \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec4 imageColor = texture2D(u_image, v_texCoord);           \
    vec4 maskColor = texture2D(u_mask, v_texCoord);             \
    if (u_backdrop.a > 0.0) {                                   \
      maskColor.rgb = maskColor.rgb * maskColor.a +             \
                      u_backdrop.rgb * (1.0 - maskColor.a);     \
    }                                                           \
    float lum;                                                  \
    if (u_subtype == 0) {                                       \
      lum = maskColor.a;                                        \
    } else {                                                    \
      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \
            maskColor.b * 0.11;                                 \
    }                                                           \
    imageColor.a *= lum;                                        \
    imageColor.rgb *= imageColor.a;                             \
    gl_FragColor = imageColor;                                  \
  }                                                             ';
  var smaskCache = null;

  function initSmaskGL() {
    var canvas, gl;
    generateGL();
    canvas = currentCanvas;
    currentCanvas = null;
    gl = currentGL;
    currentGL = null;
    var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
    var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
    var program = createProgram(gl, [vertexShader, fragmentShader]);
    gl.useProgram(program);
    var cache = {};
    cache.gl = gl;
    cache.canvas = canvas;
    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
    cache.positionLocation = gl.getAttribLocation(program, 'a_position');
    cache.backdropLocation = gl.getUniformLocation(program, 'u_backdrop');
    cache.subtypeLocation = gl.getUniformLocation(program, 'u_subtype');
    var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
    var texLayerLocation = gl.getUniformLocation(program, 'u_image');
    var texMaskLocation = gl.getUniformLocation(program, 'u_mask');
    var texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(texCoordLocation);
    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
    gl.uniform1i(texLayerLocation, 0);
    gl.uniform1i(texMaskLocation, 1);
    smaskCache = cache;
  }

  function composeSMask(layer, mask, properties) {
    var width = layer.width,
        height = layer.height;

    if (!smaskCache) {
      initSmaskGL();
    }

    var cache = smaskCache,
        canvas = cache.canvas,
        gl = cache.gl;
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform2f(cache.resolutionLocation, width, height);

    if (properties.backdrop) {
      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
    } else {
      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
    }

    gl.uniform1i(cache.subtypeLocation, properties.subtype === 'Luminosity' ? 1 : 0);
    var texture = createTexture(gl, layer, gl.TEXTURE0);
    var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(cache.positionLocation);
    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.clearColor(0, 0, 0, 0);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.flush();
    gl.deleteTexture(texture);
    gl.deleteTexture(maskTexture);
    gl.deleteBuffer(buffer);
    return canvas;
  }

  var figuresVertexShaderCode = '\
  attribute vec2 a_position;                                    \
  attribute vec3 a_color;                                       \
                                                                \
  uniform vec2 u_resolution;                                    \
  uniform vec2 u_scale;                                         \
  uniform vec2 u_offset;                                        \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    vec2 position = (a_position + u_offset) * u_scale;          \
    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_color = vec4(a_color / 255.0, 1.0);                       \
  }                                                             ';
  var figuresFragmentShaderCode = '\
  precision mediump float;                                      \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    gl_FragColor = v_color;                                     \
  }                                                             ';
  var figuresCache = null;

  function initFiguresGL() {
    var canvas, gl;
    generateGL();
    canvas = currentCanvas;
    currentCanvas = null;
    gl = currentGL;
    currentGL = null;
    var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
    var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
    var program = createProgram(gl, [vertexShader, fragmentShader]);
    gl.useProgram(program);
    var cache = {};
    cache.gl = gl;
    cache.canvas = canvas;
    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
    cache.scaleLocation = gl.getUniformLocation(program, 'u_scale');
    cache.offsetLocation = gl.getUniformLocation(program, 'u_offset');
    cache.positionLocation = gl.getAttribLocation(program, 'a_position');
    cache.colorLocation = gl.getAttribLocation(program, 'a_color');
    figuresCache = cache;
  }

  function drawFigures(width, height, backgroundColor, figures, context) {
    if (!figuresCache) {
      initFiguresGL();
    }

    var cache = figuresCache,
        canvas = cache.canvas,
        gl = cache.gl;
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform2f(cache.resolutionLocation, width, height);
    var count = 0;
    var i, ii, rows;

    for (i = 0, ii = figures.length; i < ii; i++) {
      switch (figures[i].type) {
        case 'lattice':
          rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
          break;

        case 'triangles':
          count += figures[i].coords.length;
          break;
      }
    }

    var coords = new Float32Array(count * 2);
    var colors = new Uint8Array(count * 3);
    var coordsMap = context.coords,
        colorsMap = context.colors;
    var pIndex = 0,
        cIndex = 0;

    for (i = 0, ii = figures.length; i < ii; i++) {
      var figure = figures[i],
          ps = figure.coords,
          cs = figure.colors;

      switch (figure.type) {
        case 'lattice':
          var cols = figure.verticesPerRow;
          rows = ps.length / cols | 0;

          for (var row = 1; row < rows; row++) {
            var offset = row * cols + 1;

            for (var col = 1; col < cols; col++, offset++) {
              coords[pIndex] = coordsMap[ps[offset - cols - 1]];
              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
              coords[pIndex + 2] = coordsMap[ps[offset - cols]];
              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
              coords[pIndex + 4] = coordsMap[ps[offset - 1]];
              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
              colors[cIndex] = colorsMap[cs[offset - cols - 1]];
              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
              colors[cIndex + 3] = colorsMap[cs[offset - cols]];
              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
              colors[cIndex + 6] = colorsMap[cs[offset - 1]];
              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
              coords[pIndex + 6] = coords[pIndex + 2];
              coords[pIndex + 7] = coords[pIndex + 3];
              coords[pIndex + 8] = coords[pIndex + 4];
              coords[pIndex + 9] = coords[pIndex + 5];
              coords[pIndex + 10] = coordsMap[ps[offset]];
              coords[pIndex + 11] = coordsMap[ps[offset] + 1];
              colors[cIndex + 9] = colors[cIndex + 3];
              colors[cIndex + 10] = colors[cIndex + 4];
              colors[cIndex + 11] = colors[cIndex + 5];
              colors[cIndex + 12] = colors[cIndex + 6];
              colors[cIndex + 13] = colors[cIndex + 7];
              colors[cIndex + 14] = colors[cIndex + 8];
              colors[cIndex + 15] = colorsMap[cs[offset]];
              colors[cIndex + 16] = colorsMap[cs[offset] + 1];
              colors[cIndex + 17] = colorsMap[cs[offset] + 2];
              pIndex += 12;
              cIndex += 18;
            }
          }

          break;

        case 'triangles':
          for (var j = 0, jj = ps.length; j < jj; j++) {
            coords[pIndex] = coordsMap[ps[j]];
            coords[pIndex + 1] = coordsMap[ps[j] + 1];
            colors[cIndex] = colorsMap[cs[j]];
            colors[cIndex + 1] = colorsMap[cs[j] + 1];
            colors[cIndex + 2] = colorsMap[cs[j] + 2];
            pIndex += 2;
            cIndex += 3;
          }

          break;
      }
    }

    if (backgroundColor) {
      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);
    } else {
      gl.clearColor(0, 0, 0, 0);
    }

    gl.clear(gl.COLOR_BUFFER_BIT);
    var coordsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(cache.positionLocation);
    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
    var colorsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(cache.colorLocation);
    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
    gl.drawArrays(gl.TRIANGLES, 0, count);
    gl.flush();
    gl.deleteBuffer(coordsBuffer);
    gl.deleteBuffer(colorsBuffer);
    return canvas;
  }

  return {
    tryInitGL: function tryInitGL() {
      try {
        generateGL();
        return !!currentGL;
      } catch (ex) {}

      return false;
    },
    composeSMask: composeSMask,
    drawFigures: drawFigures,
    cleanup: function cleanup() {
      if (smaskCache && smaskCache.canvas) {
        smaskCache.canvas.width = 0;
        smaskCache.canvas.height = 0;
      }

      if (figuresCache && figuresCache.canvas) {
        figuresCache.canvas.width = 0;
        figuresCache.canvas.height = 0;
      }

      smaskCache = null;
      figuresCache = null;
    }
  };
}();

/***/ }),
/* 162 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderTextLayer = void 0;

var _util = __w_pdfjs_require__(1);

var _global_scope = _interopRequireDefault(__w_pdfjs_require__(3));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var renderTextLayer = function renderTextLayerClosure() {
  var MAX_TEXT_DIVS_TO_RENDER = 100000;
  var NonWhitespaceRegexp = /\S/;

  function isAllWhitespace(str) {
    return !NonWhitespaceRegexp.test(str);
  }

  var styleBuf = ['left: ', 0, 'px; top: ', 0, 'px; font-size: ', 0, 'px; font-family: ', '', ';'];

  function appendText(task, geom, styles) {
    var textDiv = document.createElement('span');
    var textDivProperties = {
      style: null,
      angle: 0,
      canvasWidth: 0,
      isWhitespace: false,
      originalTransform: null,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      scale: 1
    };

    task._textDivs.push(textDiv);

    if (isAllWhitespace(geom.str)) {
      textDivProperties.isWhitespace = true;

      task._textDivProperties.set(textDiv, textDivProperties);

      return;
    }

    var tx = _util.Util.transform(task._viewport.transform, geom.transform);

    var angle = Math.atan2(tx[1], tx[0]);
    var style = styles[geom.fontName];

    if (style.vertical) {
      angle += Math.PI / 2;
    }

    var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
    var fontAscent = fontHeight;

    if (style.ascent) {
      fontAscent = style.ascent * fontAscent;
    } else if (style.descent) {
      fontAscent = (1 + style.descent) * fontAscent;
    }

    var left;
    var top;

    if (angle === 0) {
      left = tx[4];
      top = tx[5] - fontAscent;
    } else {
      left = tx[4] + fontAscent * Math.sin(angle);
      top = tx[5] - fontAscent * Math.cos(angle);
    }

    styleBuf[1] = left;
    styleBuf[3] = top;
    styleBuf[5] = fontHeight;
    styleBuf[7] = style.fontFamily;
    textDivProperties.style = styleBuf.join('');
    textDiv.setAttribute('style', textDivProperties.style);
    textDiv.textContent = geom.str;

    if (task._fontInspectorEnabled) {
      textDiv.dataset.fontName = geom.fontName;
    }

    if (angle !== 0) {
      textDivProperties.angle = angle * (180 / Math.PI);
    }

    if (geom.str.length > 1) {
      if (style.vertical) {
        textDivProperties.canvasWidth = geom.height * task._viewport.scale;
      } else {
        textDivProperties.canvasWidth = geom.width * task._viewport.scale;
      }
    }

    task._textDivProperties.set(textDiv, textDivProperties);

    if (task._textContentStream) {
      task._layoutText(textDiv);
    }

    if (task._enhanceTextSelection) {
      var angleCos = 1,
          angleSin = 0;

      if (angle !== 0) {
        angleCos = Math.cos(angle);
        angleSin = Math.sin(angle);
      }

      var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
      var divHeight = fontHeight;
      var m, b;

      if (angle !== 0) {
        m = [angleCos, angleSin, -angleSin, angleCos, left, top];
        b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
      } else {
        b = [left, top, left + divWidth, top + divHeight];
      }

      task._bounds.push({
        left: b[0],
        top: b[1],
        right: b[2],
        bottom: b[3],
        div: textDiv,
        size: [divWidth, divHeight],
        m: m
      });
    }
  }

  function render(task) {
    if (task._canceled) {
      return;
    }

    var textDivs = task._textDivs;
    var capability = task._capability;
    var textDivsLength = textDivs.length;

    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
      task._renderingDone = true;
      capability.resolve();
      return;
    }

    if (!task._textContentStream) {
      for (var i = 0; i < textDivsLength; i++) {
        task._layoutText(textDivs[i]);
      }
    }

    task._renderingDone = true;
    capability.resolve();
  }

  function expand(task) {
    var bounds = task._bounds;
    var viewport = task._viewport;
    var expanded = expandBounds(viewport.width, viewport.height, bounds);

    for (var i = 0; i < expanded.length; i++) {
      var div = bounds[i].div;

      var divProperties = task._textDivProperties.get(div);

      if (divProperties.angle === 0) {
        divProperties.paddingLeft = bounds[i].left - expanded[i].left;
        divProperties.paddingTop = bounds[i].top - expanded[i].top;
        divProperties.paddingRight = expanded[i].right - bounds[i].right;
        divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

        task._textDivProperties.set(div, divProperties);

        continue;
      }

      var e = expanded[i],
          b = bounds[i];
      var m = b.m,
          c = m[0],
          s = m[1];
      var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
      var ts = new Float64Array(64);
      points.forEach(function (p, i) {
        var t = _util.Util.applyTransform(p, m);

        ts[i + 0] = c && (e.left - t[0]) / c;
        ts[i + 4] = s && (e.top - t[1]) / s;
        ts[i + 8] = c && (e.right - t[0]) / c;
        ts[i + 12] = s && (e.bottom - t[1]) / s;
        ts[i + 16] = s && (e.left - t[0]) / -s;
        ts[i + 20] = c && (e.top - t[1]) / c;
        ts[i + 24] = s && (e.right - t[0]) / -s;
        ts[i + 28] = c && (e.bottom - t[1]) / c;
        ts[i + 32] = c && (e.left - t[0]) / -c;
        ts[i + 36] = s && (e.top - t[1]) / -s;
        ts[i + 40] = c && (e.right - t[0]) / -c;
        ts[i + 44] = s && (e.bottom - t[1]) / -s;
        ts[i + 48] = s && (e.left - t[0]) / s;
        ts[i + 52] = c && (e.top - t[1]) / -c;
        ts[i + 56] = s && (e.right - t[0]) / s;
        ts[i + 60] = c && (e.bottom - t[1]) / -c;
      });

      var findPositiveMin = function findPositiveMin(ts, offset, count) {
        var result = 0;

        for (var i = 0; i < count; i++) {
          var t = ts[offset++];

          if (t > 0) {
            result = result ? Math.min(t, result) : t;
          }
        }

        return result;
      };

      var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
      divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
      divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
      divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
      divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

      task._textDivProperties.set(div, divProperties);
    }
  }

  function expandBounds(width, height, boxes) {
    var bounds = boxes.map(function (box, i) {
      return {
        x1: box.left,
        y1: box.top,
        x2: box.right,
        y2: box.bottom,
        index: i,
        x1New: undefined,
        x2New: undefined
      };
    });
    expandBoundsLTR(width, bounds);
    var expanded = new Array(boxes.length);
    bounds.forEach(function (b) {
      var i = b.index;
      expanded[i] = {
        left: b.x1New,
        top: 0,
        right: b.x2New,
        bottom: 0
      };
    });
    boxes.map(function (box, i) {
      var e = expanded[i],
          b = bounds[i];
      b.x1 = box.top;
      b.y1 = width - e.right;
      b.x2 = box.bottom;
      b.y2 = width - e.left;
      b.index = i;
      b.x1New = undefined;
      b.x2New = undefined;
    });
    expandBoundsLTR(height, bounds);
    bounds.forEach(function (b) {
      var i = b.index;
      expanded[i].top = b.x1New;
      expanded[i].bottom = b.x2New;
    });
    return expanded;
  }

  function expandBoundsLTR(width, bounds) {
    bounds.sort(function (a, b) {
      return a.x1 - b.x1 || a.index - b.index;
    });
    var fakeBoundary = {
      x1: -Infinity,
      y1: -Infinity,
      x2: 0,
      y2: Infinity,
      index: -1,
      x1New: 0,
      x2New: 0
    };
    var horizon = [{
      start: -Infinity,
      end: Infinity,
      boundary: fakeBoundary
    }];
    bounds.forEach(function (boundary) {
      var i = 0;

      while (i < horizon.length && horizon[i].end <= boundary.y1) {
        i++;
      }

      var j = horizon.length - 1;

      while (j >= 0 && horizon[j].start >= boundary.y2) {
        j--;
      }

      var horizonPart, affectedBoundary;
      var q,
          k,
          maxXNew = -Infinity;

      for (q = i; q <= j; q++) {
        horizonPart = horizon[q];
        affectedBoundary = horizonPart.boundary;
        var xNew;

        if (affectedBoundary.x2 > boundary.x1) {
          xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
        } else if (affectedBoundary.x2New === undefined) {
          xNew = (affectedBoundary.x2 + boundary.x1) / 2;
        } else {
          xNew = affectedBoundary.x2New;
        }

        if (xNew > maxXNew) {
          maxXNew = xNew;
        }
      }

      boundary.x1New = maxXNew;

      for (q = i; q <= j; q++) {
        horizonPart = horizon[q];
        affectedBoundary = horizonPart.boundary;

        if (affectedBoundary.x2New === undefined) {
          if (affectedBoundary.x2 > boundary.x1) {
            if (affectedBoundary.index > boundary.index) {
              affectedBoundary.x2New = affectedBoundary.x2;
            }
          } else {
            affectedBoundary.x2New = maxXNew;
          }
        } else if (affectedBoundary.x2New > maxXNew) {
          affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
        }
      }

      var changedHorizon = [],
          lastBoundary = null;

      for (q = i; q <= j; q++) {
        horizonPart = horizon[q];
        affectedBoundary = horizonPart.boundary;
        var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;

        if (lastBoundary === useBoundary) {
          changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
        } else {
          changedHorizon.push({
            start: horizonPart.start,
            end: horizonPart.end,
            boundary: useBoundary
          });
          lastBoundary = useBoundary;
        }
      }

      if (horizon[i].start < boundary.y1) {
        changedHorizon[0].start = boundary.y1;
        changedHorizon.unshift({
          start: horizon[i].start,
          end: boundary.y1,
          boundary: horizon[i].boundary
        });
      }

      if (boundary.y2 < horizon[j].end) {
        changedHorizon[changedHorizon.length - 1].end = boundary.y2;
        changedHorizon.push({
          start: boundary.y2,
          end: horizon[j].end,
          boundary: horizon[j].boundary
        });
      }

      for (q = i; q <= j; q++) {
        horizonPart = horizon[q];
        affectedBoundary = horizonPart.boundary;

        if (affectedBoundary.x2New !== undefined) {
          continue;
        }

        var used = false;

        for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
          used = horizon[k].boundary === affectedBoundary;
        }

        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
          used = horizon[k].boundary === affectedBoundary;
        }

        for (k = 0; !used && k < changedHorizon.length; k++) {
          used = changedHorizon[k].boundary === affectedBoundary;
        }

        if (!used) {
          affectedBoundary.x2New = maxXNew;
        }
      }

      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
    });
    horizon.forEach(function (horizonPart) {
      var affectedBoundary = horizonPart.boundary;

      if (affectedBoundary.x2New === undefined) {
        affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
      }
    });
  }

  function TextLayerRenderTask(_ref) {
    var textContent = _ref.textContent,
        textContentStream = _ref.textContentStream,
        container = _ref.container,
        viewport = _ref.viewport,
        textDivs = _ref.textDivs,
        textContentItemsStr = _ref.textContentItemsStr,
        enhanceTextSelection = _ref.enhanceTextSelection;
    this._textContent = textContent;
    this._textContentStream = textContentStream;
    this._container = container;
    this._viewport = viewport;
    this._textDivs = textDivs || [];
    this._textContentItemsStr = textContentItemsStr || [];
    this._enhanceTextSelection = !!enhanceTextSelection;
    this._fontInspectorEnabled = !!(_global_scope.default.FontInspector && _global_scope.default.FontInspector.enabled);
    this._reader = null;
    this._layoutTextLastFontSize = null;
    this._layoutTextLastFontFamily = null;
    this._layoutTextCtx = null;
    this._textDivProperties = new WeakMap();
    this._renderingDone = false;
    this._canceled = false;
    this._capability = (0, _util.createPromiseCapability)();
    this._renderTimer = null;
    this._bounds = [];
  }

  TextLayerRenderTask.prototype = {
    get promise() {
      return this._capability.promise;
    },

    cancel: function TextLayer_cancel() {
      if (this._reader) {
        this._reader.cancel(new _util.AbortException('text layer task cancelled'));

        this._reader = null;
      }

      this._canceled = true;

      if (this._renderTimer !== null) {
        clearTimeout(this._renderTimer);
        this._renderTimer = null;
      }

      this._capability.reject('canceled');
    },
    _processItems: function _processItems(items, styleCache) {
      for (var i = 0, len = items.length; i < len; i++) {
        this._textContentItemsStr.push(items[i].str);

        appendText(this, items[i], styleCache);
      }
    },
    _layoutText: function _layoutText(textDiv) {
      var textLayerFrag = this._container;

      var textDivProperties = this._textDivProperties.get(textDiv);

      if (textDivProperties.isWhitespace) {
        return;
      }

      var fontSize = textDiv.style.fontSize;
      var fontFamily = textDiv.style.fontFamily;

      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
        this._layoutTextCtx.font = fontSize + ' ' + fontFamily;
        this._layoutTextLastFontSize = fontSize;
        this._layoutTextLastFontFamily = fontFamily;
      }

      var width = this._layoutTextCtx.measureText(textDiv.textContent).width;

      var transform = '';

      if (textDivProperties.canvasWidth !== 0 && width > 0) {
        textDivProperties.scale = textDivProperties.canvasWidth / width;
        transform = "scaleX(".concat(textDivProperties.scale, ")");
      }

      if (textDivProperties.angle !== 0) {
        transform = "rotate(".concat(textDivProperties.angle, "deg) ").concat(transform);
      }

      if (transform.length > 0) {
        textDivProperties.originalTransform = transform;
        textDiv.style.transform = transform;
      }

      this._textDivProperties.set(textDiv, textDivProperties);

      textLayerFrag.appendChild(textDiv);
    },
    _render: function TextLayer_render(timeout) {
      var _this = this;

      var capability = (0, _util.createPromiseCapability)();
      var styleCache = Object.create(null);
      var canvas = document.createElement('canvas');
      canvas.mozOpaque = true;
      this._layoutTextCtx = canvas.getContext('2d', {
        alpha: false
      });

      if (this._textContent) {
        var textItems = this._textContent.items;
        var textStyles = this._textContent.styles;

        this._processItems(textItems, textStyles);

        capability.resolve();
      } else if (this._textContentStream) {
        var pump = function pump() {
          _this._reader.read().then(function (_ref2) {
            var value = _ref2.value,
                done = _ref2.done;

            if (done) {
              capability.resolve();
              return;
            }

            Object.assign(styleCache, value.styles);

            _this._processItems(value.items, styleCache);

            pump();
          }, capability.reject);
        };

        this._reader = this._textContentStream.getReader();
        pump();
      } else {
        throw new Error('Neither "textContent" nor "textContentStream"' + ' parameters specified.');
      }

      capability.promise.then(function () {
        styleCache = null;

        if (!timeout) {
          render(_this);
        } else {
          _this._renderTimer = setTimeout(function () {
            render(_this);
            _this._renderTimer = null;
          }, timeout);
        }
      }, this._capability.reject);
    },
    expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
      if (!this._enhanceTextSelection || !this._renderingDone) {
        return;
      }

      if (this._bounds !== null) {
        expand(this);
        this._bounds = null;
      }

      for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
        var div = this._textDivs[i];

        var divProperties = this._textDivProperties.get(div);

        if (divProperties.isWhitespace) {
          continue;
        }

        if (expandDivs) {
          var transform = '',
              padding = '';

          if (divProperties.scale !== 1) {
            transform = 'scaleX(' + divProperties.scale + ')';
          }

          if (divProperties.angle !== 0) {
            transform = 'rotate(' + divProperties.angle + 'deg) ' + transform;
          }

          if (divProperties.paddingLeft !== 0) {
            padding += ' padding-left: ' + divProperties.paddingLeft / divProperties.scale + 'px;';
            transform += ' translateX(' + -divProperties.paddingLeft / divProperties.scale + 'px)';
          }

          if (divProperties.paddingTop !== 0) {
            padding += ' padding-top: ' + divProperties.paddingTop + 'px;';
            transform += ' translateY(' + -divProperties.paddingTop + 'px)';
          }

          if (divProperties.paddingRight !== 0) {
            padding += ' padding-right: ' + divProperties.paddingRight / divProperties.scale + 'px;';
          }

          if (divProperties.paddingBottom !== 0) {
            padding += ' padding-bottom: ' + divProperties.paddingBottom + 'px;';
          }

          if (padding !== '') {
            div.setAttribute('style', divProperties.style + padding);
          }

          if (transform !== '') {
            div.style.transform = transform;
          }
        } else {
          div.style.padding = 0;
          div.style.transform = divProperties.originalTransform || '';
        }
      }
    }
  };

  function renderTextLayer(renderParameters) {
    var task = new TextLayerRenderTask({
      textContent: renderParameters.textContent,
      textContentStream: renderParameters.textContentStream,
      container: renderParameters.container,
      viewport: renderParameters.viewport,
      textDivs: renderParameters.textDivs,
      textContentItemsStr: renderParameters.textContentItemsStr,
      enhanceTextSelection: renderParameters.enhanceTextSelection
    });

    task._render(renderParameters.timeout);

    return task;
  }

  return renderTextLayer;
}();

exports.renderTextLayer = renderTextLayer;

/***/ }),
/* 163 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnnotationLayer = void 0;

var _dom_utils = __w_pdfjs_require__(151);

var _util = __w_pdfjs_require__(1);

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AnnotationElementFactory =
/*#__PURE__*/
function () {
  function AnnotationElementFactory() {
    _classCallCheck(this, AnnotationElementFactory);
  }

  _createClass(AnnotationElementFactory, null, [{
    key: "create",
    value: function create(parameters) {
      var subtype = parameters.data.annotationType;

      switch (subtype) {
        case _util.AnnotationType.LINK:
          return new LinkAnnotationElement(parameters);

        case _util.AnnotationType.TEXT:
          return new TextAnnotationElement(parameters);

        case _util.AnnotationType.WIDGET:
          var fieldType = parameters.data.fieldType;

          switch (fieldType) {
            case 'Tx':
              return new TextWidgetAnnotationElement(parameters);

            case 'Btn':
              if (parameters.data.radioButton) {
                return new RadioButtonWidgetAnnotationElement(parameters);
              } else if (parameters.data.checkBox) {
                return new CheckboxWidgetAnnotationElement(parameters);
              }

              return new PushButtonWidgetAnnotationElement(parameters);

            case 'Ch':
              return new ChoiceWidgetAnnotationElement(parameters);
          }

          return new WidgetAnnotationElement(parameters);

        case _util.AnnotationType.POPUP:
          return new PopupAnnotationElement(parameters);

        case _util.AnnotationType.LINE:
          return new LineAnnotationElement(parameters);

        case _util.AnnotationType.SQUARE:
          return new SquareAnnotationElement(parameters);

        case _util.AnnotationType.CIRCLE:
          return new CircleAnnotationElement(parameters);

        case _util.AnnotationType.POLYLINE:
          return new PolylineAnnotationElement(parameters);

        case _util.AnnotationType.INK:
          return new InkAnnotationElement(parameters);

        case _util.AnnotationType.POLYGON:
          return new PolygonAnnotationElement(parameters);

        case _util.AnnotationType.HIGHLIGHT:
          return new HighlightAnnotationElement(parameters);

        case _util.AnnotationType.UNDERLINE:
          return new UnderlineAnnotationElement(parameters);

        case _util.AnnotationType.SQUIGGLY:
          return new SquigglyAnnotationElement(parameters);

        case _util.AnnotationType.STRIKEOUT:
          return new StrikeOutAnnotationElement(parameters);

        case _util.AnnotationType.STAMP:
          return new StampAnnotationElement(parameters);

        case _util.AnnotationType.FILEATTACHMENT:
          return new FileAttachmentAnnotationElement(parameters);

        default:
          return new AnnotationElement(parameters);
      }
    }
  }]);

  return AnnotationElementFactory;
}();

var AnnotationElement =
/*#__PURE__*/
function () {
  function AnnotationElement(parameters) {
    var isRenderable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var ignoreBorder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    _classCallCheck(this, AnnotationElement);

    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.page = parameters.page;
    this.viewport = parameters.viewport;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderInteractiveForms = parameters.renderInteractiveForms;
    this.svgFactory = parameters.svgFactory;

    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }
  }

  _createClass(AnnotationElement, [{
    key: "_createContainer",
    value: function _createContainer() {
      var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var data = this.data,
          page = this.page,
          viewport = this.viewport;
      var container = document.createElement('section');
      var width = data.rect[2] - data.rect[0];
      var height = data.rect[3] - data.rect[1];
      container.setAttribute('data-annotation-id', data.id);

      var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

      container.style.transform = 'matrix(' + viewport.transform.join(',') + ')';
      container.style.transformOrigin = -rect[0] + 'px ' + -rect[1] + 'px';

      if (!ignoreBorder && data.borderStyle.width > 0) {
        container.style.borderWidth = data.borderStyle.width + 'px';

        if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
          width = width - 2 * data.borderStyle.width;
          height = height - 2 * data.borderStyle.width;
        }

        var horizontalRadius = data.borderStyle.horizontalCornerRadius;
        var verticalRadius = data.borderStyle.verticalCornerRadius;

        if (horizontalRadius > 0 || verticalRadius > 0) {
          var radius = horizontalRadius + 'px / ' + verticalRadius + 'px';
          container.style.borderRadius = radius;
        }

        switch (data.borderStyle.style) {
          case _util.AnnotationBorderStyleType.SOLID:
            container.style.borderStyle = 'solid';
            break;

          case _util.AnnotationBorderStyleType.DASHED:
            container.style.borderStyle = 'dashed';
            break;

          case _util.AnnotationBorderStyleType.BEVELED:
            (0, _util.warn)('Unimplemented border style: beveled');
            break;

          case _util.AnnotationBorderStyleType.INSET:
            (0, _util.warn)('Unimplemented border style: inset');
            break;

          case _util.AnnotationBorderStyleType.UNDERLINE:
            container.style.borderBottomStyle = 'solid';
            break;

          default:
            break;
        }

        if (data.color) {
          container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
        } else {
          container.style.borderWidth = 0;
        }
      }

      container.style.left = rect[0] + 'px';
      container.style.top = rect[1] + 'px';
      container.style.width = width + 'px';
      container.style.height = height + 'px';
      return container;
    }
  }, {
    key: "_createPopup",
    value: function _createPopup(container, trigger, data) {
      if (!trigger) {
        trigger = document.createElement('div');
        trigger.style.height = container.style.height;
        trigger.style.width = container.style.width;
        container.appendChild(trigger);
      }

      var popupElement = new PopupElement({
        container: container,
        trigger: trigger,
        color: data.color,
        title: data.title,
        contents: data.contents,
        hideWrapper: true
      });
      var popup = popupElement.render();
      popup.style.left = container.style.width;
      container.appendChild(popup);
    }
  }, {
    key: "render",
    value: function render() {
      (0, _util.unreachable)('Abstract method `AnnotationElement.render` called');
    }
  }]);

  return AnnotationElement;
}();

var LinkAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement) {
  _inherits(LinkAnnotationElement, _AnnotationElement);

  function LinkAnnotationElement(parameters) {
    _classCallCheck(this, LinkAnnotationElement);

    var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);
    return _possibleConstructorReturn(this, _getPrototypeOf(LinkAnnotationElement).call(this, parameters, isRenderable));
  }

  _createClass(LinkAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'linkAnnotation';
      var data = this.data,
          linkService = this.linkService;
      var link = document.createElement('a');
      (0, _dom_utils.addLinkAttributes)(link, {
        url: data.url,
        target: data.newWindow ? _dom_utils.LinkTarget.BLANK : linkService.externalLinkTarget,
        rel: linkService.externalLinkRel
      });

      if (!data.url) {
        if (data.action) {
          this._bindNamedAction(link, data.action);
        } else {
          this._bindLink(link, data.dest);
        }
      }

      this.container.appendChild(link);
      return this.container;
    }
  }, {
    key: "_bindLink",
    value: function _bindLink(link, destination) {
      var _this = this;

      link.href = this.linkService.getDestinationHash(destination);

      link.onclick = function () {
        if (destination) {
          _this.linkService.navigateTo(destination);
        }

        return false;
      };

      if (destination) {
        link.className = 'internalLink';
      }
    }
  }, {
    key: "_bindNamedAction",
    value: function _bindNamedAction(link, action) {
      var _this2 = this;

      link.href = this.linkService.getAnchorUrl('');

      link.onclick = function () {
        _this2.linkService.executeNamedAction(action);

        return false;
      };

      link.className = 'internalLink';
    }
  }]);

  return LinkAnnotationElement;
}(AnnotationElement);

var TextAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement2) {
  _inherits(TextAnnotationElement, _AnnotationElement2);

  function TextAnnotationElement(parameters) {
    _classCallCheck(this, TextAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(TextAnnotationElement).call(this, parameters, isRenderable));
  }

  _createClass(TextAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'textAnnotation';
      var image = document.createElement('img');
      image.style.height = this.container.style.height;
      image.style.width = this.container.style.width;
      image.src = this.imageResourcesPath + 'annotation-' + this.data.name.toLowerCase() + '.svg';
      image.alt = '[{{type}} Annotation]';
      image.dataset.l10nId = 'text_annotation_type';
      image.dataset.l10nArgs = JSON.stringify({
        type: this.data.name
      });

      if (!this.data.hasPopup) {
        this._createPopup(this.container, image, this.data);
      }

      this.container.appendChild(image);
      return this.container;
    }
  }]);

  return TextAnnotationElement;
}(AnnotationElement);

var WidgetAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement3) {
  _inherits(WidgetAnnotationElement, _AnnotationElement3);

  function WidgetAnnotationElement() {
    _classCallCheck(this, WidgetAnnotationElement);

    return _possibleConstructorReturn(this, _getPrototypeOf(WidgetAnnotationElement).apply(this, arguments));
  }

  _createClass(WidgetAnnotationElement, [{
    key: "render",
    value: function render() {
      return this.container;
    }
  }]);

  return WidgetAnnotationElement;
}(AnnotationElement);

var TextWidgetAnnotationElement =
/*#__PURE__*/
function (_WidgetAnnotationElem) {
  _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);

  function TextWidgetAnnotationElement(parameters) {
    _classCallCheck(this, TextWidgetAnnotationElement);

    var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    return _possibleConstructorReturn(this, _getPrototypeOf(TextWidgetAnnotationElement).call(this, parameters, isRenderable));
  }

  _createClass(TextWidgetAnnotationElement, [{
    key: "render",
    value: function render() {
      var TEXT_ALIGNMENT = ['left', 'center', 'right'];
      this.container.className = 'textWidgetAnnotation';
      var element = null;

      if (this.renderInteractiveForms) {
        if (this.data.multiLine) {
          element = document.createElement('textarea');
          element.textContent = this.data.fieldValue;
        } else {
          element = document.createElement('input');
          element.type = 'text';
          element.setAttribute('value', this.data.fieldValue);
        }

        element.disabled = this.data.readOnly;

        if (this.data.maxLen !== null) {
          element.maxLength = this.data.maxLen;
        }

        if (this.data.comb) {
          var fieldWidth = this.data.rect[2] - this.data.rect[0];
          var combWidth = fieldWidth / this.data.maxLen;
          element.classList.add('comb');
          element.style.letterSpacing = 'calc(' + combWidth + 'px - 1ch)';
        }
      } else {
        element = document.createElement('div');
        element.textContent = this.data.fieldValue;
        element.style.verticalAlign = 'middle';
        element.style.display = 'table-cell';
        var font = null;

        if (this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName)) {
          font = this.page.commonObjs.get(this.data.fontRefName);
        }

        this._setTextStyle(element, font);
      }

      if (this.data.textAlignment !== null) {
        element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
      }

      this.container.appendChild(element);
      return this.container;
    }
  }, {
    key: "_setTextStyle",
    value: function _setTextStyle(element, font) {
      var style = element.style;
      style.fontSize = this.data.fontSize + 'px';
      style.direction = this.data.fontDirection < 0 ? 'rtl' : 'ltr';

      if (!font) {
        return;
      }

      style.fontWeight = font.black ? font.bold ? '900' : 'bold' : font.bold ? 'bold' : 'normal';
      style.fontStyle = font.italic ? 'italic' : 'normal';
      var fontFamily = font.loadedName ? '"' + font.loadedName + '", ' : '';
      var fallbackName = font.fallbackName || 'Helvetica, sans-serif';
      style.fontFamily = fontFamily + fallbackName;
    }
  }]);

  return TextWidgetAnnotationElement;
}(WidgetAnnotationElement);

var CheckboxWidgetAnnotationElement =
/*#__PURE__*/
function (_WidgetAnnotationElem2) {
  _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2);

  function CheckboxWidgetAnnotationElement(parameters) {
    _classCallCheck(this, CheckboxWidgetAnnotationElement);

    return _possibleConstructorReturn(this, _getPrototypeOf(CheckboxWidgetAnnotationElement).call(this, parameters, parameters.renderInteractiveForms));
  }

  _createClass(CheckboxWidgetAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'buttonWidgetAnnotation checkBox';
      var element = document.createElement('input');
      element.disabled = this.data.readOnly;
      element.type = 'checkbox';

      if (this.data.fieldValue && this.data.fieldValue !== 'Off') {
        element.setAttribute('checked', true);
      }

      this.container.appendChild(element);
      return this.container;
    }
  }]);

  return CheckboxWidgetAnnotationElement;
}(WidgetAnnotationElement);

var RadioButtonWidgetAnnotationElement =
/*#__PURE__*/
function (_WidgetAnnotationElem3) {
  _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3);

  function RadioButtonWidgetAnnotationElement(parameters) {
    _classCallCheck(this, RadioButtonWidgetAnnotationElement);

    return _possibleConstructorReturn(this, _getPrototypeOf(RadioButtonWidgetAnnotationElement).call(this, parameters, parameters.renderInteractiveForms));
  }

  _createClass(RadioButtonWidgetAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'buttonWidgetAnnotation radioButton';
      var element = document.createElement('input');
      element.disabled = this.data.readOnly;
      element.type = 'radio';
      element.name = this.data.fieldName;

      if (this.data.fieldValue === this.data.buttonValue) {
        element.setAttribute('checked', true);
      }

      this.container.appendChild(element);
      return this.container;
    }
  }]);

  return RadioButtonWidgetAnnotationElement;
}(WidgetAnnotationElement);

var PushButtonWidgetAnnotationElement =
/*#__PURE__*/
function (_LinkAnnotationElemen) {
  _inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen);

  function PushButtonWidgetAnnotationElement() {
    _classCallCheck(this, PushButtonWidgetAnnotationElement);

    return _possibleConstructorReturn(this, _getPrototypeOf(PushButtonWidgetAnnotationElement).apply(this, arguments));
  }

  _createClass(PushButtonWidgetAnnotationElement, [{
    key: "render",
    value: function render() {
      var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement.prototype), "render", this).call(this);

      container.className = 'buttonWidgetAnnotation pushButton';
      return container;
    }
  }]);

  return PushButtonWidgetAnnotationElement;
}(LinkAnnotationElement);

var ChoiceWidgetAnnotationElement =
/*#__PURE__*/
function (_WidgetAnnotationElem4) {
  _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4);

  function ChoiceWidgetAnnotationElement(parameters) {
    _classCallCheck(this, ChoiceWidgetAnnotationElement);

    return _possibleConstructorReturn(this, _getPrototypeOf(ChoiceWidgetAnnotationElement).call(this, parameters, parameters.renderInteractiveForms));
  }

  _createClass(ChoiceWidgetAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'choiceWidgetAnnotation';
      var selectElement = document.createElement('select');
      selectElement.disabled = this.data.readOnly;

      if (!this.data.combo) {
        selectElement.size = this.data.options.length;

        if (this.data.multiSelect) {
          selectElement.multiple = true;
        }
      }

      for (var i = 0, ii = this.data.options.length; i < ii; i++) {
        var option = this.data.options[i];
        var optionElement = document.createElement('option');
        optionElement.textContent = option.displayValue;
        optionElement.value = option.exportValue;

        if (this.data.fieldValue.includes(option.displayValue)) {
          optionElement.setAttribute('selected', true);
        }

        selectElement.appendChild(optionElement);
      }

      this.container.appendChild(selectElement);
      return this.container;
    }
  }]);

  return ChoiceWidgetAnnotationElement;
}(WidgetAnnotationElement);

var PopupAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement4) {
  _inherits(PopupAnnotationElement, _AnnotationElement4);

  function PopupAnnotationElement(parameters) {
    _classCallCheck(this, PopupAnnotationElement);

    var isRenderable = !!(parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(PopupAnnotationElement).call(this, parameters, isRenderable));
  }

  _createClass(PopupAnnotationElement, [{
    key: "render",
    value: function render() {
      var IGNORE_TYPES = ['Line', 'Square', 'Circle', 'PolyLine', 'Polygon', 'Ink'];
      this.container.className = 'popupAnnotation';

      if (IGNORE_TYPES.includes(this.data.parentType)) {
        return this.container;
      }

      var selector = '[data-annotation-id="' + this.data.parentId + '"]';
      var parentElement = this.layer.querySelector(selector);

      if (!parentElement) {
        return this.container;
      }

      var popup = new PopupElement({
        container: this.container,
        trigger: parentElement,
        color: this.data.color,
        title: this.data.title,
        contents: this.data.contents
      });
      var parentLeft = parseFloat(parentElement.style.left);
      var parentWidth = parseFloat(parentElement.style.width);
      this.container.style.transformOrigin = -(parentLeft + parentWidth) + 'px -' + parentElement.style.top;
      this.container.style.left = parentLeft + parentWidth + 'px';
      this.container.appendChild(popup.render());
      return this.container;
    }
  }]);

  return PopupAnnotationElement;
}(AnnotationElement);

var PopupElement =
/*#__PURE__*/
function () {
  function PopupElement(parameters) {
    _classCallCheck(this, PopupElement);

    this.container = parameters.container;
    this.trigger = parameters.trigger;
    this.color = parameters.color;
    this.title = parameters.title;
    this.contents = parameters.contents;
    this.hideWrapper = parameters.hideWrapper || false;
    this.pinned = false;
  }

  _createClass(PopupElement, [{
    key: "render",
    value: function render() {
      var BACKGROUND_ENLIGHT = 0.7;
      var wrapper = document.createElement('div');
      wrapper.className = 'popupWrapper';
      this.hideElement = this.hideWrapper ? wrapper : this.container;
      this.hideElement.setAttribute('hidden', true);
      var popup = document.createElement('div');
      popup.className = 'popup';
      var color = this.color;

      if (color) {
        var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
        var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
        var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
        popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0);
      }

      var contents = this._formatContents(this.contents);

      var title = document.createElement('h1');
      title.textContent = this.title;
      this.trigger.addEventListener('click', this._toggle.bind(this));
      this.trigger.addEventListener('mouseover', this._show.bind(this, false));
      this.trigger.addEventListener('mouseout', this._hide.bind(this, false));
      popup.addEventListener('click', this._hide.bind(this, true));
      popup.appendChild(title);
      popup.appendChild(contents);
      wrapper.appendChild(popup);
      return wrapper;
    }
  }, {
    key: "_formatContents",
    value: function _formatContents(contents) {
      var p = document.createElement('p');
      var lines = contents.split(/(?:\r\n?|\n)/);

      for (var i = 0, ii = lines.length; i < ii; ++i) {
        var line = lines[i];
        p.appendChild(document.createTextNode(line));

        if (i < ii - 1) {
          p.appendChild(document.createElement('br'));
        }
      }

      return p;
    }
  }, {
    key: "_toggle",
    value: function _toggle() {
      if (this.pinned) {
        this._hide(true);
      } else {
        this._show(true);
      }
    }
  }, {
    key: "_show",
    value: function _show() {
      var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (pin) {
        this.pinned = true;
      }

      if (this.hideElement.hasAttribute('hidden')) {
        this.hideElement.removeAttribute('hidden');
        this.container.style.zIndex += 1;
      }
    }
  }, {
    key: "_hide",
    value: function _hide() {
      var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (unpin) {
        this.pinned = false;
      }

      if (!this.hideElement.hasAttribute('hidden') && !this.pinned) {
        this.hideElement.setAttribute('hidden', true);
        this.container.style.zIndex -= 1;
      }
    }
  }]);

  return PopupElement;
}();

var LineAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement5) {
  _inherits(LineAnnotationElement, _AnnotationElement5);

  function LineAnnotationElement(parameters) {
    _classCallCheck(this, LineAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(LineAnnotationElement).call(this, parameters, isRenderable, true));
  }

  _createClass(LineAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'lineAnnotation';
      var data = this.data;
      var width = data.rect[2] - data.rect[0];
      var height = data.rect[3] - data.rect[1];
      var svg = this.svgFactory.create(width, height);
      var line = this.svgFactory.createElement('svg:line');
      line.setAttribute('x1', data.rect[2] - data.lineCoordinates[0]);
      line.setAttribute('y1', data.rect[3] - data.lineCoordinates[1]);
      line.setAttribute('x2', data.rect[2] - data.lineCoordinates[2]);
      line.setAttribute('y2', data.rect[3] - data.lineCoordinates[3]);
      line.setAttribute('stroke-width', data.borderStyle.width);
      line.setAttribute('stroke', 'transparent');
      svg.appendChild(line);
      this.container.append(svg);

      this._createPopup(this.container, line, data);

      return this.container;
    }
  }]);

  return LineAnnotationElement;
}(AnnotationElement);

var SquareAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement6) {
  _inherits(SquareAnnotationElement, _AnnotationElement6);

  function SquareAnnotationElement(parameters) {
    _classCallCheck(this, SquareAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(SquareAnnotationElement).call(this, parameters, isRenderable, true));
  }

  _createClass(SquareAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'squareAnnotation';
      var data = this.data;
      var width = data.rect[2] - data.rect[0];
      var height = data.rect[3] - data.rect[1];
      var svg = this.svgFactory.create(width, height);
      var borderWidth = data.borderStyle.width;
      var square = this.svgFactory.createElement('svg:rect');
      square.setAttribute('x', borderWidth / 2);
      square.setAttribute('y', borderWidth / 2);
      square.setAttribute('width', width - borderWidth);
      square.setAttribute('height', height - borderWidth);
      square.setAttribute('stroke-width', borderWidth);
      square.setAttribute('stroke', 'transparent');
      square.setAttribute('fill', 'none');
      svg.appendChild(square);
      this.container.append(svg);

      this._createPopup(this.container, square, data);

      return this.container;
    }
  }]);

  return SquareAnnotationElement;
}(AnnotationElement);

var CircleAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement7) {
  _inherits(CircleAnnotationElement, _AnnotationElement7);

  function CircleAnnotationElement(parameters) {
    _classCallCheck(this, CircleAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(CircleAnnotationElement).call(this, parameters, isRenderable, true));
  }

  _createClass(CircleAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'circleAnnotation';
      var data = this.data;
      var width = data.rect[2] - data.rect[0];
      var height = data.rect[3] - data.rect[1];
      var svg = this.svgFactory.create(width, height);
      var borderWidth = data.borderStyle.width;
      var circle = this.svgFactory.createElement('svg:ellipse');
      circle.setAttribute('cx', width / 2);
      circle.setAttribute('cy', height / 2);
      circle.setAttribute('rx', width / 2 - borderWidth / 2);
      circle.setAttribute('ry', height / 2 - borderWidth / 2);
      circle.setAttribute('stroke-width', borderWidth);
      circle.setAttribute('stroke', 'transparent');
      circle.setAttribute('fill', 'none');
      svg.appendChild(circle);
      this.container.append(svg);

      this._createPopup(this.container, circle, data);

      return this.container;
    }
  }]);

  return CircleAnnotationElement;
}(AnnotationElement);

var PolylineAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement8) {
  _inherits(PolylineAnnotationElement, _AnnotationElement8);

  function PolylineAnnotationElement(parameters) {
    var _this3;

    _classCallCheck(this, PolylineAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PolylineAnnotationElement).call(this, parameters, isRenderable, true));
    _this3.containerClassName = 'polylineAnnotation';
    _this3.svgElementName = 'svg:polyline';
    return _this3;
  }

  _createClass(PolylineAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = this.containerClassName;
      var data = this.data;
      var width = data.rect[2] - data.rect[0];
      var height = data.rect[3] - data.rect[1];
      var svg = this.svgFactory.create(width, height);
      var vertices = data.vertices;
      var points = [];

      for (var i = 0, ii = vertices.length; i < ii; i++) {
        var x = vertices[i].x - data.rect[0];
        var y = data.rect[3] - vertices[i].y;
        points.push(x + ',' + y);
      }

      points = points.join(' ');
      var borderWidth = data.borderStyle.width;
      var polyline = this.svgFactory.createElement(this.svgElementName);
      polyline.setAttribute('points', points);
      polyline.setAttribute('stroke-width', borderWidth);
      polyline.setAttribute('stroke', 'transparent');
      polyline.setAttribute('fill', 'none');
      svg.appendChild(polyline);
      this.container.append(svg);

      this._createPopup(this.container, polyline, data);

      return this.container;
    }
  }]);

  return PolylineAnnotationElement;
}(AnnotationElement);

var PolygonAnnotationElement =
/*#__PURE__*/
function (_PolylineAnnotationEl) {
  _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);

  function PolygonAnnotationElement(parameters) {
    var _this4;

    _classCallCheck(this, PolygonAnnotationElement);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PolygonAnnotationElement).call(this, parameters));
    _this4.containerClassName = 'polygonAnnotation';
    _this4.svgElementName = 'svg:polygon';
    return _this4;
  }

  return PolygonAnnotationElement;
}(PolylineAnnotationElement);

var InkAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement9) {
  _inherits(InkAnnotationElement, _AnnotationElement9);

  function InkAnnotationElement(parameters) {
    var _this5;

    _classCallCheck(this, InkAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(InkAnnotationElement).call(this, parameters, isRenderable, true));
    _this5.containerClassName = 'inkAnnotation';
    _this5.svgElementName = 'svg:polyline';
    return _this5;
  }

  _createClass(InkAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = this.containerClassName;
      var data = this.data;
      var width = data.rect[2] - data.rect[0];
      var height = data.rect[3] - data.rect[1];
      var svg = this.svgFactory.create(width, height);
      var inkLists = data.inkLists;

      for (var i = 0, ii = inkLists.length; i < ii; i++) {
        var inkList = inkLists[i];
        var points = [];

        for (var j = 0, jj = inkList.length; j < jj; j++) {
          var x = inkList[j].x - data.rect[0];
          var y = data.rect[3] - inkList[j].y;
          points.push(x + ',' + y);
        }

        points = points.join(' ');
        var borderWidth = data.borderStyle.width;
        var polyline = this.svgFactory.createElement(this.svgElementName);
        polyline.setAttribute('points', points);
        polyline.setAttribute('stroke-width', borderWidth);
        polyline.setAttribute('stroke', 'transparent');
        polyline.setAttribute('fill', 'none');

        this._createPopup(this.container, polyline, data);

        svg.appendChild(polyline);
      }

      this.container.append(svg);
      return this.container;
    }
  }]);

  return InkAnnotationElement;
}(AnnotationElement);

var HighlightAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement10) {
  _inherits(HighlightAnnotationElement, _AnnotationElement10);

  function HighlightAnnotationElement(parameters) {
    _classCallCheck(this, HighlightAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(HighlightAnnotationElement).call(this, parameters, isRenderable, true));
  }

  _createClass(HighlightAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'highlightAnnotation';

      if (!this.data.hasPopup) {
        this._createPopup(this.container, null, this.data);
      }

      return this.container;
    }
  }]);

  return HighlightAnnotationElement;
}(AnnotationElement);

var UnderlineAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement11) {
  _inherits(UnderlineAnnotationElement, _AnnotationElement11);

  function UnderlineAnnotationElement(parameters) {
    _classCallCheck(this, UnderlineAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(UnderlineAnnotationElement).call(this, parameters, isRenderable, true));
  }

  _createClass(UnderlineAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'underlineAnnotation';

      if (!this.data.hasPopup) {
        this._createPopup(this.container, null, this.data);
      }

      return this.container;
    }
  }]);

  return UnderlineAnnotationElement;
}(AnnotationElement);

var SquigglyAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement12) {
  _inherits(SquigglyAnnotationElement, _AnnotationElement12);

  function SquigglyAnnotationElement(parameters) {
    _classCallCheck(this, SquigglyAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(SquigglyAnnotationElement).call(this, parameters, isRenderable, true));
  }

  _createClass(SquigglyAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'squigglyAnnotation';

      if (!this.data.hasPopup) {
        this._createPopup(this.container, null, this.data);
      }

      return this.container;
    }
  }]);

  return SquigglyAnnotationElement;
}(AnnotationElement);

var StrikeOutAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement13) {
  _inherits(StrikeOutAnnotationElement, _AnnotationElement13);

  function StrikeOutAnnotationElement(parameters) {
    _classCallCheck(this, StrikeOutAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(StrikeOutAnnotationElement).call(this, parameters, isRenderable, true));
  }

  _createClass(StrikeOutAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'strikeoutAnnotation';

      if (!this.data.hasPopup) {
        this._createPopup(this.container, null, this.data);
      }

      return this.container;
    }
  }]);

  return StrikeOutAnnotationElement;
}(AnnotationElement);

var StampAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement14) {
  _inherits(StampAnnotationElement, _AnnotationElement14);

  function StampAnnotationElement(parameters) {
    _classCallCheck(this, StampAnnotationElement);

    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    return _possibleConstructorReturn(this, _getPrototypeOf(StampAnnotationElement).call(this, parameters, isRenderable, true));
  }

  _createClass(StampAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'stampAnnotation';

      if (!this.data.hasPopup) {
        this._createPopup(this.container, null, this.data);
      }

      return this.container;
    }
  }]);

  return StampAnnotationElement;
}(AnnotationElement);

var FileAttachmentAnnotationElement =
/*#__PURE__*/
function (_AnnotationElement15) {
  _inherits(FileAttachmentAnnotationElement, _AnnotationElement15);

  function FileAttachmentAnnotationElement(parameters) {
    var _this6;

    _classCallCheck(this, FileAttachmentAnnotationElement);

    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(FileAttachmentAnnotationElement).call(this, parameters, true));
    var _this6$data$file = _this6.data.file,
        filename = _this6$data$file.filename,
        content = _this6$data$file.content;
    _this6.filename = (0, _dom_utils.getFilenameFromUrl)(filename);
    _this6.content = content;

    if (_this6.linkService.eventBus) {
      _this6.linkService.eventBus.dispatch('fileattachmentannotation', {
        source: _assertThisInitialized(_assertThisInitialized(_this6)),
        id: (0, _util.stringToPDFString)(filename),
        filename: filename,
        content: content
      });
    }

    return _this6;
  }

  _createClass(FileAttachmentAnnotationElement, [{
    key: "render",
    value: function render() {
      this.container.className = 'fileAttachmentAnnotation';
      var trigger = document.createElement('div');
      trigger.style.height = this.container.style.height;
      trigger.style.width = this.container.style.width;
      trigger.addEventListener('dblclick', this._download.bind(this));

      if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
        this._createPopup(this.container, trigger, this.data);
      }

      this.container.appendChild(trigger);
      return this.container;
    }
  }, {
    key: "_download",
    value: function _download() {
      if (!this.downloadManager) {
        (0, _util.warn)('Download cannot be started due to unavailable download manager');
        return;
      }

      this.downloadManager.downloadData(this.content, this.filename, '');
    }
  }]);

  return FileAttachmentAnnotationElement;
}(AnnotationElement);

var AnnotationLayer =
/*#__PURE__*/
function () {
  function AnnotationLayer() {
    _classCallCheck(this, AnnotationLayer);
  }

  _createClass(AnnotationLayer, null, [{
    key: "render",
    value: function render(parameters) {
      for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
        var data = parameters.annotations[i];

        if (!data) {
          continue;
        }

        var element = AnnotationElementFactory.create({
          data: data,
          layer: parameters.div,
          page: parameters.page,
          viewport: parameters.viewport,
          linkService: parameters.linkService,
          downloadManager: parameters.downloadManager,
          imageResourcesPath: parameters.imageResourcesPath || '',
          renderInteractiveForms: parameters.renderInteractiveForms || false,
          svgFactory: new _dom_utils.DOMSVGFactory()
        });

        if (element.isRenderable) {
          parameters.div.appendChild(element.render());
        }
      }
    }
  }, {
    key: "update",
    value: function update(parameters) {
      for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
        var data = parameters.annotations[i];
        var element = parameters.div.querySelector('[data-annotation-id="' + data.id + '"]');

        if (element) {
          element.style.transform = 'matrix(' + parameters.viewport.transform.join(',') + ')';
        }
      }

      parameters.div.removeAttribute('hidden');
    }
  }]);

  return AnnotationLayer;
}();

exports.AnnotationLayer = AnnotationLayer;

/***/ }),
/* 164 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SVGGraphics = void 0;

var _util = __w_pdfjs_require__(1);

var _dom_utils = __w_pdfjs_require__(151);

var _is_node = _interopRequireDefault(__w_pdfjs_require__(4));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SVGGraphics = function SVGGraphics() {
  throw new Error('Not implemented: SVGGraphics');
};

exports.SVGGraphics = SVGGraphics;
{
  var SVG_DEFAULTS = {
    fontStyle: 'normal',
    fontWeight: 'normal',
    fillColor: '#000000'
  };

  var convertImgDataToPng = function convertImgDataToPngClosure() {
    var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
    var CHUNK_WRAPPER_SIZE = 12;
    var crcTable = new Int32Array(256);

    for (var i = 0; i < 256; i++) {
      var c = i;

      for (var h = 0; h < 8; h++) {
        if (c & 1) {
          c = 0xedB88320 ^ c >> 1 & 0x7fffffff;
        } else {
          c = c >> 1 & 0x7fffffff;
        }
      }

      crcTable[i] = c;
    }

    function crc32(data, start, end) {
      var crc = -1;

      for (var i = start; i < end; i++) {
        var a = (crc ^ data[i]) & 0xff;
        var b = crcTable[a];
        crc = crc >>> 8 ^ b;
      }

      return crc ^ -1;
    }

    function writePngChunk(type, body, data, offset) {
      var p = offset;
      var len = body.length;
      data[p] = len >> 24 & 0xff;
      data[p + 1] = len >> 16 & 0xff;
      data[p + 2] = len >> 8 & 0xff;
      data[p + 3] = len & 0xff;
      p += 4;
      data[p] = type.charCodeAt(0) & 0xff;
      data[p + 1] = type.charCodeAt(1) & 0xff;
      data[p + 2] = type.charCodeAt(2) & 0xff;
      data[p + 3] = type.charCodeAt(3) & 0xff;
      p += 4;
      data.set(body, p);
      p += body.length;
      var crc = crc32(data, offset + 4, p);
      data[p] = crc >> 24 & 0xff;
      data[p + 1] = crc >> 16 & 0xff;
      data[p + 2] = crc >> 8 & 0xff;
      data[p + 3] = crc & 0xff;
    }

    function adler32(data, start, end) {
      var a = 1;
      var b = 0;

      for (var i = start; i < end; ++i) {
        a = (a + (data[i] & 0xff)) % 65521;
        b = (b + a) % 65521;
      }

      return b << 16 | a;
    }

    function deflateSync(literals) {
      if (!(0, _is_node.default)()) {
        return deflateSyncUncompressed(literals);
      }

      try {
        var input;

        if (parseInt(process.versions.node) >= 8) {
          input = literals;
        } else {
          input = new Buffer(literals);
        }

        var output = __webpack_require__(5).deflateSync(input, {
          level: 9
        });

        return output instanceof Uint8Array ? output : new Uint8Array(output);
      } catch (e) {
        (0, _util.warn)('Not compressing PNG because zlib.deflateSync is unavailable: ' + e);
      }

      return deflateSyncUncompressed(literals);
    }

    function deflateSyncUncompressed(literals) {
      var len = literals.length;
      var maxBlockLength = 0xFFFF;
      var deflateBlocks = Math.ceil(len / maxBlockLength);
      var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
      var pi = 0;
      idat[pi++] = 0x78;
      idat[pi++] = 0x9c;
      var pos = 0;

      while (len > maxBlockLength) {
        idat[pi++] = 0x00;
        idat[pi++] = 0xff;
        idat[pi++] = 0xff;
        idat[pi++] = 0x00;
        idat[pi++] = 0x00;
        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
        pi += maxBlockLength;
        pos += maxBlockLength;
        len -= maxBlockLength;
      }

      idat[pi++] = 0x01;
      idat[pi++] = len & 0xff;
      idat[pi++] = len >> 8 & 0xff;
      idat[pi++] = ~len & 0xffff & 0xff;
      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
      idat.set(literals.subarray(pos), pi);
      pi += literals.length - pos;
      var adler = adler32(literals, 0, literals.length);
      idat[pi++] = adler >> 24 & 0xff;
      idat[pi++] = adler >> 16 & 0xff;
      idat[pi++] = adler >> 8 & 0xff;
      idat[pi++] = adler & 0xff;
      return idat;
    }

    function encode(imgData, kind, forceDataSchema, isMask) {
      var width = imgData.width;
      var height = imgData.height;
      var bitDepth, colorType, lineSize;
      var bytes = imgData.data;

      switch (kind) {
        case _util.ImageKind.GRAYSCALE_1BPP:
          colorType = 0;
          bitDepth = 1;
          lineSize = width + 7 >> 3;
          break;

        case _util.ImageKind.RGB_24BPP:
          colorType = 2;
          bitDepth = 8;
          lineSize = width * 3;
          break;

        case _util.ImageKind.RGBA_32BPP:
          colorType = 6;
          bitDepth = 8;
          lineSize = width * 4;
          break;

        default:
          throw new Error('invalid format');
      }

      var literals = new Uint8Array((1 + lineSize) * height);
      var offsetLiterals = 0,
          offsetBytes = 0;
      var y, i;

      for (y = 0; y < height; ++y) {
        literals[offsetLiterals++] = 0;
        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
        offsetBytes += lineSize;
        offsetLiterals += lineSize;
      }

      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
        offsetLiterals = 0;

        for (y = 0; y < height; y++) {
          offsetLiterals++;

          for (i = 0; i < lineSize; i++) {
            literals[offsetLiterals++] ^= 0xFF;
          }
        }
      }

      var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
      var idat = deflateSync(literals);
      var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
      var data = new Uint8Array(pngLength);
      var offset = 0;
      data.set(PNG_HEADER, offset);
      offset += PNG_HEADER.length;
      writePngChunk('IHDR', ihdr, data, offset);
      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
      writePngChunk('IDATA', idat, data, offset);
      offset += CHUNK_WRAPPER_SIZE + idat.length;
      writePngChunk('IEND', new Uint8Array(0), data, offset);
      return (0, _util.createObjectURL)(data, 'image/png', forceDataSchema);
    }

    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
      var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
      return encode(imgData, kind, forceDataSchema, isMask);
    };
  }();

  var SVGExtraState = function SVGExtraStateClosure() {
    function SVGExtraState() {
      this.fontSizeScale = 1;
      this.fontWeight = SVG_DEFAULTS.fontWeight;
      this.fontSize = 0;
      this.textMatrix = _util.IDENTITY_MATRIX;
      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
      this.leading = 0;
      this.textRenderingMode = _util.TextRenderingMode.FILL;
      this.x = 0;
      this.y = 0;
      this.lineX = 0;
      this.lineY = 0;
      this.charSpacing = 0;
      this.wordSpacing = 0;
      this.textHScale = 1;
      this.textRise = 0;
      this.fillColor = SVG_DEFAULTS.fillColor;
      this.strokeColor = '#000000';
      this.fillAlpha = 1;
      this.strokeAlpha = 1;
      this.lineWidth = 1;
      this.lineJoin = '';
      this.lineCap = '';
      this.miterLimit = 0;
      this.dashArray = [];
      this.dashPhase = 0;
      this.dependencies = [];
      this.activeClipUrl = null;
      this.clipGroup = null;
      this.maskId = '';
    }

    SVGExtraState.prototype = {
      clone: function SVGExtraState_clone() {
        return Object.create(this);
      },
      setCurrentPoint: function SVGExtraState_setCurrentPoint(x, y) {
        this.x = x;
        this.y = y;
      }
    };
    return SVGExtraState;
  }();

  exports.SVGGraphics = SVGGraphics = function SVGGraphicsClosure() {
    function opListToTree(opList) {
      var opTree = [];
      var tmp = [];
      var opListLen = opList.length;

      for (var x = 0; x < opListLen; x++) {
        if (opList[x].fn === 'save') {
          opTree.push({
            'fnId': 92,
            'fn': 'group',
            'items': []
          });
          tmp.push(opTree);
          opTree = opTree[opTree.length - 1].items;
          continue;
        }

        if (opList[x].fn === 'restore') {
          opTree = tmp.pop();
        } else {
          opTree.push(opList[x]);
        }
      }

      return opTree;
    }

    function pf(value) {
      if (Number.isInteger(value)) {
        return value.toString();
      }

      var s = value.toFixed(10);
      var i = s.length - 1;

      if (s[i] !== '0') {
        return s;
      }

      do {
        i--;
      } while (s[i] === '0');

      return s.substring(0, s[i] === '.' ? i : i + 1);
    }

    function pm(m) {
      if (m[4] === 0 && m[5] === 0) {
        if (m[1] === 0 && m[2] === 0) {
          if (m[0] === 1 && m[3] === 1) {
            return '';
          }

          return 'scale(' + pf(m[0]) + ' ' + pf(m[3]) + ')';
        }

        if (m[0] === m[3] && m[1] === -m[2]) {
          var a = Math.acos(m[0]) * 180 / Math.PI;
          return 'rotate(' + pf(a) + ')';
        }
      } else {
        if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
          return 'translate(' + pf(m[4]) + ' ' + pf(m[5]) + ')';
        }
      }

      return 'matrix(' + pf(m[0]) + ' ' + pf(m[1]) + ' ' + pf(m[2]) + ' ' + pf(m[3]) + ' ' + pf(m[4]) + ' ' + pf(m[5]) + ')';
    }

    function SVGGraphics(commonObjs, objs, forceDataSchema) {
      this.svgFactory = new _dom_utils.DOMSVGFactory();
      this.current = new SVGExtraState();
      this.transformMatrix = _util.IDENTITY_MATRIX;
      this.transformStack = [];
      this.extraStack = [];
      this.commonObjs = commonObjs;
      this.objs = objs;
      this.pendingClip = null;
      this.pendingEOFill = false;
      this.embedFonts = false;
      this.embeddedFonts = Object.create(null);
      this.cssStyle = null;
      this.forceDataSchema = !!forceDataSchema;
    }

    var XML_NS = 'http://www.w3.org/XML/1998/namespace';
    var XLINK_NS = 'http://www.w3.org/1999/xlink';
    var LINE_CAP_STYLES = ['butt', 'round', 'square'];
    var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
    var clipCount = 0;
    var maskCount = 0;
    SVGGraphics.prototype = {
      save: function SVGGraphics_save() {
        this.transformStack.push(this.transformMatrix);
        var old = this.current;
        this.extraStack.push(old);
        this.current = old.clone();
      },
      restore: function SVGGraphics_restore() {
        this.transformMatrix = this.transformStack.pop();
        this.current = this.extraStack.pop();
        this.pendingClip = null;
        this.tgrp = null;
      },
      group: function SVGGraphics_group(items) {
        this.save();
        this.executeOpTree(items);
        this.restore();
      },
      loadDependencies: function SVGGraphics_loadDependencies(operatorList) {
        var _this = this;

        var fnArray = operatorList.fnArray;
        var fnArrayLen = fnArray.length;
        var argsArray = operatorList.argsArray;

        for (var i = 0; i < fnArrayLen; i++) {
          if (_util.OPS.dependency === fnArray[i]) {
            var deps = argsArray[i];

            for (var n = 0, nn = deps.length; n < nn; n++) {
              var obj = deps[n];
              var common = obj.substring(0, 2) === 'g_';
              var promise;

              if (common) {
                promise = new Promise(function (resolve) {
                  _this.commonObjs.get(obj, resolve);
                });
              } else {
                promise = new Promise(function (resolve) {
                  _this.objs.get(obj, resolve);
                });
              }

              this.current.dependencies.push(promise);
            }
          }
        }

        return Promise.all(this.current.dependencies);
      },
      transform: function SVGGraphics_transform(a, b, c, d, e, f) {
        var transformMatrix = [a, b, c, d, e, f];
        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
        this.tgrp = null;
      },
      getSVG: function SVGGraphics_getSVG(operatorList, viewport) {
        var _this2 = this;

        this.viewport = viewport;

        var svgElement = this._initialize(viewport);

        return this.loadDependencies(operatorList).then(function () {
          _this2.transformMatrix = _util.IDENTITY_MATRIX;

          var opTree = _this2.convertOpList(operatorList);

          _this2.executeOpTree(opTree);

          return svgElement;
        });
      },
      convertOpList: function SVGGraphics_convertOpList(operatorList) {
        var argsArray = operatorList.argsArray;
        var fnArray = operatorList.fnArray;
        var fnArrayLen = fnArray.length;
        var REVOPS = [];
        var opList = [];

        for (var op in _util.OPS) {
          REVOPS[_util.OPS[op]] = op;
        }

        for (var x = 0; x < fnArrayLen; x++) {
          var fnId = fnArray[x];
          opList.push({
            'fnId': fnId,
            'fn': REVOPS[fnId],
            'args': argsArray[x]
          });
        }

        return opListToTree(opList);
      },
      executeOpTree: function SVGGraphics_executeOpTree(opTree) {
        var opTreeLen = opTree.length;

        for (var x = 0; x < opTreeLen; x++) {
          var fn = opTree[x].fn;
          var fnId = opTree[x].fnId;
          var args = opTree[x].args;

          switch (fnId | 0) {
            case _util.OPS.beginText:
              this.beginText();
              break;

            case _util.OPS.dependency:
              break;

            case _util.OPS.setLeading:
              this.setLeading(args);
              break;

            case _util.OPS.setLeadingMoveText:
              this.setLeadingMoveText(args[0], args[1]);
              break;

            case _util.OPS.setFont:
              this.setFont(args);
              break;

            case _util.OPS.showText:
              this.showText(args[0]);
              break;

            case _util.OPS.showSpacedText:
              this.showText(args[0]);
              break;

            case _util.OPS.endText:
              this.endText();
              break;

            case _util.OPS.moveText:
              this.moveText(args[0], args[1]);
              break;

            case _util.OPS.setCharSpacing:
              this.setCharSpacing(args[0]);
              break;

            case _util.OPS.setWordSpacing:
              this.setWordSpacing(args[0]);
              break;

            case _util.OPS.setHScale:
              this.setHScale(args[0]);
              break;

            case _util.OPS.setTextMatrix:
              this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
              break;

            case _util.OPS.setTextRise:
              this.setTextRise(args[0]);
              break;

            case _util.OPS.setTextRenderingMode:
              this.setTextRenderingMode(args[0]);
              break;

            case _util.OPS.setLineWidth:
              this.setLineWidth(args[0]);
              break;

            case _util.OPS.setLineJoin:
              this.setLineJoin(args[0]);
              break;

            case _util.OPS.setLineCap:
              this.setLineCap(args[0]);
              break;

            case _util.OPS.setMiterLimit:
              this.setMiterLimit(args[0]);
              break;

            case _util.OPS.setFillRGBColor:
              this.setFillRGBColor(args[0], args[1], args[2]);
              break;

            case _util.OPS.setStrokeRGBColor:
              this.setStrokeRGBColor(args[0], args[1], args[2]);
              break;

            case _util.OPS.setDash:
              this.setDash(args[0], args[1]);
              break;

            case _util.OPS.setGState:
              this.setGState(args[0]);
              break;

            case _util.OPS.fill:
              this.fill();
              break;

            case _util.OPS.eoFill:
              this.eoFill();
              break;

            case _util.OPS.stroke:
              this.stroke();
              break;

            case _util.OPS.fillStroke:
              this.fillStroke();
              break;

            case _util.OPS.eoFillStroke:
              this.eoFillStroke();
              break;

            case _util.OPS.clip:
              this.clip('nonzero');
              break;

            case _util.OPS.eoClip:
              this.clip('evenodd');
              break;

            case _util.OPS.paintSolidColorImageMask:
              this.paintSolidColorImageMask();
              break;

            case _util.OPS.paintJpegXObject:
              this.paintJpegXObject(args[0], args[1], args[2]);
              break;

            case _util.OPS.paintImageXObject:
              this.paintImageXObject(args[0]);
              break;

            case _util.OPS.paintInlineImageXObject:
              this.paintInlineImageXObject(args[0]);
              break;

            case _util.OPS.paintImageMaskXObject:
              this.paintImageMaskXObject(args[0]);
              break;

            case _util.OPS.paintFormXObjectBegin:
              this.paintFormXObjectBegin(args[0], args[1]);
              break;

            case _util.OPS.paintFormXObjectEnd:
              this.paintFormXObjectEnd();
              break;

            case _util.OPS.closePath:
              this.closePath();
              break;

            case _util.OPS.closeStroke:
              this.closeStroke();
              break;

            case _util.OPS.closeFillStroke:
              this.closeFillStroke();
              break;

            case _util.OPS.closeEOFillStroke:
              this.closeEOFillStroke();
              break;

            case _util.OPS.nextLine:
              this.nextLine();
              break;

            case _util.OPS.transform:
              this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
              break;

            case _util.OPS.constructPath:
              this.constructPath(args[0], args[1]);
              break;

            case _util.OPS.endPath:
              this.endPath();
              break;

            case 92:
              this.group(opTree[x].items);
              break;

            default:
              (0, _util.warn)('Unimplemented operator ' + fn);
              break;
          }
        }
      },
      setWordSpacing: function SVGGraphics_setWordSpacing(wordSpacing) {
        this.current.wordSpacing = wordSpacing;
      },
      setCharSpacing: function SVGGraphics_setCharSpacing(charSpacing) {
        this.current.charSpacing = charSpacing;
      },
      nextLine: function SVGGraphics_nextLine() {
        this.moveText(0, this.current.leading);
      },
      setTextMatrix: function SVGGraphics_setTextMatrix(a, b, c, d, e, f) {
        var current = this.current;
        this.current.textMatrix = this.current.lineMatrix = [a, b, c, d, e, f];
        this.current.x = this.current.lineX = 0;
        this.current.y = this.current.lineY = 0;
        current.xcoords = [];
        current.tspan = this.svgFactory.createElement('svg:tspan');
        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
        current.txtElement = this.svgFactory.createElement('svg:text');
        current.txtElement.appendChild(current.tspan);
      },
      beginText: function SVGGraphics_beginText() {
        this.current.x = this.current.lineX = 0;
        this.current.y = this.current.lineY = 0;
        this.current.textMatrix = _util.IDENTITY_MATRIX;
        this.current.lineMatrix = _util.IDENTITY_MATRIX;
        this.current.tspan = this.svgFactory.createElement('svg:tspan');
        this.current.txtElement = this.svgFactory.createElement('svg:text');
        this.current.txtgrp = this.svgFactory.createElement('svg:g');
        this.current.xcoords = [];
      },
      moveText: function SVGGraphics_moveText(x, y) {
        var current = this.current;
        this.current.x = this.current.lineX += x;
        this.current.y = this.current.lineY += y;
        current.xcoords = [];
        current.tspan = this.svgFactory.createElement('svg:tspan');
        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
      },
      showText: function SVGGraphics_showText(glyphs) {
        var current = this.current;
        var font = current.font;
        var fontSize = current.fontSize;

        if (fontSize === 0) {
          return;
        }

        var charSpacing = current.charSpacing;
        var wordSpacing = current.wordSpacing;
        var fontDirection = current.fontDirection;
        var textHScale = current.textHScale * fontDirection;
        var glyphsLength = glyphs.length;
        var vertical = font.vertical;
        var widthAdvanceScale = fontSize * current.fontMatrix[0];
        var x = 0,
            i;

        for (i = 0; i < glyphsLength; ++i) {
          var glyph = glyphs[i];

          if (glyph === null) {
            x += fontDirection * wordSpacing;
            continue;
          } else if ((0, _util.isNum)(glyph)) {
            x += -glyph * fontSize * 0.001;
            continue;
          }

          var width = glyph.width;
          var character = glyph.fontChar;
          var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
          var charWidth = width * widthAdvanceScale + spacing * fontDirection;

          if (!glyph.isInFont && !font.missingFile) {
            x += charWidth;
            continue;
          }

          current.xcoords.push(current.x + x * textHScale);
          current.tspan.textContent += character;
          x += charWidth;
        }

        if (vertical) {
          current.y -= x * textHScale;
        } else {
          current.x += x * textHScale;
        }

        current.tspan.setAttributeNS(null, 'x', current.xcoords.map(pf).join(' '));
        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');

        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
          current.tspan.setAttributeNS(null, 'font-style', current.fontStyle);
        }

        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
          current.tspan.setAttributeNS(null, 'font-weight', current.fontWeight);
        }

        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          if (current.fillColor !== SVG_DEFAULTS.fillColor) {
            current.tspan.setAttributeNS(null, 'fill', current.fillColor);
          }

          if (current.fillAlpha < 1) {
            current.tspan.setAttributeNS(null, 'fill-opacity', current.fillAlpha);
          }
        } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
          current.tspan.setAttributeNS(null, 'fill', 'transparent');
        } else {
          current.tspan.setAttributeNS(null, 'fill', 'none');
        }

        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          this._setStrokeAttributes(current.tspan);
        }

        var textMatrix = current.textMatrix;

        if (current.textRise !== 0) {
          textMatrix = textMatrix.slice();
          textMatrix[5] += current.textRise;
        }

        current.txtElement.setAttributeNS(null, 'transform', pm(textMatrix) + ' scale(1, -1)');
        current.txtElement.setAttributeNS(XML_NS, 'xml:space', 'preserve');
        current.txtElement.appendChild(current.tspan);
        current.txtgrp.appendChild(current.txtElement);

        this._ensureTransformGroup().appendChild(current.txtElement);
      },
      setLeadingMoveText: function SVGGraphics_setLeadingMoveText(x, y) {
        this.setLeading(-y);
        this.moveText(x, y);
      },
      addFontStyle: function SVGGraphics_addFontStyle(fontObj) {
        if (!this.cssStyle) {
          this.cssStyle = this.svgFactory.createElement('svg:style');
          this.cssStyle.setAttributeNS(null, 'type', 'text/css');
          this.defs.appendChild(this.cssStyle);
        }

        var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
        this.cssStyle.textContent += '@font-face { font-family: "' + fontObj.loadedName + '";' + ' src: url(' + url + '); }\n';
      },
      setFont: function SVGGraphics_setFont(details) {
        var current = this.current;
        var fontObj = this.commonObjs.get(details[0]);
        var size = details[1];
        this.current.font = fontObj;

        if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {
          this.addFontStyle(fontObj);
          this.embeddedFonts[fontObj.loadedName] = fontObj;
        }

        current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;
        var bold = fontObj.black ? fontObj.bold ? 'bolder' : 'bold' : fontObj.bold ? 'bold' : 'normal';
        var italic = fontObj.italic ? 'italic' : 'normal';

        if (size < 0) {
          size = -size;
          current.fontDirection = -1;
        } else {
          current.fontDirection = 1;
        }

        current.fontSize = size;
        current.fontFamily = fontObj.loadedName;
        current.fontWeight = bold;
        current.fontStyle = italic;
        current.tspan = this.svgFactory.createElement('svg:tspan');
        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
        current.xcoords = [];
      },
      endText: function endText() {
        var current = this.current;

        if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) {
          current.element = current.txtElement;
          this.clip('nonzero');
          this.endPath();
        }
      },
      setLineWidth: function SVGGraphics_setLineWidth(width) {
        if (width > 0) {
          this.current.lineWidth = width;
        }
      },
      setLineCap: function SVGGraphics_setLineCap(style) {
        this.current.lineCap = LINE_CAP_STYLES[style];
      },
      setLineJoin: function SVGGraphics_setLineJoin(style) {
        this.current.lineJoin = LINE_JOIN_STYLES[style];
      },
      setMiterLimit: function SVGGraphics_setMiterLimit(limit) {
        this.current.miterLimit = limit;
      },
      setStrokeAlpha: function SVGGraphics_setStrokeAlpha(strokeAlpha) {
        this.current.strokeAlpha = strokeAlpha;
      },
      setStrokeRGBColor: function SVGGraphics_setStrokeRGBColor(r, g, b) {
        var color = _util.Util.makeCssRgb(r, g, b);

        this.current.strokeColor = color;
      },
      setFillAlpha: function SVGGraphics_setFillAlpha(fillAlpha) {
        this.current.fillAlpha = fillAlpha;
      },
      setFillRGBColor: function SVGGraphics_setFillRGBColor(r, g, b) {
        var color = _util.Util.makeCssRgb(r, g, b);

        this.current.fillColor = color;
        this.current.tspan = this.svgFactory.createElement('svg:tspan');
        this.current.xcoords = [];
      },
      setDash: function SVGGraphics_setDash(dashArray, dashPhase) {
        this.current.dashArray = dashArray;
        this.current.dashPhase = dashPhase;
      },
      constructPath: function SVGGraphics_constructPath(ops, args) {
        var current = this.current;
        var x = current.x,
            y = current.y;
        current.path = this.svgFactory.createElement('svg:path');
        var d = [];
        var opLength = ops.length;

        for (var i = 0, j = 0; i < opLength; i++) {
          switch (ops[i] | 0) {
            case _util.OPS.rectangle:
              x = args[j++];
              y = args[j++];
              var width = args[j++];
              var height = args[j++];
              var xw = x + width;
              var yh = y + height;
              d.push('M', pf(x), pf(y), 'L', pf(xw), pf(y), 'L', pf(xw), pf(yh), 'L', pf(x), pf(yh), 'Z');
              break;

            case _util.OPS.moveTo:
              x = args[j++];
              y = args[j++];
              d.push('M', pf(x), pf(y));
              break;

            case _util.OPS.lineTo:
              x = args[j++];
              y = args[j++];
              d.push('L', pf(x), pf(y));
              break;

            case _util.OPS.curveTo:
              x = args[j + 4];
              y = args[j + 5];
              d.push('C', pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
              j += 6;
              break;

            case _util.OPS.curveTo2:
              x = args[j + 2];
              y = args[j + 3];
              d.push('C', pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
              j += 4;
              break;

            case _util.OPS.curveTo3:
              x = args[j + 2];
              y = args[j + 3];
              d.push('C', pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
              j += 4;
              break;

            case _util.OPS.closePath:
              d.push('Z');
              break;
          }
        }

        current.path.setAttributeNS(null, 'd', d.join(' '));
        current.path.setAttributeNS(null, 'fill', 'none');

        this._ensureTransformGroup().appendChild(current.path);

        current.element = current.path;
        current.setCurrentPoint(x, y);
      },
      endPath: function SVGGraphics_endPath() {
        if (!this.pendingClip) {
          return;
        }

        var current = this.current;
        var clipId = 'clippath' + clipCount;
        clipCount++;
        var clipPath = this.svgFactory.createElement('svg:clipPath');
        clipPath.setAttributeNS(null, 'id', clipId);
        clipPath.setAttributeNS(null, 'transform', pm(this.transformMatrix));
        var clipElement = current.element.cloneNode(true);

        if (this.pendingClip === 'evenodd') {
          clipElement.setAttributeNS(null, 'clip-rule', 'evenodd');
        } else {
          clipElement.setAttributeNS(null, 'clip-rule', 'nonzero');
        }

        this.pendingClip = null;
        clipPath.appendChild(clipElement);
        this.defs.appendChild(clipPath);

        if (current.activeClipUrl) {
          current.clipGroup = null;
          this.extraStack.forEach(function (prev) {
            prev.clipGroup = null;
          });
          clipPath.setAttributeNS(null, 'clip-path', current.activeClipUrl);
        }

        current.activeClipUrl = 'url(#' + clipId + ')';
        this.tgrp = null;
      },
      clip: function SVGGraphics_clip(type) {
        this.pendingClip = type;
      },
      closePath: function SVGGraphics_closePath() {
        var current = this.current;

        if (current.path) {
          var d = current.path.getAttributeNS(null, 'd');
          d += 'Z';
          current.path.setAttributeNS(null, 'd', d);
        }
      },
      setLeading: function SVGGraphics_setLeading(leading) {
        this.current.leading = -leading;
      },
      setTextRise: function SVGGraphics_setTextRise(textRise) {
        this.current.textRise = textRise;
      },
      setTextRenderingMode: function setTextRenderingMode(textRenderingMode) {
        this.current.textRenderingMode = textRenderingMode;
      },
      setHScale: function SVGGraphics_setHScale(scale) {
        this.current.textHScale = scale / 100;
      },
      setGState: function SVGGraphics_setGState(states) {
        for (var i = 0, ii = states.length; i < ii; i++) {
          var state = states[i];
          var key = state[0];
          var value = state[1];

          switch (key) {
            case 'LW':
              this.setLineWidth(value);
              break;

            case 'LC':
              this.setLineCap(value);
              break;

            case 'LJ':
              this.setLineJoin(value);
              break;

            case 'ML':
              this.setMiterLimit(value);
              break;

            case 'D':
              this.setDash(value[0], value[1]);
              break;

            case 'Font':
              this.setFont(value);
              break;

            case 'CA':
              this.setStrokeAlpha(value);
              break;

            case 'ca':
              this.setFillAlpha(value);
              break;

            default:
              (0, _util.warn)('Unimplemented graphic state ' + key);
              break;
          }
        }
      },
      fill: function SVGGraphics_fill() {
        var current = this.current;

        if (current.element) {
          current.element.setAttributeNS(null, 'fill', current.fillColor);
          current.element.setAttributeNS(null, 'fill-opacity', current.fillAlpha);
          this.endPath();
        }
      },
      stroke: function SVGGraphics_stroke() {
        var current = this.current;

        if (current.element) {
          this._setStrokeAttributes(current.element);

          current.element.setAttributeNS(null, 'fill', 'none');
          this.endPath();
        }
      },
      _setStrokeAttributes: function _setStrokeAttributes(element) {
        var current = this.current;
        element.setAttributeNS(null, 'stroke', current.strokeColor);
        element.setAttributeNS(null, 'stroke-opacity', current.strokeAlpha);
        element.setAttributeNS(null, 'stroke-miterlimit', pf(current.miterLimit));
        element.setAttributeNS(null, 'stroke-linecap', current.lineCap);
        element.setAttributeNS(null, 'stroke-linejoin', current.lineJoin);
        element.setAttributeNS(null, 'stroke-width', pf(current.lineWidth) + 'px');
        element.setAttributeNS(null, 'stroke-dasharray', current.dashArray.map(pf).join(' '));
        element.setAttributeNS(null, 'stroke-dashoffset', pf(current.dashPhase) + 'px');
      },
      eoFill: function SVGGraphics_eoFill() {
        if (this.current.element) {
          this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
        }

        this.fill();
      },
      fillStroke: function SVGGraphics_fillStroke() {
        this.stroke();
        this.fill();
      },
      eoFillStroke: function SVGGraphics_eoFillStroke() {
        if (this.current.element) {
          this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
        }

        this.fillStroke();
      },
      closeStroke: function SVGGraphics_closeStroke() {
        this.closePath();
        this.stroke();
      },
      closeFillStroke: function SVGGraphics_closeFillStroke() {
        this.closePath();
        this.fillStroke();
      },
      closeEOFillStroke: function closeEOFillStroke() {
        this.closePath();
        this.eoFillStroke();
      },
      paintSolidColorImageMask: function SVGGraphics_paintSolidColorImageMask() {
        var current = this.current;
        var rect = this.svgFactory.createElement('svg:rect');
        rect.setAttributeNS(null, 'x', '0');
        rect.setAttributeNS(null, 'y', '0');
        rect.setAttributeNS(null, 'width', '1px');
        rect.setAttributeNS(null, 'height', '1px');
        rect.setAttributeNS(null, 'fill', current.fillColor);

        this._ensureTransformGroup().appendChild(rect);
      },
      paintJpegXObject: function SVGGraphics_paintJpegXObject(objId, w, h) {
        var imgObj = this.objs.get(objId);
        var imgEl = this.svgFactory.createElement('svg:image');
        imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgObj.src);
        imgEl.setAttributeNS(null, 'width', pf(w));
        imgEl.setAttributeNS(null, 'height', pf(h));
        imgEl.setAttributeNS(null, 'x', '0');
        imgEl.setAttributeNS(null, 'y', pf(-h));
        imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / w) + ' ' + pf(-1 / h) + ')');

        this._ensureTransformGroup().appendChild(imgEl);
      },
      paintImageXObject: function SVGGraphics_paintImageXObject(objId) {
        var imgData = this.objs.get(objId);

        if (!imgData) {
          (0, _util.warn)('Dependent image isn\'t ready yet');
          return;
        }

        this.paintInlineImageXObject(imgData);
      },
      paintInlineImageXObject: function SVGGraphics_paintInlineImageXObject(imgData, mask) {
        var width = imgData.width;
        var height = imgData.height;
        var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
        var cliprect = this.svgFactory.createElement('svg:rect');
        cliprect.setAttributeNS(null, 'x', '0');
        cliprect.setAttributeNS(null, 'y', '0');
        cliprect.setAttributeNS(null, 'width', pf(width));
        cliprect.setAttributeNS(null, 'height', pf(height));
        this.current.element = cliprect;
        this.clip('nonzero');
        var imgEl = this.svgFactory.createElement('svg:image');
        imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgSrc);
        imgEl.setAttributeNS(null, 'x', '0');
        imgEl.setAttributeNS(null, 'y', pf(-height));
        imgEl.setAttributeNS(null, 'width', pf(width) + 'px');
        imgEl.setAttributeNS(null, 'height', pf(height) + 'px');
        imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / width) + ' ' + pf(-1 / height) + ')');

        if (mask) {
          mask.appendChild(imgEl);
        } else {
          this._ensureTransformGroup().appendChild(imgEl);
        }
      },
      paintImageMaskXObject: function SVGGraphics_paintImageMaskXObject(imgData) {
        var current = this.current;
        var width = imgData.width;
        var height = imgData.height;
        var fillColor = current.fillColor;
        current.maskId = 'mask' + maskCount++;
        var mask = this.svgFactory.createElement('svg:mask');
        mask.setAttributeNS(null, 'id', current.maskId);
        var rect = this.svgFactory.createElement('svg:rect');
        rect.setAttributeNS(null, 'x', '0');
        rect.setAttributeNS(null, 'y', '0');
        rect.setAttributeNS(null, 'width', pf(width));
        rect.setAttributeNS(null, 'height', pf(height));
        rect.setAttributeNS(null, 'fill', fillColor);
        rect.setAttributeNS(null, 'mask', 'url(#' + current.maskId + ')');
        this.defs.appendChild(mask);

        this._ensureTransformGroup().appendChild(rect);

        this.paintInlineImageXObject(imgData, mask);
      },
      paintFormXObjectBegin: function SVGGraphics_paintFormXObjectBegin(matrix, bbox) {
        if (Array.isArray(matrix) && matrix.length === 6) {
          this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
        }

        if (bbox) {
          var width = bbox[2] - bbox[0];
          var height = bbox[3] - bbox[1];
          var cliprect = this.svgFactory.createElement('svg:rect');
          cliprect.setAttributeNS(null, 'x', bbox[0]);
          cliprect.setAttributeNS(null, 'y', bbox[1]);
          cliprect.setAttributeNS(null, 'width', pf(width));
          cliprect.setAttributeNS(null, 'height', pf(height));
          this.current.element = cliprect;
          this.clip('nonzero');
          this.endPath();
        }
      },
      paintFormXObjectEnd: function SVGGraphics_paintFormXObjectEnd() {},
      _initialize: function _initialize(viewport) {
        var svg = this.svgFactory.create(viewport.width, viewport.height);
        var definitions = this.svgFactory.createElement('svg:defs');
        svg.appendChild(definitions);
        this.defs = definitions;
        var rootGroup = this.svgFactory.createElement('svg:g');
        rootGroup.setAttributeNS(null, 'transform', pm(viewport.transform));
        svg.appendChild(rootGroup);
        this.svg = rootGroup;
        return svg;
      },
      _ensureClipGroup: function SVGGraphics_ensureClipGroup() {
        if (!this.current.clipGroup) {
          var clipGroup = this.svgFactory.createElement('svg:g');
          clipGroup.setAttributeNS(null, 'clip-path', this.current.activeClipUrl);
          this.svg.appendChild(clipGroup);
          this.current.clipGroup = clipGroup;
        }

        return this.current.clipGroup;
      },
      _ensureTransformGroup: function SVGGraphics_ensureTransformGroup() {
        if (!this.tgrp) {
          this.tgrp = this.svgFactory.createElement('svg:g');
          this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));

          if (this.current.activeClipUrl) {
            this._ensureClipGroup().appendChild(this.tgrp);
          } else {
            this.svg.appendChild(this.tgrp);
          }
        }

        return this.tgrp;
      }
    };
    return SVGGraphics;
  }();
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFNodeStream = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(147));

var _util = __w_pdfjs_require__(1);

var _network_utils = __w_pdfjs_require__(166);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = __webpack_require__(6);

var http = __webpack_require__(7);

var https = __webpack_require__(8);

var url = __webpack_require__("so/P");

var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

function parseUrl(sourceUrl) {
  var parsedUrl = url.parse(sourceUrl);

  if (parsedUrl.protocol === 'file:' || parsedUrl.host) {
    return parsedUrl;
  }

  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
    return url.parse("file:///".concat(sourceUrl));
  }

  if (!parsedUrl.host) {
    parsedUrl.protocol = 'file:';
  }

  return parsedUrl;
}

var PDFNodeStream =
/*#__PURE__*/
function () {
  function PDFNodeStream(source) {
    _classCallCheck(this, PDFNodeStream);

    this.source = source;
    this.url = parseUrl(source.url);
    this.isHttp = this.url.protocol === 'http:' || this.url.protocol === 'https:';
    this.isFsUrl = this.url.protocol === 'file:';
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequest = null;
    this._rangeRequestReaders = [];
  }

  _createClass(PDFNodeStream, [{
    key: "getFullReader",
    value: function getFullReader() {
      (0, _util.assert)(!this._fullRequest);
      this._fullRequest = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
      return this._fullRequest;
    }
  }, {
    key: "getRangeReader",
    value: function getRangeReader(start, end) {
      var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

      this._rangeRequestReaders.push(rangeReader);

      return rangeReader;
    }
  }, {
    key: "cancelAllRequests",
    value: function cancelAllRequests(reason) {
      if (this._fullRequest) {
        this._fullRequest.cancel(reason);
      }

      var readers = this._rangeRequestReaders.slice(0);

      readers.forEach(function (reader) {
        reader.cancel(reason);
      });
    }
  }]);

  return PDFNodeStream;
}();

exports.PDFNodeStream = PDFNodeStream;

var BaseFullReader =
/*#__PURE__*/
function () {
  function BaseFullReader(stream) {
    _classCallCheck(this, BaseFullReader);

    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    var source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._headersCapability = (0, _util.createPromiseCapability)();
  }

  _createClass(BaseFullReader, [{
    key: "read",
    value: function () {
      var _read = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        var chunk, buffer;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._readCapability.promise;

              case 2:
                if (!this._done) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", {
                  value: undefined,
                  done: true
                });

              case 4:
                if (!this._storedError) {
                  _context.next = 6;
                  break;
                }

                throw this._storedError;

              case 6:
                chunk = this._readableStream.read();

                if (!(chunk === null)) {
                  _context.next = 10;
                  break;
                }

                this._readCapability = (0, _util.createPromiseCapability)();
                return _context.abrupt("return", this.read());

              case 10:
                this._loaded += chunk.length;

                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                }

                buffer = new Uint8Array(chunk).buffer;
                return _context.abrupt("return", {
                  value: buffer,
                  done: false
                });

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function read() {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "cancel",
    value: function cancel(reason) {
      if (!this._readableStream) {
        this._error(reason);

        return;
      }

      this._readableStream.destroy(reason);
    }
  }, {
    key: "_error",
    value: function _error(reason) {
      this._storedError = reason;

      this._readCapability.resolve();
    }
  }, {
    key: "_setReadableStream",
    value: function _setReadableStream(readableStream) {
      var _this = this;

      this._readableStream = readableStream;
      readableStream.on('readable', function () {
        _this._readCapability.resolve();
      });
      readableStream.on('end', function () {
        readableStream.destroy();
        _this._done = true;

        _this._readCapability.resolve();
      });
      readableStream.on('error', function (reason) {
        _this._error(reason);
      });

      if (!this._isStreamingSupported && this._isRangeSupported) {
        this._error(new _util.AbortException('streaming is disabled'));
      }

      if (this._storedError) {
        this._readableStream.destroy(this._storedError);
      }
    }
  }, {
    key: "headersReady",
    get: function get() {
      return this._headersCapability.promise;
    }
  }, {
    key: "filename",
    get: function get() {
      return this._filename;
    }
  }, {
    key: "contentLength",
    get: function get() {
      return this._contentLength;
    }
  }, {
    key: "isRangeSupported",
    get: function get() {
      return this._isRangeSupported;
    }
  }, {
    key: "isStreamingSupported",
    get: function get() {
      return this._isStreamingSupported;
    }
  }]);

  return BaseFullReader;
}();

var BaseRangeReader =
/*#__PURE__*/
function () {
  function BaseRangeReader(stream) {
    _classCallCheck(this, BaseRangeReader);

    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    var source = stream.source;
    this._isStreamingSupported = !source.disableStream;
  }

  _createClass(BaseRangeReader, [{
    key: "read",
    value: function () {
      var _read2 = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var chunk, buffer;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._readCapability.promise;

              case 2:
                if (!this._done) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return", {
                  value: undefined,
                  done: true
                });

              case 4:
                if (!this._storedError) {
                  _context2.next = 6;
                  break;
                }

                throw this._storedError;

              case 6:
                chunk = this._readableStream.read();

                if (!(chunk === null)) {
                  _context2.next = 10;
                  break;
                }

                this._readCapability = (0, _util.createPromiseCapability)();
                return _context2.abrupt("return", this.read());

              case 10:
                this._loaded += chunk.length;

                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded
                  });
                }

                buffer = new Uint8Array(chunk).buffer;
                return _context2.abrupt("return", {
                  value: buffer,
                  done: false
                });

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function read() {
        return _read2.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "cancel",
    value: function cancel(reason) {
      if (!this._readableStream) {
        this._error(reason);

        return;
      }

      this._readableStream.destroy(reason);
    }
  }, {
    key: "_error",
    value: function _error(reason) {
      this._storedError = reason;

      this._readCapability.resolve();
    }
  }, {
    key: "_setReadableStream",
    value: function _setReadableStream(readableStream) {
      var _this2 = this;

      this._readableStream = readableStream;
      readableStream.on('readable', function () {
        _this2._readCapability.resolve();
      });
      readableStream.on('end', function () {
        readableStream.destroy();
        _this2._done = true;

        _this2._readCapability.resolve();
      });
      readableStream.on('error', function (reason) {
        _this2._error(reason);
      });

      if (this._storedError) {
        this._readableStream.destroy(this._storedError);
      }
    }
  }, {
    key: "isStreamingSupported",
    get: function get() {
      return this._isStreamingSupported;
    }
  }]);

  return BaseRangeReader;
}();

function createRequestOptions(url, headers) {
  return {
    protocol: url.protocol,
    auth: url.auth,
    host: url.hostname,
    port: url.port,
    path: url.path,
    method: 'GET',
    headers: headers
  };
}

var PDFNodeStreamFullReader =
/*#__PURE__*/
function (_BaseFullReader) {
  _inherits(PDFNodeStreamFullReader, _BaseFullReader);

  function PDFNodeStreamFullReader(stream) {
    var _this3;

    _classCallCheck(this, PDFNodeStreamFullReader);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PDFNodeStreamFullReader).call(this, stream));

    var handleResponse = function handleResponse(response) {
      if (response.statusCode === 404) {
        var error = new _util.MissingPDFException("Missing PDF \"".concat(_this3._url, "\"."));
        _this3._storedError = error;

        _this3._headersCapability.reject(error);

        return;
      }

      _this3._headersCapability.resolve();

      _this3._setReadableStream(response);

      var getResponseHeader = function getResponseHeader(name) {
        return _this3._readableStream.headers[name.toLowerCase()];
      };

      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader: getResponseHeader,
        isHttp: stream.isHttp,
        rangeChunkSize: _this3._rangeChunkSize,
        disableRange: _this3._disableRange
      }),
          allowRangeRequests = _validateRangeRequest.allowRangeRequests,
          suggestedLength = _validateRangeRequest.suggestedLength;

      _this3._isRangeSupported = allowRangeRequests;
      _this3._contentLength = suggestedLength || _this3._contentLength;
      _this3._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
    };

    _this3._request = null;

    if (_this3._url.protocol === 'http:') {
      _this3._request = http.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
    } else {
      _this3._request = https.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
    }

    _this3._request.on('error', function (reason) {
      _this3._storedError = reason;

      _this3._headersCapability.reject(reason);
    });

    _this3._request.end();

    return _this3;
  }

  return PDFNodeStreamFullReader;
}(BaseFullReader);

var PDFNodeStreamRangeReader =
/*#__PURE__*/
function (_BaseRangeReader) {
  _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);

  function PDFNodeStreamRangeReader(stream, start, end) {
    var _this4;

    _classCallCheck(this, PDFNodeStreamRangeReader);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PDFNodeStreamRangeReader).call(this, stream));
    _this4._httpHeaders = {};

    for (var property in stream.httpHeaders) {
      var value = stream.httpHeaders[property];

      if (typeof value === 'undefined') {
        continue;
      }

      _this4._httpHeaders[property] = value;
    }

    _this4._httpHeaders['Range'] = "bytes=".concat(start, "-").concat(end - 1);

    var handleResponse = function handleResponse(response) {
      if (response.statusCode === 404) {
        var error = new _util.MissingPDFException("Missing PDF \"".concat(_this4._url, "\"."));
        _this4._storedError = error;
        return;
      }

      _this4._setReadableStream(response);
    };

    _this4._request = null;

    if (_this4._url.protocol === 'http:') {
      _this4._request = http.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
    } else {
      _this4._request = https.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
    }

    _this4._request.on('error', function (reason) {
      _this4._storedError = reason;
    });

    _this4._request.end();

    return _this4;
  }

  return PDFNodeStreamRangeReader;
}(BaseRangeReader);

var PDFNodeStreamFsFullReader =
/*#__PURE__*/
function (_BaseFullReader2) {
  _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);

  function PDFNodeStreamFsFullReader(stream) {
    var _this5;

    _classCallCheck(this, PDFNodeStreamFsFullReader);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(PDFNodeStreamFsFullReader).call(this, stream));
    var path = decodeURIComponent(_this5._url.path);

    if (fileUriRegex.test(_this5._url.href)) {
      path = path.replace(/^\//, '');
    }

    fs.lstat(path, function (error, stat) {
      if (error) {
        if (error.code === 'ENOENT') {
          error = new _util.MissingPDFException("Missing PDF \"".concat(path, "\"."));
        }

        _this5._storedError = error;

        _this5._headersCapability.reject(error);

        return;
      }

      _this5._contentLength = stat.size;

      _this5._setReadableStream(fs.createReadStream(path));

      _this5._headersCapability.resolve();
    });
    return _this5;
  }

  return PDFNodeStreamFsFullReader;
}(BaseFullReader);

var PDFNodeStreamFsRangeReader =
/*#__PURE__*/
function (_BaseRangeReader2) {
  _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);

  function PDFNodeStreamFsRangeReader(stream, start, end) {
    var _this6;

    _classCallCheck(this, PDFNodeStreamFsRangeReader);

    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(PDFNodeStreamFsRangeReader).call(this, stream));
    var path = decodeURIComponent(_this6._url.path);

    if (fileUriRegex.test(_this6._url.href)) {
      path = path.replace(/^\//, '');
    }

    _this6._setReadableStream(fs.createReadStream(path, {
      start: start,
      end: end - 1
    }));

    return _this6;
  }

  return PDFNodeStreamFsRangeReader;
}(BaseRangeReader);

/***/ }),
/* 166 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createResponseStatusError = createResponseStatusError;
exports.extractFilenameFromHeader = extractFilenameFromHeader;
exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
exports.validateResponseStatus = validateResponseStatus;

var _util = __w_pdfjs_require__(1);

var _content_disposition = __w_pdfjs_require__(167);

function validateRangeRequestCapabilities(_ref) {
  var getResponseHeader = _ref.getResponseHeader,
      isHttp = _ref.isHttp,
      rangeChunkSize = _ref.rangeChunkSize,
      disableRange = _ref.disableRange;
  (0, _util.assert)(rangeChunkSize > 0, 'Range chunk size must be larger than zero');
  var returnValues = {
    allowRangeRequests: false,
    suggestedLength: undefined
  };
  var length = parseInt(getResponseHeader('Content-Length'), 10);

  if (!Number.isInteger(length)) {
    return returnValues;
  }

  returnValues.suggestedLength = length;

  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }

  if (disableRange || !isHttp) {
    return returnValues;
  }

  if (getResponseHeader('Accept-Ranges') !== 'bytes') {
    return returnValues;
  }

  var contentEncoding = getResponseHeader('Content-Encoding') || 'identity';

  if (contentEncoding !== 'identity') {
    return returnValues;
  }

  returnValues.allowRangeRequests = true;
  return returnValues;
}

function extractFilenameFromHeader(getResponseHeader) {
  var contentDisposition = getResponseHeader('Content-Disposition');

  if (contentDisposition) {
    var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

    if (/\.pdf$/i.test(filename)) {
      return filename;
    }
  }

  return null;
}

function createResponseStatusError(status, url) {
  if (status === 404 || status === 0 && /^file:/.test(url)) {
    return new _util.MissingPDFException('Missing PDF "' + url + '".');
  }

  return new _util.UnexpectedResponseException('Unexpected server response (' + status + ') while retrieving PDF "' + url + '".', status);
}

function validateResponseStatus(status) {
  return status === 200 || status === 206;
}

/***/ }),
/* 167 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function getFilenameFromContentDispositionHeader(contentDisposition) {
  var needsEncodingFixup = true;
  var tmp = toParamRegExp('filename\\*', 'i').exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];
    var filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }

  tmp = rfc2231getparam(contentDisposition);

  if (tmp) {
    var _filename = rfc2047decode(tmp);

    return fixupEncoding(_filename);
  }

  tmp = toParamRegExp('filename', 'i').exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];

    var _filename2 = rfc2616unquote(tmp);

    _filename2 = rfc2047decode(_filename2);
    return fixupEncoding(_filename2);
  }

  function toParamRegExp(attributePattern, flags) {
    return new RegExp('(?:^|;)\\s*' + attributePattern + '\\s*=\\s*' + '(' + '[^";\\s][^;\\s]*' + '|' + '"(?:[^"\\\\]|\\\\"?)+"?' + ')', flags);
  }

  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }

      try {
        var decoder = new TextDecoder(encoding, {
          fatal: true
        });
        var bytes = Array.from(value, function (ch) {
          return ch.charCodeAt(0) & 0xFF;
        });
        value = decoder.decode(new Uint8Array(bytes));
        needsEncodingFixup = false;
      } catch (e) {
        if (/^utf-?8$/i.test(encoding)) {
          try {
            value = decodeURIComponent(escape(value));
            needsEncodingFixup = false;
          } catch (err) {}
        }
      }
    }

    return value;
  }

  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode('utf-8', value);

      if (needsEncodingFixup) {
        value = textdecode('iso-8859-1', value);
      }
    }

    return value;
  }

  function rfc2231getparam(contentDisposition) {
    var matches = [],
        match;
    var iter = toParamRegExp('filename\\*((?!0\\d)\\d+)(\\*?)', 'ig');

    while ((match = iter.exec(contentDisposition)) !== null) {
      var _match = match,
          _match2 = _slicedToArray(_match, 4),
          n = _match2[1],
          quot = _match2[2],
          part = _match2[3];

      n = parseInt(n, 10);

      if (n in matches) {
        if (n === 0) {
          break;
        }

        continue;
      }

      matches[n] = [quot, part];
    }

    var parts = [];

    for (var n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }

      var _matches$n = _slicedToArray(matches[n], 2),
          quot = _matches$n[0],
          part = _matches$n[1];

      part = rfc2616unquote(part);

      if (quot) {
        part = unescape(part);

        if (n === 0) {
          part = rfc5987decode(part);
        }
      }

      parts.push(part);
    }

    return parts.join('');
  }

  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      var parts = value.slice(1).split('\\"');

      for (var i = 0; i < parts.length; ++i) {
        var quotindex = parts[i].indexOf('"');

        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }

        parts[i] = parts[i].replace(/\\(.)/g, '$1');
      }

      value = parts.join('"');
    }

    return value;
  }

  function rfc5987decode(extvalue) {
    var encodingend = extvalue.indexOf('\'');

    if (encodingend === -1) {
      return extvalue;
    }

    var encoding = extvalue.slice(0, encodingend);
    var langvalue = extvalue.slice(encodingend + 1);
    var value = langvalue.replace(/^[^']*'/, '');
    return textdecode(encoding, value);
  }

  function rfc2047decode(value) {
    if (!value.startsWith('=?') || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }

    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (_, charset, encoding, text) {
      if (encoding === 'q' || encoding === 'Q') {
        text = text.replace(/_/g, ' ');
        text = text.replace(/=([0-9a-fA-F]{2})/g, function (_, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }

      try {
        text = atob(text);
      } catch (e) {}

      return textdecode(charset, text);
    });
  }

  return '';
}

/***/ }),
/* 168 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFFetchStream = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(147));

var _util = __w_pdfjs_require__(1);

var _network_utils = __w_pdfjs_require__(166);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: 'GET',
    headers: headers,
    signal: abortController && abortController.signal,
    mode: 'cors',
    credentials: withCredentials ? 'include' : 'same-origin',
    redirect: 'follow'
  };
}

var PDFFetchStream =
/*#__PURE__*/
function () {
  function PDFFetchStream(source) {
    _classCallCheck(this, PDFFetchStream);

    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  _createClass(PDFFetchStream, [{
    key: "getFullReader",
    value: function getFullReader() {
      (0, _util.assert)(!this._fullRequestReader);
      this._fullRequestReader = new PDFFetchStreamReader(this);
      return this._fullRequestReader;
    }
  }, {
    key: "getRangeReader",
    value: function getRangeReader(begin, end) {
      var reader = new PDFFetchStreamRangeReader(this, begin, end);

      this._rangeRequestReaders.push(reader);

      return reader;
    }
  }, {
    key: "cancelAllRequests",
    value: function cancelAllRequests(reason) {
      if (this._fullRequestReader) {
        this._fullRequestReader.cancel(reason);
      }

      var readers = this._rangeRequestReaders.slice(0);

      readers.forEach(function (reader) {
        reader.cancel(reason);
      });
    }
  }]);

  return PDFFetchStream;
}();

exports.PDFFetchStream = PDFFetchStream;

var PDFFetchStreamReader =
/*#__PURE__*/
function () {
  function PDFFetchStreamReader(stream) {
    var _this = this;

    _classCallCheck(this, PDFFetchStreamReader);

    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    var source = stream.source;
    this._withCredentials = source.withCredentials;
    this._contentLength = source.length;
    this._headersCapability = (0, _util.createPromiseCapability)();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    if (typeof AbortController !== 'undefined') {
      this._abortController = new AbortController();
    }

    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._headers = new Headers();

    for (var property in this._stream.httpHeaders) {
      var value = this._stream.httpHeaders[property];

      if (typeof value === 'undefined') {
        continue;
      }

      this._headers.append(property, value);
    }

    var url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      _this._reader = response.body.getReader();

      _this._headersCapability.resolve();

      var getResponseHeader = function getResponseHeader(name) {
        return response.headers.get(name);
      };

      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader: getResponseHeader,
        isHttp: _this._stream.isHttp,
        rangeChunkSize: _this._rangeChunkSize,
        disableRange: _this._disableRange
      }),
          allowRangeRequests = _validateRangeRequest.allowRangeRequests,
          suggestedLength = _validateRangeRequest.suggestedLength;

      _this._isRangeSupported = allowRangeRequests;
      _this._contentLength = suggestedLength || _this._contentLength;
      _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

      if (!_this._isStreamingSupported && _this._isRangeSupported) {
        _this.cancel(new _util.AbortException('streaming is disabled'));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }

  _createClass(PDFFetchStreamReader, [{
    key: "read",
    value: function () {
      var _read = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        var _ref, value, done, buffer;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._headersCapability.promise;

              case 2:
                _context.next = 4;
                return this._reader.read();

              case 4:
                _ref = _context.sent;
                value = _ref.value;
                done = _ref.done;

                if (!done) {
                  _context.next = 9;
                  break;
                }

                return _context.abrupt("return", {
                  value: value,
                  done: done
                });

              case 9:
                this._loaded += value.byteLength;

                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                }

                buffer = new Uint8Array(value).buffer;
                return _context.abrupt("return", {
                  value: buffer,
                  done: false
                });

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function read() {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "cancel",
    value: function cancel(reason) {
      if (this._reader) {
        this._reader.cancel(reason);
      }

      if (this._abortController) {
        this._abortController.abort();
      }
    }
  }, {
    key: "headersReady",
    get: function get() {
      return this._headersCapability.promise;
    }
  }, {
    key: "filename",
    get: function get() {
      return this._filename;
    }
  }, {
    key: "contentLength",
    get: function get() {
      return this._contentLength;
    }
  }, {
    key: "isRangeSupported",
    get: function get() {
      return this._isRangeSupported;
    }
  }, {
    key: "isStreamingSupported",
    get: function get() {
      return this._isStreamingSupported;
    }
  }]);

  return PDFFetchStreamReader;
}();

var PDFFetchStreamRangeReader =
/*#__PURE__*/
function () {
  function PDFFetchStreamRangeReader(stream, begin, end) {
    var _this2 = this;

    _classCallCheck(this, PDFFetchStreamRangeReader);

    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    var source = stream.source;
    this._withCredentials = source.withCredentials;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._isStreamingSupported = !source.disableStream;

    if (typeof AbortController !== 'undefined') {
      this._abortController = new AbortController();
    }

    this._headers = new Headers();

    for (var property in this._stream.httpHeaders) {
      var value = this._stream.httpHeaders[property];

      if (typeof value === 'undefined') {
        continue;
      }

      this._headers.append(property, value);
    }

    var rangeStr = begin + '-' + (end - 1);

    this._headers.append('Range', 'bytes=' + rangeStr);

    var url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      _this2._readCapability.resolve();

      _this2._reader = response.body.getReader();
    });
    this.onProgress = null;
  }

  _createClass(PDFFetchStreamRangeReader, [{
    key: "read",
    value: function () {
      var _read2 = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var _ref2, value, done, buffer;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._readCapability.promise;

              case 2:
                _context2.next = 4;
                return this._reader.read();

              case 4:
                _ref2 = _context2.sent;
                value = _ref2.value;
                done = _ref2.done;

                if (!done) {
                  _context2.next = 9;
                  break;
                }

                return _context2.abrupt("return", {
                  value: value,
                  done: done
                });

              case 9:
                this._loaded += value.byteLength;

                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded
                  });
                }

                buffer = new Uint8Array(value).buffer;
                return _context2.abrupt("return", {
                  value: buffer,
                  done: false
                });

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function read() {
        return _read2.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "cancel",
    value: function cancel(reason) {
      if (this._reader) {
        this._reader.cancel(reason);
      }

      if (this._abortController) {
        this._abortController.abort();
      }
    }
  }, {
    key: "isStreamingSupported",
    get: function get() {
      return this._isStreamingSupported;
    }
  }]);

  return PDFFetchStreamRangeReader;
}();

/***/ }),
/* 169 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFNetworkStream = PDFNetworkStream;
exports.NetworkManager = NetworkManager;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(147));

var _util = __w_pdfjs_require__(1);

var _network_utils = __w_pdfjs_require__(166);

var _global_scope = _interopRequireDefault(__w_pdfjs_require__(3));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

;
var OK_RESPONSE = 200;
var PARTIAL_CONTENT_RESPONSE = 206;

function NetworkManager(url, args) {
  this.url = url;
  args = args || {};
  this.isHttp = /^https?:/i.test(url);
  this.httpHeaders = this.isHttp && args.httpHeaders || {};
  this.withCredentials = args.withCredentials || false;

  this.getXhr = args.getXhr || function NetworkManager_getXhr() {
    return new XMLHttpRequest();
  };

  this.currXhrId = 0;
  this.pendingRequests = Object.create(null);
  this.loadedRequests = Object.create(null);
}

function getArrayBuffer(xhr) {
  var data = xhr.response;

  if (typeof data !== 'string') {
    return data;
  }

  var array = (0, _util.stringToBytes)(data);
  return array.buffer;
}

var supportsMozChunked = function supportsMozChunkedClosure() {
  try {
    var x = new XMLHttpRequest();
    x.open('GET', _global_scope.default.location.href);
    x.responseType = 'moz-chunked-arraybuffer';
    return x.responseType === 'moz-chunked-arraybuffer';
  } catch (e) {
    return false;
  }
}();

NetworkManager.prototype = {
  requestRange: function NetworkManager_requestRange(begin, end, listeners) {
    var args = {
      begin: begin,
      end: end
    };

    for (var prop in listeners) {
      args[prop] = listeners[prop];
    }

    return this.request(args);
  },
  requestFull: function NetworkManager_requestFull(listeners) {
    return this.request(listeners);
  },
  request: function NetworkManager_request(args) {
    var xhr = this.getXhr();
    var xhrId = this.currXhrId++;
    var pendingRequest = this.pendingRequests[xhrId] = {
      xhr: xhr
    };
    xhr.open('GET', this.url);
    xhr.withCredentials = this.withCredentials;

    for (var property in this.httpHeaders) {
      var value = this.httpHeaders[property];

      if (typeof value === 'undefined') {
        continue;
      }

      xhr.setRequestHeader(property, value);
    }

    if (this.isHttp && 'begin' in args && 'end' in args) {
      var rangeStr = args.begin + '-' + (args.end - 1);
      xhr.setRequestHeader('Range', 'bytes=' + rangeStr);
      pendingRequest.expectedStatus = 206;
    } else {
      pendingRequest.expectedStatus = 200;
    }

    var useMozChunkedLoading = supportsMozChunked && !!args.onProgressiveData;

    if (useMozChunkedLoading) {
      xhr.responseType = 'moz-chunked-arraybuffer';
      pendingRequest.onProgressiveData = args.onProgressiveData;
      pendingRequest.mozChunked = true;
    } else {
      xhr.responseType = 'arraybuffer';
    }

    if (args.onError) {
      xhr.onerror = function (evt) {
        args.onError(xhr.status);
      };
    }

    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  },
  onProgress: function NetworkManager_onProgress(xhrId, evt) {
    var pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    if (pendingRequest.mozChunked) {
      var chunk = getArrayBuffer(pendingRequest.xhr);
      pendingRequest.onProgressiveData(chunk);
    }

    var onProgress = pendingRequest.onProgress;

    if (onProgress) {
      onProgress(evt);
    }
  },
  onStateChange: function NetworkManager_onStateChange(xhrId, evt) {
    var pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    var xhr = pendingRequest.xhr;

    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }

    if (xhr.readyState !== 4) {
      return;
    }

    if (!(xhrId in this.pendingRequests)) {
      return;
    }

    delete this.pendingRequests[xhrId];

    if (xhr.status === 0 && this.isHttp) {
      if (pendingRequest.onError) {
        pendingRequest.onError(xhr.status);
      }

      return;
    }

    var xhrStatus = xhr.status || OK_RESPONSE;
    var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      if (pendingRequest.onError) {
        pendingRequest.onError(xhr.status);
      }

      return;
    }

    this.loadedRequests[xhrId] = true;
    var chunk = getArrayBuffer(xhr);

    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      var rangeHeader = xhr.getResponseHeader('Content-Range');
      var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      var begin = parseInt(matches[1], 10);
      pendingRequest.onDone({
        begin: begin,
        chunk: chunk
      });
    } else if (pendingRequest.onProgressiveData) {
      pendingRequest.onDone(null);
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk: chunk
      });
    } else if (pendingRequest.onError) {
      pendingRequest.onError(xhr.status);
    }
  },
  hasPendingRequests: function NetworkManager_hasPendingRequests() {
    for (var xhrId in this.pendingRequests) {
      return true;
    }

    return false;
  },
  getRequestXhr: function NetworkManager_getXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  },
  isStreamingRequest: function NetworkManager_isStreamingRequest(xhrId) {
    return !!this.pendingRequests[xhrId].onProgressiveData;
  },
  isPendingRequest: function NetworkManager_isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  },
  isLoadedRequest: function NetworkManager_isLoadedRequest(xhrId) {
    return xhrId in this.loadedRequests;
  },
  abortAllRequests: function NetworkManager_abortAllRequests() {
    for (var xhrId in this.pendingRequests) {
      this.abortRequest(xhrId | 0);
    }
  },
  abortRequest: function NetworkManager_abortRequest(xhrId) {
    var xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }
};

function PDFNetworkStream(source) {
  this._source = source;
  this._manager = new NetworkManager(source.url, {
    httpHeaders: source.httpHeaders,
    withCredentials: source.withCredentials
  });
  this._rangeChunkSize = source.rangeChunkSize;
  this._fullRequestReader = null;
  this._rangeRequestReaders = [];
}

PDFNetworkStream.prototype = {
  _onRangeRequestReaderClosed: function PDFNetworkStream_onRangeRequestReaderClosed(reader) {
    var i = this._rangeRequestReaders.indexOf(reader);

    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  },
  getFullReader: function PDFNetworkStream_getFullReader() {
    (0, _util.assert)(!this._fullRequestReader);
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  },
  getRangeReader: function PDFNetworkStream_getRangeReader(begin, end) {
    var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

    this._rangeRequestReaders.push(reader);

    return reader;
  },
  cancelAllRequests: function PDFNetworkStream_cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    var readers = this._rangeRequestReaders.slice(0);

    readers.forEach(function (reader) {
      reader.cancel(reason);
    });
  }
};

function PDFNetworkStreamFullRequestReader(manager, source) {
  this._manager = manager;
  var args = {
    onHeadersReceived: this._onHeadersReceived.bind(this),
    onProgressiveData: source.disableStream ? null : this._onProgressiveData.bind(this),
    onDone: this._onDone.bind(this),
    onError: this._onError.bind(this),
    onProgress: this._onProgress.bind(this)
  };
  this._url = source.url;
  this._fullRequestId = manager.requestFull(args);
  this._headersReceivedCapability = (0, _util.createPromiseCapability)();
  this._disableRange = source.disableRange || false;
  this._contentLength = source.length;
  this._rangeChunkSize = source.rangeChunkSize;

  if (!this._rangeChunkSize && !this._disableRange) {
    this._disableRange = true;
  }

  this._isStreamingSupported = false;
  this._isRangeSupported = false;
  this._cachedChunks = [];
  this._requests = [];
  this._done = false;
  this._storedError = undefined;
  this._filename = null;
  this.onProgress = null;
}

PDFNetworkStreamFullRequestReader.prototype = {
  _onHeadersReceived: function PDFNetworkStreamFullRequestReader_onHeadersReceived() {
    var fullRequestXhrId = this._fullRequestId;

    var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

    var getResponseHeader = function getResponseHeader(name) {
      return fullRequestXhr.getResponseHeader(name);
    };

    var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
      getResponseHeader: getResponseHeader,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    }),
        allowRangeRequests = _validateRangeRequest.allowRangeRequests,
        suggestedLength = _validateRangeRequest.suggestedLength;

    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }

    this._contentLength = suggestedLength || this._contentLength;
    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
    var networkManager = this._manager;

    if (networkManager.isStreamingRequest(fullRequestXhrId)) {
      this._isStreamingSupported = true;
    } else if (this._isRangeSupported) {
      networkManager.abortRequest(fullRequestXhrId);
    }

    this._headersReceivedCapability.resolve();
  },
  _onProgressiveData: function PDFNetworkStreamFullRequestReader_onProgressiveData(chunk) {
    if (this._requests.length > 0) {
      var requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._cachedChunks.push(chunk);
    }
  },
  _onDone: function PDFNetworkStreamFullRequestReader_onDone(args) {
    if (args) {
      this._onProgressiveData(args.chunk);
    }

    this._done = true;

    if (this._cachedChunks.length > 0) {
      return;
    }

    this._requests.forEach(function (requestCapability) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    });

    this._requests = [];
  },
  _onError: function PDFNetworkStreamFullRequestReader_onError(status) {
    var url = this._url;
    var exception = (0, _network_utils.createResponseStatusError)(status, url);
    this._storedError = exception;

    this._headersReceivedCapability.reject(exception);

    this._requests.forEach(function (requestCapability) {
      requestCapability.reject(exception);
    });

    this._requests = [];
    this._cachedChunks = [];
  },
  _onProgress: function PDFNetworkStreamFullRequestReader_onProgress(data) {
    if (this.onProgress) {
      this.onProgress({
        loaded: data.loaded,
        total: data.lengthComputable ? data.total : this._contentLength
      });
    }
  },

  get filename() {
    return this._filename;
  },

  get isRangeSupported() {
    return this._isRangeSupported;
  },

  get isStreamingSupported() {
    return this._isStreamingSupported;
  },

  get contentLength() {
    return this._contentLength;
  },

  get headersReady() {
    return this._headersReceivedCapability.promise;
  },

  read: function () {
    var _read = _asyncToGenerator(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      var chunk, requestCapability;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this._storedError) {
                _context.next = 2;
                break;
              }

              throw this._storedError;

            case 2:
              if (!(this._cachedChunks.length > 0)) {
                _context.next = 5;
                break;
              }

              chunk = this._cachedChunks.shift();
              return _context.abrupt("return", {
                value: chunk,
                done: false
              });

            case 5:
              if (!this._done) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", {
                value: undefined,
                done: true
              });

            case 7:
              requestCapability = (0, _util.createPromiseCapability)();

              this._requests.push(requestCapability);

              return _context.abrupt("return", requestCapability.promise);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function read() {
      return _read.apply(this, arguments);
    }

    return read;
  }(),
  cancel: function PDFNetworkStreamFullRequestReader_cancel(reason) {
    this._done = true;

    this._headersReceivedCapability.reject(reason);

    this._requests.forEach(function (requestCapability) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    });

    this._requests = [];

    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }

    this._fullRequestReader = null;
  }
};

function PDFNetworkStreamRangeRequestReader(manager, begin, end) {
  this._manager = manager;
  var args = {
    onDone: this._onDone.bind(this),
    onProgress: this._onProgress.bind(this)
  };
  this._requestId = manager.requestRange(begin, end, args);
  this._requests = [];
  this._queuedChunk = null;
  this._done = false;
  this.onProgress = null;
  this.onClosed = null;
}

PDFNetworkStreamRangeRequestReader.prototype = {
  _close: function PDFNetworkStreamRangeRequestReader_close() {
    if (this.onClosed) {
      this.onClosed(this);
    }
  },
  _onDone: function PDFNetworkStreamRangeRequestReader_onDone(data) {
    var chunk = data.chunk;

    if (this._requests.length > 0) {
      var requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }

    this._done = true;

    this._requests.forEach(function (requestCapability) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    });

    this._requests = [];

    this._close();
  },
  _onProgress: function PDFNetworkStreamRangeRequestReader_onProgress(evt) {
    if (!this.isStreamingSupported && this.onProgress) {
      this.onProgress({
        loaded: evt.loaded
      });
    }
  },

  get isStreamingSupported() {
    return false;
  },

  read: function () {
    var _read2 = _asyncToGenerator(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee2() {
      var chunk, requestCapability;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(this._queuedChunk !== null)) {
                _context2.next = 4;
                break;
              }

              chunk = this._queuedChunk;
              this._queuedChunk = null;
              return _context2.abrupt("return", {
                value: chunk,
                done: false
              });

            case 4:
              if (!this._done) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return", {
                value: undefined,
                done: true
              });

            case 6:
              requestCapability = (0, _util.createPromiseCapability)();

              this._requests.push(requestCapability);

              return _context2.abrupt("return", requestCapability.promise);

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function read() {
      return _read2.apply(this, arguments);
    }

    return read;
  }(),
  cancel: function PDFNetworkStreamRangeRequestReader_cancel(reason) {
    this._done = true;

    this._requests.forEach(function (requestCapability) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    });

    this._requests = [];

    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }

    this._close();
  }
};

/***/ })
/******/ ]);
});
//# sourceMappingURL=pdf.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("zkTx").Buffer, __webpack_require__("pCvA"), __webpack_require__("7XVh")))

/***/ }),

/***/ "gCDi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2018 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SimpleLinkService = exports.PDFLinkService = void 0;

var _ui_utils = __webpack_require__("nrGg");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PDFLinkService =
/*#__PURE__*/
function () {
  function PDFLinkService() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        eventBus = _ref.eventBus,
        _ref$externalLinkTarg = _ref.externalLinkTarget,
        externalLinkTarget = _ref$externalLinkTarg === void 0 ? null : _ref$externalLinkTarg,
        _ref$externalLinkRel = _ref.externalLinkRel,
        externalLinkRel = _ref$externalLinkRel === void 0 ? null : _ref$externalLinkRel;

    _classCallCheck(this, PDFLinkService);

    this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
    this.externalLinkTarget = externalLinkTarget;
    this.externalLinkRel = externalLinkRel;
    this.baseUrl = null;
    this.pdfDocument = null;
    this.pdfViewer = null;
    this.pdfHistory = null;
    this._pagesRefCache = null;
  }

  _createClass(PDFLinkService, [{
    key: "setDocument",
    value: function setDocument(pdfDocument) {
      var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.baseUrl = baseUrl;
      this.pdfDocument = pdfDocument;
      this._pagesRefCache = Object.create(null);
    }
  }, {
    key: "setViewer",
    value: function setViewer(pdfViewer) {
      this.pdfViewer = pdfViewer;
    }
  }, {
    key: "setHistory",
    value: function setHistory(pdfHistory) {
      this.pdfHistory = pdfHistory;
    }
  }, {
    key: "navigateTo",
    value: function navigateTo(dest) {
      var _this = this;

      var goToDestination = function goToDestination(_ref2) {
        var namedDest = _ref2.namedDest,
            explicitDest = _ref2.explicitDest;
        var destRef = explicitDest[0],
            pageNumber;

        if (destRef instanceof Object) {
          pageNumber = _this._cachedPageNumber(destRef);

          if (pageNumber === null) {
            _this.pdfDocument.getPageIndex(destRef).then(function (pageIndex) {
              _this.cachePageRef(pageIndex + 1, destRef);

              goToDestination({
                namedDest: namedDest,
                explicitDest: explicitDest
              });
            }).catch(function () {
              console.error("PDFLinkService.navigateTo: \"".concat(destRef, "\" is not ") + "a valid page reference, for dest=\"".concat(dest, "\"."));
            });

            return;
          }
        } else if (Number.isInteger(destRef)) {
          pageNumber = destRef + 1;
        } else {
          console.error("PDFLinkService.navigateTo: \"".concat(destRef, "\" is not ") + "a valid destination reference, for dest=\"".concat(dest, "\"."));
          return;
        }

        if (!pageNumber || pageNumber < 1 || pageNumber > _this.pagesCount) {
          console.error("PDFLinkService.navigateTo: \"".concat(pageNumber, "\" is not ") + "a valid page number, for dest=\"".concat(dest, "\"."));
          return;
        }

        if (_this.pdfHistory) {
          _this.pdfHistory.pushCurrentPosition();

          _this.pdfHistory.push({
            namedDest: namedDest,
            explicitDest: explicitDest,
            pageNumber: pageNumber
          });
        }

        _this.pdfViewer.scrollPageIntoView({
          pageNumber: pageNumber,
          destArray: explicitDest
        });
      };

      new Promise(function (resolve, reject) {
        if (typeof dest === 'string') {
          _this.pdfDocument.getDestination(dest).then(function (destArray) {
            resolve({
              namedDest: dest,
              explicitDest: destArray
            });
          });

          return;
        }

        resolve({
          namedDest: '',
          explicitDest: dest
        });
      }).then(function (data) {
        if (!Array.isArray(data.explicitDest)) {
          console.error("PDFLinkService.navigateTo: \"".concat(data.explicitDest, "\" is") + " not a valid destination array, for dest=\"".concat(dest, "\"."));
          return;
        }

        goToDestination(data);
      });
    }
  }, {
    key: "getDestinationHash",
    value: function getDestinationHash(dest) {
      if (typeof dest === 'string') {
        return this.getAnchorUrl('#' + escape(dest));
      }

      if (Array.isArray(dest)) {
        var str = JSON.stringify(dest);
        return this.getAnchorUrl('#' + escape(str));
      }

      return this.getAnchorUrl('');
    }
  }, {
    key: "getAnchorUrl",
    value: function getAnchorUrl(anchor) {
      return (this.baseUrl || '') + anchor;
    }
  }, {
    key: "setHash",
    value: function setHash(hash) {
      var pageNumber, dest;

      if (hash.includes('=')) {
        var params = (0, _ui_utils.parseQueryString)(hash);

        if ('search' in params) {
          this.eventBus.dispatch('findfromurlhash', {
            source: this,
            query: params['search'].replace(/"/g, ''),
            phraseSearch: params['phrase'] === 'true'
          });
        }

        if ('nameddest' in params) {
          this.navigateTo(params.nameddest);
          return;
        }

        if ('page' in params) {
          pageNumber = params.page | 0 || 1;
        }

        if ('zoom' in params) {
          var zoomArgs = params.zoom.split(',');
          var zoomArg = zoomArgs[0];
          var zoomArgNumber = parseFloat(zoomArg);

          if (!zoomArg.includes('Fit')) {
            dest = [null, {
              name: 'XYZ'
            }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
          } else {
            if (zoomArg === 'Fit' || zoomArg === 'FitB') {
              dest = [null, {
                name: zoomArg
              }];
            } else if (zoomArg === 'FitH' || zoomArg === 'FitBH' || zoomArg === 'FitV' || zoomArg === 'FitBV') {
              dest = [null, {
                name: zoomArg
              }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
            } else if (zoomArg === 'FitR') {
              if (zoomArgs.length !== 5) {
                console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
              } else {
                dest = [null, {
                  name: zoomArg
                }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
              }
            } else {
              console.error("PDFLinkService.setHash: \"".concat(zoomArg, "\" is not ") + 'a valid zoom value.');
            }
          }
        }

        if (dest) {
          this.pdfViewer.scrollPageIntoView({
            pageNumber: pageNumber || this.page,
            destArray: dest,
            allowNegativeOffset: true
          });
        } else if (pageNumber) {
          this.page = pageNumber;
        }

        if ('pagemode' in params) {
          this.eventBus.dispatch('pagemode', {
            source: this,
            mode: params.pagemode
          });
        }
      } else {
        dest = unescape(hash);

        try {
          dest = JSON.parse(dest);

          if (!Array.isArray(dest)) {
            dest = dest.toString();
          }
        } catch (ex) {}

        if (typeof dest === 'string' || isValidExplicitDestination(dest)) {
          this.navigateTo(dest);
          return;
        }

        console.error("PDFLinkService.setHash: \"".concat(unescape(hash), "\" is not ") + 'a valid destination.');
      }
    }
  }, {
    key: "executeNamedAction",
    value: function executeNamedAction(action) {
      switch (action) {
        case 'GoBack':
          if (this.pdfHistory) {
            this.pdfHistory.back();
          }

          break;

        case 'GoForward':
          if (this.pdfHistory) {
            this.pdfHistory.forward();
          }

          break;

        case 'NextPage':
          if (this.page < this.pagesCount) {
            this.page++;
          }

          break;

        case 'PrevPage':
          if (this.page > 1) {
            this.page--;
          }

          break;

        case 'LastPage':
          this.page = this.pagesCount;
          break;

        case 'FirstPage':
          this.page = 1;
          break;

        default:
          break;
      }

      this.eventBus.dispatch('namedaction', {
        source: this,
        action: action
      });
    }
  }, {
    key: "cachePageRef",
    value: function cachePageRef(pageNum, pageRef) {
      if (!pageRef) {
        return;
      }

      var refStr = pageRef.num + ' ' + pageRef.gen + ' R';
      this._pagesRefCache[refStr] = pageNum;
    }
  }, {
    key: "_cachedPageNumber",
    value: function _cachedPageNumber(pageRef) {
      var refStr = pageRef.num + ' ' + pageRef.gen + ' R';
      return this._pagesRefCache && this._pagesRefCache[refStr] || null;
    }
  }, {
    key: "isPageVisible",
    value: function isPageVisible(pageNumber) {
      return this.pdfViewer.isPageVisible(pageNumber);
    }
  }, {
    key: "pagesCount",
    get: function get() {
      return this.pdfDocument ? this.pdfDocument.numPages : 0;
    }
  }, {
    key: "page",
    get: function get() {
      return this.pdfViewer.currentPageNumber;
    },
    set: function set(value) {
      this.pdfViewer.currentPageNumber = value;
    }
  }, {
    key: "rotation",
    get: function get() {
      return this.pdfViewer.pagesRotation;
    },
    set: function set(value) {
      this.pdfViewer.pagesRotation = value;
    }
  }]);

  return PDFLinkService;
}();

exports.PDFLinkService = PDFLinkService;

function isValidExplicitDestination(dest) {
  if (!Array.isArray(dest)) {
    return false;
  }

  var destLength = dest.length,
      allowNull = true;

  if (destLength < 2) {
    return false;
  }

  var page = dest[0];

  if (!(_typeof(page) === 'object' && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
    return false;
  }

  var zoom = dest[1];

  if (!(_typeof(zoom) === 'object' && typeof zoom.name === 'string')) {
    return false;
  }

  switch (zoom.name) {
    case 'XYZ':
      if (destLength !== 5) {
        return false;
      }

      break;

    case 'Fit':
    case 'FitB':
      return destLength === 2;

    case 'FitH':
    case 'FitBH':
    case 'FitV':
    case 'FitBV':
      if (destLength !== 3) {
        return false;
      }

      break;

    case 'FitR':
      if (destLength !== 6) {
        return false;
      }

      allowNull = false;
      break;

    default:
      return false;
  }

  for (var i = 2; i < destLength; i++) {
    var param = dest[i];

    if (!(typeof param === 'number' || allowNull && param === null)) {
      return false;
    }
  }

  return true;
}

var SimpleLinkService =
/*#__PURE__*/
function () {
  function SimpleLinkService() {
    _classCallCheck(this, SimpleLinkService);

    this.externalLinkTarget = null;
    this.externalLinkRel = null;
  }

  _createClass(SimpleLinkService, [{
    key: "navigateTo",
    value: function navigateTo(dest) {}
  }, {
    key: "getDestinationHash",
    value: function getDestinationHash(dest) {
      return '#';
    }
  }, {
    key: "getAnchorUrl",
    value: function getAnchorUrl(hash) {
      return '#';
    }
  }, {
    key: "setHash",
    value: function setHash(hash) {}
  }, {
    key: "executeNamedAction",
    value: function executeNamedAction(action) {}
  }, {
    key: "cachePageRef",
    value: function cachePageRef(pageNum, pageRef) {}
  }, {
    key: "isPageVisible",
    value: function isPageVisible(pageNumber) {
      return true;
    }
  }, {
    key: "pagesCount",
    get: function get() {
      return 0;
    }
  }, {
    key: "page",
    get: function get() {
      return 0;
    },
    set: function set(value) {}
  }, {
    key: "rotation",
    get: function get() {
      return 0;
    },
    set: function set(value) {}
  }]);

  return SimpleLinkService;
}();

exports.SimpleLinkService = SimpleLinkService;

/***/ }),

/***/ "gFhn":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _HorizontalAnchors = __webpack_require__("uLv/");

var _HorizontalAnchors2 = _interopRequireDefault(_HorizontalAnchors);

var _VerticalAnchors = __webpack_require__("t1Fj");

var _VerticalAnchors2 = _interopRequireDefault(_VerticalAnchors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _propTypes2.default.shape({
  x: _propTypes2.default.oneOf([_HorizontalAnchors2.default.LEFT, _HorizontalAnchors2.default.INNER_LEFT, _HorizontalAnchors2.default.CENTER, _HorizontalAnchors2.default.RIGHT, _HorizontalAnchors2.default.INNER_RIGHT]).isRequired,
  y: _propTypes2.default.oneOf([_VerticalAnchors2.default.TOP, _VerticalAnchors2.default.CENTER, _VerticalAnchors2.default.OVERLAP, _VerticalAnchors2.default.BOTTOM]).isRequired
});

/***/ }),

/***/ "gki9":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("OvAC");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;

/***/ }),

/***/ "gqOe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = handleKeyboardAccessibility;

var _keyCodes = __webpack_require__("CNE2");

var _closest = __webpack_require__("lRx6");

var _closest2 = _interopRequireDefault(_closest);

var _isFormPartRole = __webpack_require__("awmu");

var _isFormPartRole2 = _interopRequireDefault(_isFormPartRole);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A utility function for adding keyboard accessibility to elements that are not a natively
 * clickable (div, span, etc). When the space or enter key is pressed while focusing the
 * element, different flows will happen.
 *
 * - space - The click event will be triggered and the default page scrolling behavior of the
 *      spacebar will be prevented
 * - enter - If the element has a form role ('checkbox' or 'radio'), the click event will not
 *      be triggered. Instead, it will find out if the element is inside a form. If it is, it
 *      will emulate the default behavior of attempting to submit the form. If the element does
 *      not have a form role, the click event will be triggered.
 *
 * @param {Event} e - the keydown event
 * @param {function} onClick - the on click event to be triggered if space or enter was pressed
 * @param {boolean=true} listenToEnter - boolean if the enter key should be used to trigger the
 *      the click event. Even if this is true, the click event will not be triggered if the role
 *      is for a form role.
 * @param {boolean=true} listenToSpace - boolean if the space key should be used to trigger the
 *      click event.
 * @return {Boolean} true if the enter or space keys were pressed while their listener is also active.
 */
function handleKeyboardAccessibility(e, onClick) {
  var listenToEnter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var listenToSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var key = e.which || e.keyCode;
  var space = listenToSpace && key === _keyCodes.SPACE;
  var enter = key === _keyCodes.ENTER;

  var tagName = e.target.tagName;
  // it is valid to press space in text fields, contenteditable, and buttons

  if (space && !tagName.match(/input|textarea|button/i) && e.target.getAttribute('contenteditable') !== 'true') {
    // Stop page scrolling
    e.preventDefault();
  }

  if (enter && (0, _isFormPartRole2.default)(e.target)) {
    var form = (0, _closest2.default)(e.target, 'form');
    var submit = form ? form.querySelector('*[type="submit"]') : null;
    if (submit) {
      submit.click();
    }

    return true;
  }

  if (enter && listenToEnter || space) {
    onClick(e);

    return true;
  }

  return false;
} /** @module utils/EventUtils/handleKeyboardAccessibility */

/***/ }),

/***/ "h+vt":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "hfno":
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__("s3UK");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "hx1s":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("10o/");

exports.__esModule = true;
exports.default = exports.animationEnd = exports.animationDelay = exports.animationTiming = exports.animationDuration = exports.animationName = exports.transitionEnd = exports.transitionDuration = exports.transitionDelay = exports.transitionTiming = exports.transitionProperty = exports.transform = void 0;

var _inDOM = _interopRequireDefault(__webpack_require__("Dhpq"));

var transform = 'transform';
exports.transform = transform;
var prefix, transitionEnd, animationEnd;
exports.animationEnd = animationEnd;
exports.transitionEnd = transitionEnd;
var transitionProperty, transitionDuration, transitionTiming, transitionDelay;
exports.transitionDelay = transitionDelay;
exports.transitionTiming = transitionTiming;
exports.transitionDuration = transitionDuration;
exports.transitionProperty = transitionProperty;
var animationName, animationDuration, animationTiming, animationDelay;
exports.animationDelay = animationDelay;
exports.animationTiming = animationTiming;
exports.animationDuration = animationDuration;
exports.animationName = animationName;

if (_inDOM.default) {
  var _getTransitionPropert = getTransitionProperties();

  prefix = _getTransitionPropert.prefix;
  exports.transitionEnd = transitionEnd = _getTransitionPropert.transitionEnd;
  exports.animationEnd = animationEnd = _getTransitionPropert.animationEnd;
  exports.transform = transform = prefix + "-" + transform;
  exports.transitionProperty = transitionProperty = prefix + "-transition-property";
  exports.transitionDuration = transitionDuration = prefix + "-transition-duration";
  exports.transitionDelay = transitionDelay = prefix + "-transition-delay";
  exports.transitionTiming = transitionTiming = prefix + "-transition-timing-function";
  exports.animationName = animationName = prefix + "-animation-name";
  exports.animationDuration = animationDuration = prefix + "-animation-duration";
  exports.animationTiming = animationTiming = prefix + "-animation-delay";
  exports.animationDelay = animationDelay = prefix + "-animation-timing-function";
}

var _default = {
  transform: transform,
  end: transitionEnd,
  property: transitionProperty,
  timing: transitionTiming,
  delay: transitionDelay,
  duration: transitionDuration
};
exports.default = _default;

function getTransitionProperties() {
  var style = document.createElement('div').style;
  var vendorMap = {
    O: function O(e) {
      return "o" + e.toLowerCase();
    },
    Moz: function Moz(e) {
      return e.toLowerCase();
    },
    Webkit: function Webkit(e) {
      return "webkit" + e;
    },
    ms: function ms(e) {
      return "MS" + e;
    }
  };
  var vendors = Object.keys(vendorMap);
  var transitionEnd, animationEnd;
  var prefix = '';

  for (var i = 0; i < vendors.length; i++) {
    var vendor = vendors[i];

    if (vendor + "TransitionProperty" in style) {
      prefix = "-" + vendor.toLowerCase();
      transitionEnd = vendorMap[vendor]('TransitionEnd');
      animationEnd = vendorMap[vendor]('AnimationEnd');
      break;
    }
  }

  if (!transitionEnd && 'transitionProperty' in style) transitionEnd = 'transitionend';
  if (!animationEnd && 'animationName' in style) animationEnd = 'animationend';
  style = null;
  return {
    animationEnd: animationEnd,
    transitionEnd: transitionEnd,
    prefix: prefix
  };
}

/***/ }),

/***/ "iNmH":
/***/ (function(module, exports) {

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "iXzu":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ __webpack_exports__["default"] = (index);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("pCvA")))

/***/ }),

/***/ "ikrR":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "iouw":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getField;
/** @module utils/getField */

/**
 * Gets the current field for a component that can the field
 * as either uncontrolled or controlled.
 *
 * @param {Object} props - the props object.
 * @param {Object} state = the state object.
 * @param {string=} field - the field to extract a value from. Defaults to 'value'.
 *
 * @return the field's value.
 */
function getField(props, state) {
  var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'value';

  return typeof props[field] !== 'undefined' ? props[field] : state[field];
}

/***/ }),

/***/ "j5Ak":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.Subheader = undefined;

var _Subheader2 = __webpack_require__("oP2t");

var _Subheader3 = _interopRequireDefault(_Subheader2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Subheader3.default;
exports.Subheader = _Subheader3.default;

/***/ }),

/***/ "j6ZD":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("9aUh"),
    isSymbol = __webpack_require__("zXe4");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "jL08":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// turn {x: {val: 1, stiffness: 1, damping: 2}, y: 2} generated by
// `{x: spring(1, {stiffness: 1, damping: 2}), y: 2}` into {x: 1, y: 2}



exports.__esModule = true;
exports['default'] = stripStyle;

function stripStyle(style) {
  var ret = {};
  for (var key in style) {
    if (!Object.prototype.hasOwnProperty.call(style, key)) {
      continue;
    }
    ret[key] = typeof style[key] === 'number' ? style[key] : style[key].val;
  }
  return ret;
}

module.exports = exports['default'];

/***/ }),

/***/ "jgJv":
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__("s3UK");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "jjyK":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = between;

var _isBetween = __webpack_require__("P1qJ");

var _isBetween2 = _interopRequireDefault(_isBetween);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Validates that a number is between a min and max value.
 *
 * @param {function} validator - The number validator to use.
 * @param {number} min - The min number to use.
 * @param {number} max - The max number to use.
 * @return {Error} the prop type error or null
 */
function between(validator, min, max) {
  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      args[_key - 5] = arguments[_key];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    var value = props[propName];
    if (!err && typeof value !== 'undefined' && !(0, _isBetween2.default)(value, min, max)) {
      err = new Error('You provided a `' + propFullNameSafe + '` ' + location + ' to the ' + componentNameSafe + ' that was ' + ('not within the range from \'' + min + ' - ' + max + '\'. `' + propFullNameSafe + '`: ' + value + '.'));
    }

    return err;
  };
} /** @module utils/PropTypes/between */

/***/ }),

/***/ "juoQ":
/***/ (function(module, exports) {

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;

/***/ }),

/***/ "kFlJ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _chainFunction = __webpack_require__("xHj8");

var _chainFunction2 = _interopRequireDefault(_chainFunction);

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _warning = __webpack_require__("KNR4");

var _warning2 = _interopRequireDefault(_warning);

var _ChildMapping = __webpack_require__("6SGH");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
  component: _propTypes2.default.any,
  childFactory: _propTypes2.default.func,
  children: _propTypes2.default.node
};

var defaultProps = {
  component: 'span',
  childFactory: function childFactory(child) {
    return child;
  }
};

var TransitionGroup = function (_React$Component) {
  _inherits(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    _classCallCheck(this, TransitionGroup);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

    _this.performAppear = function (key, component) {
      _this.currentlyTransitioningKeys[key] = true;

      if (component.componentWillAppear) {
        component.componentWillAppear(_this._handleDoneAppearing.bind(_this, key, component));
      } else {
        _this._handleDoneAppearing(key, component);
      }
    };

    _this._handleDoneAppearing = function (key, component) {
      if (component.componentDidAppear) {
        component.componentDidAppear();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping = (0, _ChildMapping.getChildMapping)(_this.props.children);

      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        // This was removed before it had fully appeared. Remove it.
        _this.performLeave(key, component);
      }
    };

    _this.performEnter = function (key, component) {
      _this.currentlyTransitioningKeys[key] = true;

      if (component.componentWillEnter) {
        component.componentWillEnter(_this._handleDoneEntering.bind(_this, key, component));
      } else {
        _this._handleDoneEntering(key, component);
      }
    };

    _this._handleDoneEntering = function (key, component) {
      if (component.componentDidEnter) {
        component.componentDidEnter();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping = (0, _ChildMapping.getChildMapping)(_this.props.children);

      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        // This was removed before it had fully entered. Remove it.
        _this.performLeave(key, component);
      }
    };

    _this.performLeave = function (key, component) {
      _this.currentlyTransitioningKeys[key] = true;

      if (component.componentWillLeave) {
        component.componentWillLeave(_this._handleDoneLeaving.bind(_this, key, component));
      } else {
        // Note that this is somewhat dangerous b/c it calls setState()
        // again, effectively mutating the component before all the work
        // is done.
        _this._handleDoneLeaving(key, component);
      }
    };

    _this._handleDoneLeaving = function (key, component) {
      if (component.componentDidLeave) {
        component.componentDidLeave();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping = (0, _ChildMapping.getChildMapping)(_this.props.children);

      if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
        // This entered again before it fully left. Add it again.
        _this.keysToEnter.push(key);
      } else {
        _this.setState(function (state) {
          var newChildren = _extends({}, state.children);
          delete newChildren[key];
          return { children: newChildren };
        });
      }
    };

    _this.childRefs = Object.create(null);

    _this.state = {
      children: (0, _ChildMapping.getChildMapping)(props.children)
    };
    return _this;
  }

  TransitionGroup.prototype.componentWillMount = function componentWillMount() {
    this.currentlyTransitioningKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
  };

  TransitionGroup.prototype.componentDidMount = function componentDidMount() {
    var initialChildMapping = this.state.children;
    for (var key in initialChildMapping) {
      if (initialChildMapping[key]) {
        this.performAppear(key, this.childRefs[key]);
      }
    }
  };

  TransitionGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var nextChildMapping = (0, _ChildMapping.getChildMapping)(nextProps.children);
    var prevChildMapping = this.state.children;

    this.setState({
      children: (0, _ChildMapping.mergeChildMappings)(prevChildMapping, nextChildMapping)
    });

    for (var key in nextChildMapping) {
      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
        this.keysToEnter.push(key);
      }
    }

    for (var _key in prevChildMapping) {
      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(_key);
      if (prevChildMapping[_key] && !hasNext && !this.currentlyTransitioningKeys[_key]) {
        this.keysToLeave.push(_key);
      }
    }

    // If we want to someday check for reordering, we could do it here.
  };

  TransitionGroup.prototype.componentDidUpdate = function componentDidUpdate() {
    var _this2 = this;

    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(function (key) {
      return _this2.performEnter(key, _this2.childRefs[key]);
    });

    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(function (key) {
      return _this2.performLeave(key, _this2.childRefs[key]);
    });
  };

  TransitionGroup.prototype.render = function render() {
    var _this3 = this;

    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    var childrenToRender = [];

    var _loop = function _loop(key) {
      var child = _this3.state.children[key];
      if (child) {
        var isCallbackRef = typeof child.ref !== 'string';
        var factoryChild = _this3.props.childFactory(child);
        var ref = function ref(r) {
          _this3.childRefs[key] = r;
        };

         false ? undefined : void 0;

        // Always chaining the refs leads to problems when the childFactory
        // wraps the child. The child ref callback gets called twice with the
        // wrapper and the child. So we only need to chain the ref if the
        // factoryChild is not different from child.
        if (factoryChild === child && isCallbackRef) {
          ref = (0, _chainFunction2.default)(child.ref, ref);
        }

        // You may need to apply reactive updates to a child as it is leaving.
        // The normal React way to do it won't work since the child will have
        // already been removed. In case you need this behavior you can provide
        // a childFactory function to wrap every child, even the ones that are
        // leaving.
        childrenToRender.push(_react2.default.cloneElement(factoryChild, {
          key: key,
          ref: ref
        }));
      }
    };

    for (var key in this.state.children) {
      _loop(key);
    }

    // Do not forward TransitionGroup props to primitive DOM nodes
    var props = _extends({}, this.props);
    delete props.transitionLeave;
    delete props.transitionName;
    delete props.transitionAppear;
    delete props.transitionEnter;
    delete props.childFactory;
    delete props.transitionLeaveTimeout;
    delete props.transitionEnterTimeout;
    delete props.transitionAppearTimeout;
    delete props.component;

    return _react2.default.createElement(this.props.component, props, childrenToRender);
  };

  return TransitionGroup;
}(_react2.default.Component);

TransitionGroup.displayName = 'TransitionGroup';


TransitionGroup.propTypes =  false ? undefined : {};
TransitionGroup.defaultProps = defaultProps;

exports.default = TransitionGroup;
module.exports = exports['default'];

/***/ }),

/***/ "kgVC":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = __webpack_require__("mXGw");

var _default = (0, _react.createContext)(null);

exports.default = _default;

/***/ }),

/***/ "kkTS":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getSelectedText;
/** @module utils/getSelectedText */

/**
 * A utility function that gets the current selected text in the document. I think
 * that all the browsers I support have `window.getSelection`, but it falls back to
 * support others.
 *
 * @return {String} the current selection on the page
 */
function getSelectedText() {
  if (typeof window.getSelection !== 'undefined') {
    return window.getSelection().toString();
  } else if (typeof document.selection !== 'undefined' && document.selection.type === 'Text') {
    return document.selection.createRange().text;
  }

  return '';
}

/***/ }),

/***/ "kluZ":
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "knJb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports['default'] = reorderKeys;

var hasWarned = false;

function reorderKeys() {
  if (false) {}
}

module.exports = exports['default'];

/***/ }),

/***/ "lLgq":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getSelectedTextPosition;

var _getSelectedText = __webpack_require__("kkTS");

var _getSelectedText2 = _interopRequireDefault(_getSelectedText);

var _getTextWidth = __webpack_require__("Sj4t");

var _getTextWidth2 = _interopRequireDefault(_getTextWidth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @module utils/Positoning/getSelectedTextPosition */
var ZERO_WIDTH_CHARACTER = '\u200B';

/**
 * A utility function to attempt to get the current highlighted text position.
 *
 * When a context menu is opened, this function attempts to find the bounding client rect
 * for the highlighted text. However, if the text is in the text field, some weird stuff
 * happens and it is unable to get it correctly.
 */
function getSelectedTextPosition(e) {
  var height = void 0;
  var target = e.target,
      clientX = e.clientX,
      clientY = e.clientY;

  var text = (0, _getSelectedText2.default)();
  var width = Math.round((0, _getTextWidth2.default)(text, target) || 0);
  if (!text || target.classList.contains('md-text-field')) {
    height = parseInt(window.getComputedStyle(target).fontSize, 10);
    return {
      width: width,
      height: height,
      left: clientX - width,
      top: clientY
    };
  }

  // All browsers I am supporting have window.getSelection, but better safe than sorry
  if (window.getSelection) {
    var selection = window.getSelection();
    if (selection.rangeCount) {
      var range = selection.getRangeAt(0).cloneRange();
      var rect = null;
      if (range.getClientRects) {
        var rects = range.getClientRects();
        if (rects.length > 0) {
          rect = rects[0];
        }
      }

      if (!rect) {
        var span = document.createElement('span');
        span.appendChild(document.createTextNode(ZERO_WIDTH_CHARACTER));
        range.insertNode(span);
        rect = span.getBoundingClientRect();

        var spanParent = span.parentNode;
        spanParent.removeChild(span);
        spanParent.normalize();
      }

      return rect;
    }
  }

  return null;
}

/***/ }),

/***/ "lQ3I":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = getScroll;
/** @module utils/Positioning/getScroll */

/**
 * A utility function to just get an element's scroll x and y
 * values. This is really just needed because `window` uses
 * different attributes.
 *
 * @param {Object} el - The element to get a scroll value from.
 * @return {Object} an object containing the scrollX and scrollY of the element.
 */
function getScroll(el) {
  if (typeof el.scrollX !== 'undefined' && typeof el.scrollY !== 'undefined') {
    return { x: el.scrollX, y: el.scrollY };
  } else if (typeof el.scrollLeft !== 'undefined' && typeof el.scrollTop !== 'undefined') {
    return { x: el.scrollLeft, y: el.scrollTop };
  }

  return { x: 0, y: 0 };
}

/***/ }),

/***/ "lRx6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = closest;
/** @module utils/closest */

/**
 * A _very_ primitive polyfill for the Element.closest function. If this is a browser that doesn't
 * support it (IE, Edge, etc), it will just keep searching the parent elements until the nodeName
 * matches the provided type.
 *
 * @param {Element} el - the html element to find a closest node type for
 * @param {String} type - the html element type to find.
 * @return {Element} the found element or null.
 */
function closest(el, type) {
  if (typeof el.closest === 'function') {
    return el.closest(type);
  }

  var nodeType = type.toUpperCase();
  var node = el.parentElement;
  while (node && node.parentElement) {
    if (node.nodeName === nodeType) {
      return node;
    }

    node = node.parentElement;
  }

  return null;
}

/***/ }),

/***/ "lUDM":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The divider component will pass all other props such as style or
 * event listeners on to the component.
 */
var Divider = function (_PureComponent) {
  _inherits(Divider, _PureComponent);

  function Divider() {
    _classCallCheck(this, Divider);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Divider.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        inset = _props.inset,
        vertical = _props.vertical,
        props = _objectWithoutProperties(_props, ['className', 'inset', 'vertical']);

    var Component = vertical ? 'div' : 'hr';

    return _react2.default.createElement(Component, _extends({}, props, {
      className: (0, _classnames2.default)('md-divider', {
        'md-divider--vertical': vertical,
        'md-divider--inset': inset
      }, className)
    }));
  };

  return Divider;
}(_react.PureComponent);

Divider.propTypes = {
  /*
   * An optional style to apply to the divider.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply to the divider.
   */
  className: _propTypes2.default.string,

  /**
   * Boolean if this divider should be inset relative to it's container
   * component. This means that if it is in a `List` with `Avatar`, it
   * will start the divider  to the left of the main text in the list.
   */
  inset: _propTypes2.default.bool,

  /**
   * Boolean if the divider should be vertical instead of horizontal.
   */
  vertical: _propTypes2.default.bool
};
exports.default = Divider;

/***/ }),

/***/ "lZXN":
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__("+IV6");

var setPrototypeOf = __webpack_require__("WI9V");

var isNativeFunction = __webpack_require__("juoQ");

var construct = __webpack_require__("uUj8");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;

/***/ }),

/***/ "lcrv":
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "lphy":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("RoC8")(module), __webpack_require__("pCvA")))

/***/ }),

/***/ "m4Rk":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _reactLifecyclesCompat = __webpack_require__("NGR8");

var _ChildMapping = __webpack_require__("wc4P");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
  /**
   * The `<TransitionGroup>` component manages a set of transition components
   * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
   * components, `<TransitionGroup>` is a state machine for managing the mounting
   * and unmounting of components over time.
   *
   * Consider the example below. As items are removed or added to the TodoList the
   * `in` prop is toggled automatically by the `<TransitionGroup>`.
   *
   * Note that `<TransitionGroup>`  does not define any animation behavior!
   * Exactly _how_ a list item animates is up to the individual transition
   * component. This means you can mix and match animations across different list
   * items.
   */

};

var TransitionGroup =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this))); // Initial children should all be entering, dependent on appear


    _this.state = {
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      transitionGroup: {
        isMounting: !this.appeared
      }
    };
  };

  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
    this.mounted = true;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? (0, _ChildMapping.getInitialChildMapping)(nextProps, handleExited) : (0, _ChildMapping.getNextChildMapping)(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = (0, _ChildMapping.getChildMapping)(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return children;
    }

    return _react.default.createElement(Component, props, children);
  };

  return TransitionGroup;
}(_react.default.Component);

TransitionGroup.childContextTypes = {
  transitionGroup: _propTypes.default.object.isRequired
};
TransitionGroup.propTypes =  false ? undefined : {};
TransitionGroup.defaultProps = defaultProps;

var _default = (0, _reactLifecyclesCompat.polyfill)(TransitionGroup);

exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "mXGw":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__("BdB7");
} else {}


/***/ }),

/***/ "miBv":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = calcPageOffset;

var _getPagePosition = __webpack_require__("MDH+");

var _getPagePosition2 = _interopRequireDefault(_getPagePosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Calculates the page offset of an element. If the element
 * is false-ish, an empty object will be returned.
 *
 * This is really only used for calculating an ink position.
 *
 * @param {Node} el - An html node to find a page offset for.
 * @return {Object} an object with a left and top attribute for the page
 *    offset.
 */
function calcPageOffset(el) {
  if (!el) {
    return { left: null, right: null };
  }

  var rect = el.getBoundingClientRect();
  return {
    left: rect.left + (0, _getPagePosition2.default)('x'),
    top: rect.top + (0, _getPagePosition2.default)('y')
  };
} /** @module utils/Positioning/calcPageOffset */

/***/ }),

/***/ "n+IE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = calculateHypotenuse;
/** @module utils/NumberUtils/calculateHypotenuse */

/**
 * Calculates the hypotenuse using the x and y coordinates given.
 *
 * @param {number} a the x coordinate
 * @param {number} b the y coordinate
 * @return {number} the hypotenuse length for the given x and y coordinates.
 */
function calculateHypotenuse(a, b) {
  return Math.sqrt(a * a + b * b);
}

/***/ }),

/***/ "n4ZD":
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__("yvDY");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "nHLA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = isRequiredForA11y;
function isRequiredForA11y(validator) {
  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    if (props[propName] == null) {
      return new Error('The ' + location + ' `' + propFullNameSafe + '` is required to make ' + ('`' + componentNameSafe + '` accessible for users of assistive ') + 'technologies such as screen readers.');
    }

    for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      args[_key - 5] = arguments[_key];
    }

    return validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
  };
}

/***/ }),

/***/ "nZ0h":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergeClassNames;

function mergeClassNames() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args.reduce(function (classList, arg) {
    return typeof arg === 'string' || arg instanceof Array ? classList.concat(arg) : classList;
  }, []).filter(Boolean).join(' ');
}

/***/ }),

/***/ "ncg+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "pdfjs", {
  enumerable: true,
  get: function get() {
    return _pdfjsDist.default;
  }
});
Object.defineProperty(exports, "Document", {
  enumerable: true,
  get: function get() {
    return _Document.default;
  }
});
Object.defineProperty(exports, "Outline", {
  enumerable: true,
  get: function get() {
    return _Outline.default;
  }
});
Object.defineProperty(exports, "Page", {
  enumerable: true,
  get: function get() {
    return _Page.default;
  }
});

var _pdfjsDist = _interopRequireDefault(__webpack_require__("g93O"));

var _Document = _interopRequireDefault(__webpack_require__("vRn4"));

var _Outline = _interopRequireDefault(__webpack_require__("nirI"));

var _Page = _interopRequireDefault(__webpack_require__("O4SF"));

var _utils = __webpack_require__("YliN");

if (_utils.isLocalFileSystem) {
  (0, _utils.warnOnDev)('You are running React-PDF from your local file system. PDF.js Worker may fail to load due to browser\'s security policies. If you\'re on Google Chrome, you can use --allow-file-access-from-files flag for debugging purposes.');
}

_pdfjsDist.default.GlobalWorkerOptions.workerSrc = 'pdf.worker.js';

/***/ }),

/***/ "nirI":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__("vdEC");

var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OutlineInternal = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__("gki9"));

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _regenerator = _interopRequireDefault(__webpack_require__("NthX"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__("fFdx"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _makeEventProps = _interopRequireDefault(__webpack_require__("1QXF"));

var _mergeClassNames = _interopRequireDefault(__webpack_require__("nZ0h"));

var _DocumentContext = _interopRequireDefault(__webpack_require__("tvHm"));

var _OutlineContext = _interopRequireDefault(__webpack_require__("kgVC"));

var _OutlineItem = _interopRequireDefault(__webpack_require__("etjl"));

var _utils = __webpack_require__("YliN");

var _propTypes2 = __webpack_require__("T5tG");

var OutlineInternal =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(OutlineInternal, _PureComponent);

  function OutlineInternal() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, OutlineInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(OutlineInternal)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "state", {
      outline: null
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "loadOutline",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      var pdf, cancellable, outline;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              pdf = _this.props.pdf;

              _this.setState(function (prevState) {
                if (!prevState.outline) {
                  return null;
                }

                return {
                  outline: null
                };
              });

              _context.prev = 2;
              cancellable = (0, _utils.makeCancellable)(pdf.getOutline());
              _this.runningTask = cancellable;
              _context.next = 7;
              return cancellable.promise;

            case 7:
              outline = _context.sent;

              _this.setState({
                outline: outline
              }, _this.onLoadSuccess);

              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](2);

              _this.onLoadError(_context.t0);

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[2, 11]]);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadSuccess", function () {
      var onLoadSuccess = _this.props.onLoadSuccess;
      var outline = _this.state.outline;
      (0, _utils.callIfDefined)(onLoadSuccess, outline);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadError", function (error) {
      if ((0, _utils.isCancelException)(error)) {
        return;
      }

      _this.setState({
        outline: false
      });

      (0, _utils.errorOnDev)(error);
      var onLoadError = _this.props.onLoadError;
      (0, _utils.callIfDefined)(onLoadError, error);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onItemClick", function (_ref2) {
      var pageIndex = _ref2.pageIndex,
          pageNumber = _ref2.pageNumber;
      var onItemClick = _this.props.onItemClick;
      (0, _utils.callIfDefined)(onItemClick, {
        pageIndex: pageIndex,
        pageNumber: pageNumber
      });
    });
    return _this;
  }

  (0, _createClass2.default)(OutlineInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var pdf = this.props.pdf;

      if (!pdf) {
        throw new Error('Attempted to load an outline, but no document was specified.');
      }

      this.loadOutline();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var pdf = this.props.pdf;

      if (prevProps.pdf && pdf !== prevProps.pdf) {
        this.loadOutline();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      (0, _utils.cancelRunningTask)(this.runningTask);
    }
  }, {
    key: "renderOutline",
    value: function renderOutline() {
      var outline = this.state.outline;
      return _react.default.createElement("ul", null, outline.map(function (item, itemIndex) {
        return _react.default.createElement(_OutlineItem.default, {
          key: typeof item.destination === 'string' ? item.destination : itemIndex,
          item: item
        });
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var pdf = this.props.pdf;
      var outline = this.state.outline;

      if (!pdf || !outline) {
        return null;
      }

      var _this$props = this.props,
          className = _this$props.className,
          inputRef = _this$props.inputRef;
      return _react.default.createElement("div", (0, _extends2.default)({
        className: (0, _mergeClassNames.default)('react-pdf__Outline', className),
        ref: inputRef
      }, this.eventProps), _react.default.createElement(_OutlineContext.default.Provider, {
        value: this.childContext
      }, this.renderOutline()));
    }
  }, {
    key: "childContext",
    get: function get() {
      return {
        onClick: this.onItemClick
      };
    }
  }, {
    key: "eventProps",
    get: function get() {
      var _this2 = this;

      // eslint-disable-next-line react/destructuring-assignment
      return (0, _makeEventProps.default)(this.props, function () {
        return _this2.state.outline;
      });
    }
    /**
     * Called when an outline is read successfully
     */

  }]);
  return OutlineInternal;
}(_react.PureComponent);

exports.OutlineInternal = OutlineInternal;
OutlineInternal.propTypes = (0, _objectSpread2.default)({
  className: _propTypes2.isClassName,
  inputRef: _propTypes.default.func,
  onItemClick: _propTypes.default.func,
  onLoadError: _propTypes.default.func,
  onLoadSuccess: _propTypes.default.func,
  pdf: _propTypes2.isPdf
}, (0, _propTypes2.eventsProps)());

function Outline(props, ref) {
  return _react.default.createElement(_DocumentContext.default.Consumer, null, function (context) {
    return _react.default.createElement(OutlineInternal, (0, _extends2.default)({
      ref: ref
    }, context, props));
  });
}

var _default = _react.default.forwardRef(Outline);

exports.default = _default;

/***/ }),

/***/ "noPx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp('(^|\\s)' + classToRemove + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}

module.exports = function removeClass(element, className) {
  if (element.classList) element.classList.remove(className);else if (typeof element.className === 'string') element.className = replaceClassName(element.className, className);else element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
};

/***/ }),

/***/ "nrGg":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2018 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isValidRotation = isValidRotation;
exports.isValidScrollMode = isValidScrollMode;
exports.isValidSpreadMode = isValidSpreadMode;
exports.isPortraitOrientation = isPortraitOrientation;
exports.getGlobalEventBus = getGlobalEventBus;
exports.getPDFFileNameFromURL = getPDFFileNameFromURL;
exports.noContextMenuHandler = noContextMenuHandler;
exports.parseQueryString = parseQueryString;
exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
exports.getVisibleElements = getVisibleElements;
exports.roundToDivide = roundToDivide;
exports.getPageSizeInches = getPageSizeInches;
exports.approximateFraction = approximateFraction;
exports.getOutputScale = getOutputScale;
exports.scrollIntoView = scrollIntoView;
exports.watchScroll = watchScroll;
exports.binarySearchFirstItem = binarySearchFirstItem;
exports.normalizeWheelEventDelta = normalizeWheelEventDelta;
exports.waitOnEventOrTimeout = waitOnEventOrTimeout;
exports.moveToEndOfArray = moveToEndOfArray;
exports.WaitOnType = exports.animationStarted = exports.ProgressBar = exports.EventBus = exports.NullL10n = exports.SpreadMode = exports.ScrollMode = exports.TextLayerMode = exports.RendererType = exports.PresentationModeState = exports.VERTICAL_PADDING = exports.SCROLLBAR_PADDING = exports.MAX_AUTO_SCALE = exports.UNKNOWN_SCALE = exports.MAX_SCALE = exports.MIN_SCALE = exports.DEFAULT_SCALE = exports.DEFAULT_SCALE_VALUE = exports.CSS_UNITS = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__("NthX"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var CSS_UNITS = 96.0 / 72.0;
exports.CSS_UNITS = CSS_UNITS;
var DEFAULT_SCALE_VALUE = 'auto';
exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
var DEFAULT_SCALE = 1.0;
exports.DEFAULT_SCALE = DEFAULT_SCALE;
var MIN_SCALE = 0.10;
exports.MIN_SCALE = MIN_SCALE;
var MAX_SCALE = 10.0;
exports.MAX_SCALE = MAX_SCALE;
var UNKNOWN_SCALE = 0;
exports.UNKNOWN_SCALE = UNKNOWN_SCALE;
var MAX_AUTO_SCALE = 1.25;
exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
var SCROLLBAR_PADDING = 40;
exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
var VERTICAL_PADDING = 5;
exports.VERTICAL_PADDING = VERTICAL_PADDING;
var PresentationModeState = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
};
exports.PresentationModeState = PresentationModeState;
var RendererType = {
  CANVAS: 'canvas',
  SVG: 'svg'
};
exports.RendererType = RendererType;
var TextLayerMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_ENHANCE: 2
};
exports.TextLayerMode = TextLayerMode;
var ScrollMode = {
  UNKNOWN: -1,
  VERTICAL: 0,
  HORIZONTAL: 1,
  WRAPPED: 2
};
exports.ScrollMode = ScrollMode;
var SpreadMode = {
  UNKNOWN: -1,
  NONE: 0,
  ODD: 1,
  EVEN: 2
};
exports.SpreadMode = SpreadMode;

function formatL10nValue(text, args) {
  if (!args) {
    return text;
  }

  return text.replace(/\{\{\s*(\w+)\s*\}\}/g, function (all, name) {
    return name in args ? args[name] : '{{' + name + '}}';
  });
}

var NullL10n = {
  getLanguage: function () {
    var _getLanguage = _asyncToGenerator(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", 'en-us');

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getLanguage() {
      return _getLanguage.apply(this, arguments);
    }

    return getLanguage;
  }(),
  getDirection: function () {
    var _getDirection = _asyncToGenerator(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee2() {
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", 'ltr');

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getDirection() {
      return _getDirection.apply(this, arguments);
    }

    return getDirection;
  }(),
  get: function () {
    var _get = _asyncToGenerator(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee3(property, args, fallback) {
      return _regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", formatL10nValue(fallback, args));

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function get(_x, _x2, _x3) {
      return _get.apply(this, arguments);
    }

    return get;
  }(),
  translate: function () {
    var _translate = _asyncToGenerator(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee4(element) {
      return _regenerator.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function translate(_x4) {
      return _translate.apply(this, arguments);
    }

    return translate;
  }()
};
exports.NullL10n = NullL10n;

function getOutputScale(ctx) {
  var devicePixelRatio = window.devicePixelRatio || 1;
  var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
  var pixelRatio = devicePixelRatio / backingStoreRatio;
  return {
    sx: pixelRatio,
    sy: pixelRatio,
    scaled: pixelRatio !== 1
  };
}

function scrollIntoView(element, spot) {
  var skipOverflowHiddenElements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var parent = element.offsetParent;

  if (!parent) {
    console.error('offsetParent is not set -- cannot scroll');
    return;
  }

  var offsetY = element.offsetTop + element.clientTop;
  var offsetX = element.offsetLeft + element.clientLeft;

  while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === 'hidden') {
    if (parent.dataset._scaleY) {
      offsetY /= parent.dataset._scaleY;
      offsetX /= parent.dataset._scaleX;
    }

    offsetY += parent.offsetTop;
    offsetX += parent.offsetLeft;
    parent = parent.offsetParent;

    if (!parent) {
      return;
    }
  }

  if (spot) {
    if (spot.top !== undefined) {
      offsetY += spot.top;
    }

    if (spot.left !== undefined) {
      offsetX += spot.left;
      parent.scrollLeft = offsetX;
    }
  }

  parent.scrollTop = offsetY;
}

function watchScroll(viewAreaElement, callback) {
  var debounceScroll = function debounceScroll(evt) {
    if (rAF) {
      return;
    }

    rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
      rAF = null;
      var currentX = viewAreaElement.scrollLeft;
      var lastX = state.lastX;

      if (currentX !== lastX) {
        state.right = currentX > lastX;
      }

      state.lastX = currentX;
      var currentY = viewAreaElement.scrollTop;
      var lastY = state.lastY;

      if (currentY !== lastY) {
        state.down = currentY > lastY;
      }

      state.lastY = currentY;
      callback(state);
    });
  };

  var state = {
    right: true,
    down: true,
    lastX: viewAreaElement.scrollLeft,
    lastY: viewAreaElement.scrollTop,
    _eventHandler: debounceScroll
  };
  var rAF = null;
  viewAreaElement.addEventListener('scroll', debounceScroll, true);
  return state;
}

function parseQueryString(query) {
  var parts = query.split('&');
  var params = Object.create(null);

  for (var i = 0, ii = parts.length; i < ii; ++i) {
    var param = parts[i].split('=');
    var key = param[0].toLowerCase();
    var value = param.length > 1 ? param[1] : null;
    params[decodeURIComponent(key)] = decodeURIComponent(value);
  }

  return params;
}

function binarySearchFirstItem(items, condition) {
  var minIndex = 0;
  var maxIndex = items.length - 1;

  if (items.length === 0 || !condition(items[maxIndex])) {
    return items.length;
  }

  if (condition(items[minIndex])) {
    return minIndex;
  }

  while (minIndex < maxIndex) {
    var currentIndex = minIndex + maxIndex >> 1;
    var currentItem = items[currentIndex];

    if (condition(currentItem)) {
      maxIndex = currentIndex;
    } else {
      minIndex = currentIndex + 1;
    }
  }

  return minIndex;
}

function approximateFraction(x) {
  if (Math.floor(x) === x) {
    return [x, 1];
  }

  var xinv = 1 / x;
  var limit = 8;

  if (xinv > limit) {
    return [1, limit];
  } else if (Math.floor(xinv) === xinv) {
    return [1, xinv];
  }

  var x_ = x > 1 ? xinv : x;
  var a = 0,
      b = 1,
      c = 1,
      d = 1;

  while (true) {
    var p = a + c,
        q = b + d;

    if (q > limit) {
      break;
    }

    if (x_ <= p / q) {
      c = p;
      d = q;
    } else {
      a = p;
      b = q;
    }
  }

  var result;

  if (x_ - a / b < c / d - x_) {
    result = x_ === x ? [a, b] : [b, a];
  } else {
    result = x_ === x ? [c, d] : [d, c];
  }

  return result;
}

function roundToDivide(x, div) {
  var r = x % div;
  return r === 0 ? x : Math.round(x - r + div);
}

function getPageSizeInches(_ref) {
  var view = _ref.view,
      userUnit = _ref.userUnit,
      rotate = _ref.rotate;

  var _view = _slicedToArray(view, 4),
      x1 = _view[0],
      y1 = _view[1],
      x2 = _view[2],
      y2 = _view[3];

  var changeOrientation = rotate % 180 !== 0;
  var width = (x2 - x1) / 72 * userUnit;
  var height = (y2 - y1) / 72 * userUnit;
  return {
    width: changeOrientation ? height : width,
    height: changeOrientation ? width : height
  };
}

function backtrackBeforeAllVisibleElements(index, views, top) {
  if (index < 2) {
    return index;
  }

  var elt = views[index].div;
  var pageTop = elt.offsetTop + elt.clientTop;

  if (pageTop >= top) {
    elt = views[index - 1].div;
    pageTop = elt.offsetTop + elt.clientTop;
  }

  for (var i = index - 2; i >= 0; --i) {
    elt = views[i].div;

    if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
      break;
    }

    index = i;
  }

  return index;
}

function getVisibleElements(scrollEl, views) {
  var sortByVisibility = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var horizontal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var top = scrollEl.scrollTop,
      bottom = top + scrollEl.clientHeight;
  var left = scrollEl.scrollLeft,
      right = left + scrollEl.clientWidth;

  function isElementBottomAfterViewTop(view) {
    var element = view.div;
    var elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
    return elementBottom > top;
  }

  function isElementRightAfterViewLeft(view) {
    var element = view.div;
    var elementRight = element.offsetLeft + element.clientLeft + element.clientWidth;
    return elementRight > left;
  }

  var visible = [],
      numViews = views.length;
  var firstVisibleElementInd = numViews === 0 ? 0 : binarySearchFirstItem(views, horizontal ? isElementRightAfterViewLeft : isElementBottomAfterViewTop);

  if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
    firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
  }

  var lastEdge = horizontal ? right : -1;

  for (var i = firstVisibleElementInd; i < numViews; i++) {
    var view = views[i],
        element = view.div;
    var currentWidth = element.offsetLeft + element.clientLeft;
    var currentHeight = element.offsetTop + element.clientTop;
    var viewWidth = element.clientWidth,
        viewHeight = element.clientHeight;
    var viewRight = currentWidth + viewWidth;
    var viewBottom = currentHeight + viewHeight;

    if (lastEdge === -1) {
      if (viewBottom >= bottom) {
        lastEdge = viewBottom;
      }
    } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
      break;
    }

    if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
      continue;
    }

    var hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
    var hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
    var percent = (viewHeight - hiddenHeight) * (viewWidth - hiddenWidth) * 100 / viewHeight / viewWidth | 0;
    visible.push({
      id: view.id,
      x: currentWidth,
      y: currentHeight,
      view: view,
      percent: percent
    });
  }

  var first = visible[0],
      last = visible[visible.length - 1];

  if (sortByVisibility) {
    visible.sort(function (a, b) {
      var pc = a.percent - b.percent;

      if (Math.abs(pc) > 0.001) {
        return -pc;
      }

      return a.id - b.id;
    });
  }

  return {
    first: first,
    last: last,
    views: visible
  };
}

function noContextMenuHandler(evt) {
  evt.preventDefault();
}

function isDataSchema(url) {
  var i = 0,
      ii = url.length;

  while (i < ii && url[i].trim() === '') {
    i++;
  }

  return url.substring(i, i + 5).toLowerCase() === 'data:';
}

function getPDFFileNameFromURL(url) {
  var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'document.pdf';

  if (typeof url !== 'string') {
    return defaultFilename;
  }

  if (isDataSchema(url)) {
    console.warn('getPDFFileNameFromURL: ' + 'ignoring "data:" URL for performance reasons.');
    return defaultFilename;
  }

  var reURI = /^(?:(?:[^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  var reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  var splitURI = reURI.exec(url);
  var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];

    if (suggestedFilename.includes('%')) {
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch (ex) {}
    }
  }

  return suggestedFilename || defaultFilename;
}

function normalizeWheelEventDelta(evt) {
  var delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);
  var angle = Math.atan2(evt.deltaY, evt.deltaX);

  if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
    delta = -delta;
  }

  var MOUSE_DOM_DELTA_PIXEL_MODE = 0;
  var MOUSE_DOM_DELTA_LINE_MODE = 1;
  var MOUSE_PIXELS_PER_LINE = 30;
  var MOUSE_LINES_PER_PAGE = 30;

  if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
    delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
  } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
    delta /= MOUSE_LINES_PER_PAGE;
  }

  return delta;
}

function isValidRotation(angle) {
  return Number.isInteger(angle) && angle % 90 === 0;
}

function isValidScrollMode(mode) {
  return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
}

function isValidSpreadMode(mode) {
  return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
}

function isPortraitOrientation(size) {
  return size.width <= size.height;
}

var WaitOnType = {
  EVENT: 'event',
  TIMEOUT: 'timeout'
};
exports.WaitOnType = WaitOnType;

function waitOnEventOrTimeout(_ref2) {
  var target = _ref2.target,
      name = _ref2.name,
      _ref2$delay = _ref2.delay,
      delay = _ref2$delay === void 0 ? 0 : _ref2$delay;
  return new Promise(function (resolve, reject) {
    if (_typeof(target) !== 'object' || !(name && typeof name === 'string') || !(Number.isInteger(delay) && delay >= 0)) {
      throw new Error('waitOnEventOrTimeout - invalid parameters.');
    }

    function handler(type) {
      if (target instanceof EventBus) {
        target.off(name, eventHandler);
      } else {
        target.removeEventListener(name, eventHandler);
      }

      if (timeout) {
        clearTimeout(timeout);
      }

      resolve(type);
    }

    var eventHandler = handler.bind(null, WaitOnType.EVENT);

    if (target instanceof EventBus) {
      target.on(name, eventHandler);
    } else {
      target.addEventListener(name, eventHandler);
    }

    var timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
    var timeout = setTimeout(timeoutHandler, delay);
  });
}

var animationStarted = new Promise(function (resolve) {
  if (typeof window === 'undefined') {
    setTimeout(resolve, 20);
    return;
  }

  window.requestAnimationFrame(resolve);
});
exports.animationStarted = animationStarted;

var EventBus =
/*#__PURE__*/
function () {
  function EventBus() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$dispatchToDOM = _ref3.dispatchToDOM,
        dispatchToDOM = _ref3$dispatchToDOM === void 0 ? false : _ref3$dispatchToDOM;

    _classCallCheck(this, EventBus);

    this._listeners = Object.create(null);
    this._dispatchToDOM = dispatchToDOM === true;
  }

  _createClass(EventBus, [{
    key: "on",
    value: function on(eventName, listener) {
      var eventListeners = this._listeners[eventName];

      if (!eventListeners) {
        eventListeners = [];
        this._listeners[eventName] = eventListeners;
      }

      eventListeners.push(listener);
    }
  }, {
    key: "off",
    value: function off(eventName, listener) {
      var eventListeners = this._listeners[eventName];
      var i;

      if (!eventListeners || (i = eventListeners.indexOf(listener)) < 0) {
        return;
      }

      eventListeners.splice(i, 1);
    }
  }, {
    key: "dispatch",
    value: function dispatch(eventName) {
      var eventListeners = this._listeners[eventName];

      if (!eventListeners || eventListeners.length === 0) {
        if (this._dispatchToDOM) {
          var _args5 = Array.prototype.slice.call(arguments, 1);

          this._dispatchDOMEvent(eventName, _args5);
        }

        return;
      }

      var args = Array.prototype.slice.call(arguments, 1);
      eventListeners.slice(0).forEach(function (listener) {
        listener.apply(null, args);
      });

      if (this._dispatchToDOM) {
        this._dispatchDOMEvent(eventName, args);
      }
    }
  }, {
    key: "_dispatchDOMEvent",
    value: function _dispatchDOMEvent(eventName) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var details = Object.create(null);

      if (args && args.length > 0) {
        var obj = args[0];

        for (var key in obj) {
          var value = obj[key];

          if (key === 'source') {
            if (value === window || value === document) {
              return;
            }

            continue;
          }

          details[key] = value;
        }
      }

      var event = document.createEvent('CustomEvent');
      event.initCustomEvent(eventName, true, true, details);
      document.dispatchEvent(event);
    }
  }]);

  return EventBus;
}();

exports.EventBus = EventBus;
var globalEventBus = null;

function getGlobalEventBus() {
  var dispatchToDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  if (!globalEventBus) {
    globalEventBus = new EventBus({
      dispatchToDOM: dispatchToDOM
    });
  }

  return globalEventBus;
}

function clamp(v, min, max) {
  return Math.min(Math.max(v, min), max);
}

var ProgressBar =
/*#__PURE__*/
function () {
  function ProgressBar(id) {
    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        height = _ref4.height,
        width = _ref4.width,
        units = _ref4.units;

    _classCallCheck(this, ProgressBar);

    this.visible = true;
    this.div = document.querySelector(id + ' .progress');
    this.bar = this.div.parentNode;
    this.height = height || 100;
    this.width = width || 100;
    this.units = units || '%';
    this.div.style.height = this.height + this.units;
    this.percent = 0;
  }

  _createClass(ProgressBar, [{
    key: "_updateBar",
    value: function _updateBar() {
      if (this._indeterminate) {
        this.div.classList.add('indeterminate');
        this.div.style.width = this.width + this.units;
        return;
      }

      this.div.classList.remove('indeterminate');
      var progressSize = this.width * this._percent / 100;
      this.div.style.width = progressSize + this.units;
    }
  }, {
    key: "setWidth",
    value: function setWidth(viewer) {
      if (!viewer) {
        return;
      }

      var container = viewer.parentNode;
      var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;

      if (scrollbarWidth > 0) {
        this.bar.setAttribute('style', 'width: calc(100% - ' + scrollbarWidth + 'px);');
      }
    }
  }, {
    key: "hide",
    value: function hide() {
      if (!this.visible) {
        return;
      }

      this.visible = false;
      this.bar.classList.add('hidden');
      document.body.classList.remove('loadingInProgress');
    }
  }, {
    key: "show",
    value: function show() {
      if (this.visible) {
        return;
      }

      this.visible = true;
      document.body.classList.add('loadingInProgress');
      this.bar.classList.remove('hidden');
    }
  }, {
    key: "percent",
    get: function get() {
      return this._percent;
    },
    set: function set(val) {
      this._indeterminate = isNaN(val);
      this._percent = clamp(val, 0, 100);

      this._updateBar();
    }
  }]);

  return ProgressBar;
}();

exports.ProgressBar = ProgressBar;

function moveToEndOfArray(arr, condition) {
  var moved = [],
      len = arr.length;
  var write = 0;

  for (var read = 0; read < len; ++read) {
    if (condition(arr[read])) {
      moved.push(arr[read]);
    } else {
      arr[write] = arr[read];
      ++write;
    }
  }

  for (var _read = 0; write < len; ++_read, ++write) {
    arr[write] = moved[_read];
  }
}

/***/ }),

/***/ "nuxT":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.setTouchEvent = setTouchEvent;
exports.addTouchEvent = addTouchEvent;
exports.removeTouchEvent = removeTouchEvent;
// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
var supportsPassive = void 0;
try {
  var opts = Object.defineProperty({}, 'passive', {
    get: function get() {
      supportsPassive = true;
    }
  });
  window.addEventListener('test', null, opts);
} catch (e) {
  supportsPassive = false;
}

/**
 * A helper function for manually setting touch events on elements with the passive
 * option (when it is supported).
 *
 * @param {boolean} add - Boolean if the event listener should be added or removed.
 * @param {HTMLElement} el - The element to add the listener to.
 * @param {String} type - the event type to set. This should be 'start', 'move', or 'end'
 * @param {function} callback - The event listener callback function.
 * @param {Object=} options - any additional options to apply.
 */
function setTouchEvent(add, el, eventType, callback, options) {
  return el[(add ? 'add' : 'remove') + 'EventListener']('touch' + eventType, callback, supportsPassive ? _extends({ passive: true }, options) : false);
}

/**
 * A helper function for manually adding touch events on elements with the passive
 * option (when it is supported).
 *
 * @param {HTMLElement} el - The element to add the listener to.
 * @param {String} type - the event type to set. This should be 'start', 'move', or 'end'
 * @param {function} callback - The event listener callback function.
 * @param {Object=} options - any additional options to apply.
 */
function addTouchEvent(el, type, callback, options) {
  return setTouchEvent(true, el, type, callback, options);
}

/**
 * A helper function for manually removing touch events on elements with the passive
 * option (when it is supported).
 *
 * @param {HTMLElement} el - The element to add the listener to.
 * @param {String} type - the event type to set. This should be 'start', 'move', or 'end'
 * @param {function} callback - The event listener callback function.
 * @param {Object=} options - any additional options to apply.
 */
function removeTouchEvent(el, type, callback, options) {
  return setTouchEvent(false, el, type, callback, options);
}

/***/ }),

/***/ "nxTg":
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__("+3YS");

var iterableToArrayLimit = __webpack_require__("S411");

var nonIterableRest = __webpack_require__("+bRE");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "o9tr":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _pdf_link_service = __webpack_require__("gCDi");

var _default = _pdf_link_service.PDFLinkService;
exports.default = _default;

/***/ }),

/***/ "oIW1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("Qt3m");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _warning = _interopRequireDefault(__webpack_require__("FIWN"));

var checkIndexBounds = function checkIndexBounds(props) {
  var index = props.index,
      children = props.children;

  var childrenCount = _react.default.Children.count(children);

   false ? undefined : void 0;
};

var _default = checkIndexBounds;
exports.default = _default;

/***/ }),

/***/ "oP2t":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _themeColors = __webpack_require__("VZNk");

var _themeColors2 = _interopRequireDefault(_themeColors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `Subheader` component is generally used inside of lists or menus.
 */
var Subheader = function (_PureComponent) {
  _inherits(Subheader, _PureComponent);

  function Subheader() {
    _classCallCheck(this, Subheader);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  Subheader.prototype.render = function render() {
    var _props = this.props,
        Component = _props.component,
        inset = _props.inset,
        primary = _props.primary,
        primaryText = _props.primaryText,
        className = _props.className,
        children = _props.children,
        props = _objectWithoutProperties(_props, ['component', 'inset', 'primary', 'primaryText', 'className', 'children']);

    return _react2.default.createElement(
      Component,
      _extends({}, props, {
        className: (0, _classnames2.default)('md-subheader', {
          'md-list-item--inset': inset
        }, (0, _themeColors2.default)({ primary: primary, hint: !primary }), className)
      }),
      primaryText,
      children
    );
  };

  return Subheader;
}(_react.PureComponent);

Subheader.propTypes = {
  /**
   * An optional style to apply to the subheader.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply to the subheader.
   */
  className: _propTypes2.default.string,

  /**
   * Boolean if the subheader should be styled with the primary color.
   */
  primary: _propTypes2.default.bool,

  /**
   * Boolean if the subheader is inset in the list. This will add additional
   * spacing to align the subheader.
   */
  inset: _propTypes2.default.bool,

  /**
   * The primary text to use in the subheader.
   */
  primaryText: _propTypes2.default.node.isRequired,

  /**
   * Any optional children to display after the `primaryText`. This prop is
   * not recommended.
   */
  children: _propTypes2.default.node,

  /**
   * The component to render the Subheader as.
   */
  component: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]).isRequired
};
Subheader.defaultProps = {
  component: 'li'
};
exports.default = Subheader;

/***/ }),

/***/ "oeXn":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__("xARA");

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _keyCodes = __webpack_require__("CNE2");

var _handleKeyboardAccessibility = __webpack_require__("gqOe");

var _handleKeyboardAccessibility2 = _interopRequireDefault(_handleKeyboardAccessibility);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `AccessibleFakeButton` is a generic component that can be used to render
 * a `div` or any other non `button` components as a button. This should not be
 * used often.
 *
 * The `AccessibleFakeButton` allows the user to tab focus the element, use the
 * space or enter key to trigger the `onClick` event, and toggles the `aria-pressed`
 * attribute.
 */
var AccessibleFakeButton = function (_PureComponent) {
  _inherits(AccessibleFakeButton, _PureComponent);

  function AccessibleFakeButton() {
    var _temp, _this, _ret;

    _classCallCheck(this, AccessibleFakeButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { pressed: false, tabFocused: false }, _this.focus = function () {
      if (_this._node) {
        _this._node.focus();
      }
    }, _this.blur = function () {
      if (_this._node) {
        _this._node.blur();
      }
    }, _this._setNode = function (node) {
      if (node) {
        _this._node = (0, _reactDom.findDOMNode)(node);
      }
    }, _this._handleClick = function (e) {
      if (_this.props.disabled) {
        return;
      }

      if (_this.props.onClick) {
        _this.props.onClick(e);
      }

      _this._node.focus();
      _this.setState({ pressed: !_this.state.pressed });
    }, _this._handleKeyDown = function (e) {
      var _this$props = _this.props,
          disabled = _this$props.disabled,
          onKeyDown = _this$props.onKeyDown,
          listenToEnter = _this$props.listenToEnter,
          listenToSpace = _this$props.listenToSpace;

      if (disabled) {
        return;
      }

      if (onKeyDown) {
        onKeyDown(e);
      }

      (0, _handleKeyboardAccessibility2.default)(e, _this._handleClick, listenToEnter, listenToSpace);
    }, _this._handleKeyUp = function (e) {
      var _this$props2 = _this.props,
          onKeyUp = _this$props2.onKeyUp,
          onTabFocus = _this$props2.onTabFocus;

      if (onKeyUp) {
        onKeyUp(e);
      }

      if ((e.which || e.keyCode) === _keyCodes.TAB) {
        if (onTabFocus) {
          onTabFocus(e);
        }

        _this.setState({ tabFocused: true });
      }
    }, _this._handleBlur = function (e) {
      if (_this.props.onBlur) {
        _this.props.onBlur(e);
      }

      if (_this.state.tabFocused) {
        _this.setState({ tabFocused: false });
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  /**
   * Focuses the button.
   */


  /**
   * Blurs the button.
   */


  AccessibleFakeButton.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        Component = _props.component,
        children = _props.children,
        className = _props.className,
        tabbedClassName = _props.tabbedClassName,
        disabled = _props.disabled,
        tabIndex = _props.tabIndex,
        ink = _props.ink,
        noFocusOutline = _props.noFocusOutline,
        onBlur = _props.onBlur,
        onClick = _props.onClick,
        onKeyUp = _props.onKeyUp,
        onKeyDown = _props.onKeyDown,
        onTabFocus = _props.onTabFocus,
        listenToEnter = _props.listenToEnter,
        listenToSpace = _props.listenToSpace,
        props = _objectWithoutProperties(_props, ['component', 'children', 'className', 'tabbedClassName', 'disabled', 'tabIndex', 'ink', 'noFocusOutline', 'onBlur', 'onClick', 'onKeyUp', 'onKeyDown', 'onTabFocus', 'listenToEnter', 'listenToSpace']);

    var childElements = children;
    if (ink) {
      childElements = _react.Children.toArray(children);
      childElements.unshift(ink);
    }

    return _react2.default.createElement(
      Component,
      _extends({}, props, {
        ref: this._setNode,
        className: (0, _classnames2.default)('md-fake-btn', (_cn = {
          'md-pointer--hover': !disabled,
          'md-fake-btn--no-outline': noFocusOutline
        }, _cn[tabbedClassName] = tabbedClassName && this.state.tabFocused, _cn), className),
        disabled: disabled,
        tabIndex: disabled ? null : tabIndex,
        onBlur: this._handleBlur,
        onClick: this._handleClick,
        onKeyUp: this._handleKeyUp,
        onKeyDown: this._handleKeyDown,
        'aria-pressed': this.state.pressed
      }),
      childElements
    );
  };

  return AccessibleFakeButton;
}(_react.PureComponent);

AccessibleFakeButton.propTypes = {
  /**
   * An optional style to apply.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply.
   */
  className: _propTypes2.default.string,

  /**
   * An optional function to call only when the button has been focused with the tab key.
   */
  tabbedClassName: _propTypes2.default.string,

  /**
   * Any children to display in the Accessible Fake Button.
   */
  children: _propTypes2.default.node,

  /**
   * An optional onClick function to call when the user clicks the
   * button or presses space || enter.
   */
  onClick: _propTypes2.default.func,

  /**
   * An optional onKeyDown function to call.
   */
  onKeyDown: _propTypes2.default.func,

  /**
   * An optional onBlur function to call.
   */
  onBlur: _propTypes2.default.func,

  /**
   * An optional onKeyUp function to call.
   */
  onKeyUp: _propTypes2.default.func,

  /**
   * An optional function to call when the element is focused with the tab key.
   */
  onTabFocus: _propTypes2.default.func,

  /**
   * The component to render the Fake button as.
   */
  component: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired,

  /**
   * Boolean if the default outline should be removed the when the fake button has been focused.
   *
   * @see {@link #tabbedClassName}
   */
  noFocusOutline: _propTypes2.default.bool,

  /**
   * The tab index to use for the Fake button so it is keyboard focusable.
   */
  tabIndex: _propTypes2.default.number,

  /**
   * Boolean if the Button is disabled. This will prevent tab focus.
   */
  disabled: _propTypes2.default.bool,

  /**
   * The role for the accessible fake button. It is recommended to keep it
   * the default of `button` unless you are rendering it as an `a` tag.
   */
  role: _propTypes2.default.string,

  /**
   * The ink when coming from the AccessibleFakeInkedButton
   * @access private
   */
  ink: _propTypes2.default.node,

  /**
   * Boolean if the spacebar should be used to trigger the click event. This _should_ be `true`
   * is almost all cases.
   */
  listenToSpace: _propTypes2.default.bool,

  /**
   * Boolean if the enter key should be used to trigger the click event. This _should_ be `true`
   * in most cases. By default, the param will be ignored if the `role` attribute is for a `checkbox`
   * or `radio`. When it is a checkbox or radio, it will attempt to submit the form on the enter
   * keypress instead like the native elements.
   */
  listenToEnter: _propTypes2.default.bool
};
AccessibleFakeButton.defaultProps = {
  component: 'div',
  tabIndex: 0,
  role: 'button',
  noFocusOutline: true,
  listenToEnter: true,
  listenToSpace: true
};
exports.default = AccessibleFakeButton;

/***/ }),

/***/ "p5wU":
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = once;


/***/ }),

/***/ "pCvA":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "pb74":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var Message = function Message(_ref) {
  var children = _ref.children,
      type = _ref.type;
  return _react.default.createElement("div", {
    className: "react-pdf__message react-pdf__message--".concat(type)
  }, children);
};

Message.propTypes = {
  children: _propTypes.default.node,
  type: _propTypes.default.oneOf(['error', 'loading', 'no-data']).isRequired
};
var _default = Message;
exports.default = _default;

/***/ }),

/***/ "ph+7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.BottomNavigation = undefined;

var _BottomNavigation2 = __webpack_require__("zPkt");

var _BottomNavigation3 = _interopRequireDefault(_BottomNavigation2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _BottomNavigation3.default;
exports.BottomNavigation = _BottomNavigation3.default;

/***/ }),

/***/ "qJif":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = spring;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _presets = __webpack_require__("PogH");

var _presets2 = _interopRequireDefault(_presets);

var defaultConfig = _extends({}, _presets2['default'].noWobble, {
  precision: 0.01
});

function spring(val, config) {
  return _extends({}, defaultConfig, config, { val: val });
}

module.exports = exports['default'];

/***/ }),

/***/ "qiae":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__("xARA");

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _deprecated = __webpack_require__("PioW");

var _deprecated2 = _interopRequireDefault(_deprecated);

var _isRequiredForA11y = __webpack_require__("nHLA");

var _isRequiredForA11y2 = _interopRequireDefault(_isRequiredForA11y);

var _CSSTransitionGroupTick = __webpack_require__("+5Nw");

var _CSSTransitionGroupTick2 = _interopRequireDefault(_CSSTransitionGroupTick);

var _getField = __webpack_require__("iouw");

var _getField2 = _interopRequireDefault(_getField);

var _handleKeyboardAccessibility = __webpack_require__("gqOe");

var _handleKeyboardAccessibility2 = _interopRequireDefault(_handleKeyboardAccessibility);

var _anchorShape = __webpack_require__("gFhn");

var _anchorShape2 = _interopRequireDefault(_anchorShape);

var _fixedToShape = __webpack_require__("wp+c");

var _fixedToShape2 = _interopRequireDefault(_fixedToShape);

var _positionShape = __webpack_require__("fzjA");

var _positionShape2 = _interopRequireDefault(_positionShape);

var _Layover = __webpack_require__("942r");

var _Layover2 = _interopRequireDefault(_Layover);

var _List = __webpack_require__("wvQ6");

var _List2 = _interopRequireDefault(_List);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `Menu` controlled component is used to display a list of children in the `List`
 * component once the `visible` prop is true.
 */
var Menu = function (_PureComponent) {
  _inherits(Menu, _PureComponent);

  function Menu() {
    var _temp, _this, _ret;

    _classCallCheck(this, Menu);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._handleClose = function (e) {
      var _this$props = _this.props,
          close = _this$props.close,
          onClose = _this$props.onClose;

      if (close || onClose) {
        (close || onClose)(e);
      }
    }, _this._handleClick = function (e) {
      if (_this.props.onClick) {
        _this.props.onClick(e);
      }

      var node = e.target;
      while (_this._container && _this._container.contains(node)) {
        if (_this._isIgnoreTarget(node)) {
          return;
        } else if (_this._isCloseTarget(node)) {
          e.persist();
          // set a timeout so item click events still trigger, and then close
          _this._timeout = setTimeout(function () {
            _this._timeout = null;
            _this._handleClose(e);
          }, _CSSTransitionGroupTick2.default);

          return;
        }

        node = node.parentNode;
      }
    }, _this._handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }

      (0, _handleKeyboardAccessibility2.default)(e, _this._handleClick, true, true);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Menu.prototype.getChildContext = function getChildContext() {
    var _props = this.props,
        cascading = _props.cascading,
        id = _props.id,
        fixedTo = _props.fixedTo,
        cascadingAnchor = _props.cascadingAnchor;

    var listLevel = this.context.listLevel || 0;
    var cascadingMenu = typeof cascading !== 'undefined' ? cascading : this.context.cascadingMenu;
    var cascadingZDepth = (0, _getField2.default)(this.context, this.props, 'cascadingZDepth');
    var cascadingFixedTo = typeof fixedTo !== 'undefined' ? fixedTo : this.context.cascadingFixedTo;

    return {
      listLevel: listLevel,
      cascadingId: id + '-level-' + (listLevel + 1),
      cascadingMenu: cascadingMenu,
      cascadingAnchor: cascadingAnchor,
      cascadingZDepth: cascadingZDepth,
      cascadingFixedTo: cascadingFixedTo
    };
  };

  Menu.prototype.componentDidMount = function componentDidMount() {
    this._container = (0, _reactDom.findDOMNode)(this);
  };

  Menu.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  /**
   * Checks if a provided event target or HTML Element is considered a menu click target.
   * This normally is just a ListItem.
   */
  Menu.prototype._isCloseTarget = function _isCloseTarget(target) {
    return target.classList.contains('md-list-item') && !target.classList.contains('md-list-item--nested-container');
  };

  /**
   * Checks if a provided event target or HTML Element is something that should shortcut/break
   * out of the click event loop because it **should not** close menus when clicked.
   */


  Menu.prototype._isIgnoreTarget = function _isIgnoreTarget(target) {
    return target.getAttribute('disabled') !== null || target.classList.contains('md-list-control');
  };

  Menu.prototype.render = function render() {
    var _cn;

    var _props2 = this.props,
        id = _props2.id,
        className = _props2.className,
        listStyle = _props2.listStyle,
        listClassName = _props2.listClassName,
        visible = _props2.visible,
        children = _props2.children,
        listProps = _props2.listProps,
        listZDepth = _props2.listZDepth,
        listInline = _props2.listInline,
        listHeightRestricted = _props2.listHeightRestricted,
        cascading = _props2.cascading,
        sameWidth = _props2.sameWidth,
        simplified = _props2.simplified,
        contained = _props2.contained,
        isOpen = _props2.isOpen,
        propFixedTo = _props2.fixedTo,
        propListId = _props2.listId,
        cascadingAnchor = _props2.cascadingAnchor,
        cascadingZDepth = _props2.cascadingZDepth,
        onClose = _props2.onClose,
        propPosition = _props2.position,
        close = _props2.close,
        autoclose = _props2.autoclose,
        limitHeight = _props2.limitHeight,
        expanderIconChildren = _props2.expanderIconChildren,
        expanderIconClassName = _props2.expanderIconClassName,
        props = _objectWithoutProperties(_props2, ['id', 'className', 'listStyle', 'listClassName', 'visible', 'children', 'listProps', 'listZDepth', 'listInline', 'listHeightRestricted', 'cascading', 'sameWidth', 'simplified', 'contained', 'isOpen', 'fixedTo', 'listId', 'cascadingAnchor', 'cascadingZDepth', 'onClose', 'position', 'close', 'autoclose', 'limitHeight', 'expanderIconChildren', 'expanderIconClassName']);

    var _props3 = this.props,
        listId = _props3.listId,
        position = _props3.position;

    if (!listId) {
      listId = id + '-list';
    }

    // can't have a simplified menu for cascading and context menus
    var simple = !cascading && !props.onContextMenu && position !== 'context' && simplified;
    if (position === 'context') {
      position = Menu.Positions.BELOW;
    }

    var below = position === Menu.Positions.BELOW;
    var fixedTo = typeof propFixedTo !== 'undefined' ? propFixedTo : this.context.cascadingFixedTo;
    var listVisible = typeof isOpen !== 'undefined' ? isOpen : visible;
    return _react2.default.createElement(
      _Layover2.default,
      _extends({}, props, {
        id: id,
        className: (0, _classnames2.default)('md-menu-container', {
          'md-menu-container--menu-below': simplified && below
        }, className),
        simplified: simple,
        sameWidth: contained || sameWidth,
        fixedTo: fixedTo,
        onClick: this._handleClick,
        onKeyDown: this._handleKeyDown,
        onClose: this._handleClose,
        animationPosition: position,
        visible: listVisible,
        'aria-haspopup': true,
        'aria-expanded': listVisible,
        'aria-owns': listId
      }),
      _react2.default.createElement(
        _List2.default,
        _extends({}, listProps, {
          id: listId,
          key: 'menu-list',
          style: listStyle,
          className: (0, _classnames2.default)('md-list--menu', (_cn = {
            'md-list--menu-restricted': listHeightRestricted,
            'md-list--menu-contained': simplified && (sameWidth || contained)
          }, _cn['md-list--menu-' + position] = simplified, _cn['md-paper md-paper--' + listZDepth] = listZDepth, _cn), listClassName),
          inline: listInline
        }),
        children
      )
    );
  };

  return Menu;
}(_react.PureComponent);

Menu.HorizontalAnchors = _Layover2.default.HorizontalAnchors;
Menu.VerticalAnchors = _Layover2.default.VerticalAnchors;
Menu.Positions = {
  // Can't do ...Layover.Positions since it triggers the get for CONTEXT
  TOP_LEFT: _Layover2.default.Positions.TOP_LEFT,
  TOP_RIGHT: _Layover2.default.Positions.TOP_RIGHT,
  BOTTOM_LEFT: _Layover2.default.Positions.BOTTOM_LEFT,
  BOTTOM_RIGHT: _Layover2.default.Positions.BOTTOM_RIGHT,
  BELOW: _Layover2.default.Positions.BELOW,
  _warned: false,
  get CONTEXT() {
    if (!this._warned) {
      /* eslint-disable no-console */
      console.error('The `Menu.Positions.CONTEXT` position has been deprecated and will be removed ' + 'in the next major release. To make the `Menu` behave as a context menu, provide ' + 'the `onContextMenu` prop instead.');
      /* eslint-enable no-console */
    }

    this._warned = true;
    return 'context';
  }
};
Menu.propTypes = {
  /**
   * An id to provide to the menu's container. This is required for accessibility as it generates
   * the `aria-` attributes for dynamic content.
   *
   * @see {@link #listId}
   */
  id: (0, _isRequiredForA11y2.default)(_propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string])),

  /**
   * An optional id to provide to the menu's list. If this prop is omitted, the list's id will be
   * `\`${id}-list\``
   */
  listId: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),

  /**
   * An optional style to apply to the main container for the menu.
   */
  style: _propTypes2.default.object,

  /**
   * An optional class name to apply to the main container for the menu.
   */
  className: _propTypes2.default.string,

  /**
   * An optional style to apply to the list once the menu has opened.
   */
  listStyle: _propTypes2.default.object,

  /**
   * An optional class name to apply to the list once the menu has opened.
   */
  listClassName: _propTypes2.default.string,

  /**
   * The component to render the main container as.
   *
   * @see {@link Helpers/Layover#component}
   */
  component: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),

  /**
   * This is how the menu's `List` gets anchored to the `toggle` element.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  anchor: _anchorShape2.default,

  /**
   * This is the optional anchor to use when the `position` is set to `Menu.Positions.BELOW`.
   * Set this to `null` to use the default `anchor` prop.
   *
   * @see {@link Helpers/Layover#belowAnchor}
   */
  belowAnchor: _anchorShape2.default,

  /**
   * This is the animation position for the list that appears.
   *
   * @see {@link Helpers/Layover#animationPosition}
   */
  position: _positionShape2.default,

  /**
   * This is the component/element that should toggle the menu open.
   *
   * @see {@link Helpers/Layover#toggle}
   */
  toggle: _propTypes2.default.node,

  /**
   * This is how the menu's list will be "fixed" to the `toggle` component.
   *
   * @see {@link Helpers/Layover#fixedTo}
   */
  fixedTo: _fixedToShape2.default,

  /**
   * Any additional props that should be applied to the list in the menu. This is really used
   * when additional `aria-` tags need to be applied.
   */
  listProps: _propTypes2.default.object,

  /**
   * Boolean if the menu's list should appear horizontally instead of vertically.
   */
  listInline: _propTypes2.default.bool,

  /**
   * The list's z-depth for applying box shadow. This should be a number from 0 to 5.
   */
  listZDepth: _propTypes2.default.number.isRequired,

  /**
   * Boolean if the list should have its height restricted to the `$md-menu-mobile-max-height`/
   * `$md-menu-desktop-max-height` values.
   *
   * @see [md-menu-mobile-max-height](/components/menus?tab=2#variable-md-menu-mobile-max-height)
   * @see [md-menu-desktop-max-height](/components/menus?tab=2#variable-md-menu-desktop-max-height)
   */
  listHeightRestricted: _propTypes2.default.bool,

  /**
   * Boolean if the menu's list is visible.
   */
  visible: _propTypes2.default.bool.isRequired,

  /**
   * Any children to render in the menu's list. This _should_ normally be `ListItem`, or
   * `ListItemControl`.
   */
  children: _propTypes2.default.node,

  /**
   * An optional function to call when en element in the menu has been clicked.
   */
  onClick: _propTypes2.default.func,

  /**
   * An optional function to call when a key is pressed anywhere in the menu.
   */
  onKeyDown: _propTypes2.default.func,

  /**
   * A function to call to close the menu. This is used for closing on outside clicks,
   * closing when a list item has been clicked, or the user presses escape.
   */
  onClose: _propTypes2.default.func.isRequired,

  /**
   * Boolean if the menu should be cascading. This means that the menu will pop the additional
   * `nestedItems` on any `ListItem` to be appear either to the right or left of the visible list.
   */
  cascading: _propTypes2.default.bool,

  /**
   * This is how the cascading lists get anchored to the list item.
   *
   * @see {@link Helpers/Layover#anchor}
   */
  cascadingAnchor: _Layover2.default.propTypes.anchor,

  /**
   * This is the z-depth the list should gain for a cascading menu. This only gets applied on
   * items that are more than 1 level deep.
   */
  cascadingZDepth: _propTypes2.default.number.isRequired,

  /**
   * Boolean if the `md-full-width` class name should get applied to the menu's container.
   */
  fullWidth: _propTypes2.default.bool,

  /**
   * Boolean if the menu should be displayed as a block instead of as an inline block.
   *
   * @see {@link #fullWidth}
   */
  block: _propTypes2.default.bool,

  /**
   * @see {@link Helpers/Layover#centered}
   */
  centered: _Layover2.default.propTypes.centered,

  /**
   * @see {@link Helpers/Layover#sameWidth}
   */
  sameWidth: _Layover2.default.propTypes.sameWidth,

  /**
   * If you would like the menu to interact as a context menu, provide this prop.
   *
   * @see {@link Helpers/Layover#onContextMenu}
   */
  onContextMenu: _Layover2.default.propTypes.onContextMenu,

  /**
   * Boolean if the default behavior of the context menu should be prevented when using the
   * `onContextMenu` prop.
   *
   * @see {@link Helpers/Layover#preventContextMenu}
   */
  preventContextMenu: _Layover2.default.propTypes.preventContextMenu,

  /**
   * @see {@link Helpers/Layover#xThreshold}
   */
  xThreshold: _propTypes2.default.number,

  /**
   * @see {@link Helpers/Layover#yThreshold}
   */
  yThreshold: _propTypes2.default.number,

  /**
   * @see {@link Helpers/Layover#closeOnOutsideClick}
   */
  closeOnOutsideClick: _propTypes2.default.bool,

  /**
   * @see {@link Helpers/Layover#toggleQuery}
   */
  toggleQuery: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.object, _propTypes2.default.string]),

  /**
   * An optional transition name to use for the list appearing/disappearing.
   *
   * @see {@link Helpers/Layover#transitionName}
   */
  transitionName: _propTypes2.default.string,

  /**
   * @see {@link Helpers/Layover#transitionEnterTimeout}
   */
  transitionEnterTimeout: _propTypes2.default.number,

  /**
   * @see {@link Helpers/Layover#transitionLeaveTimeout}
   */
  transitionLeaveTimeout: _propTypes2.default.number,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the `fixedTo` element scrolls.
   *
   * @see {@link Helpers/Layover#repositionOnScroll}
   */
  repositionOnScroll: _propTypes2.default.bool,

  /**
   * Boolean if the menu should automatically try to reposition itself to stay within
   * the viewport when the window resizes.
   *
   * @see {@link Helpers/Layover#repositionOnResize}
   */
  repositionOnResize: _propTypes2.default.bool,

  /**
   * @see {@link Helpers/Layover#simplified}
   */
  simplified: _propTypes2.default.bool,

  /**
   * @see {@link Helpers/Layover#minLeft}
   */
  minLeft: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),

  /**
   * @see {@link Helpers/Layover#minRight}
   */
  minRight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),

  /**
   * @see {@link Helpers/Layover#minBottom}
   */
  minBottom: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),

  /**
   * @see {@link Helpers/Layover#fillViewportWidth}
   */
  fillViewportWidth: _propTypes2.default.bool,

  /**
   * @see {@link Helpers/Layover#fillViewportHeight}
   */
  fillViewportHeight: _propTypes2.default.bool,

  isOpen: (0, _deprecated2.default)(_propTypes2.default.bool, 'Use `visible` instead'),
  close: (0, _deprecated2.default)(_propTypes2.default.func, 'Use `onClose` instead'),
  autoclose: (0, _deprecated2.default)(_propTypes2.default.bool, 'The menus will always autoclose as according to the specs'),
  contained: (0, _deprecated2.default)(_propTypes2.default.bool, 'Use `sameWidth` instead'),
  limitHeight: (0, _deprecated2.default)(_propTypes2.default.bool, 'The menus will always be limited in height as according to the specs'),
  expanderIconClassName: (0, _deprecated2.default)(_propTypes2.default.node, 'The expander for cascading menus will now just be a simple rotate of the existing `ListItem` ' + 'expander icon'),
  expanderIconChildren: (0, _deprecated2.default)(_propTypes2.default.node, 'The expander for cascading menus will now just be a simple rotate of the existing `ListItem` ' + 'expander icon')
};
Menu.defaultProps = {
  anchor: {
    x: _Layover2.default.HorizontalAnchors.INNER_RIGHT,
    y: _Layover2.default.VerticalAnchors.OVERLAP
  },
  cascadingAnchor: {
    x: _Layover2.default.HorizontalAnchors.RIGHT,
    y: _Layover2.default.VerticalAnchors.OVERLAP
  },
  position: _Layover2.default.Positions.TOP_RIGHT,
  fixedTo: typeof window !== 'undefined' ? window : {},
  listZDepth: 2,
  listHeightRestricted: true,
  cascadingZDepth: 3,
  repositionOnScroll: true,
  repositionOnResize: false,
  simplified: true
};
Menu.contextTypes = {
  listLevel: _propTypes2.default.number,
  cascadingId: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  cascadingMenu: _propTypes2.default.bool,
  cascadingAnchor: _anchorShape2.default,
  cascadingZDepth: _propTypes2.default.number
};
Menu.childContextTypes = {
  listLevel: _propTypes2.default.number,
  cascadingId: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  cascadingMenu: _propTypes2.default.bool,
  cascadingFixedTo: _fixedToShape2.default,
  cascadingAnchor: _anchorShape2.default,
  cascadingZDepth: _propTypes2.default.number
};
exports.default = Menu;

/***/ }),

/***/ "qzSP":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _oneRequiredForA11yIf = __webpack_require__("ILPZ");

var _oneRequiredForA11yIf2 = _interopRequireDefault(_oneRequiredForA11yIf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The avatar component is used to convert a `FontIcon`, an image, or
 * a letter into an avatar.
 *
 * Any other props given to the Avatar component such as event listeners
 * or styles will also be applied.
 */
var Avatar = function (_PureComponent) {
  _inherits(Avatar, _PureComponent);

  function Avatar() {
    var _temp, _this, _ret;

    _classCallCheck(this, Avatar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = { color: null }, _this._setRandomColor = function () {
      var suffixes = _this.props.suffixes;


      var i = Math.floor(Math.random() * (suffixes.length - 1)) + 1;
      _this.setState({ color: suffixes[i] });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Avatar.prototype.componentWillMount = function componentWillMount() {
    if (this.props.random) {
      this._setRandomColor();
    }
  };

  Avatar.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.random && (this.props.src !== nextProps.src || this.props.icon !== nextProps.icon)) {
      this._setRandomColor();
    } else if (this.props.random && !nextProps.random) {
      this.setState({ color: null });
    }
  };

  Avatar.prototype._getColor = function _getColor(suffix, suffixes, color) {
    if (suffix) {
      return 'md-avatar--' + suffix;
    } else if (!!suffixes && !color) {
      return 'md-avatar--default';
    }

    return 'md-avatar--' + color;
  };

  Avatar.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        contentStyle = _props.contentStyle,
        contentClassName = _props.contentClassName,
        src = _props.src,
        alt = _props.alt,
        icon = _props.icon,
        children = _props.children,
        suffix = _props.suffix,
        suffixes = _props.suffixes,
        iconSized = _props.iconSized,
        role = _props.role,
        random = _props.random,
        props = _objectWithoutProperties(_props, ['className', 'contentStyle', 'contentClassName', 'src', 'alt', 'icon', 'children', 'suffix', 'suffixes', 'iconSized', 'role', 'random']);

    var content = void 0;
    if (src) {
      content = _react2.default.createElement('img', {
        src: src,
        alt: alt,
        role: role,
        style: contentStyle,
        className: (0, _classnames2.default)('md-avatar-img', contentClassName)
      });
    } else {
      content = _react2.default.createElement(
        'div',
        {
          style: contentStyle,
          className: (0, _classnames2.default)('md-avatar-content', contentClassName)
        },
        icon || children
      );
    }
    return _react2.default.createElement(
      'div',
      _extends({}, props, {
        className: (0, _classnames2.default)('md-inline-block md-avatar', this._getColor(suffix, suffixes, this.state.color), {
          'md-avatar--icon-sized': iconSized
        }, className)
      }),
      content
    );
  };

  return Avatar;
}(_react.PureComponent);

Avatar.propTypes = {
  /**
   * An optional className to apply to the avatar.
   */
  className: _propTypes2.default.string,

  /**
   * An optional style to apply to either the `<img>` or `<div>` surrounding the content. The `<img>` tag
   * will be used with the `src` prop is defined.
   */
  contentStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to either the `<img>` or `<div>` surrounding the content. The `<img>` tag
   * will be used with the `src` prop is defined.
   */
  contentClassName: _propTypes2.default.string,

  /**
   * An optional image source to use for the avatar.
   */
  src: (0, _oneRequiredForA11yIf2.default)(_propTypes2.default.string, 'role', 'alt'),

  /**
   * An optional image alt to use for the avatar if it is
   * an image.
   */
  alt: _propTypes2.default.string,

  /**
   * An optional `FontIcon` to convert into an avatar.
   */
  icon: _propTypes2.default.node,

  /**
   * An optional letter to display in the avatar.
   */
  children: _propTypes2.default.node,

  /**
   * A boolean if a random color should be applied to the avatar.
   * This will be one of the `suffixes`.
   */
  random: _propTypes2.default.bool,

  /**
   * A list of available suffixes to use when generating a random
   * color for the avatar.
   */
  suffixes: _propTypes2.default.arrayOf(_propTypes2.default.string),

  /**
   * The suffix to use for a color. This can be any value but
   * *should* be one of the available `suffixes`.
   */
  suffix: _propTypes2.default.string,

  /**
   * Boolean if the `Avatar` should be sized to a `FontIcon` size. This
   * will just set the width and height to the `$md-font-icon-size`.
   */
  iconSized: _propTypes2.default.bool,

  /**
   * A role for the avatar's image. When the `src` prop is set, either a `role` of `presentation`
   * or the `alt` prop must be defined for a11y.
   */
  role: _propTypes2.default.oneOf(['presentation'])
};
Avatar.defaultProps = {
  suffixes: ['red', 'pink', 'purple', 'deep-purple', 'indigo', 'blue', 'light-blue', 'cyan', 'teal', 'green', 'light-green', 'lime', 'yellow', 'amber', 'orange', 'deep-orange', 'brown', 'grey', 'blue-grey']
};
exports.default = Avatar;

/***/ }),

/***/ "rKUl":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = hasClass;

function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);else return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

module.exports = exports["default"];

/***/ }),

/***/ "rQBY":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var now = __webpack_require__("TGEZ")
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("pCvA")))

/***/ }),

/***/ "rY4S":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _mapToZero = __webpack_require__("VNYx");

var _mapToZero2 = _interopRequireDefault(_mapToZero);

var _stripStyle = __webpack_require__("jL08");

var _stripStyle2 = _interopRequireDefault(_stripStyle);

var _stepper3 = __webpack_require__("1obq");

var _stepper4 = _interopRequireDefault(_stepper3);

var _mergeDiff = __webpack_require__("3Zmt");

var _mergeDiff2 = _interopRequireDefault(_mergeDiff);

var _performanceNow = __webpack_require__("7nMe");

var _performanceNow2 = _interopRequireDefault(_performanceNow);

var _raf = __webpack_require__("rQBY");

var _raf2 = _interopRequireDefault(_raf);

var _shouldStopAnimation = __webpack_require__("fsLg");

var _shouldStopAnimation2 = _interopRequireDefault(_shouldStopAnimation);

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("W0B4");

var _propTypes2 = _interopRequireDefault(_propTypes);

var msPerFrame = 1000 / 60;

// the children function & (potential) styles function asks as param an
// Array<TransitionPlainStyle>, where each TransitionPlainStyle is of the format
// {key: string, data?: any, style: PlainStyle}. However, the way we keep
// internal states doesn't contain such a data structure (check the state and
// TransitionMotionState). So when children function and others ask for such
// data we need to generate them on the fly by combining mergedPropsStyles and
// currentStyles/lastIdealStyles
function rehydrateStyles(mergedPropsStyles, unreadPropStyles, plainStyles) {
  // Copy the value to a `const` so that Flow understands that the const won't
  // change and will be non-nullable in the callback below.
  var cUnreadPropStyles = unreadPropStyles;
  if (cUnreadPropStyles == null) {
    return mergedPropsStyles.map(function (mergedPropsStyle, i) {
      return {
        key: mergedPropsStyle.key,
        data: mergedPropsStyle.data,
        style: plainStyles[i]
      };
    });
  }
  return mergedPropsStyles.map(function (mergedPropsStyle, i) {
    for (var j = 0; j < cUnreadPropStyles.length; j++) {
      if (cUnreadPropStyles[j].key === mergedPropsStyle.key) {
        return {
          key: cUnreadPropStyles[j].key,
          data: cUnreadPropStyles[j].data,
          style: plainStyles[i]
        };
      }
    }
    return { key: mergedPropsStyle.key, data: mergedPropsStyle.data, style: plainStyles[i] };
  });
}

function shouldStopAnimationAll(currentStyles, destStyles, currentVelocities, mergedPropsStyles) {
  if (mergedPropsStyles.length !== destStyles.length) {
    return false;
  }

  for (var i = 0; i < mergedPropsStyles.length; i++) {
    if (mergedPropsStyles[i].key !== destStyles[i].key) {
      return false;
    }
  }

  // we have the invariant that mergedPropsStyles and
  // currentStyles/currentVelocities/last* are synced in terms of cells, see
  // mergeAndSync comment for more info
  for (var i = 0; i < mergedPropsStyles.length; i++) {
    if (!_shouldStopAnimation2['default'](currentStyles[i], destStyles[i].style, currentVelocities[i])) {
      return false;
    }
  }

  return true;
}

// core key merging logic

// things to do: say previously merged style is {a, b}, dest style (prop) is {b,
// c}, previous current (interpolating) style is {a, b}
// **invariant**: current[i] corresponds to merged[i] in terms of key

// steps:
// turn merged style into {a?, b, c}
//    add c, value of c is destStyles.c
//    maybe remove a, aka call willLeave(a), then merged is either {b, c} or {a, b, c}
// turn current (interpolating) style from {a, b} into {a?, b, c}
//    maybe remove a
//    certainly add c, value of c is willEnter(c)
// loop over merged and construct new current
// dest doesn't change, that's owner's
function mergeAndSync(willEnter, willLeave, didLeave, oldMergedPropsStyles, destStyles, oldCurrentStyles, oldCurrentVelocities, oldLastIdealStyles, oldLastIdealVelocities) {
  var newMergedPropsStyles = _mergeDiff2['default'](oldMergedPropsStyles, destStyles, function (oldIndex, oldMergedPropsStyle) {
    var leavingStyle = willLeave(oldMergedPropsStyle);
    if (leavingStyle == null) {
      didLeave({ key: oldMergedPropsStyle.key, data: oldMergedPropsStyle.data });
      return null;
    }
    if (_shouldStopAnimation2['default'](oldCurrentStyles[oldIndex], leavingStyle, oldCurrentVelocities[oldIndex])) {
      didLeave({ key: oldMergedPropsStyle.key, data: oldMergedPropsStyle.data });
      return null;
    }
    return { key: oldMergedPropsStyle.key, data: oldMergedPropsStyle.data, style: leavingStyle };
  });

  var newCurrentStyles = [];
  var newCurrentVelocities = [];
  var newLastIdealStyles = [];
  var newLastIdealVelocities = [];
  for (var i = 0; i < newMergedPropsStyles.length; i++) {
    var newMergedPropsStyleCell = newMergedPropsStyles[i];
    var foundOldIndex = null;
    for (var j = 0; j < oldMergedPropsStyles.length; j++) {
      if (oldMergedPropsStyles[j].key === newMergedPropsStyleCell.key) {
        foundOldIndex = j;
        break;
      }
    }
    // TODO: key search code
    if (foundOldIndex == null) {
      var plainStyle = willEnter(newMergedPropsStyleCell);
      newCurrentStyles[i] = plainStyle;
      newLastIdealStyles[i] = plainStyle;

      var velocity = _mapToZero2['default'](newMergedPropsStyleCell.style);
      newCurrentVelocities[i] = velocity;
      newLastIdealVelocities[i] = velocity;
    } else {
      newCurrentStyles[i] = oldCurrentStyles[foundOldIndex];
      newLastIdealStyles[i] = oldLastIdealStyles[foundOldIndex];
      newCurrentVelocities[i] = oldCurrentVelocities[foundOldIndex];
      newLastIdealVelocities[i] = oldLastIdealVelocities[foundOldIndex];
    }
  }

  return [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities];
}

var TransitionMotion = (function (_React$Component) {
  _inherits(TransitionMotion, _React$Component);

  _createClass(TransitionMotion, null, [{
    key: 'propTypes',
    value: {
      defaultStyles: _propTypes2['default'].arrayOf(_propTypes2['default'].shape({
        key: _propTypes2['default'].string.isRequired,
        data: _propTypes2['default'].any,
        style: _propTypes2['default'].objectOf(_propTypes2['default'].number).isRequired
      })),
      styles: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].arrayOf(_propTypes2['default'].shape({
        key: _propTypes2['default'].string.isRequired,
        data: _propTypes2['default'].any,
        style: _propTypes2['default'].objectOf(_propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].object])).isRequired
      }))]).isRequired,
      children: _propTypes2['default'].func.isRequired,
      willEnter: _propTypes2['default'].func,
      willLeave: _propTypes2['default'].func,
      didLeave: _propTypes2['default'].func
    },
    enumerable: true
  }, {
    key: 'defaultProps',
    value: {
      willEnter: function willEnter(styleThatEntered) {
        return _stripStyle2['default'](styleThatEntered.style);
      },
      // recall: returning null makes the current unmounting TransitionStyle
      // disappear immediately
      willLeave: function willLeave() {
        return null;
      },
      didLeave: function didLeave() {}
    },
    enumerable: true
  }]);

  function TransitionMotion(props) {
    var _this = this;

    _classCallCheck(this, TransitionMotion);

    _React$Component.call(this, props);
    this.unmounting = false;
    this.animationID = null;
    this.prevTime = 0;
    this.accumulatedTime = 0;
    this.unreadPropStyles = null;

    this.clearUnreadPropStyle = function (unreadPropStyles) {
      var _mergeAndSync = mergeAndSync(_this.props.willEnter, _this.props.willLeave, _this.props.didLeave, _this.state.mergedPropsStyles, unreadPropStyles, _this.state.currentStyles, _this.state.currentVelocities, _this.state.lastIdealStyles, _this.state.lastIdealVelocities);

      var mergedPropsStyles = _mergeAndSync[0];
      var currentStyles = _mergeAndSync[1];
      var currentVelocities = _mergeAndSync[2];
      var lastIdealStyles = _mergeAndSync[3];
      var lastIdealVelocities = _mergeAndSync[4];

      for (var i = 0; i < unreadPropStyles.length; i++) {
        var unreadPropStyle = unreadPropStyles[i].style;
        var dirty = false;

        for (var key in unreadPropStyle) {
          if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {
            continue;
          }

          var styleValue = unreadPropStyle[key];
          if (typeof styleValue === 'number') {
            if (!dirty) {
              dirty = true;
              currentStyles[i] = _extends({}, currentStyles[i]);
              currentVelocities[i] = _extends({}, currentVelocities[i]);
              lastIdealStyles[i] = _extends({}, lastIdealStyles[i]);
              lastIdealVelocities[i] = _extends({}, lastIdealVelocities[i]);
              mergedPropsStyles[i] = {
                key: mergedPropsStyles[i].key,
                data: mergedPropsStyles[i].data,
                style: _extends({}, mergedPropsStyles[i].style)
              };
            }
            currentStyles[i][key] = styleValue;
            currentVelocities[i][key] = 0;
            lastIdealStyles[i][key] = styleValue;
            lastIdealVelocities[i][key] = 0;
            mergedPropsStyles[i].style[key] = styleValue;
          }
        }
      }

      // unlike the other 2 components, we can't detect staleness and optionally
      // opt out of setState here. each style object's data might contain new
      // stuff we're not/cannot compare
      _this.setState({
        currentStyles: currentStyles,
        currentVelocities: currentVelocities,
        mergedPropsStyles: mergedPropsStyles,
        lastIdealStyles: lastIdealStyles,
        lastIdealVelocities: lastIdealVelocities
      });
    };

    this.startAnimationIfNecessary = function () {
      if (_this.unmounting) {
        return;
      }

      // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
      // call cb? No, otherwise accidental parent rerender causes cb trigger
      _this.animationID = _raf2['default'](function (timestamp) {
        // https://github.com/chenglou/react-motion/pull/420
        // > if execution passes the conditional if (this.unmounting), then
        // executes async defaultRaf and after that component unmounts and after
        // that the callback of defaultRaf is called, then setState will be called
        // on unmounted component.
        if (_this.unmounting) {
          return;
        }

        var propStyles = _this.props.styles;
        var destStyles = typeof propStyles === 'function' ? propStyles(rehydrateStyles(_this.state.mergedPropsStyles, _this.unreadPropStyles, _this.state.lastIdealStyles)) : propStyles;

        // check if we need to animate in the first place
        if (shouldStopAnimationAll(_this.state.currentStyles, destStyles, _this.state.currentVelocities, _this.state.mergedPropsStyles)) {
          // no need to cancel animationID here; shouldn't have any in flight
          _this.animationID = null;
          _this.accumulatedTime = 0;
          return;
        }

        var currentTime = timestamp || _performanceNow2['default']();
        var timeDelta = currentTime - _this.prevTime;
        _this.prevTime = currentTime;
        _this.accumulatedTime = _this.accumulatedTime + timeDelta;
        // more than 10 frames? prolly switched browser tab. Restart
        if (_this.accumulatedTime > msPerFrame * 10) {
          _this.accumulatedTime = 0;
        }

        if (_this.accumulatedTime === 0) {
          // no need to cancel animationID here; shouldn't have any in flight
          _this.animationID = null;
          _this.startAnimationIfNecessary();
          return;
        }

        var currentFrameCompletion = (_this.accumulatedTime - Math.floor(_this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;
        var framesToCatchUp = Math.floor(_this.accumulatedTime / msPerFrame);

        var _mergeAndSync2 = mergeAndSync(_this.props.willEnter, _this.props.willLeave, _this.props.didLeave, _this.state.mergedPropsStyles, destStyles, _this.state.currentStyles, _this.state.currentVelocities, _this.state.lastIdealStyles, _this.state.lastIdealVelocities);

        var newMergedPropsStyles = _mergeAndSync2[0];
        var newCurrentStyles = _mergeAndSync2[1];
        var newCurrentVelocities = _mergeAndSync2[2];
        var newLastIdealStyles = _mergeAndSync2[3];
        var newLastIdealVelocities = _mergeAndSync2[4];

        for (var i = 0; i < newMergedPropsStyles.length; i++) {
          var newMergedPropsStyle = newMergedPropsStyles[i].style;
          var newCurrentStyle = {};
          var newCurrentVelocity = {};
          var newLastIdealStyle = {};
          var newLastIdealVelocity = {};

          for (var key in newMergedPropsStyle) {
            if (!Object.prototype.hasOwnProperty.call(newMergedPropsStyle, key)) {
              continue;
            }

            var styleValue = newMergedPropsStyle[key];
            if (typeof styleValue === 'number') {
              newCurrentStyle[key] = styleValue;
              newCurrentVelocity[key] = 0;
              newLastIdealStyle[key] = styleValue;
              newLastIdealVelocity[key] = 0;
            } else {
              var newLastIdealStyleValue = newLastIdealStyles[i][key];
              var newLastIdealVelocityValue = newLastIdealVelocities[i][key];
              for (var j = 0; j < framesToCatchUp; j++) {
                var _stepper = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

                newLastIdealStyleValue = _stepper[0];
                newLastIdealVelocityValue = _stepper[1];
              }

              var _stepper2 = _stepper4['default'](msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);

              var nextIdealX = _stepper2[0];
              var nextIdealV = _stepper2[1];

              newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;
              newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;
              newLastIdealStyle[key] = newLastIdealStyleValue;
              newLastIdealVelocity[key] = newLastIdealVelocityValue;
            }
          }

          newLastIdealStyles[i] = newLastIdealStyle;
          newLastIdealVelocities[i] = newLastIdealVelocity;
          newCurrentStyles[i] = newCurrentStyle;
          newCurrentVelocities[i] = newCurrentVelocity;
        }

        _this.animationID = null;
        // the amount we're looped over above
        _this.accumulatedTime -= framesToCatchUp * msPerFrame;

        _this.setState({
          currentStyles: newCurrentStyles,
          currentVelocities: newCurrentVelocities,
          lastIdealStyles: newLastIdealStyles,
          lastIdealVelocities: newLastIdealVelocities,
          mergedPropsStyles: newMergedPropsStyles
        });

        _this.unreadPropStyles = null;

        _this.startAnimationIfNecessary();
      });
    };

    this.state = this.defaultState();
  }

  TransitionMotion.prototype.defaultState = function defaultState() {
    var _props = this.props;
    var defaultStyles = _props.defaultStyles;
    var styles = _props.styles;
    var willEnter = _props.willEnter;
    var willLeave = _props.willLeave;
    var didLeave = _props.didLeave;

    var destStyles = typeof styles === 'function' ? styles(defaultStyles) : styles;

    // this is special. for the first time around, we don't have a comparison
    // between last (no last) and current merged props. we'll compute last so:
    // say default is {a, b} and styles (dest style) is {b, c}, we'll
    // fabricate last as {a, b}
    var oldMergedPropsStyles = undefined;
    if (defaultStyles == null) {
      oldMergedPropsStyles = destStyles;
    } else {
      oldMergedPropsStyles = defaultStyles.map(function (defaultStyleCell) {
        // TODO: key search code
        for (var i = 0; i < destStyles.length; i++) {
          if (destStyles[i].key === defaultStyleCell.key) {
            return destStyles[i];
          }
        }
        return defaultStyleCell;
      });
    }
    var oldCurrentStyles = defaultStyles == null ? destStyles.map(function (s) {
      return _stripStyle2['default'](s.style);
    }) : defaultStyles.map(function (s) {
      return _stripStyle2['default'](s.style);
    });
    var oldCurrentVelocities = defaultStyles == null ? destStyles.map(function (s) {
      return _mapToZero2['default'](s.style);
    }) : defaultStyles.map(function (s) {
      return _mapToZero2['default'](s.style);
    });

    var _mergeAndSync3 = mergeAndSync(
    // Because this is an old-style createReactClass component, Flow doesn't
    // understand that the willEnter and willLeave props have default values
    // and will always be present.
    willEnter, willLeave, didLeave, oldMergedPropsStyles, destStyles, oldCurrentStyles, oldCurrentVelocities, oldCurrentStyles, // oldLastIdealStyles really
    oldCurrentVelocities);

    var mergedPropsStyles = _mergeAndSync3[0];
    var currentStyles = _mergeAndSync3[1];
    var currentVelocities = _mergeAndSync3[2];
    var lastIdealStyles = _mergeAndSync3[3];
    var lastIdealVelocities = _mergeAndSync3[4];
    // oldLastIdealVelocities really

    return {
      currentStyles: currentStyles,
      currentVelocities: currentVelocities,
      lastIdealStyles: lastIdealStyles,
      lastIdealVelocities: lastIdealVelocities,
      mergedPropsStyles: mergedPropsStyles
    };
  };

  // after checking for unreadPropStyles != null, we manually go set the
  // non-interpolating values (those that are a number, without a spring
  // config)

  TransitionMotion.prototype.componentDidMount = function componentDidMount() {
    this.prevTime = _performanceNow2['default']();
    this.startAnimationIfNecessary();
  };

  TransitionMotion.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
    if (this.unreadPropStyles) {
      // previous props haven't had the chance to be set yet; set them here
      this.clearUnreadPropStyle(this.unreadPropStyles);
    }

    var styles = props.styles;
    if (typeof styles === 'function') {
      this.unreadPropStyles = styles(rehydrateStyles(this.state.mergedPropsStyles, this.unreadPropStyles, this.state.lastIdealStyles));
    } else {
      this.unreadPropStyles = styles;
    }

    if (this.animationID == null) {
      this.prevTime = _performanceNow2['default']();
      this.startAnimationIfNecessary();
    }
  };

  TransitionMotion.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unmounting = true;
    if (this.animationID != null) {
      _raf2['default'].cancel(this.animationID);
      this.animationID = null;
    }
  };

  TransitionMotion.prototype.render = function render() {
    var hydratedStyles = rehydrateStyles(this.state.mergedPropsStyles, this.unreadPropStyles, this.state.currentStyles);
    var renderedChildren = this.props.children(hydratedStyles);
    return renderedChildren && _react2['default'].Children.only(renderedChildren);
  };

  return TransitionMotion;
})(_react2['default'].Component);

exports['default'] = TransitionMotion;
module.exports = exports['default'];

// list of styles, each containing interpolating values. Part of what's passed
// to children function. Notice that this is
// Array<ActualInterpolatingStyleObject>, without the wrapper that is {key: ...,
// data: ... style: ActualInterpolatingStyleObject}. Only mergedPropsStyles
// contains the key & data info (so that we only have a single source of truth
// for these, and to save space). Check the comment for `rehydrateStyles` to
// see how we regenerate the entirety of what's passed to children function

// the array that keeps track of currently rendered stuff! Including stuff
// that you've unmounted but that's still animating. This is where it lives

// it's possible that currentStyle's value is stale: if props is immediately
// changed from 0 to 400 to spring(0) again, the async currentStyle is still
// at 0 (didn't have time to tick and interpolate even once). If we naively
// compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
// In reality currentStyle should be 400

/***/ }),

/***/ "rhKL":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var Ref =
/*#__PURE__*/
function () {
  function Ref(_ref) {
    var num = _ref.num,
        gen = _ref.gen;
    (0, _classCallCheck2.default)(this, Ref);
    this.num = num;
    this.gen = gen;
  }

  (0, _createClass2.default)(Ref, [{
    key: "toString",
    value: function toString() {
      var str = "".concat(this.num, "R");

      if (this.gen !== 0) {
        str += this.gen;
      }

      return str;
    }
  }]);
  return Ref;
}();

exports.default = Ref;

/***/ }),

/***/ "s3UK":
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__("FfeU");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "sTV1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _themeColors = __webpack_require__("VZNk");

var _themeColors2 = _interopRequireDefault(_themeColors);

var _ListItemText = __webpack_require__("z10u");

var _ListItemText2 = _interopRequireDefault(_ListItemText);

var _TileAddon = __webpack_require__("2gDV");

var _TileAddon2 = _interopRequireDefault(_TileAddon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ListItemControl = function (_PureComponent) {
  _inherits(ListItemControl, _PureComponent);

  function ListItemControl() {
    _classCallCheck(this, ListItemControl);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  ListItemControl.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        tileStyle = _props.tileStyle,
        tileClassName = _props.tileClassName,
        primaryAction = _props.primaryAction,
        secondaryAction = _props.secondaryAction,
        primaryText = _props.primaryText,
        secondaryText = _props.secondaryText,
        threeLines = _props.threeLines,
        leftIcon = _props.leftIcon,
        leftAvatar = _props.leftAvatar,
        rightIcon = _props.rightIcon,
        rightAvatar = _props.rightAvatar,
        props = _objectWithoutProperties(_props, ['className', 'tileStyle', 'tileClassName', 'primaryAction', 'secondaryAction', 'primaryText', 'secondaryText', 'threeLines', 'leftIcon', 'leftAvatar', 'rightIcon', 'rightAvatar']);

    var control = _react.Children.only(primaryAction || secondaryAction);
    var text = _react2.default.createElement(_ListItemText2.default, {
      key: 'text',
      primaryText: control.props.label || primaryText,
      secondaryText: secondaryText,
      className: (0, _classnames2.default)({
        'md-tile-content--left-icon': leftIcon,
        'md-tile-content--left-avatar': leftAvatar,
        'md-tile-content--left-button': primaryAction,
        'md-tile-content--right-padding': primaryAction
      })
    });
    control = (0, _react.cloneElement)(control, {
      className: (0, _classnames2.default)('md-list-control', {
        'md-list-control--right': secondaryAction
      }, control.props.className),
      label: text
    });

    var leftNode = _react2.default.createElement(_TileAddon2.default, {
      key: 'left-addon',
      icon: leftIcon,
      avatar: leftAvatar
    });

    var rightNode = _react2.default.createElement(_TileAddon2.default, {
      key: 'right-addon',
      icon: rightIcon,
      avatar: rightAvatar
    });

    var icond = !!leftIcon || !!rightIcon;
    var avatard = !!leftAvatar || !!rightAvatar;

    return _react2.default.createElement(
      'li',
      _extends({}, props, { className: (0, _classnames2.default)('md-list-item', className) }),
      _react2.default.createElement(
        'div',
        {
          style: tileStyle,
          className: (0, _classnames2.default)('md-list-tile', {
            'md-list-tile--icon': !secondaryText && icond && !avatard,
            'md-list-tile--avatar': !secondaryText && avatard,
            'md-list-tile--two-lines': secondaryText && !threeLines,
            'md-list-tile--three-lines': secondaryText && threeLines,
            'md-list-tile--control-left': primaryAction,
            'md-list-tile--control-right': secondaryAction
          }, (0, _themeColors2.default)({ text: true }), tileClassName)
        },
        leftNode,
        control,
        rightNode
      )
    );
  };

  return ListItemControl;
}(_react.PureComponent);

ListItemControl.propTypes = {
  /**
   * An optional style to apply to the `.md-list-item`.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply to the `.md-list-item`.
   */
  className: _propTypes2.default.string,

  /**
   * An optional style to apply to the `.md-list-tile`.
   */
  tileStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to the `.md-list-tile`.
   */
  tileClassName: _propTypes2.default.string,

  /**
   * The primary text to display in the `ListItemControl`. The `primaryAction` or
   * `secondaryAction` will end up getting the `label` prop injected into it with
   * a combination of the `primaryText` and `secondaryText`. If the `primaryAction`
   * or `secondaryAction` already have a label prop, the `label` prop will be used
   * as the `primaryText`.
   */
  primaryText: _propTypes2.default.node,

  /**
   * An optional secondary text that can be displayed in the label of the `primaryAction`
   * or `secondaryAction`.
   */
  secondaryText: _propTypes2.default.node,

  /**
   * Boolean if the primary and secondary text will span three lines.
   */
  threeLines: _propTypes2.default.bool,

  /**
   * The primary action of the `ListItemControl`. This _should_ normally
   * be a type of `SelectionControl`
   */
  primaryAction: _propTypes2.default.element,

  /**
   * The secondary action of the `ListItemControl`. This _should_ normally
   * be a type of `SelectionControl`. If it is a selection control,
   * make sure to add the `labelBefore` prop to get correct positioning.
   */
  secondaryAction: _propTypes2.default.element,

  /**
   * An optional `FontIcon` to display to the left of the action.
   */
  leftIcon: _propTypes2.default.node,

  /**
   * An optional `Avatar` to display to the left of the action.
   */
  leftAvatar: _propTypes2.default.node,

  /**
   * An optional `FontIcon` to display to the right of the action.
   */
  rightIcon: _propTypes2.default.node,

  /**
   * An optional `FontIcon` to display to the right of the action.
   */
  rightAvatar: _propTypes2.default.node,

  /**
   * Defines the number of items in the list. This is only required when all items in the
   * list are not present in the DOM.
   *
   * @see https://www.w3.org/TR/wai-aria/states_and_properties#aria-setsize
   */
  'aria-setsize': _propTypes2.default.number,

  /**
   * Defines the items position in the list. This is only required when all items in the list
   * are not present in the DOM. The custom validation just requires this prop if the `aria-setsize`
   * prop is defined as a helpful reminder.
   *
   * @see https://www.w3.org/TR/wai-aria/states_and_properties#aria-posinset
   */
  'aria-posinset': function ariaPosinset(props, propName) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var validator = _propTypes2.default.number;
    if (typeof props['aria-setsize'] !== 'undefined') {
      validator = validator.isRequired;
    }

    return validator.apply(undefined, [props, propName].concat(args));
  }
};
exports.default = ListItemControl;

/***/ }),

/***/ "sd4F":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = controlled;

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Validates the a component is fully controlled or uncontrolled.  If the given prop is not
 * `undefined`, it will check if the `funcName` is defined and a function. A missing function
 * will generate an error similar to the built-in React controlled validation message.
 *
 * @param {String} funcName - The function name to use for additional validation.
 * @param {function} validator - The PropTypes validator to use for the given prop.
 * @return {Error} an error or null.
 */
function controlled(validator, funcName) {
  var fallbackPropName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'defaultValue';

  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      args[_key - 5] = arguments[_key];
    }

    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
    if (!err && typeof props[propName] !== 'undefined' && !props.readOnly && !props.disabled) {
      var _PropTypes$func;

      var funcError = (_PropTypes$func = _propTypes2.default.func).isRequired.apply(_PropTypes$func, [props, funcName, componentName, location, propFullName].concat(args));
      if (funcError) {
        err = new Error('You provided a `' + propFullNameSafe + '` ' + location + ' to the ' + componentNameSafe + ' without a ' + ('`' + funcName + '` handler. This will render a read only field. Set either the `' + funcName + '` ') + ('or use the `' + fallbackPropName + '` instead.'));
      }
    }

    return err;
  };
} /** @module utils/PropTypes/controlled */

/***/ }),

/***/ "snpA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _TransitionGroup = __webpack_require__("kFlJ");

var _TransitionGroup2 = _interopRequireDefault(_TransitionGroup);

var _CSSTransitionGroupChild = __webpack_require__("MdvH");

var _CSSTransitionGroupChild2 = _interopRequireDefault(_CSSTransitionGroupChild);

var _PropTypes = __webpack_require__("8JTt");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
  transitionName: _PropTypes.nameShape.isRequired,

  transitionAppear: _propTypes2.default.bool,
  transitionEnter: _propTypes2.default.bool,
  transitionLeave: _propTypes2.default.bool,
  transitionAppearTimeout: (0, _PropTypes.transitionTimeout)('Appear'),
  transitionEnterTimeout: (0, _PropTypes.transitionTimeout)('Enter'),
  transitionLeaveTimeout: (0, _PropTypes.transitionTimeout)('Leave')
};

var defaultProps = {
  transitionAppear: false,
  transitionEnter: true,
  transitionLeave: true
};

var CSSTransitionGroup = function (_React$Component) {
  _inherits(CSSTransitionGroup, _React$Component);

  function CSSTransitionGroup() {
    var _temp, _this, _ret;

    _classCallCheck(this, CSSTransitionGroup);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this._wrapChild = function (child) {
      return _react2.default.createElement(_CSSTransitionGroupChild2.default, {
        name: _this.props.transitionName,
        appear: _this.props.transitionAppear,
        enter: _this.props.transitionEnter,
        leave: _this.props.transitionLeave,
        appearTimeout: _this.props.transitionAppearTimeout,
        enterTimeout: _this.props.transitionEnterTimeout,
        leaveTimeout: _this.props.transitionLeaveTimeout
      }, child);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  // We need to provide this childFactory so that
  // ReactCSSTransitionGroupChild can receive updates to name, enter, and
  // leave while it is leaving.


  CSSTransitionGroup.prototype.render = function render() {
    return _react2.default.createElement(_TransitionGroup2.default, _extends({}, this.props, { childFactory: this._wrapChild }));
  };

  return CSSTransitionGroup;
}(_react2.default.Component);

CSSTransitionGroup.displayName = 'CSSTransitionGroup';


CSSTransitionGroup.propTypes =  false ? undefined : {};
CSSTransitionGroup.defaultProps = defaultProps;

exports.default = CSSTransitionGroup;
module.exports = exports['default'];

/***/ }),

/***/ "so/P":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__("lphy");
var util = __webpack_require__("wjI5");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__("UKnr");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "t1Fj":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/** @module Helpers/VerticalAnchors */

/**
 * An enum for all the different types of horizontal anchors on a layover.
 *
 * @readonly
 * @enum {string}
 */
var VerticalAnchors = {
  /**
   * Positions the layover to be placed over the toggle component so that
   * it will never overlay the toggle component.
   */
  TOP: 'top',

  /**
   * Positions the layover so that it will be centered over the toggle component
   * based on the layover's height.
   */
  CENTER: 'center',

  /**
   * Positions the layover so that it will overlap the toggle component by
   * fixing to the top of the toggle.
   */
  OVERLAP: 'overlap',

  /**
   * Positions the layover to be placed below the toggle component so that
   * it will never overlay the toggle component.
   */
  BOTTOM: 'bottom'
};

exports.default = VerticalAnchors;

/***/ }),

/***/ "tvHm":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = __webpack_require__("mXGw");

var _default = (0, _react.createContext)(null);

exports.default = _default;

/***/ }),

/***/ "uLv/":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/** @module Helpers/HorizontalAnchors */

/**
 * An enum for all the different types of horizontal anchors on a layover.
 *
 * @readonly
 * @enum {string}
 */
var HorizontalAnchors = {
  /**
   * Positions the layover to the outside left on the toggle component
   * so that it does not overlap.
   */
  LEFT: 'left',

  /**
   * Positions the layover to the inner left of the toggle component so
   * that it will overlap.
   */
  INNER_LEFT: 'inner left',

  /**
   * Positions the layover so that it overlaps the toggle component
   * by positioning itself in the cetner of the toggle component's width.
   */
  CENTER: 'center',

  /**
   * Positions the layover to the outside right on the toggle component
   * so that it does not overlap.
   */
  RIGHT: 'right',

  /**
   * Positions the layover to the outside right on the toggle component
   * so that it will overlap.
   */
  INNER_RIGHT: 'inner right'
};

exports.default = HorizontalAnchors;

/***/ }),

/***/ "uUj8":
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__("WI9V");

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "uo0B":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "v1MJ":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "vMIC":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _themeColors = __webpack_require__("VZNk");

var _themeColors2 = _interopRequireDefault(_themeColors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ICON_SIZE = 24;

/**
 * The \`FontIcon\` component is used for rendering a font-icon library's
 * icon. The default is to use the `material-icons` library, but others
 * can be used as well.
 *
 * If you are using another font-icon library that does not always create
 * icons with a perfect 1:1 scale (such as font-awesome), it is recommended
 * to update the `.md-icon` styles to set the width and height to `$md-font-icon-size`.
 * However, this will prevent different sided icons.
 *
 * ```scss
 * .md-icon.fa {
 *   height: $md-font-icon-size;
 *   width: $md-font-icon-size;
 * }
 * ```
 */

var FontIcon = function (_PureComponent) {
  _inherits(FontIcon, _PureComponent);

  function FontIcon(props) {
    _classCallCheck(this, FontIcon);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this));

    _initialiseProps.call(_this);

    _this.state = { styles: _this._mergeStyles(props) };
    return _this;
  }

  FontIcon.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _props = this.props,
        style = _props.style,
        forceSize = _props.forceSize,
        forceFontSize = _props.forceFontSize;

    if (style !== nextProps.style || forceSize !== nextProps.forceSize || forceFontSize !== nextProps.forceFontSize) {
      this.setState({ styles: this._mergeStyles(nextProps) });
    }
  };

  FontIcon.prototype.render = function render() {
    var styles = this.state.styles;

    var _props2 = this.props,
        iconClassName = _props2.iconClassName,
        className = _props2.className,
        children = _props2.children,
        disabled = _props2.disabled,
        primary = _props2.primary,
        secondary = _props2.secondary,
        error = _props2.error,
        inherit = _props2.inherit,
        style = _props2.style,
        forceSize = _props2.forceSize,
        forceFontSize = _props2.forceFontSize,
        props = _objectWithoutProperties(_props2, ['iconClassName', 'className', 'children', 'disabled', 'primary', 'secondary', 'error', 'inherit', 'style', 'forceSize', 'forceFontSize']);

    var classes = (0, _classnames2.default)('md-icon', iconClassName, (0, _themeColors2.default)({
      disabled: disabled,
      error: error,
      inherit: inherit,
      primary: primary,
      secondary: secondary
    }), className);

    return _react2.default.createElement(
      'i',
      _extends({}, props, { style: styles, className: classes }),
      children
    );
  };

  return FontIcon;
}(_react.PureComponent);

FontIcon.propTypes = {
  /**
   * An optional style to apply.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply to the `FontIcon`.
   */
  className: _propTypes2.default.string,

  /**
   * The icon font library className to use to display the icon.
   */
  iconClassName: _propTypes2.default.string.isRequired,

  /**
   * Boolean if the primary theme color should be applied.
   */
  primary: _propTypes2.default.bool,

  /**
   * Boolean if the secondary theme color should be applied.
   */
  secondary: _propTypes2.default.bool,

  /**
   * Boolean if the icon is considered disabled and should inherit the
   * disabled color.
   */
  disabled: _propTypes2.default.bool,

  /**
   * Boolean if the error color should be applied to the icon.
   */
  error: _propTypes2.default.bool,

  /**
   * Boolean if the color of the icon should be inherited by parent elements.
   */
  inherit: _propTypes2.default.bool,

  /**
   * Either a boolean that will enforce the 24x24 size of the font icon or a number of the size
   * to enforce. This is useful when using other font icon libraries that do not have a consistent
   * size.
   */
  forceSize: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.number]),

  /**
   * Boolean if the `forceSize` prop should also force the `font-size` instead of only `width` and `height`.
   */
  forceFontSize: function forceFontSize(props, propName, component) {
    for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    var error = _propTypes2.default.bool.apply(_propTypes2.default, [props, propName, component].concat(args));
    if (!error && typeof props.forceSize === 'undefined' && props[propName]) {
      error = new Error('You provided a `forceFontSize` prop to the ' + component + ' component, without specifying the `forceSize` ' + ('prop. Either set the `forceSize` prop to a boolean or a number, or disable `' + propName + '`.'));
    }

    return error;
  },

  /**
   * Any children required to display the icon with the font library.
   */
  children: _propTypes2.default.node
};
FontIcon.defaultProps = {
  iconClassName: 'material-icons'
};

var _initialiseProps = function _initialiseProps() {
  this._mergeStyles = function (_ref) {
    var style = _ref.style,
        forceSize = _ref.forceSize,
        forceFontSize = _ref.forceFontSize;

    var styles = style;
    if (typeof forceSize === 'boolean') {
      styles = _extends({
        height: ICON_SIZE,
        width: ICON_SIZE,
        fontSize: forceFontSize ? ICON_SIZE : undefined
      }, style);
    } else if (typeof forceSize === 'number') {
      styles = _extends({
        height: forceSize,
        width: forceSize,
        fontSize: forceFontSize ? forceSize : undefined
      }, style);
    }

    return styles;
  };
};

exports.default = FontIcon;

/***/ }),

/***/ "vMVM":
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__("jgJv");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "vPRa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `IconSeparator` component is a simple helper component to render some text and
 * an icon with some space between them while centering the text. The icon can either
 * come before or after the text.
 */
var IconSeparator = function (_PureComponent) {
  _inherits(IconSeparator, _PureComponent);

  function IconSeparator() {
    _classCallCheck(this, IconSeparator);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  IconSeparator.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        labelStyle = _props.labelStyle,
        labelClassName = _props.labelClassName,
        component = _props.component,
        label = _props.label,
        iconBefore = _props.iconBefore,
        children = _props.children,
        props = _objectWithoutProperties(_props, ['className', 'labelStyle', 'labelClassName', 'component', 'label', 'iconBefore', 'children']);

    var text = void 0;
    if ((0, _react.isValidElement)(label)) {
      var labelProps = _react.Children.only(label).props;
      text = (0, _react.cloneElement)(label, {
        className: (0, _classnames2.default)('md-icon-text', labelClassName, labelProps.className),
        style: _extends({}, labelStyle, labelProps.style)
      });
    } else {
      text = _react2.default.createElement(
        'span',
        { style: labelStyle, className: (0, _classnames2.default)('md-icon-text', labelClassName) },
        label
      );
    }

    var Component = component;

    return _react2.default.createElement(
      Component,
      _extends({}, props, { className: (0, _classnames2.default)('md-icon-separator', className) }),
      iconBefore && children,
      text,
      !iconBefore && children
    );
  };

  return IconSeparator;
}(_react.PureComponent);

IconSeparator.propTypes = {
  /**
   * An optional style to apply.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply.
   */
  className: _propTypes2.default.string,

  /**
   * An optional style to apply to the label.
   */
  labelStyle: _propTypes2.default.object,

  /**
   * An optional className to apply to the label.
   */
  labelClassName: _propTypes2.default.string,

  /**
   * The label to display.
   */
  label: _propTypes2.default.node.isRequired,

  /**
   * The icon to display.
   */
  children: _propTypes2.default.node.isRequired,

  /**
   * Boolean if the icon should appear before or after the text
   */
  iconBefore: _propTypes2.default.bool,

  /**
   * The component to be rendered as.
   */
  component: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]).isRequired
};
IconSeparator.defaultProps = {
  component: 'div'
};
exports.default = IconSeparator;

/***/ }),

/***/ "vQGw":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("Qt3m");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = computeIndex;

var _react = _interopRequireDefault(__webpack_require__("mXGw"));

var _constant = _interopRequireDefault(__webpack_require__("EK6g"));

function computeIndex(params) {
  var children = params.children,
      startIndex = params.startIndex,
      startX = params.startX,
      pageX = params.pageX,
      viewLength = params.viewLength,
      resistance = params.resistance;
  var indexMax = _react.default.Children.count(children) - 1;
  var index = startIndex + (startX - pageX) / viewLength;
  var newStartX;

  if (!resistance) {
    // Reset the starting point
    if (index < 0) {
      index = 0;
      newStartX = (index - startIndex) * viewLength + pageX;
    } else if (index > indexMax) {
      index = indexMax;
      newStartX = (index - startIndex) * viewLength + pageX;
    }
  } else if (index < 0) {
    index = Math.exp(index * _constant.default.RESISTANCE_COEF) - 1;
  } else if (index > indexMax) {
    index = indexMax + 1 - Math.exp((indexMax - index) * _constant.default.RESISTANCE_COEF);
  }

  return {
    index: index,
    startX: newStartX
  };
}

/***/ }),

/***/ "vRn4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__("vdEC");

var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__("RiSW"));

var _typeof2 = _interopRequireDefault(__webpack_require__("e+GP"));

var _regenerator = _interopRequireDefault(__webpack_require__("NthX"));

var _objectSpread2 = _interopRequireDefault(__webpack_require__("gki9"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__("fFdx"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _makeEventProps = _interopRequireDefault(__webpack_require__("1QXF"));

var _mergeClassNames = _interopRequireDefault(__webpack_require__("nZ0h"));

var _pdfjsDist = _interopRequireWildcard(__webpack_require__("g93O"));

var _DocumentContext = _interopRequireDefault(__webpack_require__("tvHm"));

var _Message = _interopRequireDefault(__webpack_require__("pb74"));

var _LinkService = _interopRequireDefault(__webpack_require__("o9tr"));

var _PasswordResponses = _interopRequireDefault(__webpack_require__("Vzoa"));

var _utils = __webpack_require__("YliN");

var _propTypes2 = __webpack_require__("T5tG");

/**
 * Loads a PDF document. Passes it to all children.
 */
var Document =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(Document, _PureComponent);

  function Document() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, Document);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Document)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "state", {
      pdf: null
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "viewer", {
      scrollPageIntoView: function scrollPageIntoView(_ref) {
        var pageNumber = _ref.pageNumber;
        // Handling jumping to internal links target
        var onItemClick = _this.props.onItemClick; // First, check if custom handling of onItemClick was provided

        if (onItemClick) {
          onItemClick({
            pageNumber: pageNumber
          });
          return;
        } // If not, try to look for target page within the <Document>.


        var page = _this.pages[pageNumber - 1];

        if (page) {
          // Scroll to the page automatically
          page.scrollIntoView();
          return;
        }

        (0, _utils.warnOnDev)("Warning: An internal link leading to page ".concat(pageNumber, " was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>."));
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "linkService", new _LinkService.default());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "loadDocument",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      var source, _this$props, options, onLoadProgress, onPassword, loadingTask, cancellable, pdf;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              source = null;
              _context.prev = 1;
              _context.next = 4;
              return _this.findDocumentSource();

            case 4:
              source = _context.sent;

              _this.onSourceSuccess();

              _context.next = 11;
              break;

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](1);

              _this.onSourceError(_context.t0);

            case 11:
              if (source) {
                _context.next = 13;
                break;
              }

              return _context.abrupt("return");

            case 13:
              _this.setState(function (prevState) {
                if (!prevState.pdf) {
                  return null;
                }

                return {
                  pdf: null
                };
              });

              _this$props = _this.props, options = _this$props.options, onLoadProgress = _this$props.onLoadProgress, onPassword = _this$props.onPassword;
              _context.prev = 15;
              // If another loading is in progress, let's cancel it
              (0, _utils.cancelRunningTask)(_this.runningTask);
              loadingTask = _pdfjsDist.default.getDocument((0, _objectSpread2.default)({}, source, options));
              loadingTask.onPassword = onPassword;

              if (onLoadProgress) {
                loadingTask.onProgress = onLoadProgress;
              }

              cancellable = (0, _utils.makeCancellable)(loadingTask.promise);
              _this.runningTask = cancellable;
              _context.next = 24;
              return cancellable.promise;

            case 24:
              pdf = _context.sent;

              _this.setState(function (prevState) {
                if (prevState.pdf && prevState.pdf.fingerprint === pdf.fingerprint) {
                  return null;
                }

                return {
                  pdf: pdf
                };
              }, _this.onLoadSuccess);

              _context.next = 31;
              break;

            case 28:
              _context.prev = 28;
              _context.t1 = _context["catch"](15);

              _this.onLoadError(_context.t1);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 8], [15, 28]]);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "setupLinkService", function () {
      _this.linkService.setViewer(_this.viewer);

      var documentInstance = (0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this));
      Object.defineProperty(_this.linkService, 'externalLinkTarget', {
        get: function get() {
          var externalLinkTarget = documentInstance.props.externalLinkTarget;

          switch (externalLinkTarget) {
            case '_self':
              return 1;

            case '_blank':
              return 2;

            case '_parent':
              return 3;

            case '_top':
              return 4;

            default:
              return 0;
          }
        }
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onSourceSuccess", function () {
      var onSourceSuccess = _this.props.onSourceSuccess;
      (0, _utils.callIfDefined)(onSourceSuccess);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onSourceError", function (error) {
      if ((0, _utils.isCancelException)(error)) {
        return;
      }

      (0, _utils.errorOnDev)(error);
      var onSourceError = _this.props.onSourceError;
      (0, _utils.callIfDefined)(onSourceError, error);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadSuccess", function () {
      var onLoadSuccess = _this.props.onLoadSuccess;
      var pdf = _this.state.pdf;
      (0, _utils.callIfDefined)(onLoadSuccess, pdf);
      _this.pages = new Array(pdf.numPages);

      _this.linkService.setDocument(pdf);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadError", function (error) {
      if ((0, _utils.isCancelException)(error)) {
        return;
      }

      _this.setState({
        pdf: false
      });

      (0, _utils.errorOnDev)(error);
      var onLoadError = _this.props.onLoadError;
      (0, _utils.callIfDefined)(onLoadError, error);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "findDocumentSource",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee2() {
      var file, fileUint8Array, url, otherParams, _fileUint8Array;

      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              file = _this.props.file;

              if (file) {
                _context2.next = 3;
                break;
              }

              return _context2.abrupt("return", null);

            case 3:
              if (!(typeof file === 'string')) {
                _context2.next = 9;
                break;
              }

              if (!(0, _utils.isDataURI)(file)) {
                _context2.next = 7;
                break;
              }

              fileUint8Array = (0, _utils.dataURItoUint8Array)(file);
              return _context2.abrupt("return", {
                data: fileUint8Array
              });

            case 7:
              (0, _utils.displayCORSWarning)();
              return _context2.abrupt("return", {
                url: file
              });

            case 9:
              if (!(file instanceof _pdfjsDist.PDFDataRangeTransport)) {
                _context2.next = 11;
                break;
              }

              return _context2.abrupt("return", {
                range: file
              });

            case 11:
              if (!(0, _utils.isArrayBuffer)(file)) {
                _context2.next = 13;
                break;
              }

              return _context2.abrupt("return", {
                data: file
              });

            case 13:
              if (!_utils.isBrowser) {
                _context2.next = 19;
                break;
              }

              if (!((0, _utils.isBlob)(file) || (0, _utils.isFile)(file))) {
                _context2.next = 19;
                break;
              }

              _context2.next = 17;
              return (0, _utils.loadFromFile)(file);

            case 17:
              _context2.t0 = _context2.sent;
              return _context2.abrupt("return", {
                data: _context2.t0
              });

            case 19:
              if (!((0, _typeof2.default)(file) !== 'object')) {
                _context2.next = 21;
                break;
              }

              throw new Error('Invalid parameter in file, need either Uint8Array, string or a parameter object');

            case 21:
              if (!(!file.url && !file.data && !file.range)) {
                _context2.next = 23;
                break;
              }

              throw new Error('Invalid parameter object: need either .data, .range or .url');

            case 23:
              if (!(typeof file.url === 'string')) {
                _context2.next = 29;
                break;
              }

              if (!(0, _utils.isDataURI)(file.url)) {
                _context2.next = 28;
                break;
              }

              url = file.url, otherParams = (0, _objectWithoutProperties2.default)(file, ["url"]);
              _fileUint8Array = (0, _utils.dataURItoUint8Array)(url);
              return _context2.abrupt("return", (0, _objectSpread2.default)({
                data: _fileUint8Array
              }, otherParams));

            case 28:
              (0, _utils.displayCORSWarning)();

            case 29:
              return _context2.abrupt("return", file);

            case 30:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "registerPage", function (pageIndex, ref) {
      _this.pages[pageIndex] = ref;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "unregisterPage", function (pageIndex) {
      delete _this.pages[pageIndex];
    });
    return _this;
  }

  (0, _createClass2.default)(Document, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.loadDocument();
      this.setupLinkService();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var file = this.props.file;

      if (file !== prevProps.file) {
        this.loadDocument();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      (0, _utils.cancelRunningTask)(this.runningTask);
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var children = this.props.children;
      return _react.default.createElement(_DocumentContext.default.Provider, {
        value: this.childContext
      }, children);
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var file = this.props.file;
      var pdf = this.state.pdf;

      if (!file) {
        var noData = this.props.noData;
        return _react.default.createElement(_Message.default, {
          type: "no-data"
        }, typeof noData === 'function' ? noData() : noData);
      }

      if (pdf === null) {
        var loading = this.props.loading;
        return _react.default.createElement(_Message.default, {
          type: "loading"
        }, typeof loading === 'function' ? loading() : loading);
      }

      if (pdf === false) {
        var error = this.props.error;
        return _react.default.createElement(_Message.default, {
          type: "error"
        }, typeof error === 'function' ? error() : error);
      }

      return this.renderChildren();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          className = _this$props2.className,
          inputRef = _this$props2.inputRef;
      return _react.default.createElement("div", (0, _extends2.default)({
        className: (0, _mergeClassNames.default)('react-pdf__Document', className),
        ref: inputRef
      }, this.eventProps), this.renderContent());
    }
  }, {
    key: "childContext",
    get: function get() {
      var linkService = this.linkService,
          registerPage = this.registerPage,
          unregisterPage = this.unregisterPage;
      var _this$props3 = this.props,
          renderMode = _this$props3.renderMode,
          rotate = _this$props3.rotate;
      var pdf = this.state.pdf;
      return {
        linkService: linkService,
        pdf: pdf,
        registerPage: registerPage,
        renderMode: renderMode,
        rotate: rotate,
        unregisterPage: unregisterPage
      };
    }
  }, {
    key: "eventProps",
    get: function get() {
      var _this2 = this;

      // eslint-disable-next-line react/destructuring-assignment
      return (0, _makeEventProps.default)(this.props, function () {
        return _this2.state.pdf;
      });
    }
    /**
     * Called when a document source is resolved correctly
     */

  }]);
  return Document;
}(_react.PureComponent);

exports.default = Document;
Document.defaultProps = {
  error: 'Failed to load PDF file.',
  loading: 'Loading PDF…',
  noData: 'No PDF file specified.',
  onPassword: function onPassword(callback, reason) {
    switch (reason) {
      case _PasswordResponses.default.NEED_PASSWORD:
        {
          // eslint-disable-next-line no-alert
          var password = prompt('Enter the password to open this PDF file.');
          callback(password);
          break;
        }

      case _PasswordResponses.default.INCORRECT_PASSWORD:
        {
          // eslint-disable-next-line no-alert
          var _password = prompt('Invalid password. Please try again.');

          callback(_password);
          break;
        }

      default:
    }
  }
};
Document.propTypes = (0, _objectSpread2.default)({
  children: _propTypes.default.node,
  className: _propTypes2.isClassName,
  error: _propTypes.default.node,
  file: _utils.isFile,
  inputRef: _propTypes.default.func,
  loading: _propTypes.default.node,
  noData: _propTypes.default.node,
  onItemClick: _propTypes.default.func,
  onLoadError: _propTypes.default.func,
  onLoadProgress: _propTypes.default.func,
  onLoadSuccess: _propTypes.default.func,
  onPassword: _propTypes.default.func,
  onSourceError: _propTypes.default.func,
  onSourceSuccess: _propTypes.default.func,
  rotate: _propTypes.default.number
}, (0, _propTypes2.eventsProps)());

/***/ }),

/***/ "vdEC":
/***/ (function(module, exports) {

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "w/sC":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/** @module Helpers/Positions */

/**
 * An enum for all the animation positions for a layover appearing.
 *
 * @readonly
 * @enum {string}
 */
var Positions = {
  /**
   * The layover will appear by transitioning from the top left and expand
   * down right.
   */
  TOP_LEFT: 'tl',

  /**
   * The layover will appear by transitioning from the top right and expand
   * down left.
   */
  TOP_RIGHT: 'tr',

  /**
   * The layover will appear by transitioning from the bottom left and expand
   * top right.
   */
  BOTTOM_LEFT: 'bl',

  /**
   * The layover will appear by transitioning from the bottom right and expand
   * top left.
   */
  BOTTOM_RIGHT: 'br',

  /**
   * The layover will appear by just transitioning downwards from the bottom
   * of the toggle component.
   */
  BELOW: 'below'
};

exports.default = Positions;

/***/ }),

/***/ "wHgh":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = handleWindowClickListeners;
/** @module utils/EventUtils/handleWindowClickListeners */
var mobileSafari = void 0;

/**
 * Since mobile safari doesn't delegate click events to the window (it only does touch events),
 * this utility function will hack a fix to allow the delegation by updaging the body's cursor
 * to be a pointer.
 *
 * Hopefully this can be removed one day....
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Events/click#Safari_Mobile
 * @param {function} cb - the callback function to use for a window click event.
 * @param {boolean} enabled - boolean if the click event is enabled.
 */
function handleWindowClickListeners(cb) {
  var enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (typeof mobileSafari === 'undefined' && typeof window !== 'undefined') {
    var ua = window.navigator.userAgent;
    var iOS = ua.match(/iP(ad|hone)/i);
    var webkit = ua.match(/WebKit/i);
    mobileSafari = iOS && webkit && !ua.match(/CriOS/i);

    if (mobileSafari) {
      document.body.style.cursor = 'pointer';
    }
  }

  var listener = window[(enabled ? 'add' : 'remove') + 'EventListener'];
  listener('click', cb);
}

/***/ }),

/***/ "wMFK":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

var _Motion = __webpack_require__("8Tgy");

exports.Motion = _interopRequire(_Motion);

var _StaggeredMotion = __webpack_require__("BF0r");

exports.StaggeredMotion = _interopRequire(_StaggeredMotion);

var _TransitionMotion = __webpack_require__("rY4S");

exports.TransitionMotion = _interopRequire(_TransitionMotion);

var _spring = __webpack_require__("qJif");

exports.spring = _interopRequire(_spring);

var _presets = __webpack_require__("PogH");

exports.presets = _interopRequire(_presets);

var _stripStyle = __webpack_require__("jL08");

exports.stripStyle = _interopRequire(_stripStyle);

// deprecated, dummy warning function

var _reorderKeys = __webpack_require__("knJb");

exports.reorderKeys = _interopRequire(_reorderKeys);

/***/ }),

/***/ "wc4P":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getChildMapping = getChildMapping;
exports.mergeChildMappings = mergeChildMappings;
exports.getInitialChildMapping = getInitialChildMapping;
exports.getNextChildMapping = getNextChildMapping;

var _react = __webpack_require__("mXGw");

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */
function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) _react.Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */


function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return (0, _react.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}

function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!(0, _react.isValidElement)(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = (0, _react.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

/***/ }),

/***/ "wjI5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "wp+c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.shape({
  x: _propTypes2.default.object,
  y: _propTypes2.default.object
})]);

/***/ }),

/***/ "wvQ6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__("xARA");

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _deprecated = __webpack_require__("PioW");

var _deprecated2 = _interopRequireDefault(_deprecated);

var _getField = __webpack_require__("iouw");

var _getField2 = _interopRequireDefault(_getField);

var _fixedToShape = __webpack_require__("wp+c");

var _fixedToShape2 = _interopRequireDefault(_fixedToShape);

var _Subheaders = __webpack_require__("j5Ak");

var _Subheaders2 = _interopRequireDefault(_Subheaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Lists present multiple line items vertically as a single continuous element.
 */
var List = function (_PureComponent) {
  _inherits(List, _PureComponent);

  function List() {
    var _temp, _this, _ret;

    _classCallCheck(this, List);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = {}, _temp), _possibleConstructorReturn(_this, _ret);
  }

  List.prototype.getChildContext = function getChildContext() {
    var _context = this.context,
        listLevel = _context.listLevel,
        context = _objectWithoutProperties(_context, ['listLevel']);

    var cascadingFixedTo = (0, _getField2.default)(this.state, this.context, 'cascadingFixedTo');
    return _extends({}, context, {
      cascadingFixedTo: cascadingFixedTo,
      listLevel: typeof listLevel === 'undefined' ? 1 : listLevel + 1
    });
  };

  List.prototype.componentDidMount = function componentDidMount() {
    if (this.context.cascadingMenu) {
      var list = (0, _reactDom.findDOMNode)(this);
      if (list.offsetHeight < list.scrollHeight) {
        var cascadingFixedTo = { y: (0, _reactDom.findDOMNode)(this) };
        this.setState({ cascadingFixedTo: cascadingFixedTo }); // eslint-disable-line react/no-did-mount-set-state
      }
    }
  };

  List.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        className = _props.className,
        ordered = _props.ordered,
        children = _props.children,
        subheader = _props.subheader,
        inline = _props.inline,
        primarySubheader = _props.primarySubheader,
        props = _objectWithoutProperties(_props, ['className', 'ordered', 'children', 'subheader', 'inline', 'primarySubheader']);

    var _context2 = this.context,
        cascadingMenu = _context2.cascadingMenu,
        cascadingZDepth = _context2.cascadingZDepth,
        listLevel = _context2.listLevel;


    var subheaderEl = void 0;
    if (subheader) {
      subheaderEl = _react2.default.createElement(_Subheaders2.default, { key: 'subheader', primaryText: subheader, primary: primarySubheader });
    }

    var Component = ordered ? 'ol' : 'ul';
    return _react2.default.createElement(
      Component,
      _extends({}, props, {
        className: (0, _classnames2.default)('md-list', (_cn = {
          'md-list--inline': inline,
          'md-list--menu-cascading': cascadingMenu
        }, _cn['md-paper md-paper--' + cascadingZDepth] = cascadingZDepth && cascadingMenu && listLevel > 0, _cn['md-list--nested-' + listLevel] = listLevel && !cascadingMenu, _cn), className)
      }),
      subheaderEl,
      children
    );
  };

  return List;
}(_react.PureComponent);

List.propTypes = {
  /**
   * An optional style to apply to the list.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply to the list.
   */
  className: _propTypes2.default.string,

  /**
   * Boolean if this should be an ordered list (`<ol>`) component. Otherwise, it will
   * be rendered as `<ul>`.
   */
  ordered: _propTypes2.default.bool,

  /**
   * This *should* be a list of `ListItem`, `ListItemControl`, `Divider`, or
   * `Subheader`.
   */
  children: _propTypes2.default.node,

  /**
   * Boolean if the list should appear horizontally instead of vertically.
   */
  inline: _propTypes2.default.bool,
  subheader: (0, _deprecated2.default)(_propTypes2.default.string, 'Use the `Subheader` component as a child instead'),
  primarySubheader: (0, _deprecated2.default)(_propTypes2.default.bool, 'Use the `Subheader` component as a child instead')
};
List.childContextTypes = {
  listLevel: _propTypes2.default.number,
  cascadingMenu: _propTypes2.default.bool,
  cascadingFixedTo: _fixedToShape2.default,
  cascadingZDepth: _propTypes2.default.number
};
List.contextTypes = {
  listLevel: _propTypes2.default.number,
  cascadingMenu: _propTypes2.default.bool,
  cascadingFixedTo: _fixedToShape2.default,
  cascadingZDepth: _propTypes2.default.number
};
exports.default = List;

/***/ }),

/***/ "xARA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__("9t1y");
} else {}


/***/ }),

/***/ "xHj8":
/***/ (function(module, exports) {


module.exports = function chain(){
  var len = arguments.length
  var args = [];

  for (var i = 0; i < len; i++)
    args[i] = arguments[i]

  args = args.filter(function(fn){ return fn != null })

  if (args.length === 0) return undefined
  if (args.length === 1) return args[0]

  return args.reduce(function(current, next){
    return function chainedFunction() {
      current.apply(this, arguments);
      next.apply(this, arguments);
    };
  })
}


/***/ }),

/***/ "yALM":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _componentDeprecated = __webpack_require__("9/Bt");

var _componentDeprecated2 = _interopRequireDefault(_componentDeprecated);

var _IconButton = __webpack_require__("ZVcq");

var _IconButton2 = _interopRequireDefault(_IconButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A `FloatingButton` is an extension of the `IconButton`.
 * A tooltip can be displayed on hover or touch hold if the
 * `tooltipLabel` prop is given.
 *
 * Another name for this button is a `FloatingActionButton` (FAB).
 *
 * Any other props (such as style or event listeners) will also be
 * applied.
 */
var FloatingButton = function (_PureComponent) {
  _inherits(FloatingButton, _PureComponent);

  function FloatingButton() {
    _classCallCheck(this, FloatingButton);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  FloatingButton.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        fixed = _props.fixed,
        mini = _props.mini,
        children = _props.children,
        iconClassName = _props.iconClassName,
        props = _objectWithoutProperties(_props, ['className', 'fixed', 'mini', 'children', 'iconClassName']);

    return _react2.default.createElement(
      _IconButton2.default,
      _extends({}, props, {
        className: (0, _classnames2.default)({
          'md-btn--floating-fixed': fixed,
          'md-btn--floating-mini': mini
        }, className),
        iconClassName: iconClassName,
        floating: true
      }),
      children
    );
  };

  return FloatingButton;
}(_react.PureComponent);

FloatingButton.propTypes = {
  /**
   * The className to use for rendering the `FontIcon`.
   */
  iconClassName: _propTypes2.default.string,

  /**
   * Any children to use to render the `FontIcon`.
   */
  children: _propTypes2.default.node,

  /**
   * An optional className to apply to the button.
   */
  className: _propTypes2.default.string,

  /**
   * The button type.
   */
  type: _propTypes2.default.string,

  /**
   * Boolean if the button is disabled.
   */
  disabled: _propTypes2.default.bool,

  /**
   * An optional href to convert the button into a link button.
   */
  href: _propTypes2.default.string,

  /**
   * An optional function to call when the button is clicked.
   */
  onClick: _propTypes2.default.func,

  /**
   * An optional label to use if you would like a tooltip to display
   * on hover or touch hold.
   */
  tooltipLabel: _propTypes2.default.node,

  /**
   * The position that the tooltip should be displayed relative to
   * the button.
   */
  tooltipPosition: _propTypes2.default.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * An optional amount of delay before the tooltip appears.
   */
  tooltipDelay: _propTypes2.default.number,

  /**
   * Boolean if the floating button is fixed.
   */
  fixed: _propTypes2.default.bool,

  /**
   * Boolean if the floating button should be displayed as the mini
   * version.
   */
  mini: _propTypes2.default.bool,

  /**
   * Boolean if the floating button should be styled with the primary color.
   */
  primary: _propTypes2.default.bool,

  /**
   * Boolean if the floating button should be styled with the secondary color.
   */
  secondary: _propTypes2.default.bool,

  deprecated: (0, _componentDeprecated2.default)('The behavior of the `FloatingButton` can be achieved with the `Button` component ' + 'without the additional bundle size. Switch to the `Button` component and add a ' + 'prop `floating`.')
};
exports.default = FloatingButton;

/***/ }),

/***/ "yVgl":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__("xARA");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var isReact16 = typeof _reactDom.createPortal === 'function';

/**
 * Creates a "Portal" for the children to be rendered in. Basically it will render the
 * children only when the `visible` prop is `true`. When it is visible, a new `component`
 * will be rendered as the first child in the body with the children inside.
 *
 * Unlike all the other components, `style` will not be applied for the `Portal`.
 */

var Portal = function (_PureComponent) {
  _inherits(Portal, _PureComponent);

  function Portal() {
    var _temp, _this, _ret;

    _classCallCheck(this, Portal);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this._container = null, _this._portal = null, _this._applyStyles = function (props) {
      if (props.className) {
        _this._container.className = props.className;
      }
    }, _this._renderPortal = function (props) {
      if (!_this._container) {
        _this._container = document.createElement(props.component);

        _this._applyStyles(props);
        var node = props.renderNode || document.body;
        if (props.lastChild) {
          node.appendChild(_this._container);
        } else {
          node.insertBefore(_this._container, node.firstChild);
        }
      } else {
        _this._applyStyles(props);
      }

      if (!isReact16) {
        _this._portal = (0, _reactDom.unstable_renderSubtreeIntoContainer)(_this, props.children, _this._container);
      }
    }, _this._removePortal = function () {
      if (_this.props.onClose) {
        _this.props.onClose();
      }

      if (_this._container) {
        if (!isReact16) {
          (0, _reactDom.unmountComponentAtNode)(_this._container);
        }

        (_this.props.renderNode || document.body).removeChild(_this._container);
      }

      _this._portal = null;
      _this._container = null;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Portal.prototype.componentDidMount = function componentDidMount() {
    if (this.props.visible) {
      this._renderPortal(this.props);

      if (isReact16) {
        // Need to update after the renderPortal created the DOM element.
        this.forceUpdate();
      }
    }
  };

  Portal.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var visible = nextProps.visible,
        onOpen = nextProps.onOpen;

    if (this.props.visible === visible) {
      if (visible && !isReact16) {
        // Need to just re-render the subtree
        this._renderPortal(nextProps);
      }

      return;
    }

    if (visible) {
      if (onOpen) {
        onOpen();
      }

      this._renderPortal(nextProps);
    } else {
      this._removePortal();
    }
  };

  Portal.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.visible && this.props.onClose) {
      this.props.onClose();
    }
    this._removePortal();
  };

  Portal.prototype.render = function render() {
    var _props = this.props,
        Component = _props.component,
        className = _props.className,
        children = _props.children,
        visible = _props.visible;

    // When doing server side rendering, actually render the component as a direct child of its parent.
    // Once it has been rendered and working client side, it will be removed correctly.

    if (typeof window === 'undefined' && visible) {
      return _react2.default.createElement(
        Component,
        { className: className },
        children
      );
    } else if (isReact16 && visible && this._container && typeof window !== 'undefined') {
      return (0, _reactDom.createPortal)(children, this._container);
    }

    return null;
  };

  return Portal;
}(_react.PureComponent);

Portal.propTypes = {
  /**
   * An optional className to apply to the newly created `component` when visible.
   */
  className: _propTypes2.default.string,

  /**
   * Boolean if the children are visible.
   */
  visible: _propTypes2.default.bool.isRequired,

  /**
   * The children to render when visible.
   */
  children: _propTypes2.default.element,

  /**
   * The component to render as. This should be a valid DOM element.
   */
  component: _propTypes2.default.string.isRequired,

  /**
   * An optional function to call when the portal is opened.
   */
  onOpen: _propTypes2.default.func,

  /**
   * An optional function to call when the portal is closed
   */
  onClose: _propTypes2.default.func,

  /**
   * An optional DOM Node to render the portal into. The default is to render as
   * the first child in the `body`.
   */
  renderNode: _propTypes2.default.object,

  /**
   * Boolean if the portal should render the children as the last child of the `renderNode`
   * or `body` instead of the first.
   */
  lastChild: _propTypes2.default.bool
};
Portal.defaultProps = {
  component: 'span'
};
exports.default = Portal;

/***/ }),

/***/ "yWUr":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__("vdEC");

var _interopRequireDefault = __webpack_require__("63Ad");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AnnotationLayerInternal = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__("8VmE"));

var _regenerator = _interopRequireDefault(__webpack_require__("NthX"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__("fFdx"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__("SDJZ"));

var _createClass2 = _interopRequireDefault(__webpack_require__("NToG"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("K4DB"));

var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__("+IV6"));

var _inherits2 = _interopRequireDefault(__webpack_require__("eef+"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("T1e2"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__("OvAC"));

var _react = _interopRequireWildcard(__webpack_require__("mXGw"));

var _propTypes = _interopRequireDefault(__webpack_require__("W0B4"));

var _pdfjsDist = _interopRequireDefault(__webpack_require__("g93O"));

var _DocumentContext = _interopRequireDefault(__webpack_require__("tvHm"));

var _PageContext = _interopRequireDefault(__webpack_require__("1VGG"));

var _utils = __webpack_require__("YliN");

var _propTypes2 = __webpack_require__("T5tG");

var AnnotationLayerInternal =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(AnnotationLayerInternal, _PureComponent);

  function AnnotationLayerInternal() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, AnnotationLayerInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(AnnotationLayerInternal)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "state", {
      annotations: null
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "loadAnnotations",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      var page, cancellable, annotations;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              page = _this.props.page;
              _context.prev = 1;
              cancellable = (0, _utils.makeCancellable)(page.getAnnotations());
              _this.runningTask = cancellable;
              _context.next = 6;
              return cancellable.promise;

            case 6:
              annotations = _context.sent;

              _this.setState({
                annotations: annotations
              }, _this.onLoadSuccess);

              _context.next = 13;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](1);

              _this.onLoadError(_context.t0);

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 10]]);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadSuccess", function () {
      var onGetAnnotationsSuccess = _this.props.onGetAnnotationsSuccess;
      var annotations = _this.state.annotations;
      (0, _utils.callIfDefined)(onGetAnnotationsSuccess, annotations);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onLoadError", function (error) {
      if ((0, _utils.isCancelException)(error)) {
        return;
      }

      _this.setState({
        annotations: false
      });

      (0, _utils.errorOnDev)(error);
      var onGetAnnotationsError = _this.props.onGetAnnotationsError;
      (0, _utils.callIfDefined)(onGetAnnotationsError, error);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onRenderSuccess", function () {
      var onRenderAnnotationLayerSuccess = _this.props.onRenderAnnotationLayerSuccess;
      (0, _utils.callIfDefined)(onRenderAnnotationLayerSuccess);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onRenderError", function (error) {
      if ((0, _utils.isCancelException)(error)) {
        return;
      }

      (0, _utils.errorOnDev)(error);
      var onRenderAnnotationLayerError = _this.props.onRenderAnnotationLayerError;
      (0, _utils.callIfDefined)(onRenderAnnotationLayerError, error);
    });
    return _this;
  }

  (0, _createClass2.default)(AnnotationLayerInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var page = this.props.page;

      if (!page) {
        throw new Error('Attempted to load page annotations, but no page was specified.');
      }

      this.loadAnnotations();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props = this.props,
          page = _this$props.page,
          renderInteractiveForms = _this$props.renderInteractiveForms;

      if (prevProps.page && page !== prevProps.page || renderInteractiveForms !== prevProps.renderInteractiveForms) {
        this.loadAnnotations();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      (0, _utils.cancelRunningTask)(this.runningTask);
    }
  }, {
    key: "renderAnnotationLayer",
    value: function renderAnnotationLayer() {
      var annotations = this.state.annotations;

      if (!annotations) {
        return;
      }

      var _this$props2 = this.props,
          linkService = _this$props2.linkService,
          page = _this$props2.page,
          renderInteractiveForms = _this$props2.renderInteractiveForms;
      var viewport = this.viewport.clone({
        dontFlip: true
      });
      var parameters = {
        annotations: annotations,
        div: this.annotationLayer,
        linkService: linkService,
        page: page,
        renderInteractiveForms: renderInteractiveForms,
        viewport: viewport
      };
      this.annotationLayer.innerHTML = '';

      try {
        _pdfjsDist.default.AnnotationLayer.render(parameters);

        this.onRenderSuccess();
      } catch (error) {
        this.onRenderError(error);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return _react.default.createElement("div", {
        className: "react-pdf__Page__annotations annotationLayer",
        ref: function ref(_ref2) {
          _this2.annotationLayer = _ref2;
        }
      }, this.renderAnnotationLayer());
    }
  }, {
    key: "viewport",
    get: function get() {
      var _this$props3 = this.props,
          page = _this$props3.page,
          rotate = _this$props3.rotate,
          scale = _this$props3.scale;
      return page.getViewport({
        scale: scale,
        rotation: rotate
      });
    }
  }]);
  return AnnotationLayerInternal;
}(_react.PureComponent);

exports.AnnotationLayerInternal = AnnotationLayerInternal;
AnnotationLayerInternal.propTypes = {
  linkService: _propTypes2.isLinkService.isRequired,
  onGetAnnotationsError: _propTypes.default.func,
  onGetAnnotationsSuccess: _propTypes.default.func,
  onRenderAnnotationLayerError: _propTypes.default.func,
  onRenderAnnotationLayerSuccess: _propTypes.default.func,
  page: _propTypes2.isPage,
  renderInteractiveForms: _propTypes.default.bool,
  rotate: _propTypes2.isRotate,
  scale: _propTypes.default.number
};

var AnnotationLayer = function AnnotationLayer(props) {
  return _react.default.createElement(_DocumentContext.default.Consumer, null, function (documentContext) {
    return _react.default.createElement(_PageContext.default.Consumer, null, function (pageContext) {
      return _react.default.createElement(AnnotationLayerInternal, (0, _extends2.default)({}, documentContext, pageContext, props));
    });
  });
};

var _default = AnnotationLayer;
exports.default = _default;

/***/ }),

/***/ "yvDY":
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "z10u":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _themeColors = __webpack_require__("VZNk");

var _themeColors2 = _interopRequireDefault(_themeColors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `ListItemText` component is used to render the `primaryText` and an optional
 * `secondaryText` for a `ListItem`.
 */
var ListItemText = function (_PureComponent) {
  _inherits(ListItemText, _PureComponent);

  function ListItemText() {
    _classCallCheck(this, ListItemText);

    return _possibleConstructorReturn(this, _PureComponent.apply(this, arguments));
  }

  ListItemText.prototype.render = function render() {
    var _cn;

    var _props = this.props,
        active = _props.active,
        activeClassName = _props.activeClassName,
        disabled = _props.disabled,
        primaryText = _props.primaryText,
        primaryTextStyle = _props.primaryTextStyle,
        primaryTextClassName = _props.primaryTextClassName,
        secondaryText = _props.secondaryText,
        secondaryTextStyle = _props.secondaryTextStyle,
        secondaryTextClassName = _props.secondaryTextClassName,
        className = _props.className,
        threeLines = _props.threeLines,
        props = _objectWithoutProperties(_props, ['active', 'activeClassName', 'disabled', 'primaryText', 'primaryTextStyle', 'primaryTextClassName', 'secondaryText', 'secondaryTextStyle', 'secondaryTextClassName', 'className', 'threeLines']);

    var secondaryTextNode = void 0;
    if (secondaryText) {
      secondaryTextNode = _react2.default.createElement(
        'div',
        {
          style: secondaryTextStyle,
          className: (0, _classnames2.default)('md-tile-text--secondary', {
            'md-tile-text--three-lines': threeLines
          }, (0, _themeColors2.default)({ disabled: disabled, hint: !disabled }), secondaryTextClassName)
        },
        secondaryText
      );
    }

    return _react2.default.createElement(
      'div',
      _extends({}, props, { className: (0, _classnames2.default)('md-tile-content', className) }),
      _react2.default.createElement(
        'div',
        {
          style: primaryTextStyle,
          className: (0, _classnames2.default)('md-tile-text--primary', (_cn = {}, _cn[activeClassName] = !disabled && active, _cn), (0, _themeColors2.default)({ disabled: disabled, text: !active }), primaryTextClassName)
        },
        primaryText
      ),
      secondaryTextNode
    );
  };

  return ListItemText;
}(_react.PureComponent);

ListItemText.propTypes = {
  active: _propTypes2.default.bool,
  activeClassName: _propTypes2.default.string,
  disabled: _propTypes2.default.bool,
  primaryText: _propTypes2.default.node.isRequired,
  primaryTextStyle: _propTypes2.default.object,
  primaryTextClassName: _propTypes2.default.string,
  secondaryText: _propTypes2.default.node,
  secondaryTextStyle: _propTypes2.default.object,
  secondaryTextClassName: _propTypes2.default.string,
  className: _propTypes2.default.string,
  threeLines: _propTypes2.default.bool
};
exports.default = ListItemText;

/***/ }),

/***/ "zPkt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("mXGw");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5+ba");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__("8Jek");

var _classnames2 = _interopRequireDefault(_classnames);

var _deprecated = __webpack_require__("PioW");

var _deprecated2 = _interopRequireDefault(_deprecated);

var _getField = __webpack_require__("iouw");

var _getField2 = _interopRequireDefault(_getField);

var _controlled = __webpack_require__("sd4F");

var _controlled2 = _interopRequireDefault(_controlled);

var _touches = __webpack_require__("nuxT");

var _Portal = __webpack_require__("yVgl");

var _Portal2 = _interopRequireDefault(_Portal);

var _Paper = __webpack_require__("2oCQ");

var _Paper2 = _interopRequireDefault(_Paper);

var _BottomNav = __webpack_require__("+vVB");

var _BottomNav2 = _interopRequireDefault(_BottomNav);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `BottomNavigation` component is an alternative to the `NavigationDrawer` for handling navigation
 * only on mobile devices.
 */
var BottomNavigation = function (_PureComponent) {
  _inherits(BottomNavigation, _PureComponent);

  function BottomNavigation(props) {
    _classCallCheck(this, BottomNavigation);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _initialiseProps.call(_this);

    var visible = typeof props.initiallyVisible === 'boolean' ? props.initiallyVisible : props.defaultVisible;
    _this.state = {
      visible: visible,
      portalVisible: visible
    };

    if (typeof props.activeIndex === 'undefined') {
      _this.state.activeIndex = props.defaultActiveIndex;
    }
    return _this;
  }

  BottomNavigation.prototype.componentDidMount = function componentDidMount() {
    if (this.props.dynamic) {
      this._addTouchEvents();
    }
  };

  BottomNavigation.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var dynamic = nextProps.dynamic;

    if (this.props.dynamic === dynamic) {
      return;
    }

    if (dynamic) {
      this._addTouchEvents();
    } else {
      this._removeTouchEvents();
    }
  };

  BottomNavigation.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {
    if (this.state.visible !== nextState.visible && nextProps.onVisibilityChange) {
      nextProps.onVisibilityChange(nextState.visible);
    }
  };

  BottomNavigation.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.dynamic) {
      this._removeTouchEvents();
    }

    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  };

  BottomNavigation.prototype.render = function render() {
    var _this2 = this;

    var _state = this.state,
        visible = _state.visible,
        portalVisible = _state.portalVisible;

    var _props = this.props,
        className = _props.className,
        actions = _props.actions,
        colored = _props.colored,
        dynamic = _props.dynamic,
        lastChild = _props.lastChild,
        animate = _props.animate,
        portal = _props.portal,
        propLinks = _props.links,
        propActiveIndex = _props.activeIndex,
        propRenderNode = _props.renderNode,
        onNavChange = _props.onNavChange,
        onVisibilityChange = _props.onVisibilityChange,
        defaultVisible = _props.defaultVisible,
        defaultActiveIndex = _props.defaultActiveIndex,
        dynamicThreshold = _props.dynamicThreshold,
        transitionDuration = _props.transitionDuration,
        onChange = _props.onChange,
        initiallyVisible = _props.initiallyVisible,
        containerStyle = _props.containerStyle,
        containerClassName = _props.containerClassName,
        transitionName = _props.transitionName,
        transitionEnterTimeout = _props.transitionEnterTimeout,
        transitionLeaveTimeout = _props.transitionLeaveTimeout,
        props = _objectWithoutProperties(_props, ['className', 'actions', 'colored', 'dynamic', 'lastChild', 'animate', 'portal', 'links', 'activeIndex', 'renderNode', 'onNavChange', 'onVisibilityChange', 'defaultVisible', 'defaultActiveIndex', 'dynamicThreshold', 'transitionDuration', 'onChange', 'initiallyVisible', 'containerStyle', 'containerClassName', 'transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout']);

    var links = this.props.links;

    if (actions) {
      links = actions;
    }

    var fixed = links.length === 3;
    var activeIndex = (0, _getField2.default)(this.props, this.state, 'activeIndex');
    var renderNode = (0, _getField2.default)(this.props, this.context, 'renderNode');
    var navigation = _react2.default.createElement(
      _Paper2.default,
      _extends({}, props, {
        key: 'navigation',
        className: (0, _classnames2.default)('md-bottom-navigation', {
          'md-background--card': !colored,
          'md-background--primary': colored,
          'md-bottom-navigation--dynamic': dynamic,
          'md-bottom-navigation--dynamic-inactive': dynamic && !visible
        }, className),
        role: 'navigation'
      }),
      links.map(function (action, index) {
        return _react2.default.createElement(_BottomNav2.default, _extends({}, action, {
          animate: animate,
          key: action.key || index,
          index: index,
          onNavChange: _this2._handleNavChange,
          active: activeIndex === index,
          colored: colored,
          fixed: fixed
        }));
      })
    );

    if (!portal) {
      return portalVisible ? navigation : null;
    }

    return _react2.default.createElement(
      _Portal2.default,
      { renderNode: renderNode, visible: portalVisible, lastChild: lastChild },
      navigation
    );
  };

  return BottomNavigation;
}(_react.PureComponent);

BottomNavigation.propTypes = {
  /**
   * An optional style to apply.
   */
  style: _propTypes2.default.object,

  /**
   * An optional className to apply.
   */
  className: _propTypes2.default.string,

  /**
   * A list of objects to generate a bottom navigation link. There must be at least 3 and no more
   * than 5 links. A link gets rendered as the `AccessibleFakeButton` component, so any additional
   * props in the link's shape will be passed along.
   *
   * ```docgen
   * PropTypes.arrayOf(PropTypes.shape({
   *   label: PropTypes.node.isRequired,
   *   icon: PropTypes.element,
   *   component: PropTypes.oneOfType([
   *      PropTypes.func,
   *      PropTypes.string,
   *   ]),
   * }).isRequired
   * ```
   */
  links: function links(props, propName, component) {
    for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    var _PropTypes$arrayOf;

    var links = props[propName] || props.actions;
    var len = links.length;

    if (len < 3) {
      return new Error('Only ' + len + ' `' + propName + '` were given to the ' + component + '. At least 3 are required.');
    } else if (len > 5) {
      return new Error(len + ' `' + propName + '` were given to the ' + component + '. No more than 5 may be given.');
    }

    return (_PropTypes$arrayOf = _propTypes2.default.arrayOf(_propTypes2.default.shape({
      label: _propTypes2.default.node.isRequired,
      icon: _propTypes2.default.element,
      iconChildren: (0, _deprecated2.default)(_propTypes2.default.node, 'Use `icon` instead'),
      iconClassName: (0, _deprecated2.default)(_propTypes2.default.string, 'Use `icon` instead'),
      component: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string])
    }))).isRequired.apply(_PropTypes$arrayOf, [props, propName, component].concat(args));
  },

  /**
   * Boolean if the bottom navigation should be colored with the primary color or whatever color
   * was a result of the `react-md-theme-bottom-navigations-colored` mixin.
   */
  colored: _propTypes2.default.bool,

  /**
   * Boolean if the bottom navigation should dynamically appear based on scrolling. When the user
   * scrolls the `dynamicThreshold` amount, this component will either disappear (scrolling down)
   * or appear (scrolling up).
   */
  dynamic: _propTypes2.default.bool,

  /**
   * The distance a user must scroll before the bottom navigation appears or disappears when it is `dynamic`.
   */
  dynamicThreshold: _propTypes2.default.number.isRequired,

  /**
   * An optional function to call when a link has been clicked. The callback will
   * include the new active index and the click event.
   *
   * ```js
   * onNavChange(newActiveIndex, event);
   * ```
   */
  onNavChange: _propTypes2.default.func,

  /**
   * An optional active index to use. This will make the component controlled and require the
   * `onNavChange` prop to be defined.
   */
  activeIndex: (0, _controlled2.default)(_propTypes2.default.number, 'onNavChange', 'defaultActiveIndex'),

  /**
   * The index for the link that is active by default.
   */
  defaultActiveIndex: _propTypes2.default.number.isRequired,

  /**
   * Boolean if the bottom navigation is visible by default. This *should* probably always
   * be true.
   */
  defaultVisible: _propTypes2.default.bool.isRequired,

  /**
   * The component to render the bottom navigation as.
   */
  component: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired,

  /**
   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied
   * to the bottom navigation.
   *
   * @see {@link Helpers/Portal}
   */
  portal: _propTypes2.default.bool,

  /**
   * Since the `BottomNavigation` component uses the `Portal` component, you can pass an optional
   * HTML Node to render in.
   */
  renderNode: _propTypes2.default.object,

  /**
   * Boolean if the bottom navigation should render as the last child in the `renderNode` or `body`
   * instead of as the first.
   */
  lastChild: _propTypes2.default.bool,

  /**
   * The transition duration for the dynamic bottom navigation to appear or disappear. This should
   * match the `$md-bottom-navigation-transition-time` variable.
   */
  transitionDuration: _propTypes2.default.number.isRequired,

  /**
   * An optional function to call when the visibility of the bottom navigation changes. The callback
   * will include the new visibility.
   *
   * ```js
   * onVisibilityChange(!visible);
   * ```
   */
  onVisibilityChange: _propTypes2.default.func,

  /**
   * Boolean if the label on a shifting navigation should animate in and out.
   */
  animate: _propTypes2.default.bool,

  onChange: (0, _deprecated2.default)(_propTypes2.default.func, 'Use `onNavChange` instead'),
  initiallyVisible: (0, _deprecated2.default)(_propTypes2.default.bool, 'Use `defaultVisible` instead'),
  initialActiveIndex: (0, _deprecated2.default)(_propTypes2.default.number, 'Use `defaultActiveIndex` instead'),
  containerStyle: (0, _deprecated2.default)(_propTypes2.default.object, 'Use `style` instead'),
  containerClassName: (0, _deprecated2.default)(_propTypes2.default.string, 'Use `className` instead'),
  transitionName: (0, _deprecated2.default)(_propTypes2.default.string, 'There is no CSSTransitionGroup used anymore'),
  transitionEnterTimeout: (0, _deprecated2.default)(_propTypes2.default.number, 'Use `transitionDuration` instead'),
  transitionLeaveTimeout: (0, _deprecated2.default)(_propTypes2.default.number, 'Use `transitionDuration` instead'),
  actions: (0, _deprecated2.default)(_propTypes2.default.array, 'Use `links` instead')
};
BottomNavigation.defaultProps = {
  animate: true,
  defaultActiveIndex: 0,
  component: 'footer',
  defaultVisible: true,
  transitionDuration: 300,
  portal: false,
  dynamicThreshold: 5
};
BottomNavigation.contextTypes = {
  renderNode: _propTypes2.default.object
};

var _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this._addTouchEvents = function () {
    (0, _touches.addTouchEvent)(window, 'start', _this3._handleTouchStart);
    (0, _touches.addTouchEvent)(window, 'move', _this3._handleTouchMove);
    (0, _touches.addTouchEvent)(window, 'end', _this3._handleTouchEnd);
  };

  this._removeTouchEvents = function () {
    (0, _touches.removeTouchEvent)(window, 'start', _this3._handleTouchStart);
    (0, _touches.removeTouchEvent)(window, 'move', _this3._handleTouchMove);
    (0, _touches.removeTouchEvent)(window, 'end', _this3._handleTouchEnd);
  };

  this._animateIn = function () {
    if (_this3._timeout) {
      clearTimeout(_this3._timeout);
    }

    _this3._timeout = setTimeout(function () {
      _this3._timeout = null;
      _this3.setState({ visible: true });
    }, 17);

    _this3.setState({ portalVisible: true });
  };

  this._animateOut = function () {
    if (_this3._timeout) {
      clearTimeout(_this3._timeout);
    }

    _this3._timeout = setTimeout(function () {
      _this3._timeout = null;
      _this3.setState({ portalVisible: false });
    }, _this3.props.transitionDuration);

    _this3.setState({ visible: false });
  };

  this._handleTouchStart = function (e) {
    var pageY = e.changedTouches[0].pageY;


    _this3._pageY = pageY;
    _this3._scrolling = true;
  };

  this._handleTouchMove = function (e) {
    var visible = _this3.state.visible;

    if (!_this3._scrolling) {
      return;
    }

    var touchY = e.changedTouches[0].pageY;
    var dynamicThreshold = _this3.props.dynamicThreshold;

    var passedThreshold = Math.abs(_this3._pageY - touchY) >= dynamicThreshold;
    if (_this3._pageY > touchY && visible && passedThreshold) {
      _this3._pageY = touchY;
      _this3._animateOut();
    } else if (_this3._pageY < touchY && !visible && passedThreshold) {
      _this3._pageY = touchY;
      _this3._animateIn();
    }
  };

  this._handleTouchEnd = function () {
    _this3._scrolling = false;
  };

  this._handleNavChange = function (index, e) {
    if (_this3.props.onNavChange || _this3.props.onChange) {
      (_this3.props.onNavChange || _this3.props.onChange)(index, e);
    }

    if (typeof _this3.props.activeIndex === 'undefined') {
      _this3.setState({ activeIndex: index });
    }
  };
};

exports.default = BottomNavigation;

/***/ }),

/***/ "zXe4":
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__("GI0s"),
    isObjectLike = __webpack_require__("T9Ud");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "zaJg":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__("53Ck");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _SwipeableViews = _interopRequireDefault(__webpack_require__("TWrC"));

var _default = _SwipeableViews.default;
exports.default = _default;

/***/ }),

/***/ "zkTx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__("KlUR")
var ieee754 = __webpack_require__("FaXh")
var isArray = __webpack_require__("uo0B")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("pCvA")))

/***/ })

}]);